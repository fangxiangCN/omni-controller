var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method2) => (__accessCheck(obj, member, "access private method"), method2);
var _a2, _parsers, _ScrcpyDeviceMessageParsers_instances, add_fn, _promise, _resolve, _reject, _state, _types, _options2, _typeMap, _scrollController, _buffered, _bufferedOffset, _bufferedLength, _position, _BufferedReadableStream_instances, readBuffered_fn, readSource_fn, _readable, _writable, _task, _resolver, _writer, _serializer, _controller, _resolvers, _closed, _controller2, _clipboard, _ackClipboardHandler, _uHidOutput, _deviceMessageParsers;
import { app, BrowserWindow, ipcMain } from "electron";
import { fileURLToPath } from "node:url";
import * as path$5 from "node:path";
import path__default, { join as join$3, dirname as dirname$1, resolve as resolve$3, basename as basename$2 } from "node:path";
import * as fs$5 from "node:fs";
import fs__default, { existsSync, mkdirSync, readFileSync, openSync, statSync, readSync, closeSync, writeFileSync, rmSync, truncateSync, appendFileSync, unlinkSync } from "node:fs";
import util$7, { promisify as promisify$1, isDeepStrictEqual } from "node:util";
import require$$0$3 from "tty";
import require$$1$1 from "util";
import require$$0$4 from "os";
import os$1, { tmpdir } from "node:os";
import require$$0$6, { randomFillSync, randomUUID } from "crypto";
import require$$0$5 from "buffer";
import assert$1 from "node:assert";
import { Buffer as Buffer$3 } from "node:buffer";
import "node:fs/promises";
import { execFile } from "node:child_process";
import net from "node:net";
import require$$1$2 from "path";
import require$$0$8 from "fs";
import require$$0$7 from "net";
import require$$0$9 from "events";
import require$$1$3 from "stream";
import require$$3$1 from "zlib";
import require$$1$4 from "string_decoder";
import require$$8 from "querystring";
import require$$0$a from "url";
import require$$0$b from "http";
import { EventEmitter as EventEmitter$1 } from "node:events";
import require$$0$c from "child_process";
import require$$1$5 from "async_hooks";
import require$$0$d from "assert";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var src$2 = { exports: {} };
var browser$2 = { exports: {} };
var s$1 = 1e3;
var m = s$1 * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
var ms$2 = function(val, options2) {
  options2 = options2 || {};
  var type3 = typeof val;
  if (type3 === "string" && val.length > 0) {
    return parse$h(val);
  } else if (type3 === "number" && isFinite(val)) {
    return options2.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$h(str2) {
  str2 = String(str2);
  if (str2.length > 100) {
    return;
  }
  var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str2
  );
  if (!match2) {
    return;
  }
  var n = parseFloat(match2[1]);
  var type3 = (match2[2] || "ms").toLowerCase();
  switch (type3) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s$1;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (msAbs >= s$1) {
    return Math.round(ms2 / s$1) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s$1) {
    return plural(ms2, msAbs, s$1, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
}
var common$2;
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$2;
  hasRequiredCommon$1 = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms$2;
    createDebug.destroy = destroy2;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
          if (match2 === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend3;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend3(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$2 = setup;
  return common$2;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2.exports;
  hasRequiredBrowser$2 = 1;
  (function(module, exports$1) {
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load2;
    exports$1.useColors = useColors;
    exports$1.storage = localstorage();
    exports$1.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports$1.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports$1.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports$1.storage.setItem("debug", namespaces);
        } else {
          exports$1.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports$1.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = requireCommon$1()(exports$1);
    const { formatters: formatters2 } = module.exports;
    formatters2.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser$2, browser$2.exports);
  return browser$2.exports;
}
var node$2 = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os2 = require$$0$4;
  const tty = require$$0$3;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode$2;
function requireNode$2() {
  if (hasRequiredNode$2) return node$2.exports;
  hasRequiredNode$2 = 1;
  (function(module, exports$1) {
    const tty = require$$0$3;
    const util2 = require$$1$1;
    exports$1.init = init2;
    exports$1.log = log2;
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load2;
    exports$1.useColors = useColors;
    exports$1.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports$1.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports$1.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports$1.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports$1.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util2.formatWithOptions(exports$1.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports$1.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon$1()(exports$1);
    const { formatters: formatters2 } = module.exports;
    formatters2.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters2.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$2, node$2.exports);
  return node$2.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src$2.exports = requireBrowser$2();
} else {
  src$2.exports = requireNode$2();
}
var srcExports$2 = src$2.exports;
const debug$t = /* @__PURE__ */ getDefaultExportFromCjs(srcExports$2);
const MIDSCENE_MODEL_INIT_CONFIG_JSON = "MIDSCENE_MODEL_INIT_CONFIG_JSON";
const MIDSCENE_MODEL_NAME = "MIDSCENE_MODEL_NAME";
const MIDSCENE_DEBUG_MODEL_PROFILE = "MIDSCENE_DEBUG_MODEL_PROFILE";
const MIDSCENE_DEBUG_MODEL_RESPONSE = "MIDSCENE_DEBUG_MODEL_RESPONSE";
const MIDSCENE_DANGEROUSLY_PRINT_ALL_CONFIG = "MIDSCENE_DANGEROUSLY_PRINT_ALL_CONFIG";
const MIDSCENE_DEBUG_MODE = "MIDSCENE_DEBUG_MODE";
const MIDSCENE_MCP_USE_PUPPETEER_MODE = "MIDSCENE_MCP_USE_PUPPETEER_MODE";
const MIDSCENE_MCP_CHROME_PATH = "MIDSCENE_MCP_CHROME_PATH";
const MIDSCENE_MCP_ANDROID_MODE = "MIDSCENE_MCP_ANDROID_MODE";
const DOCKER_CONTAINER = "DOCKER_CONTAINER";
const MIDSCENE_FORCE_DEEP_THINK = "MIDSCENE_FORCE_DEEP_THINK";
const OMNI_DEBUG_MODE = MIDSCENE_DEBUG_MODE;
const OMNI_FORCE_DEEP_THINK = MIDSCENE_FORCE_DEEP_THINK;
const MIDSCENE_LANGSMITH_DEBUG = "MIDSCENE_LANGSMITH_DEBUG";
const MIDSCENE_LANGFUSE_DEBUG = "MIDSCENE_LANGFUSE_DEBUG";
const OMNI_LANGSMITH_DEBUG = MIDSCENE_LANGSMITH_DEBUG;
const OMNI_LANGFUSE_DEBUG = MIDSCENE_LANGFUSE_DEBUG;
const MIDSCENE_MODEL_SOCKS_PROXY = "MIDSCENE_MODEL_SOCKS_PROXY";
const MIDSCENE_MODEL_HTTP_PROXY = "MIDSCENE_MODEL_HTTP_PROXY";
const MIDSCENE_MODEL_API_KEY = "MIDSCENE_MODEL_API_KEY";
const MIDSCENE_MODEL_BASE_URL = "MIDSCENE_MODEL_BASE_URL";
const MIDSCENE_MODEL_MAX_TOKENS = "MIDSCENE_MODEL_MAX_TOKENS";
const MIDSCENE_MODEL_TIMEOUT = "MIDSCENE_MODEL_TIMEOUT";
const MIDSCENE_MODEL_TEMPERATURE = "MIDSCENE_MODEL_TEMPERATURE";
const MIDSCENE_MODEL_RETRY_COUNT = "MIDSCENE_MODEL_RETRY_COUNT";
const MIDSCENE_MODEL_RETRY_INTERVAL = "MIDSCENE_MODEL_RETRY_INTERVAL";
const OMNI_MODEL_MAX_TOKENS = MIDSCENE_MODEL_MAX_TOKENS;
const OPENAI_API_KEY = "OPENAI_API_KEY";
const OPENAI_BASE_URL = "OPENAI_BASE_URL";
const MIDSCENE_OPENAI_INIT_CONFIG_JSON = "MIDSCENE_OPENAI_INIT_CONFIG_JSON";
const MIDSCENE_OPENAI_HTTP_PROXY = "MIDSCENE_OPENAI_HTTP_PROXY";
const MIDSCENE_OPENAI_SOCKS_PROXY = "MIDSCENE_OPENAI_SOCKS_PROXY";
const OPENAI_MAX_TOKENS = "OPENAI_MAX_TOKENS";
const MIDSCENE_ADB_PATH = "MIDSCENE_ADB_PATH";
const MIDSCENE_ADB_REMOTE_HOST = "MIDSCENE_ADB_REMOTE_HOST";
const MIDSCENE_ADB_REMOTE_PORT = "MIDSCENE_ADB_REMOTE_PORT";
const MIDSCENE_ANDROID_IME_STRATEGY = "MIDSCENE_ANDROID_IME_STRATEGY";
const MIDSCENE_IOS_DEVICE_UDID = "MIDSCENE_IOS_DEVICE_UDID";
const MIDSCENE_IOS_SIMULATOR_UDID = "MIDSCENE_IOS_SIMULATOR_UDID";
const MIDSCENE_CACHE = "MIDSCENE_CACHE";
const OMNI_CACHE = MIDSCENE_CACHE;
const MIDSCENE_USE_VLM_UI_TARS = "MIDSCENE_USE_VLM_UI_TARS";
const MIDSCENE_USE_QWEN_VL = "MIDSCENE_USE_QWEN_VL";
const MIDSCENE_USE_QWEN3_VL = "MIDSCENE_USE_QWEN3_VL";
const MIDSCENE_USE_DOUBAO_VISION = "MIDSCENE_USE_DOUBAO_VISION";
const MIDSCENE_USE_GEMINI = "MIDSCENE_USE_GEMINI";
const MIDSCENE_USE_VL_MODEL = "MIDSCENE_USE_VL_MODEL";
const MATCH_BY_POSITION = "MATCH_BY_POSITION";
const MIDSCENE_REPORT_TAG_NAME = "MIDSCENE_REPORT_TAG_NAME";
const MIDSCENE_REPORT_QUIET = "MIDSCENE_REPORT_QUIET";
const OMNI_REPORT_TAG_NAME = MIDSCENE_REPORT_TAG_NAME;
const MIDSCENE_PREFERRED_LANGUAGE = "MIDSCENE_PREFERRED_LANGUAGE";
const MIDSCENE_CACHE_MAX_FILENAME_LENGTH = "MIDSCENE_CACHE_MAX_FILENAME_LENGTH";
const OMNI_CACHE_MAX_FILENAME_LENGTH = MIDSCENE_CACHE_MAX_FILENAME_LENGTH;
const MIDSCENE_REPLANNING_CYCLE_LIMIT = "MIDSCENE_REPLANNING_CYCLE_LIMIT";
const OMNI_REPLANNING_CYCLE_LIMIT = MIDSCENE_REPLANNING_CYCLE_LIMIT;
const MIDSCENE_RUN_DIR = "MIDSCENE_RUN_DIR";
const MIDSCENE_INSIGHT_MODEL_NAME = "MIDSCENE_INSIGHT_MODEL_NAME";
const MIDSCENE_INSIGHT_MODEL_SOCKS_PROXY = "MIDSCENE_INSIGHT_MODEL_SOCKS_PROXY";
const MIDSCENE_INSIGHT_MODEL_HTTP_PROXY = "MIDSCENE_INSIGHT_MODEL_HTTP_PROXY";
const MIDSCENE_INSIGHT_MODEL_BASE_URL = "MIDSCENE_INSIGHT_MODEL_BASE_URL";
const MIDSCENE_INSIGHT_MODEL_API_KEY = "MIDSCENE_INSIGHT_MODEL_API_KEY";
const MIDSCENE_INSIGHT_MODEL_INIT_CONFIG_JSON = "MIDSCENE_INSIGHT_MODEL_INIT_CONFIG_JSON";
const MIDSCENE_INSIGHT_MODEL_TIMEOUT = "MIDSCENE_INSIGHT_MODEL_TIMEOUT";
const MIDSCENE_INSIGHT_MODEL_TEMPERATURE = "MIDSCENE_INSIGHT_MODEL_TEMPERATURE";
const MIDSCENE_INSIGHT_MODEL_RETRY_COUNT = "MIDSCENE_INSIGHT_MODEL_RETRY_COUNT";
const MIDSCENE_INSIGHT_MODEL_RETRY_INTERVAL = "MIDSCENE_INSIGHT_MODEL_RETRY_INTERVAL";
const MIDSCENE_INSIGHT_MODEL_FAMILY = "MIDSCENE_INSIGHT_MODEL_FAMILY";
const MIDSCENE_PLANNING_MODEL_NAME = "MIDSCENE_PLANNING_MODEL_NAME";
const MIDSCENE_PLANNING_MODEL_SOCKS_PROXY = "MIDSCENE_PLANNING_MODEL_SOCKS_PROXY";
const MIDSCENE_PLANNING_MODEL_HTTP_PROXY = "MIDSCENE_PLANNING_MODEL_HTTP_PROXY";
const MIDSCENE_PLANNING_MODEL_BASE_URL = "MIDSCENE_PLANNING_MODEL_BASE_URL";
const MIDSCENE_PLANNING_MODEL_API_KEY = "MIDSCENE_PLANNING_MODEL_API_KEY";
const MIDSCENE_PLANNING_MODEL_INIT_CONFIG_JSON = "MIDSCENE_PLANNING_MODEL_INIT_CONFIG_JSON";
const MIDSCENE_PLANNING_MODEL_TIMEOUT = "MIDSCENE_PLANNING_MODEL_TIMEOUT";
const MIDSCENE_PLANNING_MODEL_TEMPERATURE = "MIDSCENE_PLANNING_MODEL_TEMPERATURE";
const MIDSCENE_PLANNING_MODEL_RETRY_COUNT = "MIDSCENE_PLANNING_MODEL_RETRY_COUNT";
const MIDSCENE_PLANNING_MODEL_RETRY_INTERVAL = "MIDSCENE_PLANNING_MODEL_RETRY_INTERVAL";
const MIDSCENE_PLANNING_MODEL_FAMILY = "MIDSCENE_PLANNING_MODEL_FAMILY";
const MIDSCENE_MODEL_FAMILY = "MIDSCENE_MODEL_FAMILY";
const UNUSED_ENV_KEYS = [MIDSCENE_DANGEROUSLY_PRINT_ALL_CONFIG];
const BASIC_ENV_KEYS = [
  MIDSCENE_DEBUG_MODE,
  MIDSCENE_DEBUG_MODEL_PROFILE,
  MIDSCENE_DEBUG_MODEL_RESPONSE,
  MIDSCENE_RUN_DIR
];
const BOOLEAN_ENV_KEYS = [
  MIDSCENE_CACHE,
  MIDSCENE_FORCE_DEEP_THINK,
  MIDSCENE_MCP_USE_PUPPETEER_MODE,
  MIDSCENE_MCP_ANDROID_MODE,
  MIDSCENE_LANGSMITH_DEBUG,
  MIDSCENE_LANGFUSE_DEBUG,
  MIDSCENE_REPORT_QUIET
];
const NUMBER_ENV_KEYS = [
  MIDSCENE_MODEL_MAX_TOKENS,
  MIDSCENE_CACHE_MAX_FILENAME_LENGTH,
  MIDSCENE_REPLANNING_CYCLE_LIMIT
];
const STRING_ENV_KEYS = [
  MIDSCENE_MODEL_MAX_TOKENS,
  OPENAI_MAX_TOKENS,
  MIDSCENE_ADB_PATH,
  MIDSCENE_ADB_REMOTE_HOST,
  MIDSCENE_ADB_REMOTE_PORT,
  MIDSCENE_ANDROID_IME_STRATEGY,
  MIDSCENE_IOS_DEVICE_UDID,
  MIDSCENE_IOS_SIMULATOR_UDID,
  MIDSCENE_REPORT_TAG_NAME,
  MIDSCENE_PREFERRED_LANGUAGE,
  MATCH_BY_POSITION,
  MIDSCENE_MCP_CHROME_PATH,
  DOCKER_CONTAINER
];
const GLOBAL_ENV_KEYS = [
  ...BOOLEAN_ENV_KEYS,
  ...NUMBER_ENV_KEYS,
  ...STRING_ENV_KEYS
];
const MODEL_ENV_KEYS = [
  // model default
  MIDSCENE_MODEL_NAME,
  MIDSCENE_MODEL_INIT_CONFIG_JSON,
  MIDSCENE_MODEL_API_KEY,
  MIDSCENE_MODEL_BASE_URL,
  MIDSCENE_MODEL_SOCKS_PROXY,
  MIDSCENE_MODEL_HTTP_PROXY,
  MIDSCENE_MODEL_TIMEOUT,
  MIDSCENE_MODEL_TEMPERATURE,
  MIDSCENE_MODEL_RETRY_COUNT,
  MIDSCENE_MODEL_RETRY_INTERVAL,
  MIDSCENE_USE_VLM_UI_TARS,
  MIDSCENE_USE_QWEN_VL,
  MIDSCENE_USE_QWEN3_VL,
  MIDSCENE_USE_DOUBAO_VISION,
  MIDSCENE_USE_GEMINI,
  MIDSCENE_USE_VL_MODEL,
  // model default legacy
  OPENAI_API_KEY,
  OPENAI_BASE_URL,
  MIDSCENE_OPENAI_INIT_CONFIG_JSON,
  MIDSCENE_OPENAI_HTTP_PROXY,
  MIDSCENE_OPENAI_SOCKS_PROXY,
  // INSIGHT (unified VQA and Grounding)
  MIDSCENE_INSIGHT_MODEL_NAME,
  MIDSCENE_INSIGHT_MODEL_SOCKS_PROXY,
  MIDSCENE_INSIGHT_MODEL_HTTP_PROXY,
  MIDSCENE_INSIGHT_MODEL_BASE_URL,
  MIDSCENE_INSIGHT_MODEL_API_KEY,
  MIDSCENE_INSIGHT_MODEL_INIT_CONFIG_JSON,
  MIDSCENE_INSIGHT_MODEL_TIMEOUT,
  MIDSCENE_INSIGHT_MODEL_TEMPERATURE,
  MIDSCENE_INSIGHT_MODEL_RETRY_COUNT,
  MIDSCENE_INSIGHT_MODEL_RETRY_INTERVAL,
  MIDSCENE_INSIGHT_MODEL_FAMILY,
  // PLANNING
  MIDSCENE_PLANNING_MODEL_NAME,
  MIDSCENE_PLANNING_MODEL_SOCKS_PROXY,
  MIDSCENE_PLANNING_MODEL_HTTP_PROXY,
  MIDSCENE_PLANNING_MODEL_BASE_URL,
  MIDSCENE_PLANNING_MODEL_API_KEY,
  MIDSCENE_PLANNING_MODEL_INIT_CONFIG_JSON,
  MIDSCENE_PLANNING_MODEL_TIMEOUT,
  MIDSCENE_PLANNING_MODEL_TEMPERATURE,
  MIDSCENE_PLANNING_MODEL_RETRY_COUNT,
  MIDSCENE_PLANNING_MODEL_RETRY_INTERVAL,
  MIDSCENE_PLANNING_MODEL_FAMILY,
  MIDSCENE_MODEL_FAMILY
];
const ALL_ENV_KEYS = [
  ...UNUSED_ENV_KEYS,
  ...BASIC_ENV_KEYS,
  ...GLOBAL_ENV_KEYS,
  ...MODEL_ENV_KEYS
];
const VL_MODE_RAW_VALID_VALUES = [
  "doubao-vision",
  "gemini",
  "qwen2.5-vl",
  "qwen3-vl",
  "vlm-ui-tars",
  "vlm-ui-tars-doubao",
  "vlm-ui-tars-doubao-1.5",
  "glm-v",
  "auto-glm",
  "auto-glm-multilingual"
];
const MODEL_FAMILY_VALUES = [
  ...VL_MODE_RAW_VALID_VALUES,
  "gpt-5"
];
var UITarsModelVersion = /* @__PURE__ */ ((UITarsModelVersion2) => {
  UITarsModelVersion2["V1_0"] = "1.0";
  UITarsModelVersion2["V1_5"] = "1.5";
  UITarsModelVersion2["DOUBAO_1_5_15B"] = "doubao-1.5-15B";
  UITarsModelVersion2["DOUBAO_1_5_20B"] = "doubao-1.5-20B";
  return UITarsModelVersion2;
})(UITarsModelVersion || {});
const getBasicEnvValue = (key) => {
  if (!BASIC_ENV_KEYS.includes(key)) {
    throw new Error(`getBasicEnvValue with key ${key} is not supported.`);
  }
  return process.env[key];
};
var sha256$1 = { exports: {} };
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.11.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2024
 * @license MIT
 */
(function(module) {
  (function() {
    var ERROR = "input is invalid type";
    var WINDOW = typeof window === "object";
    var root3 = WINDOW ? window : {};
    if (root3.JS_SHA256_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root3.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root3 = commonjsGlobal;
    } else if (WEB_WORKER) {
      root3 = self;
    }
    var COMMON_JS = !root3.JS_SHA256_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root3.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
    var blocks = [];
    if (root3.JS_SHA256_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root3.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(outputType, is224) {
      return function(message) {
        return new Sha256(is224, true).update(message)[outputType]();
      };
    };
    var createMethod = function(is224) {
      var method2 = createOutputMethod("hex", is224);
      if (NODE_JS) {
        method2 = nodeWrap(method2, is224);
      }
      method2.create = function() {
        return new Sha256(is224);
      };
      method2.update = function(message) {
        return method2.create().update(message);
      };
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type3 = OUTPUT_TYPES[i];
        method2[type3] = createOutputMethod(type3, is224);
      }
      return method2;
    };
    var nodeWrap = function(method2, is224) {
      var crypto2 = require$$0$6;
      var Buffer2 = require$$0$5.Buffer;
      var algorithm = is224 ? "sha224" : "sha256";
      var bufferFrom;
      if (Buffer2.from && !root3.JS_SHA256_NO_BUFFER_FROM) {
        bufferFrom = Buffer2.from;
      } else {
        bufferFrom = function(message) {
          return new Buffer2(message);
        };
      }
      var nodeMethod = function(message) {
        if (typeof message === "string") {
          return crypto2.createHash(algorithm).update(message, "utf8").digest("hex");
        } else {
          if (message === null || message === void 0) {
            throw new Error(ERROR);
          } else if (message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          }
        }
        if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer2) {
          return crypto2.createHash(algorithm).update(bufferFrom(message)).digest("hex");
        } else {
          return method2(message);
        }
      };
      return nodeMethod;
    };
    var createHmacOutputMethod = function(outputType, is224) {
      return function(key, message) {
        return new HmacSha256(key, is224, true).update(message)[outputType]();
      };
    };
    var createHmacMethod = function(is224) {
      var method2 = createHmacOutputMethod("hex", is224);
      method2.create = function(key) {
        return new HmacSha256(key, is224);
      };
      method2.update = function(key, message) {
        return method2.create(key).update(message);
      };
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type3 = OUTPUT_TYPES[i];
        method2[type3] = createHmacOutputMethod(type3, is224);
      }
      return method2;
    };
    function Sha256(is224, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        this.blocks = blocks;
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      if (is224) {
        this.h0 = 3238371032;
        this.h1 = 914150663;
        this.h2 = 812702999;
        this.h3 = 4144912697;
        this.h4 = 4290775857;
        this.h5 = 1750603025;
        this.h6 = 1694076839;
        this.h7 = 3204075428;
      } else {
        this.h0 = 1779033703;
        this.h1 = 3144134277;
        this.h2 = 1013904242;
        this.h3 = 2773480762;
        this.h4 = 1359893119;
        this.h5 = 2600822924;
        this.h6 = 528734635;
        this.h7 = 1541459225;
      }
      this.block = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
      this.first = true;
      this.is224 = is224;
    }
    Sha256.prototype.update = function(message) {
      if (this.finalized) {
        return;
      }
      var notString, type3 = typeof message;
      if (type3 !== "string") {
        if (type3 === "object") {
          if (message === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
        notString = true;
      }
      var code, index2 = 0, i, length = message.length, blocks2 = this.blocks;
      while (index2 < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks2[0] = this.block;
          this.block = blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        if (notString) {
          for (i = this.start; index2 < length && i < 64; ++index2) {
            blocks2[i >>> 2] |= message[index2] << SHIFT[i++ & 3];
          }
        } else {
          for (i = this.start; index2 < length && i < 64; ++index2) {
            code = message.charCodeAt(index2);
            if (code < 128) {
              blocks2[i >>> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 2048) {
              blocks2[i >>> 2] |= (192 | code >>> 6) << SHIFT[i++ & 3];
              blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks2[i >>> 2] |= (224 | code >>> 12) << SHIFT[i++ & 3];
              blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks2[i >>> 2] |= (240 | code >>> 18) << SHIFT[i++ & 3];
              blocks2[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i++ & 3];
              blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            }
          }
        }
        this.lastByteIndex = i;
        this.bytes += i - this.start;
        if (i >= 64) {
          this.block = blocks2[16];
          this.start = i - 64;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i;
        }
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha256.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i = this.lastByteIndex;
      blocks2[16] = this.block;
      blocks2[i >>> 2] |= EXTRA[i & 3];
      this.block = blocks2[16];
      if (i >= 56) {
        if (!this.hashed) {
          this.hash();
        }
        blocks2[0] = this.block;
        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
      }
      blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
      blocks2[15] = this.bytes << 3;
      this.hash();
    };
    Sha256.prototype.hash = function() {
      var a = this.h0, b = this.h1, c = this.h2, d2 = this.h3, e = this.h4, f = this.h5, g = this.h6, h2 = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
      for (j = 16; j < 64; ++j) {
        t1 = blocks2[j - 15];
        s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
        t1 = blocks2[j - 2];
        s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
      }
      bc = b & c;
      for (j = 0; j < 64; j += 4) {
        if (this.first) {
          if (this.is224) {
            ab = 300032;
            t1 = blocks2[0] - 1413257819;
            h2 = t1 - 150054599 << 0;
            d2 = t1 + 24177077 << 0;
          } else {
            ab = 704751109;
            t1 = blocks2[0] - 210244248;
            h2 = t1 - 1521486534 << 0;
            d2 = t1 + 143694565 << 0;
          }
          this.first = false;
        } else {
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ab = a & b;
          maj = ab ^ a & c ^ bc;
          ch = e & f ^ ~e & g;
          t1 = h2 + s1 + ch + K[j] + blocks2[j];
          t2 = s0 + maj;
          h2 = d2 + t1 << 0;
          d2 = t1 + t2 << 0;
        }
        s0 = (d2 >>> 2 | d2 << 30) ^ (d2 >>> 13 | d2 << 19) ^ (d2 >>> 22 | d2 << 10);
        s1 = (h2 >>> 6 | h2 << 26) ^ (h2 >>> 11 | h2 << 21) ^ (h2 >>> 25 | h2 << 7);
        da = d2 & a;
        maj = da ^ d2 & b ^ ab;
        ch = h2 & e ^ ~h2 & f;
        t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
        t2 = s0 + maj;
        g = c + t1 << 0;
        c = t1 + t2 << 0;
        s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
        s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
        cd = c & d2;
        maj = cd ^ c & a ^ da;
        ch = g & h2 ^ ~g & e;
        t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
        t2 = s0 + maj;
        f = b + t1 << 0;
        b = t1 + t2 << 0;
        s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
        s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
        bc = b & c;
        maj = bc ^ b & d2 ^ cd;
        ch = f & g ^ ~f & h2;
        t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
        t2 = s0 + maj;
        e = a + t1 << 0;
        a = t1 + t2 << 0;
        this.chromeBugWorkAround = true;
      }
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d2 << 0;
      this.h4 = this.h4 + e << 0;
      this.h5 = this.h5 + f << 0;
      this.h6 = this.h6 + g << 0;
      this.h7 = this.h7 + h2 << 0;
    };
    Sha256.prototype.hex = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var hex = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + HEX_CHARS[h6 & 15];
      if (!this.is224) {
        hex += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15];
      }
      return hex;
    };
    Sha256.prototype.toString = Sha256.prototype.hex;
    Sha256.prototype.digest = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var arr = [
        h0 >>> 24 & 255,
        h0 >>> 16 & 255,
        h0 >>> 8 & 255,
        h0 & 255,
        h1 >>> 24 & 255,
        h1 >>> 16 & 255,
        h1 >>> 8 & 255,
        h1 & 255,
        h2 >>> 24 & 255,
        h2 >>> 16 & 255,
        h2 >>> 8 & 255,
        h2 & 255,
        h3 >>> 24 & 255,
        h3 >>> 16 & 255,
        h3 >>> 8 & 255,
        h3 & 255,
        h4 >>> 24 & 255,
        h4 >>> 16 & 255,
        h4 >>> 8 & 255,
        h4 & 255,
        h5 >>> 24 & 255,
        h5 >>> 16 & 255,
        h5 >>> 8 & 255,
        h5 & 255,
        h6 >>> 24 & 255,
        h6 >>> 16 & 255,
        h6 >>> 8 & 255,
        h6 & 255
      ];
      if (!this.is224) {
        arr.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
      }
      return arr;
    };
    Sha256.prototype.array = Sha256.prototype.digest;
    Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var buffer2 = new ArrayBuffer(this.is224 ? 28 : 32);
      var dataView = new DataView(buffer2);
      dataView.setUint32(0, this.h0);
      dataView.setUint32(4, this.h1);
      dataView.setUint32(8, this.h2);
      dataView.setUint32(12, this.h3);
      dataView.setUint32(16, this.h4);
      dataView.setUint32(20, this.h5);
      dataView.setUint32(24, this.h6);
      if (!this.is224) {
        dataView.setUint32(28, this.h7);
      }
      return buffer2;
    };
    function HmacSha256(key, is224, sharedMemory) {
      var i, type3 = typeof key;
      if (type3 === "string") {
        var bytes2 = [], length = key.length, index2 = 0, code;
        for (i = 0; i < length; ++i) {
          code = key.charCodeAt(i);
          if (code < 128) {
            bytes2[index2++] = code;
          } else if (code < 2048) {
            bytes2[index2++] = 192 | code >>> 6;
            bytes2[index2++] = 128 | code & 63;
          } else if (code < 55296 || code >= 57344) {
            bytes2[index2++] = 224 | code >>> 12;
            bytes2[index2++] = 128 | code >>> 6 & 63;
            bytes2[index2++] = 128 | code & 63;
          } else {
            code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
            bytes2[index2++] = 240 | code >>> 18;
            bytes2[index2++] = 128 | code >>> 12 & 63;
            bytes2[index2++] = 128 | code >>> 6 & 63;
            bytes2[index2++] = 128 | code & 63;
          }
        }
        key = bytes2;
      } else {
        if (type3 === "object") {
          if (key === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
            key = new Uint8Array(key);
          } else if (!Array.isArray(key)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
      }
      if (key.length > 64) {
        key = new Sha256(is224, true).update(key).array();
      }
      var oKeyPad = [], iKeyPad = [];
      for (i = 0; i < 64; ++i) {
        var b = key[i] || 0;
        oKeyPad[i] = 92 ^ b;
        iKeyPad[i] = 54 ^ b;
      }
      Sha256.call(this, is224, sharedMemory);
      this.update(iKeyPad);
      this.oKeyPad = oKeyPad;
      this.inner = true;
      this.sharedMemory = sharedMemory;
    }
    HmacSha256.prototype = new Sha256();
    HmacSha256.prototype.finalize = function() {
      Sha256.prototype.finalize.call(this);
      if (this.inner) {
        this.inner = false;
        var innerHash = this.array();
        Sha256.call(this, this.is224, this.sharedMemory);
        this.update(this.oKeyPad);
        this.update(innerHash);
        Sha256.prototype.finalize.call(this);
      }
    };
    var exports$1 = createMethod();
    exports$1.sha256 = exports$1;
    exports$1.sha224 = createMethod(true);
    exports$1.sha256.hmac = createHmacMethod();
    exports$1.sha224.hmac = createHmacMethod(true);
    if (COMMON_JS) {
      module.exports = exports$1;
    } else {
      root3.sha256 = exports$1.sha256;
      root3.sha224 = exports$1.sha224;
    }
  })();
})(sha256$1);
var sha256Exports = sha256$1.exports;
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
const native = { randomUUID };
function v4(options2, buf, offset) {
  var _a3;
  if (native.randomUUID && true && !options2) {
    return native.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random ?? ((_a3 = options2.rng) == null ? void 0 : _a3.call(options2)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
const ifInBrowser = typeof window !== "undefined";
const ifInWorker = typeof WorkerGlobalScope !== "undefined";
const ifInNode = typeof process !== "undefined" && ((_a2 = process.versions) == null ? void 0 : _a2.node);
function uuid() {
  return v4();
}
const hashMap = {};
function generateHashId(rect, content = "") {
  const combined = JSON.stringify({
    content,
    rect
  });
  let sliceLength = 5;
  let slicedHash = "";
  const hashHex = sha256Exports.sha256.create().update(combined).hex();
  const toLetters = (hex) => {
    return hex.split("").map((char) => {
      const code = Number.parseInt(char, 16);
      return String.fromCharCode(97 + code % 26);
    }).join("");
  };
  const hashLetters = toLetters(hashHex);
  while (sliceLength < hashLetters.length - 1) {
    slicedHash = hashLetters.slice(0, sliceLength);
    if (hashMap[slicedHash] && hashMap[slicedHash] !== combined) {
      sliceLength++;
      continue;
    }
    hashMap[slicedHash] = combined;
    break;
  }
  return slicedHash;
}
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function logMsg(...message) {
  {
    console.log(...message);
  }
}
const REGEXP_LT = /</g;
const REGEXP_GT = />/g;
const REGEXP_LT_ESCAPE = "__midscene_lt__";
const REGEXP_GT_ESCAPE = "__midscene_gt__";
const escapeScriptTag = (html) => {
  return html.replace(REGEXP_LT, REGEXP_LT_ESCAPE).replace(REGEXP_GT, REGEXP_GT_ESCAPE);
};
const antiEscapeScriptTag = (html) => {
  const REGEXP_LT2 = new RegExp(REGEXP_LT_ESCAPE, "g");
  const REGEXP_GT2 = new RegExp(REGEXP_GT_ESCAPE, "g");
  return html.replace(REGEXP_LT2, "<").replace(REGEXP_GT2, ">");
};
function replaceIllegalPathCharsAndSpace(str2) {
  return str2.replace(/[:*?"<>|# ]/g, "-");
}
function isPlainObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
const defaultRunDirName = "omni_run";
const getRunDir = () => {
  if (!ifInNode) {
    return "";
  }
  return getBasicEnvValue(MIDSCENE_RUN_DIR) || defaultRunDirName;
};
const getRunBaseDir = () => {
  if (!ifInNode) {
    return "";
  }
  let basePath2 = path__default.resolve(process.cwd(), getRunDir());
  if (!existsSync(basePath2)) {
    try {
      mkdirSync(basePath2, { recursive: true });
    } catch (error2) {
      basePath2 = path__default.join(tmpdir(), defaultRunDirName);
      mkdirSync(basePath2, { recursive: true });
    }
  }
  return basePath2;
};
const getRunSubDir = (subdir) => {
  if (!ifInNode) {
    return "";
  }
  const basePath2 = getRunBaseDir();
  const logPath = path__default.join(basePath2, subdir);
  if (!existsSync(logPath)) {
    mkdirSync(logPath, { recursive: true });
  }
  return logPath;
};
const topicPrefix = "midscene";
const logStreams = /* @__PURE__ */ new Map();
const debugInstances = /* @__PURE__ */ new Map();
function getLogStream(topic) {
  const topicFileName = topic.replace(/:/g, "-");
  if (!logStreams.has(topicFileName)) {
    const logFile = path__default.join(
      getRunSubDir("log"),
      `${topicFileName}.log`
    );
    const stream2 = fs__default.createWriteStream(logFile, { flags: "a" });
    logStreams.set(topicFileName, stream2);
  }
  return logStreams.get(topicFileName);
}
function writeLogToFile(topic, message) {
  if (!ifInNode) return;
  const stream2 = getLogStream(topic);
  const now = /* @__PURE__ */ new Date();
  const isoDate = now.toLocaleDateString("sv-SE");
  const isoTime = now.toLocaleTimeString("sv-SE");
  const milliseconds = now.getMilliseconds().toString().padStart(3, "0");
  const timezoneOffsetMinutes = now.getTimezoneOffset();
  const sign2 = timezoneOffsetMinutes <= 0 ? "+" : "-";
  const hours = Math.floor(Math.abs(timezoneOffsetMinutes) / 60).toString().padStart(2, "0");
  const minutes = (Math.abs(timezoneOffsetMinutes) % 60).toString().padStart(2, "0");
  const timezoneString = `${sign2}${hours}:${minutes}`;
  const localISOTime = `${isoDate}T${isoTime}.${milliseconds}${timezoneString}`;
  stream2.write(`[${localISOTime}] ${message}
`);
}
function getDebug(topic) {
  const fullTopic = `${topicPrefix}:${topic}`;
  if (!debugInstances.has(fullTopic)) {
    const debugFn = debug$t(fullTopic);
    const wrapper = (...args) => {
      if (ifInNode) {
        const message = util$7.format(...args);
        writeLogToFile(topic, message);
      }
      debugFn(...args);
    };
    debugInstances.set(fullTopic, wrapper);
  }
  return debugInstances.get(fullTopic);
}
function enableDebug(topic) {
  if (ifInNode) {
    return;
  }
  debug$t.enable(`${topicPrefix}:${topic}`);
}
const initDebugConfig = () => {
  const shouldPrintTiming = getBasicEnvValue(MIDSCENE_DEBUG_MODEL_PROFILE);
  let debugConfig = "";
  if (shouldPrintTiming) {
    console.warn(
      "MIDSCENE_DEBUG_MODEL_PROFILE is deprecated, use DEBUG=midscene:ai:profile instead"
    );
    debugConfig = "ai:profile";
  }
  const shouldPrintModelResponse = getBasicEnvValue(
    MIDSCENE_DEBUG_MODEL_RESPONSE
  );
  if (shouldPrintModelResponse) {
    console.warn(
      "MIDSCENE_DEBUG_MODEL_RESPONSE is deprecated, use DEBUG=midscene:ai:response instead"
    );
    if (debugConfig) {
      debugConfig = "ai:*";
    } else {
      debugConfig = "ai:call";
    }
  }
  if (debugConfig) {
    enableDebug(debugConfig);
  }
};
class GlobalConfigManager {
  constructor() {
    __publicField(this, "override");
    __publicField(this, "keysHaveBeenRead", {});
    __publicField(this, "globalModelConfigManager");
    initDebugConfig();
  }
  /**
   * recalculate allEnvConfig every time because process.env can be updated any time
   */
  getAllEnvConfig() {
    const envConfig = ALL_ENV_KEYS.reduce(
      (p, name) => {
        p[name] = process.env[name];
        return p;
      },
      /* @__PURE__ */ Object.create(null)
    );
    if (this.override) {
      const { newConfig, extendMode } = this.override;
      if (extendMode) {
        return { ...envConfig, ...newConfig };
      } else {
        return { ...newConfig };
      }
    } else {
      return envConfig;
    }
  }
  getEnvConfigValue(key) {
    const allConfig = this.getAllEnvConfig();
    if (key === MATCH_BY_POSITION) {
      throw new Error(
        "MATCH_BY_POSITION is discarded, use MIDSCENE_MODEL_FAMILY instead"
      );
    }
    if (!STRING_ENV_KEYS.includes(key)) {
      throw new Error(`getEnvConfigValue with key ${key} is not supported.`);
    }
    const value = allConfig[key];
    this.keysHaveBeenRead[key] = true;
    if (typeof value === "string") {
      return value.trim();
    }
    return value;
  }
  /**
   * read boolean only from process.env
   */
  getEnvConfigInBoolean(key) {
    const allConfig = this.getAllEnvConfig();
    if (!BOOLEAN_ENV_KEYS.includes(key)) {
      throw new Error(`getEnvConfigInBoolean with key ${key} is not supported`);
    }
    const value = allConfig[key];
    this.keysHaveBeenRead[key] = true;
    if (!value) {
      return false;
    }
    if (/^(true|1)$/i.test(value)) {
      return true;
    }
    if (/^(false|0)$/i.test(value)) {
      return false;
    }
    return !!value.trim();
  }
  /**
   * Read environment variable value and convert it to number.
   * Returns undefined if the value is not set or cannot be converted to a valid number.
   */
  getEnvConfigValueAsNumber(key) {
    if (!STRING_ENV_KEYS.includes(key) && !NUMBER_ENV_KEYS.includes(key)) {
      throw new Error(
        `getEnvConfigValueAsNumber with key ${key} is not supported.`
      );
    }
    const allConfig = this.getAllEnvConfig();
    const value = allConfig[key];
    this.keysHaveBeenRead[key] = true;
    if (typeof value !== "string") {
      return void 0;
    }
    const trimmed = value.trim();
    if (!trimmed) {
      return void 0;
    }
    const numValue = Number(trimmed);
    return Number.isNaN(numValue) ? void 0 : numValue;
  }
  registerModelConfigManager(globalModelConfigManager2) {
    this.globalModelConfigManager = globalModelConfigManager2;
  }
  /**
   * @deprecated use the modelConfig param in Agent constructor instead
   */
  overrideAIConfig(newConfig, extendMode = false) {
    var _a3;
    for (const key in newConfig) {
      if (![...GLOBAL_ENV_KEYS, ...MODEL_ENV_KEYS].includes(key)) {
        throw new Error(`Failed to override AI config, invalid key: ${key}`);
      }
      const value = newConfig[key];
      if (typeof value !== "string") {
        throw new Error(
          `Failed to override AI config, value for key ${key} must be a string, but got with type ${typeof value}`
        );
      }
      if (this.keysHaveBeenRead[key]) {
        console.warn(
          `Warning: try to override AI config with key ${key} ,but it has been read.`
        );
      }
    }
    const savedNewConfig = extendMode ? {
      ...(_a3 = this.override) == null ? void 0 : _a3.newConfig,
      ...newConfig
    } : newConfig;
    this.override = {
      newConfig: {
        ...savedNewConfig
      },
      extendMode
    };
    if (!this.globalModelConfigManager) {
      throw new Error(
        "globalModelConfigManager is not registered, which should not happen"
      );
    }
    this.globalModelConfigManager.clearModelConfigMap();
  }
}
const INSIGHT_MODEL_CONFIG_KEYS = {
  modelName: MIDSCENE_INSIGHT_MODEL_NAME,
  /**
   * proxy
   */
  socksProxy: MIDSCENE_INSIGHT_MODEL_SOCKS_PROXY,
  httpProxy: MIDSCENE_INSIGHT_MODEL_HTTP_PROXY,
  /**
   * OpenAI
   */
  openaiBaseURL: MIDSCENE_INSIGHT_MODEL_BASE_URL,
  openaiApiKey: MIDSCENE_INSIGHT_MODEL_API_KEY,
  openaiExtraConfig: MIDSCENE_INSIGHT_MODEL_INIT_CONFIG_JSON,
  /**
   * Extra
   */
  modelFamily: MIDSCENE_INSIGHT_MODEL_FAMILY,
  /**
   * Timeout
   */
  timeout: MIDSCENE_INSIGHT_MODEL_TIMEOUT,
  /**
   * Temperature
   */
  temperature: MIDSCENE_INSIGHT_MODEL_TEMPERATURE,
  /**
   * Retry
   */
  retryCount: MIDSCENE_INSIGHT_MODEL_RETRY_COUNT,
  retryInterval: MIDSCENE_INSIGHT_MODEL_RETRY_INTERVAL
};
const PLANNING_MODEL_CONFIG_KEYS = {
  modelName: MIDSCENE_PLANNING_MODEL_NAME,
  /**
   * proxy
   */
  socksProxy: MIDSCENE_PLANNING_MODEL_SOCKS_PROXY,
  httpProxy: MIDSCENE_PLANNING_MODEL_HTTP_PROXY,
  /**
   * OpenAI
   */
  openaiBaseURL: MIDSCENE_PLANNING_MODEL_BASE_URL,
  openaiApiKey: MIDSCENE_PLANNING_MODEL_API_KEY,
  openaiExtraConfig: MIDSCENE_PLANNING_MODEL_INIT_CONFIG_JSON,
  /**
   * Extra
   */
  modelFamily: MIDSCENE_PLANNING_MODEL_FAMILY,
  /**
   * Timeout
   */
  timeout: MIDSCENE_PLANNING_MODEL_TIMEOUT,
  /**
   * Temperature
   */
  temperature: MIDSCENE_PLANNING_MODEL_TEMPERATURE,
  /**
   * Retry
   */
  retryCount: MIDSCENE_PLANNING_MODEL_RETRY_COUNT,
  retryInterval: MIDSCENE_PLANNING_MODEL_RETRY_INTERVAL
};
const DEFAULT_MODEL_CONFIG_KEYS = {
  modelName: MIDSCENE_MODEL_NAME,
  /**
   * proxy
   */
  socksProxy: MIDSCENE_MODEL_SOCKS_PROXY,
  httpProxy: MIDSCENE_MODEL_HTTP_PROXY,
  /**
   * OpenAI
   */
  openaiBaseURL: MIDSCENE_MODEL_BASE_URL,
  openaiApiKey: MIDSCENE_MODEL_API_KEY,
  openaiExtraConfig: MIDSCENE_MODEL_INIT_CONFIG_JSON,
  /**
   * Extra
   */
  modelFamily: MIDSCENE_MODEL_FAMILY,
  /**
   * Timeout
   */
  timeout: MIDSCENE_MODEL_TIMEOUT,
  /**
   * Temperature
   */
  temperature: MIDSCENE_MODEL_TEMPERATURE,
  /**
   * Retry
   */
  retryCount: MIDSCENE_MODEL_RETRY_COUNT,
  retryInterval: MIDSCENE_MODEL_RETRY_INTERVAL
};
const maskKey = (key, maskChar = "*") => {
  if (typeof key !== "string" || key.length === 0) {
    return key;
  }
  const prefixLen = 3;
  const suffixLen = 3;
  const keepLength = prefixLen + suffixLen;
  if (key.length <= keepLength) {
    return key;
  }
  const prefix = key.substring(0, prefixLen);
  const suffix = key.substring(key.length - suffixLen);
  const maskLength = key.length - keepLength;
  const mask = maskChar.repeat(maskLength);
  return `${prefix}${mask}${suffix}`;
};
const maskConfig = (config2) => {
  return Object.fromEntries(
    Object.entries(config2).map(([key, value]) => {
      if (!value) return [key, value];
      if (typeof value === "string" && /key/i.test(key)) {
        return [key, maskKey(value)];
      }
      if (typeof value === "object") {
        const valueStr = JSON.stringify(value);
        if (/key/i.test(valueStr)) {
          return [key, maskKey(valueStr)];
        }
      }
      return [key, value];
    })
  );
};
const parseJson = (key, value) => {
  if (value) {
    try {
      return JSON.parse(value);
    } catch (e) {
      throw new Error(
        `Failed to parse ${key} as a JSON. ${e.message}`,
        {
          cause: e
        }
      );
    }
  }
  return void 0;
};
const KEYS_MAP = {
  insight: INSIGHT_MODEL_CONFIG_KEYS,
  planning: PLANNING_MODEL_CONFIG_KEYS,
  default: DEFAULT_MODEL_CONFIG_KEYS
};
const getUITarsModelVersion = (modelFamily) => {
  if (modelFamily === "vlm-ui-tars") {
    return UITarsModelVersion.V1_0;
  }
  if (modelFamily === "vlm-ui-tars-doubao" || modelFamily === "vlm-ui-tars-doubao-1.5") {
    return UITarsModelVersion.DOUBAO_1_5_20B;
  }
  return void 0;
};
const validateModelFamily = (modelFamily) => {
  if (modelFamily && !MODEL_FAMILY_VALUES.includes(modelFamily)) {
    throw new Error(`Invalid MIDSCENE_MODEL_FAMILY value: ${modelFamily}`);
  }
};
const legacyConfigToModelFamily = (provider) => {
  const isDoubao = provider[MIDSCENE_USE_DOUBAO_VISION];
  const isQwen = provider[MIDSCENE_USE_QWEN_VL];
  const isQwen3 = provider[MIDSCENE_USE_QWEN3_VL];
  const isUiTars = provider[MIDSCENE_USE_VLM_UI_TARS];
  const isGemini = provider[MIDSCENE_USE_GEMINI];
  const enabledModes = [
    isDoubao && MIDSCENE_USE_DOUBAO_VISION,
    isQwen && MIDSCENE_USE_QWEN_VL,
    isQwen3 && MIDSCENE_USE_QWEN3_VL,
    isUiTars && MIDSCENE_USE_VLM_UI_TARS,
    isGemini && MIDSCENE_USE_GEMINI
  ].filter(Boolean);
  if (enabledModes.length > 1) {
    throw new Error(
      `Only one vision mode can be enabled at a time. Currently enabled modes: ${enabledModes.join(", ")}. Please disable all but one mode.`
    );
  }
  if (isQwen3) return "qwen3-vl";
  if (isQwen) return "qwen2.5-vl";
  if (isDoubao) return "doubao-vision";
  if (isGemini) return "gemini";
  if (isUiTars) {
    if (isUiTars === "1") {
      return "vlm-ui-tars";
    } else if (isUiTars === "DOUBAO" || isUiTars === "DOUBAO-1.5") {
      return "vlm-ui-tars-doubao-1.5";
    } else {
      return "vlm-ui-tars-doubao";
    }
  }
  return void 0;
};
const getModelDescription = (modelFamily, uiTarsModelVersion) => {
  if (uiTarsModelVersion) {
    return `UI-TARS=${uiTarsModelVersion}`;
  }
  if (modelFamily) {
    return `${modelFamily} mode`;
  }
  return "";
};
const parseOpenaiSdkConfig = ({
  keys,
  provider,
  useLegacyLogic = false
}) => {
  initDebugConfig();
  const debugLog2 = getDebug("ai:config");
  debugLog2("enter parseOpenaiSdkConfig with keys:", keys);
  const legacyAPIKey = useLegacyLogic ? provider[OPENAI_API_KEY] : void 0;
  const legacyBaseURL = useLegacyLogic ? provider[OPENAI_BASE_URL] : void 0;
  const legacySocksProxy = useLegacyLogic ? provider[MIDSCENE_OPENAI_SOCKS_PROXY] : void 0;
  const legacyHttpProxy = useLegacyLogic ? provider[MIDSCENE_OPENAI_HTTP_PROXY] : void 0;
  const legacyOpenaiExtraConfig = useLegacyLogic ? provider[MIDSCENE_OPENAI_INIT_CONFIG_JSON] : void 0;
  const legacyModelFamily = useLegacyLogic ? legacyConfigToModelFamily(provider) : void 0;
  const modelFamilyRaw = provider[keys.modelFamily] || legacyModelFamily;
  const openaiApiKey = provider[keys.openaiApiKey] || legacyAPIKey;
  const openaiBaseURL = provider[keys.openaiBaseURL] || legacyBaseURL;
  const socksProxy = provider[keys.socksProxy] || legacySocksProxy;
  const httpProxy = provider[keys.httpProxy] || legacyHttpProxy;
  const modelName = provider[keys.modelName];
  const openaiExtraConfigStr = provider[keys.openaiExtraConfig];
  const openaiExtraConfig = parseJson(
    keys.openaiExtraConfig,
    openaiExtraConfigStr || legacyOpenaiExtraConfig
  );
  const temperature = provider[keys.temperature] ? Number(provider[keys.temperature]) : 0;
  const modelFamily = modelFamilyRaw;
  validateModelFamily(modelFamily);
  const uiTarsModelVersion = getUITarsModelVersion(modelFamily);
  const modelDescription = getModelDescription(modelFamily, uiTarsModelVersion);
  return {
    socksProxy,
    httpProxy,
    openaiBaseURL,
    openaiApiKey,
    openaiExtraConfig,
    modelFamily,
    uiTarsModelVersion,
    modelName,
    modelDescription,
    intent: "-",
    timeout: provider[keys.timeout] ? Number(provider[keys.timeout]) : void 0,
    temperature,
    retryCount: (() => {
      if (!provider[keys.retryCount]) return 1;
      const val = Number(provider[keys.retryCount]);
      if (!Number.isFinite(val)) return 1;
      if (val < 0)
        throw new Error(`${keys.retryCount} must be non-negative, got ${val}`);
      return val;
    })(),
    retryInterval: (() => {
      if (!provider[keys.retryInterval]) return 2e3;
      const val = Number(provider[keys.retryInterval]);
      if (!Number.isFinite(val)) return 2e3;
      if (val < 0)
        throw new Error(
          `${keys.retryInterval} must be non-negative, got ${val}`
        );
      return val;
    })()
  };
};
const decideModelConfigFromIntentConfig = (intent, configMap) => {
  const debugLog2 = getDebug("ai:config");
  debugLog2(
    "will decideModelConfig base on agent.modelConfig()",
    intent,
    maskConfig(configMap)
  );
  const keysForFn = KEYS_MAP[intent];
  const modelName = configMap[keysForFn.modelName];
  if (!modelName) {
    debugLog2("no modelName found for intent", intent);
    return void 0;
  }
  const finalResult = parseOpenaiSdkConfig({
    keys: keysForFn,
    provider: configMap,
    useLegacyLogic: intent === "default"
  });
  finalResult.intent = intent;
  debugLog2(
    "decideModelConfig result by agent.modelConfig() with intent",
    intent,
    maskConfig({ ...finalResult })
  );
  assert(
    finalResult.openaiBaseURL,
    `failed to get base URL of model (intent=${intent}). See https://midscenejs.com/model-strategy`
  );
  if (!finalResult.modelName) {
    console.warn(
      `modelName is not set for intent ${intent}, this may cause unexpected behavior. See https://midscenejs.com/model-strategy`
    );
  }
  return finalResult;
};
class ModelConfigManager {
  constructor(modelConfig, createOpenAIClientFn) {
    __publicField(this, "modelConfigMap");
    __publicField(this, "isInitialized", false);
    // once modelConfig is set, isolatedMode will be true
    // modelConfigMap will only depend on provided config and not be affected by process.env
    __publicField(this, "isolatedMode", false);
    __publicField(this, "globalConfigManager");
    __publicField(this, "modelConfig");
    __publicField(this, "createOpenAIClientFn");
    this.modelConfig = modelConfig;
    this.createOpenAIClientFn = createOpenAIClientFn;
  }
  initialize() {
    var _a3;
    if (this.isInitialized) {
      return;
    }
    let configMap;
    if (this.modelConfig) {
      this.isolatedMode = true;
      configMap = this.normalizeModelConfig(this.modelConfig);
    } else {
      configMap = ((_a3 = this.globalConfigManager) == null ? void 0 : _a3.getAllEnvConfig()) || {};
    }
    const defaultConfig = decideModelConfigFromIntentConfig(
      "default",
      configMap
    );
    if (!defaultConfig) {
      throw new Error(
        "Model configuration is incomplete: model name (MIDSCENE_MODEL_NAME) is required. See https://midscenejs.com/model-strategy.html"
      );
    }
    const insightConfig = decideModelConfigFromIntentConfig(
      "insight",
      configMap
    );
    const planningConfig = decideModelConfigFromIntentConfig(
      "planning",
      configMap
    );
    this.modelConfigMap = {
      default: {
        ...defaultConfig,
        createOpenAIClient: this.createOpenAIClientFn
      },
      insight: {
        ...insightConfig || defaultConfig,
        createOpenAIClient: this.createOpenAIClientFn
      },
      planning: {
        ...planningConfig || defaultConfig,
        createOpenAIClient: this.createOpenAIClientFn
      }
    };
    this.isInitialized = true;
  }
  normalizeModelConfig(config2) {
    return Object.entries(config2).reduce(
      (acc, [key, value]) => {
        if (value === void 0 || value === null) {
          return acc;
        }
        acc[key] = String(value);
        return acc;
      },
      /* @__PURE__ */ Object.create(null)
    );
  }
  /**
   * should only be called by GlobalConfigManager
   */
  clearModelConfigMap() {
    if (this.isolatedMode) {
      throw new Error(
        "ModelConfigManager work in isolated mode, so clearModelConfigMap should not be called"
      );
    }
    this.isInitialized = false;
  }
  /**
   * if isolatedMode is true, modelConfigMap was initialized in constructor and can't be changed
   * if isolatedMode is false, modelConfigMap can be changed by process.env so we need to recalculate it when it's undefined
   */
  getModelConfig(intent) {
    if (!this.isInitialized) {
      this.initialize();
    }
    if (!this.modelConfigMap) {
      throw new Error(
        "modelConfigMap is not initialized, which should not happen"
      );
    }
    return this.modelConfigMap[intent];
  }
  getUploadTestServerUrl() {
    const { openaiExtraConfig } = this.getModelConfig("default");
    const serverUrl = openaiExtraConfig == null ? void 0 : openaiExtraConfig.REPORT_SERVER_URL;
    return serverUrl;
  }
  registerGlobalConfigManager(globalConfigManager2) {
    this.globalConfigManager = globalConfigManager2;
  }
  throwErrorIfNonVLModel() {
    const modelConfig = this.getModelConfig("default");
    if (!modelConfig.modelFamily) {
      throw new Error(
        "MIDSCENE_MODEL_FAMILY is not set to a visual language model (VL model), the element localization can not be achieved. Check your model configuration. See https://midscenejs.com/model-strategy.html"
      );
    }
  }
}
const globalModelConfigManager = new ModelConfigManager();
const globalConfigManager = new GlobalConfigManager();
globalConfigManager.registerModelConfigManager(globalModelConfigManager);
globalModelConfigManager.registerGlobalConfigManager(globalConfigManager);
async function getCurrentTime(device, useDeviceTimestamp) {
  if (useDeviceTimestamp && (device == null ? void 0 : device.getTimestamp)) {
    try {
      return await device.getTimestamp();
    } catch (error2) {
      console.warn(
        `Failed to get device time, falling back to system time: ${error2}`
      );
      return Date.now();
    }
  }
  return Date.now();
}
const getPreferredLanguage = () => {
  const prefer = globalConfigManager.getEnvConfigValue(
    MIDSCENE_PREFERRED_LANGUAGE
  );
  if (prefer) {
    return prefer;
  }
  const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const isChina = timeZone === "Asia/Shanghai";
  return isChina ? "Chinese" : "English";
};
const overrideAIConfig = (newConfig, extendMode = false) => {
  globalConfigManager.overrideAIConfig(newConfig, extendMode);
};
class JSONRepairError extends Error {
  constructor(message, position) {
    super("".concat(message, " at position ").concat(position));
    this.position = position;
  }
}
const codeSpace = 32;
const codeNewline = 10;
const codeTab = 9;
const codeReturn = 13;
const codeNonBreakingSpace = 160;
const codeEnQuad = 8192;
const codeHairSpace = 8202;
const codeNarrowNoBreakSpace = 8239;
const codeMediumMathematicalSpace = 8287;
const codeIdeographicSpace = 12288;
function isHex(char) {
  return /^[0-9A-Fa-f]$/.test(char);
}
function isDigit(char) {
  return char >= "0" && char <= "9";
}
function isValidStringCharacter(char) {
  return char >= " ";
}
function isDelimiter(char) {
  return ",:[]/{}()\n+".includes(char);
}
function isFunctionNameCharStart(char) {
  return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char === "_" || char === "$";
}
function isFunctionNameChar(char) {
  return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char === "_" || char === "$" || char >= "0" && char <= "9";
}
const regexUrlStart = /^(http|https|ftp|mailto|file|data|irc):\/\/$/;
const regexUrlChar = /^[A-Za-z0-9-._~:/?#@!$&'()*+;=]$/;
function isUnquotedStringDelimiter(char) {
  return ",[]/{}\n+".includes(char);
}
function isStartOfValue(char) {
  return isQuote(char) || regexStartOfValue.test(char);
}
const regexStartOfValue = /^[[{\w-]$/;
function isControlCharacter(char) {
  return char === "\n" || char === "\r" || char === "	" || char === "\b" || char === "\f";
}
function isWhitespace$1(text, index2) {
  const code = text.charCodeAt(index2);
  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;
}
function isWhitespaceExceptNewline(text, index2) {
  const code = text.charCodeAt(index2);
  return code === codeSpace || code === codeTab || code === codeReturn;
}
function isSpecialWhitespace(text, index2) {
  const code = text.charCodeAt(index2);
  return code === codeNonBreakingSpace || code >= codeEnQuad && code <= codeHairSpace || code === codeNarrowNoBreakSpace || code === codeMediumMathematicalSpace || code === codeIdeographicSpace;
}
function isQuote(char) {
  return isDoubleQuoteLike(char) || isSingleQuoteLike(char);
}
function isDoubleQuoteLike(char) {
  return char === '"' || char === "" || char === "";
}
function isDoubleQuote(char) {
  return char === '"';
}
function isSingleQuoteLike(char) {
  return char === "'" || char === "" || char === "" || char === "`" || char === "";
}
function isSingleQuote(char) {
  return char === "'";
}
function stripLastOccurrence(text, textToStrip) {
  let stripRemainingText = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const index2 = text.lastIndexOf(textToStrip);
  return index2 !== -1 ? text.substring(0, index2) + (stripRemainingText ? "" : text.substring(index2 + 1)) : text;
}
function insertBeforeLastWhitespace(text, textToInsert) {
  let index2 = text.length;
  if (!isWhitespace$1(text, index2 - 1)) {
    return text + textToInsert;
  }
  while (isWhitespace$1(text, index2 - 1)) {
    index2--;
  }
  return text.substring(0, index2) + textToInsert + text.substring(index2);
}
function removeAtIndex(text, start, count) {
  return text.substring(0, start) + text.substring(start + count);
}
function endsWithCommaOrNewline(text) {
  return /[,\n][ \t\r]*$/.test(text);
}
const controlCharacters = {
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
const escapeCharacters = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
  // note that \u is handled separately in parseString()
};
function jsonrepair(text) {
  let i = 0;
  let output = "";
  parseMarkdownCodeBlock();
  const processed = parseValue();
  if (!processed) {
    throwUnexpectedEnd();
  }
  parseMarkdownCodeBlock();
  const processedComma = parseCharacter(",");
  if (processedComma) {
    parseWhitespaceAndSkipComments();
  }
  if (isStartOfValue(text[i]) && endsWithCommaOrNewline(output)) {
    if (!processedComma) {
      output = insertBeforeLastWhitespace(output, ",");
    }
    parseNewlineDelimitedJSON();
  } else if (processedComma) {
    output = stripLastOccurrence(output, ",");
  }
  while (text[i] === "}" || text[i] === "]") {
    i++;
    parseWhitespaceAndSkipComments();
  }
  if (i >= text.length) {
    return output;
  }
  throwUnexpectedCharacter();
  function parseValue() {
    parseWhitespaceAndSkipComments();
    const processed2 = parseObject() || parseArray() || parseString() || parseNumber() || parseKeywords() || parseUnquotedString(false) || parseRegex();
    parseWhitespaceAndSkipComments();
    return processed2;
  }
  function parseWhitespaceAndSkipComments() {
    let skipNewline = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    const start = i;
    let changed = parseWhitespace(skipNewline);
    do {
      changed = parseComment();
      if (changed) {
        changed = parseWhitespace(skipNewline);
      }
    } while (changed);
    return i > start;
  }
  function parseWhitespace(skipNewline) {
    const _isWhiteSpace = skipNewline ? isWhitespace$1 : isWhitespaceExceptNewline;
    let whitespace = "";
    while (true) {
      if (_isWhiteSpace(text, i)) {
        whitespace += text[i];
        i++;
      } else if (isSpecialWhitespace(text, i)) {
        whitespace += " ";
        i++;
      } else {
        break;
      }
    }
    if (whitespace.length > 0) {
      output += whitespace;
      return true;
    }
    return false;
  }
  function parseComment() {
    if (text[i] === "/" && text[i + 1] === "*") {
      while (i < text.length && !atEndOfBlockComment(text, i)) {
        i++;
      }
      i += 2;
      return true;
    }
    if (text[i] === "/" && text[i + 1] === "/") {
      while (i < text.length && text[i] !== "\n") {
        i++;
      }
      return true;
    }
    return false;
  }
  function parseMarkdownCodeBlock() {
    if (text.slice(i, i + 3) === "```") {
      i += 3;
      if (isFunctionNameCharStart(text[i])) {
        while (i < text.length && isFunctionNameChar(text[i])) {
          i++;
        }
      }
      parseWhitespaceAndSkipComments();
      return true;
    }
    return false;
  }
  function parseCharacter(char) {
    if (text[i] === char) {
      output += text[i];
      i++;
      return true;
    }
    return false;
  }
  function skipCharacter(char) {
    if (text[i] === char) {
      i++;
      return true;
    }
    return false;
  }
  function skipEscapeCharacter() {
    return skipCharacter("\\");
  }
  function skipEllipsis() {
    parseWhitespaceAndSkipComments();
    if (text[i] === "." && text[i + 1] === "." && text[i + 2] === ".") {
      i += 3;
      parseWhitespaceAndSkipComments();
      skipCharacter(",");
      return true;
    }
    return false;
  }
  function parseObject() {
    if (text[i] === "{") {
      output += "{";
      i++;
      parseWhitespaceAndSkipComments();
      if (skipCharacter(",")) {
        parseWhitespaceAndSkipComments();
      }
      let initial = true;
      while (i < text.length && text[i] !== "}") {
        let processedComma2;
        if (!initial) {
          processedComma2 = parseCharacter(",");
          if (!processedComma2) {
            output = insertBeforeLastWhitespace(output, ",");
          }
          parseWhitespaceAndSkipComments();
        } else {
          processedComma2 = true;
          initial = false;
        }
        skipEllipsis();
        const processedKey = parseString() || parseUnquotedString(true);
        if (!processedKey) {
          if (text[i] === "}" || text[i] === "{" || text[i] === "]" || text[i] === "[" || text[i] === void 0) {
            output = stripLastOccurrence(output, ",");
          } else {
            throwObjectKeyExpected();
          }
          break;
        }
        parseWhitespaceAndSkipComments();
        const processedColon = parseCharacter(":");
        const truncatedText = i >= text.length;
        if (!processedColon) {
          if (isStartOfValue(text[i]) || truncatedText) {
            output = insertBeforeLastWhitespace(output, ":");
          } else {
            throwColonExpected();
          }
        }
        const processedValue = parseValue();
        if (!processedValue) {
          if (processedColon || truncatedText) {
            output += "null";
          } else {
            throwColonExpected();
          }
        }
      }
      if (text[i] === "}") {
        output += "}";
        i++;
      } else {
        output = insertBeforeLastWhitespace(output, "}");
      }
      return true;
    }
    return false;
  }
  function parseArray() {
    if (text[i] === "[") {
      output += "[";
      i++;
      parseWhitespaceAndSkipComments();
      if (skipCharacter(",")) {
        parseWhitespaceAndSkipComments();
      }
      let initial = true;
      while (i < text.length && text[i] !== "]") {
        if (!initial) {
          const processedComma2 = parseCharacter(",");
          if (!processedComma2) {
            output = insertBeforeLastWhitespace(output, ",");
          }
        } else {
          initial = false;
        }
        skipEllipsis();
        const processedValue = parseValue();
        if (!processedValue) {
          output = stripLastOccurrence(output, ",");
          break;
        }
      }
      if (text[i] === "]") {
        output += "]";
        i++;
      } else {
        output = insertBeforeLastWhitespace(output, "]");
      }
      return true;
    }
    return false;
  }
  function parseNewlineDelimitedJSON() {
    let initial = true;
    let processedValue = true;
    while (processedValue) {
      if (!initial) {
        const processedComma2 = parseCharacter(",");
        if (!processedComma2) {
          output = insertBeforeLastWhitespace(output, ",");
        }
      } else {
        initial = false;
      }
      processedValue = parseValue();
    }
    if (!processedValue) {
      output = stripLastOccurrence(output, ",");
    }
    output = "[\n".concat(output, "\n]");
  }
  function parseString() {
    let stopAtDelimiter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let stopAtIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    let skipEscapeChars = text[i] === "\\";
    if (skipEscapeChars) {
      i++;
      skipEscapeChars = true;
    }
    if (isQuote(text[i])) {
      const isEndQuote = isDoubleQuote(text[i]) ? isDoubleQuote : isSingleQuote(text[i]) ? isSingleQuote : isSingleQuoteLike(text[i]) ? isSingleQuoteLike : isDoubleQuoteLike;
      const iBefore = i;
      const oBefore = output.length;
      let str2 = '"';
      i++;
      while (true) {
        if (i >= text.length) {
          const iPrev = prevNonWhitespaceIndex(i - 1);
          if (!stopAtDelimiter && isDelimiter(text.charAt(iPrev))) {
            i = iBefore;
            output = output.substring(0, oBefore);
            return parseString(true);
          }
          str2 = insertBeforeLastWhitespace(str2, '"');
          output += str2;
          return true;
        } else if (i === stopAtIndex) {
          str2 = insertBeforeLastWhitespace(str2, '"');
          output += str2;
          return true;
        } else if (isEndQuote(text[i])) {
          const iQuote = i;
          const oQuote = str2.length;
          str2 += '"';
          i++;
          output += str2;
          parseWhitespaceAndSkipComments(false);
          if (stopAtDelimiter || i >= text.length || isDelimiter(text[i]) || isQuote(text[i]) || isDigit(text[i])) {
            parseConcatenatedString();
            return true;
          }
          const iPrevChar = prevNonWhitespaceIndex(iQuote - 1);
          const prevChar = text.charAt(iPrevChar);
          if (prevChar === ",") {
            i = iBefore;
            output = output.substring(0, oBefore);
            return parseString(false, iPrevChar);
          }
          if (isDelimiter(prevChar)) {
            i = iBefore;
            output = output.substring(0, oBefore);
            return parseString(true);
          }
          output = output.substring(0, oBefore);
          i = iQuote + 1;
          str2 = "".concat(str2.substring(0, oQuote), "\\").concat(str2.substring(oQuote));
        } else if (stopAtDelimiter && isUnquotedStringDelimiter(text[i])) {
          if (text[i - 1] === ":" && regexUrlStart.test(text.substring(iBefore + 1, i + 2))) {
            while (i < text.length && regexUrlChar.test(text[i])) {
              str2 += text[i];
              i++;
            }
          }
          str2 = insertBeforeLastWhitespace(str2, '"');
          output += str2;
          parseConcatenatedString();
          return true;
        } else if (text[i] === "\\") {
          const char = text.charAt(i + 1);
          const escapeChar = escapeCharacters[char];
          if (escapeChar !== void 0) {
            str2 += text.slice(i, i + 2);
            i += 2;
          } else if (char === "u") {
            let j = 2;
            while (j < 6 && isHex(text[i + j])) {
              j++;
            }
            if (j === 6) {
              str2 += text.slice(i, i + 6);
              i += 6;
            } else if (i + j >= text.length) {
              i = text.length;
            } else {
              throwInvalidUnicodeCharacter();
            }
          } else {
            str2 += char;
            i += 2;
          }
        } else {
          const char = text.charAt(i);
          if (char === '"' && text[i - 1] !== "\\") {
            str2 += "\\".concat(char);
            i++;
          } else if (isControlCharacter(char)) {
            str2 += controlCharacters[char];
            i++;
          } else {
            if (!isValidStringCharacter(char)) {
              throwInvalidCharacter(char);
            }
            str2 += char;
            i++;
          }
        }
        if (skipEscapeChars) {
          skipEscapeCharacter();
        }
      }
    }
    return false;
  }
  function parseConcatenatedString() {
    let processed2 = false;
    parseWhitespaceAndSkipComments();
    while (text[i] === "+") {
      processed2 = true;
      i++;
      parseWhitespaceAndSkipComments();
      output = stripLastOccurrence(output, '"', true);
      const start = output.length;
      const parsedStr = parseString();
      if (parsedStr) {
        output = removeAtIndex(output, start, 1);
      } else {
        output = insertBeforeLastWhitespace(output, '"');
      }
    }
    return processed2;
  }
  function parseNumber() {
    const start = i;
    if (text[i] === "-") {
      i++;
      if (atEndOfNumber()) {
        repairNumberEndingWithNumericSymbol(start);
        return true;
      }
      if (!isDigit(text[i])) {
        i = start;
        return false;
      }
    }
    while (isDigit(text[i])) {
      i++;
    }
    if (text[i] === ".") {
      i++;
      if (atEndOfNumber()) {
        repairNumberEndingWithNumericSymbol(start);
        return true;
      }
      if (!isDigit(text[i])) {
        i = start;
        return false;
      }
      while (isDigit(text[i])) {
        i++;
      }
    }
    if (text[i] === "e" || text[i] === "E") {
      i++;
      if (text[i] === "-" || text[i] === "+") {
        i++;
      }
      if (atEndOfNumber()) {
        repairNumberEndingWithNumericSymbol(start);
        return true;
      }
      if (!isDigit(text[i])) {
        i = start;
        return false;
      }
      while (isDigit(text[i])) {
        i++;
      }
    }
    if (!atEndOfNumber()) {
      i = start;
      return false;
    }
    if (i > start) {
      const num = text.slice(start, i);
      const hasInvalidLeadingZero = /^0\d/.test(num);
      output += hasInvalidLeadingZero ? '"'.concat(num, '"') : num;
      return true;
    }
    return false;
  }
  function parseKeywords() {
    return parseKeyword("true", "true") || parseKeyword("false", "false") || parseKeyword("null", "null") || // repair Python keywords True, False, None
    parseKeyword("True", "true") || parseKeyword("False", "false") || parseKeyword("None", "null");
  }
  function parseKeyword(name, value) {
    if (text.slice(i, i + name.length) === name) {
      output += value;
      i += name.length;
      return true;
    }
    return false;
  }
  function parseUnquotedString(isKey) {
    const start = i;
    if (isFunctionNameCharStart(text[i])) {
      while (i < text.length && isFunctionNameChar(text[i])) {
        i++;
      }
      let j = i;
      while (isWhitespace$1(text, j)) {
        j++;
      }
      if (text[j] === "(") {
        i = j + 1;
        parseValue();
        if (text[i] === ")") {
          i++;
          if (text[i] === ";") {
            i++;
          }
        }
        return true;
      }
    }
    while (i < text.length && !isUnquotedStringDelimiter(text[i]) && !isQuote(text[i]) && (!isKey || text[i] !== ":")) {
      i++;
    }
    if (text[i - 1] === ":" && regexUrlStart.test(text.substring(start, i + 2))) {
      while (i < text.length && regexUrlChar.test(text[i])) {
        i++;
      }
    }
    if (i > start) {
      while (isWhitespace$1(text, i - 1) && i > 0) {
        i--;
      }
      const symbol = text.slice(start, i);
      output += symbol === "undefined" ? "null" : JSON.stringify(symbol);
      if (text[i] === '"') {
        i++;
      }
      return true;
    }
  }
  function parseRegex() {
    if (text[i] === "/") {
      const start = i;
      i++;
      while (i < text.length && (text[i] !== "/" || text[i - 1] === "\\")) {
        i++;
      }
      i++;
      output += '"'.concat(text.substring(start, i), '"');
      return true;
    }
  }
  function prevNonWhitespaceIndex(start) {
    let prev = start;
    while (prev > 0 && isWhitespace$1(text, prev)) {
      prev--;
    }
    return prev;
  }
  function atEndOfNumber() {
    return i >= text.length || isDelimiter(text[i]) || isWhitespace$1(text, i);
  }
  function repairNumberEndingWithNumericSymbol(start) {
    output += "".concat(text.slice(start, i), "0");
  }
  function throwInvalidCharacter(char) {
    throw new JSONRepairError("Invalid character ".concat(JSON.stringify(char)), i);
  }
  function throwUnexpectedCharacter() {
    throw new JSONRepairError("Unexpected character ".concat(JSON.stringify(text[i])), i);
  }
  function throwUnexpectedEnd() {
    throw new JSONRepairError("Unexpected end of json string", text.length);
  }
  function throwObjectKeyExpected() {
    throw new JSONRepairError("Object key expected", i);
  }
  function throwColonExpected() {
    throw new JSONRepairError("Colon expected", i);
  }
  function throwInvalidUnicodeCharacter() {
    const chars = text.slice(i, i + 6);
    throw new JSONRepairError('Invalid unicode character "'.concat(chars, '"'), i);
  }
}
function atEndOfBlockComment(text, i) {
  return text[i] === "*" && text[i + 1] === "/";
}
function __classPrivateFieldSet$1(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
function __classPrivateFieldGet$1(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
let uuid4 = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2 == null ? void 0 : crypto2.randomUUID) {
    uuid4 = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u82 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u82)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};
function isAbortError(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
const castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error2 = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error2.stack = err.stack;
        if (err.cause && !error2.cause)
          error2.cause = err.cause;
        if (err.name)
          error2.name = err.name;
        return error2;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};
class OpenAIError extends Error {
}
class APIError extends OpenAIError {
  constructor(status3, error2, message, headers) {
    super(`${APIError.makeMessage(status3, error2, message)}`);
    this.status = status3;
    this.headers = headers;
    this.requestID = headers == null ? void 0 : headers.get("x-request-id");
    this.error = error2;
    const data = error2;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status3, error2, message) {
    const msg = (error2 == null ? void 0 : error2.message) ? typeof error2.message === "string" ? error2.message : JSON.stringify(error2.message) : error2 ? JSON.stringify(error2) : message;
    if (status3 && msg) {
      return `${status3} ${msg}`;
    }
    if (status3) {
      return `${status3} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status3, errorResponse, message, headers) {
    if (!status3 || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error2 = errorResponse == null ? void 0 : errorResponse["error"];
    if (status3 === 400) {
      return new BadRequestError(status3, error2, message, headers);
    }
    if (status3 === 401) {
      return new AuthenticationError(status3, error2, message, headers);
    }
    if (status3 === 403) {
      return new PermissionDeniedError(status3, error2, message, headers);
    }
    if (status3 === 404) {
      return new NotFoundError(status3, error2, message, headers);
    }
    if (status3 === 409) {
      return new ConflictError(status3, error2, message, headers);
    }
    if (status3 === 422) {
      return new UnprocessableEntityError(status3, error2, message, headers);
    }
    if (status3 === 429) {
      return new RateLimitError(status3, error2, message, headers);
    }
    if (status3 >= 500) {
      return new InternalServerError(status3, error2, message, headers);
    }
    return new APIError(status3, error2, message, headers);
  }
}
class APIUserAbortError extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
}
class APIConnectionError extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
}
class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
}
class BadRequestError extends APIError {
}
class AuthenticationError extends APIError {
}
class PermissionDeniedError extends APIError {
}
class NotFoundError extends APIError {
}
class ConflictError extends APIError {
}
class UnprocessableEntityError extends APIError {
}
class RateLimitError extends APIError {
}
class InternalServerError extends APIError {
}
class LengthFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
}
class ContentFilterFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
}
class InvalidWebhookSignatureError extends Error {
  constructor(message) {
    super(message);
  }
}
const startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
const isAbsoluteURL = (url2) => {
  return startsWithSchemeRegexp.test(url2);
};
let isArray = (val) => (isArray = Array.isArray, isArray(val));
let isReadonlyArray = isArray;
function maybeObj(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k2 in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
const validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
const safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
const sleep$1 = (ms2) => new Promise((resolve3) => setTimeout(resolve3, ms2));
const VERSION = "6.3.0";
const isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
const getPlatformProperties = () => {
  var _a3;
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : ((_a3 = Deno.version) == null ? void 0 : _a3.deno) ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match2 = pattern.exec(navigator.userAgent);
    if (match2) {
      const major2 = match2[1] || 0;
      const minor2 = match2[2] || 0;
      const patch2 = match2[3] || 0;
      return { browser: key, version: `${major2}.${minor2}.${patch2}` };
    }
  }
  return null;
}
const normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
const normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
let _platformHeaders;
const getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      var _a3;
      await ((_a3 = iter.return) == null ? void 0 : _a3.call(iter));
    }
  });
}
function ReadableStreamToAsyncIterable(stream2) {
  if (stream2[Symbol.asyncIterator])
    return stream2;
  const reader2 = stream2.getReader();
  return {
    async next() {
      try {
        const result = await reader2.read();
        if (result == null ? void 0 : result.done)
          reader2.releaseLock();
        return result;
      } catch (e) {
        reader2.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader2.cancel();
      reader2.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream2) {
  var _a3, _b;
  if (stream2 === null || typeof stream2 !== "object")
    return;
  if (stream2[Symbol.asyncIterator]) {
    await ((_b = (_a3 = stream2[Symbol.asyncIterator]()).return) == null ? void 0 : _b.call(_a3));
    return;
  }
  const reader2 = stream2.getReader();
  const cancelPromise = reader2.cancel();
  reader2.releaseLock();
  await cancelPromise;
}
const FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};
const default_format = "RFC3986";
const default_formatter = (v) => String(v);
const formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: default_formatter
};
const RFC1738 = "RFC1738";
let has = (obj, key) => (has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), has(obj, key));
const hex_table = /* @__PURE__ */ (() => {
  const array = [];
  for (let i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
})();
const limit = 1024;
const encode = (str2, _defaultEncoder, charset3, _kind, format2) => {
  if (str2.length === 0) {
    return str2;
  }
  let string2 = str2;
  if (typeof str2 === "symbol") {
    string2 = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string2 = String(str2);
  }
  if (charset3 === "iso-8859-1") {
    return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string2.length; j += limit) {
    const segment = string2.length >= limit ? string2.slice(j, j + limit) : string2;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format2 === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (isArray(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}
const array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
const push_to_array = function(arr, value_or_array) {
  Array.prototype.push.apply(arr, isArray(value_or_array) ? value_or_array : [value_or_array]);
};
let toISOString;
const defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: default_formatter,
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return (toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString)))(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
const sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort2, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset3, sideChannel2) {
  let obj = object;
  let tmp_sc = sideChannel2;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter2 === "function") {
    obj = filter2(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate == null ? void 0 : serializeDate(obj);
  } else if (generateArrayPrefix === "comma" && isArray(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate == null ? void 0 : serializeDate(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset3, "key", format2)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset3, "key", format2);
      return [
        (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
        (formatter == null ? void 0 : formatter(encoder(obj, defaults.encoder, charset3, "value", format2)))
      ];
    }
    return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && isArray(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray(filter2)) {
    obj_keys = filter2;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort2 ? keys.sort(sort2) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel2.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel2);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
      filter2,
      sort2,
      allowDots,
      serializeDate,
      format2,
      formatter,
      encodeValuesOnly,
      charset3,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset3 = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format2 = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  const formatter = formatters[format2];
  let filter2 = defaults.filter;
  if (typeof opts.filter === "function" || isArray(opts.filter)) {
    filter2 = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset: charset3,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter: filter2,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify$1(object, opts = {}) {
  let obj = object;
  const options2 = normalize_stringify_options(opts);
  let obj_keys;
  let filter2;
  if (typeof options2.filter === "function") {
    filter2 = options2.filter;
    obj = filter2("", obj);
  } else if (isArray(options2.filter)) {
    filter2 = options2.filter;
    obj_keys = filter2;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options2.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options2.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options2.sort) {
    obj_keys.sort(options2.sort);
  }
  const sideChannel2 = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options2.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options2.allowEmptyArrays,
      options2.strictNullHandling,
      options2.skipNulls,
      options2.encodeDotInKeys,
      options2.encode ? options2.encoder : null,
      options2.filter,
      options2.sort,
      options2.allowDots,
      options2.serializeDate,
      options2.format,
      options2.formatter,
      options2.encodeValuesOnly,
      options2.charset,
      sideChannel2
    ));
  }
  const joined = keys.join(options2.delimiter);
  let prefix = options2.addQueryPrefix === true ? "?" : "";
  if (options2.charsetSentinel) {
    if (options2.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}
function concatBytes(buffers) {
  let length = 0;
  for (const buffer2 of buffers) {
    length += buffer2.length;
  }
  const output = new Uint8Array(length);
  let index2 = 0;
  for (const buffer2 of buffers) {
    output.set(buffer2, index2);
    index2 += buffer2.length;
  }
  return output;
}
let encodeUTF8_;
function encodeUTF8(str2) {
  let encoder;
  return (encodeUTF8_ ?? (encoder = new globalThis.TextEncoder(), encodeUTF8_ = encoder.encode.bind(encoder)))(str2);
}
let decodeUTF8_;
function decodeUTF8(bytes2) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes2);
}
var _LineDecoder_buffer, _LineDecoder_carriageReturnIndex;
class LineDecoder {
  constructor() {
    _LineDecoder_buffer.set(this, void 0);
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    __classPrivateFieldSet$1(this, _LineDecoder_buffer, new Uint8Array());
    __classPrivateFieldSet$1(this, _LineDecoder_carriageReturnIndex, null);
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet$1(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet$1(this, _LineDecoder_buffer, "f"), binaryChunk]));
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet$1(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet$1(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet$1(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet$1(this, _LineDecoder_carriageReturnIndex, patternIndex.index);
        continue;
      }
      if (__classPrivateFieldGet$1(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet$1(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet$1(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet$1(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet$1(this, _LineDecoder_buffer, __classPrivateFieldGet$1(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet$1(this, _LineDecoder_carriageReturnIndex, "f")));
        __classPrivateFieldSet$1(this, _LineDecoder_carriageReturnIndex, null);
        continue;
      }
      const endIndex2 = __classPrivateFieldGet$1(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet$1(this, _LineDecoder_buffer, "f").subarray(0, endIndex2));
      lines.push(line);
      __classPrivateFieldSet$1(this, _LineDecoder_buffer, __classPrivateFieldGet$1(this, _LineDecoder_buffer, "f").subarray(patternIndex.index));
      __classPrivateFieldSet$1(this, _LineDecoder_carriageReturnIndex, null);
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet$1(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
}
_LineDecoder_buffer = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer2, startIndex2) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex2 ?? 0; i < buffer2.length; i++) {
    if (buffer2[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer2[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer2) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer2.length - 1; i++) {
    if (buffer2[i] === newline && buffer2[i + 1] === newline) {
      return i + 2;
    }
    if (buffer2[i] === carriage && buffer2[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer2[i] === carriage && buffer2[i + 1] === newline && i + 3 < buffer2.length && buffer2[i + 2] === carriage && buffer2[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
const levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
const parseLogLevel = (maybeLevel, sourceName, client2) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client2).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return void 0;
};
function noop$1() {
}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop$1;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
const noopLogger = {
  error: noop$1,
  warn: noop$1,
  info: noop$1,
  debug: noop$1
};
let cachedLoggers = /* @__PURE__ */ new WeakMap();
function loggerFor(client2) {
  const logger = client2.logger;
  const logLevel = client2.logLevel ?? "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
const formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};
var _Stream_client;
let Stream$2 = class Stream {
  constructor(iterator2, controller, client2) {
    this.iterator = iterator2;
    _Stream_client.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet$1(this, _Stream_client, client2);
  }
  static fromSSEResponse(response2, controller, client2) {
    let consumed = false;
    const logger = client2 ? loggerFor(client2) : console;
    async function* iterator2() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response2, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || !sse.event.startsWith("thread.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, response2.headers);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator2, controller, client2);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client2) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator2() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator2, controller, client2);
  }
  [(_Stream_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator2 = this.iterator();
    const teeIterator = (queue2) => {
      return {
        next: () => {
          if (queue2.length === 0) {
            const result = iterator2.next();
            left.push(result);
            right.push(result);
          }
          return queue2.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet$1(this, _Stream_client, "f")),
      new Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet$1(this, _Stream_client, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    return makeReadableStream({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes2 = encodeUTF8(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes2);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a3;
        await ((_a3 = iter.return) == null ? void 0 : _a3.call(iter));
      }
    });
  }
};
async function* _iterSSEMessages(response2, controller) {
  if (!response2.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response2.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator2) {
  let data = new Uint8Array();
  for await (const chunk of iterator2) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
class SSEDecoder {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
}
function partition(str2, delimiter) {
  const index2 = str2.indexOf(delimiter);
  if (index2 !== -1) {
    return [str2.substring(0, index2), delimiter, str2.substring(index2 + delimiter.length)];
  }
  return [str2, "", ""];
}
async function defaultParseResponse(client2, props2) {
  const { response: response2, requestLogID, retryOfRequestLogID, startTime } = props2;
  const body = await (async () => {
    var _a3;
    if (props2.options.stream) {
      loggerFor(client2).debug("response", response2.status, response2.url, response2.headers, response2.body);
      if (props2.options.__streamClass) {
        return props2.options.__streamClass.fromSSEResponse(response2, props2.controller, client2);
      }
      return Stream$2.fromSSEResponse(response2, props2.controller, client2);
    }
    if (response2.status === 204) {
      return null;
    }
    if (props2.options.__binaryResponse) {
      return response2;
    }
    const contentType3 = response2.headers.get("content-type");
    const mediaType3 = (_a3 = contentType3 == null ? void 0 : contentType3.split(";")[0]) == null ? void 0 : _a3.trim();
    const isJSON = (mediaType3 == null ? void 0 : mediaType3.includes("application/json")) || (mediaType3 == null ? void 0 : mediaType3.endsWith("+json"));
    if (isJSON) {
      const json3 = await response2.json();
      return addRequestID(json3, response2);
    }
    const text = await response2.text();
    return text;
  })();
  loggerFor(client2).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response2.url,
    status: response2.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID(value, response2) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response2.headers.get("x-request-id"),
    enumerable: false
  });
}
var _APIPromise_client;
class APIPromise extends Promise {
  constructor(client2, responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve3) => {
      resolve3(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client.set(this, void 0);
    __classPrivateFieldSet$1(this, _APIPromise_client, client2);
  }
  _thenUnwrap(transform2) {
    return new APIPromise(__classPrivateFieldGet$1(this, _APIPromise_client, "f"), this.responsePromise, async (client2, props2) => addRequestID(transform2(await this.parseResponse(client2, props2), props2), props2.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response2] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response: response2, request_id: response2.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet$1(this, _APIPromise_client, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
}
_APIPromise_client = /* @__PURE__ */ new WeakMap();
var _AbstractPage_client;
class AbstractPage {
  constructor(client2, response2, body, options2) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet$1(this, _AbstractPage_client, client2);
    this.options = options2;
    this.response = response2;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet$1(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
}
class PagePromise extends APIPromise {
  constructor(client2, request2, Page2) {
    super(client2, request2, async (client3, props2) => new Page2(client3, props2.response, await defaultParseResponse(client3, props2), props2.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
}
class Page extends AbstractPage {
  constructor(client2, response2, body, options2) {
    super(client2, response2, body, options2);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
}
class CursorPage extends AbstractPage {
  constructor(client2, response2, body, options2) {
    super(client2, response2, body, options2);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    var _a3;
    const data = this.getPaginatedItems();
    const id = (_a3 = data[data.length - 1]) == null ? void 0 : _a3.id;
    if (!id) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: id
      }
    };
  }
}
class ConversationCursorPage extends AbstractPage {
  constructor(client2, response2, body, options2) {
    super(client2, response2, body, options2);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.last_id = body.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: cursor
      }
    };
  }
}
const checkFileSupport = () => {
  var _a3;
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof ((_a3 = process2 == null ? void 0 : process2.versions) == null ? void 0 : _a3.node) === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile(fileBits, fileName, options2) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options2);
}
function getName(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
const isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
const maybeMultipartFormRequestOptions = async (opts, fetch2) => {
  if (!hasUploadableValue(opts.body))
    return opts;
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
const multipartFormRequestOptions = async (opts, fetch2) => {
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
const supportsFormDataMap = /* @__PURE__ */ new WeakMap();
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap.get(fetch2);
  if (cached)
    return cached;
  const promise2 = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise2);
  return promise2;
}
const createForm = async (body, fetch2) => {
  if (!await supportsFormData(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
const isNamedBlob = (value) => value instanceof Blob && "name" in value;
const isUploadable = (value) => typeof value === "object" && value !== null && (value instanceof Response || isAsyncIterable(value) || isNamedBlob(value));
const hasUploadableValue = (value) => {
  if (isUploadable(value))
    return true;
  if (Array.isArray(value))
    return value.some(hasUploadableValue);
  if (value && typeof value === "object") {
    for (const k in value) {
      if (hasUploadableValue(value[k]))
        return true;
    }
  }
  return false;
};
const addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    form.append(key, makeFile([await value.blob()], getName(value)));
  } else if (isAsyncIterable(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
  } else if (isNamedBlob(value)) {
    form.append(key, value, getName(value));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry2) => addFormValue(form, key + "[]", entry2)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};
const isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
const isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
const isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile(value, name, options2) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options2);
  }
  const parts = await getBytes(value);
  name || (name = getName(value));
  if (!(options2 == null ? void 0 : options2.type)) {
    const type3 = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type3 === "string") {
      options2 = { ...options2, type: type3 };
    }
  }
  return makeFile(parts, name, options2);
}
async function getBytes(value) {
  var _a3;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = (_a3 = value == null ? void 0 : value.constructor) == null ? void 0 : _a3.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props2 = Object.getOwnPropertyNames(value);
  return `; props: [${props2.map((p) => `"${p}"`).join(", ")}]`;
}
class APIResource {
  constructor(client2) {
    this._client = client2;
  }
}
function encodeURIPath(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
const EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
const createPathTagFunction = (pathEncoder = encodeURIPath) => function path3(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path4 = statics.reduce((previousValue, currentValue, index2) => {
    var _a3;
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index2];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index2 !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === ((_a3 = Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)) == null ? void 0 : _a3.toString))) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index2 === params.length ? "" : encoded);
  }, "");
  const pathOnly = path4.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
  let match2;
  while ((match2 = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match2.index,
      length: match2[0].length,
      error: `Value "${match2[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path4}
${underline}`);
  }
  return path4;
};
const path$4 = /* @__PURE__ */ createPathTagFunction(encodeURIPath);
let Messages$1 = class Messages extends APIResource {
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(completionID, query = {}, options2) {
    return this._client.getAPIList(path$4`/chat/completions/${completionID}/messages`, CursorPage, { query, ...options2 });
  }
};
function isChatCompletionFunctionTool(tool) {
  return tool !== void 0 && "function" in tool && tool.function !== void 0;
}
function isAutoParsableResponseFormat(response_format) {
  return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
}
function isAutoParsableTool$1(tool) {
  return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput$1(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...choice.message.tool_calls ? {
              tool_calls: choice.message.tool_calls
            } : void 0
          }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    var _a3;
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: ((_a3 = choice.message.tool_calls) == null ? void 0 : _a3.map((toolCall) => parseToolCall$1(params, toolCall))) ?? void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  var _a3, _b;
  if (((_a3 = params.response_format) == null ? void 0 : _a3.type) !== "json_schema") {
    return null;
  }
  if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall$1(params, toolCall) {
  var _a3;
  const inputTool = (_a3 = params.tools) == null ? void 0 : _a3.find((inputTool2) => {
    var _a4;
    return isChatCompletionFunctionTool(inputTool2) && ((_a4 = inputTool2.function) == null ? void 0 : _a4.name) === toolCall.function.name;
  });
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  var _a3;
  if (!params || !("tools" in params) || !params.tools) {
    return false;
  }
  const inputTool = (_a3 = params.tools) == null ? void 0 : _a3.find((inputTool2) => {
    var _a4;
    return isChatCompletionFunctionTool(inputTool2) && ((_a4 = inputTool2.function) == null ? void 0 : _a4.name) === toolCall.function.name;
  });
  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool$1(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false);
}
function hasAutoParseableInput$1(params) {
  var _a3;
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return ((_a3 = params.tools) == null ? void 0 : _a3.some((t2) => isAutoParsableTool$1(t2) || t2.type === "function" && t2.function.strict === true)) ?? false;
}
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
    }
  }
}
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}
const isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
const isToolMessage = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};
var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;
class EventStream {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet$1(this, _EventStream_connectedPromise, new Promise((resolve3, reject) => {
      __classPrivateFieldSet$1(this, _EventStream_resolveConnectedPromise, resolve3, "f");
      __classPrivateFieldSet$1(this, _EventStream_rejectConnectedPromise, reject, "f");
    }));
    __classPrivateFieldSet$1(this, _EventStream_endPromise, new Promise((resolve3, reject) => {
      __classPrivateFieldSet$1(this, _EventStream_resolveEndPromise, resolve3, "f");
      __classPrivateFieldSet$1(this, _EventStream_rejectEndPromise, reject, "f");
    }));
    __classPrivateFieldGet$1(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet$1(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet$1(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet$1(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet$1(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet$1(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet$1(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener2) {
    const listeners = __classPrivateFieldGet$1(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$1(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener: listener2 });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener2) {
    const listeners = __classPrivateFieldGet$1(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index2 = listeners.findIndex((l) => l.listener === listener2);
    if (index2 >= 0)
      listeners.splice(index2, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener2) {
    const listeners = __classPrivateFieldGet$1(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$1(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener: listener2, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve3, reject) => {
      __classPrivateFieldSet$1(this, _EventStream_catchingPromiseCreated, true);
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve3);
    });
  }
  async done() {
    __classPrivateFieldSet$1(this, _EventStream_catchingPromiseCreated, true);
    await __classPrivateFieldGet$1(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet$1(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet$1(this, _EventStream_ended, true);
      __classPrivateFieldGet$1(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet$1(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet$1(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener: listener2 }) => listener2(...args));
    }
    if (event === "abort") {
      const error2 = args[0];
      if (!__classPrivateFieldGet$1(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet$1(this, _EventStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet$1(this, _EventStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error2 = args[0];
      if (!__classPrivateFieldGet$1(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet$1(this, _EventStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet$1(this, _EventStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
}
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error2) {
  __classPrivateFieldSet$1(this, _EventStream_errored, true);
  if (error2 instanceof Error && error2.name === "AbortError") {
    error2 = new APIUserAbortError();
  }
  if (error2 instanceof APIUserAbortError) {
    __classPrivateFieldSet$1(this, _EventStream_aborted, true);
    return this._emit("abort", error2);
  }
  if (error2 instanceof OpenAIError) {
    return this._emit("error", error2);
  }
  if (error2 instanceof Error) {
    const openAIError = new OpenAIError(error2.message);
    openAIError.cause = error2;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error2)));
};
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}
var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionToolCall, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;
const DEFAULT_MAX_CHAT_COMPLETIONS = 10;
class AbstractChatCompletionRunner extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    var _a3;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = (_a3 = chatCompletion.choices[0]) == null ? void 0 : _a3.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if (isToolMessage(message) && message.content) {
        this._emit("functionToolCallResult", message.content);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionToolCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    await this.done();
    return __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
  }
  async finalFunctionToolCallResult() {
    await this.done();
    return __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionToolCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client2, params, options2) {
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client2.chat.completions.create({ ...params, stream: false }, { ...options2, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client2, params, options2) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client2, params, options2);
  }
  async _runTools(client2, params, options2) {
    var _a3, _b, _c;
    const role = "tool";
    const { tool_choice = "auto", stream: stream2, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && ((_a3 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a3.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options2 || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool$1(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t2) => t2.type === "function" ? {
      type: "function",
      function: {
        name: t2.function.name || t2.function.function.name,
        parameters: t2.function.parameters,
        description: t2.function.description,
        strict: t2.function.strict
      }
    } : t2) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client2, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options2);
      const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error2) {
          const content2 = error2 instanceof Error ? error2.message : String(error2);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
}
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet$1(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const ret = {
        ...message,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
  var _a3, _b;
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && ((_a3 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a3.length)) {
      return (_b = message.tool_calls.filter((x) => x.type === "function").at(-1)) == null ? void 0 : _b.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
      var _a3;
      return x.role === "assistant" && ((_a3 = x.tool_calls) == null ? void 0 : _a3.some((y2) => y2.type === "function" && y2.id === message.tool_call_id));
    })) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};
class ChatCompletionRunner extends AbstractChatCompletionRunner {
  static runTools(client2, params, options2) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client2, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
}
const STR = 1;
const NUM = 2;
const ARR = 4;
const OBJ = 8;
const NULL = 16;
const BOOL = 32;
const NAN = 64;
const INFINITY = 128;
const MINUS_INFINITY = 256;
const INF = INFINITY | MINUS_INFINITY;
const SPECIAL = NULL | BOOL | INF | NAN;
const ATOM = STR | NUM | SPECIAL;
const COLLECTION = ARR | OBJ;
const ALL = ATOM | COLLECTION;
const Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
class PartialJSON extends Error {
}
class MalformedJSON extends Error {
}
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
const _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index2 = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index2}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index2}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index2 >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index2] === '"')
      return parseStr();
    if (jsonString[index2] === "{")
      return parseObj();
    if (jsonString[index2] === "[")
      return parseArr();
    if (jsonString.substring(index2, index2 + 4) === "null" || Allow.NULL & allow && length - index2 < 4 && "null".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return null;
    }
    if (jsonString.substring(index2, index2 + 4) === "true" || Allow.BOOL & allow && length - index2 < 4 && "true".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return true;
    }
    if (jsonString.substring(index2, index2 + 5) === "false" || Allow.BOOL & allow && length - index2 < 5 && "false".startsWith(jsonString.substring(index2))) {
      index2 += 5;
      return false;
    }
    if (jsonString.substring(index2, index2 + 8) === "Infinity" || Allow.INFINITY & allow && length - index2 < 8 && "Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 8;
      return Infinity;
    }
    if (jsonString.substring(index2, index2 + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index2 && length - index2 < 9 && "-Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 9;
      return -Infinity;
    }
    if (jsonString.substring(index2, index2 + 3) === "NaN" || Allow.NAN & allow && length - index2 < 3 && "NaN".startsWith(jsonString.substring(index2))) {
      index2 += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index2;
    let escape2 = false;
    index2++;
    while (index2 < length && (jsonString[index2] !== '"' || escape2 && jsonString[index2 - 1] === "\\")) {
      escape2 = jsonString[index2] === "\\" ? !escape2 : false;
      index2++;
    }
    if (jsonString.charAt(index2) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index2 - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index2 - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index2++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index2] !== "}") {
        skipBlank();
        if (index2 >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index2++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index2] === ",")
          index2++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index2++;
    return obj;
  };
  const parseArr = () => {
    index2++;
    const arr = [];
    try {
      while (jsonString[index2] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index2] === ",") {
          index2++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index2++;
    return arr;
  };
  const parseNum = () => {
    if (index2 === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index2;
    if (jsonString[index2] === "-")
      index2++;
    while (jsonString[index2] && !",]}".includes(jsonString[index2]))
      index2++;
    if (index2 == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index2));
    } catch (e) {
      if (jsonString.substring(start, index2) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index2 < length && " \n\r	".includes(jsonString[index2])) {
      index2++;
    }
  };
  return parseAny();
};
const partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);
var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;
class ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet$1(this, _ChatCompletionStream_params, params);
    __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, []);
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream2) {
    const runner = new ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream2));
    return runner;
  }
  static createChatCompletion(client2, params, options2) {
    const runner = new ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client2, { ...params, stream: true }, { ...options2, headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client2, params, options2) {
    var _a3;
    super._createChatCompletion;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream2 = await client2.chat.completions.create({ ...params, stream: true }, { ...options2, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream2) {
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if ((_a3 = stream2.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream2 = Stream$2.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream2) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a3 = stream2.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0);
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    var _a3, _b, _c, _d, _e, _f, _g2, _h, _i, _j, _k2, _l, _m, _n, _o;
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && ((_a3 = choiceSnapshot.message) == null ? void 0 : _a3.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
        this._emit("logprobs.content.delta", {
          content: (_g2 = choice.logprobs) == null ? void 0 : _g2.content,
          snapshot: ((_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) ?? []
        });
      }
      if (((_i = choice.logprobs) == null ? void 0 : _i.refusal) != null && ((_j = choiceSnapshot.message) == null ? void 0 : _j.role) === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: (_k2 = choice.logprobs) == null ? void 0 : _k2.refusal,
          snapshot: ((_l = choiceSnapshot.logprobs) == null ? void 0 : _l.refusal) ?? []
        });
      }
      const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = (_m = choiceSnapshot.message.tool_calls) == null ? void 0 : _m[toolCallDelta.index];
        if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
          continue;
        }
        if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: (_n = toolCallSnapshot.function) == null ? void 0 : _n.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: ((_o = toolCallDelta.function) == null ? void 0 : _o.arguments) ?? ""
          });
        } else {
          assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    var _a3, _b, _c;
    const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = (_a3 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a3[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = (_c = (_b = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool) => isChatCompletionFunctionTool(tool) && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    var _a3, _b;
    const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (((_a3 = choiceSnapshot.logprobs) == null ? void 0 : _a3.content) && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0);
    __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, []);
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    var _a3;
    const responseFormat = (_a3 = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a3.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a3, _b, _c, _d;
    let snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      });
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index: index2, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index2];
      if (!choice) {
        choice = snapshot.choices[index2] = { finish_reason, index: index2, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a3 = choice.logprobs).content ?? (_a3.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b = choice.logprobs).refusal ?? (_b.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput$1(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index3, id, type: type3, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index3] ?? (_d[index3] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type3)
            tool_call.type = type3;
          if (fn)
            tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
          if (fn == null ? void 0 : fn.name)
            tool_call.function.name = fn.name;
          if (fn == null ? void 0 : fn.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader2 = readQueue.shift();
      if (reader2) {
        reader2.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader2 of readQueue) {
        reader2.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader2 of readQueue) {
        reader2.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader2 of readQueue) {
        reader2.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve3, reject) => readQueue.push({ resolve: resolve3, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream2 = new Stream$2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream2.toReadableStream();
  }
}
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index: index2, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index2}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index2}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index2}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index2}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index: index2,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index: index2,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type: type3, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].id
${str$1(snapshot)}`);
              }
              if (type3 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].type
${str$1(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.name
${str$1(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.arguments
${str$1(snapshot)}`);
              }
              return { ...toolRest, id: id2, type: type3, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index: index2,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str$1(x) {
  return JSON.stringify(x);
}
function assertNever(_x) {
}
class ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream2) {
    const runner = new ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream2));
    return runner;
  }
  static runTools(client2, params, options2) {
    const runner = new ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client2, params, opts));
    return runner;
  }
}
let Completions$1 = class Completions extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages$1(this._client);
  }
  create(body, options2) {
    return this._client.post("/chat/completions", { body, ...options2, stream: body.stream ?? false });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(completionID, options2) {
    return this._client.get(path$4`/chat/completions/${completionID}`, options2);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(completionID, body, options2) {
    return this._client.post(path$4`/chat/completions/${completionID}`, { body, ...options2 });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/chat/completions", CursorPage, { query, ...options2 });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(completionID, options2) {
    return this._client.delete(path$4`/chat/completions/${completionID}`, options2);
  }
  parse(body, options2) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options2,
      headers: {
        ...options2 == null ? void 0 : options2.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runTools(body, options2) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options2);
    }
    return ChatCompletionRunner.runTools(this._client, body, options2);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options2) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options2);
  }
};
Completions$1.Messages = Messages$1;
class Chat extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions$1(this._client);
  }
}
Chat.Completions = Completions$1;
const brand_privateNullableHeaders = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
const buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};
class Speech extends APIResource {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options2) {
    return this._client.post("/audio/speech", {
      body,
      ...options2,
      headers: buildHeaders([{ Accept: "application/octet-stream" }, options2 == null ? void 0 : options2.headers]),
      __binaryResponse: true
    });
  }
}
class Transcriptions extends APIResource {
  create(body, options2) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
      body,
      ...options2,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }, this._client));
  }
}
class Translations extends APIResource {
  create(body, options2) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options2, __metadata: { model: body.model } }, this._client));
  }
}
class Audio extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
}
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;
class Batches extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options2) {
    return this._client.post("/batches", { body, ...options2 });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchID, options2) {
    return this._client.get(path$4`/batches/${batchID}`, options2);
  }
  /**
   * List your organization's batches.
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/batches", CursorPage, { query, ...options2 });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchID, options2) {
    return this._client.post(path$4`/batches/${batchID}/cancel`, options2);
  }
}
class Assistants extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(body, options2) {
    return this._client.post("/assistants", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(assistantID, options2) {
    return this._client.get(path$4`/assistants/${assistantID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(assistantID, body, options2) {
    return this._client.post(path$4`/assistants/${assistantID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const assistant of client.beta.assistants.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/assistants", CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted =
   *   await client.beta.assistants.delete('assistant_id');
   * ```
   */
  delete(assistantID, options2) {
    return this._client.delete(path$4`/assistants/${assistantID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
let Sessions$1 = class Sessions extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(body, options2) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
};
class TranscriptionSessions extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(body, options2) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
let Realtime$1 = class Realtime extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions$1(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
};
Realtime$1.Sessions = Sessions$1;
Realtime$1.TranscriptionSessions = TranscriptionSessions;
class Sessions2 extends APIResource {
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(body, options2) {
    return this._client.post("/chatkit/sessions", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(sessionID, options2) {
    return this._client.post(path$4`/chatkit/sessions/${sessionID}/cancel`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
let Threads$1 = class Threads extends APIResource {
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(threadID, options2) {
    return this._client.get(path$4`/chatkit/threads/${threadID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/chatkit/threads", ConversationCursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(threadID, options2) {
    return this._client.delete(path$4`/chatkit/threads/${threadID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(threadID, query = {}, options2) {
    return this._client.getAPIList(path$4`/chatkit/threads/${threadID}/items`, ConversationCursorPage, { query, ...options2, headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers]) });
  }
};
class ChatKit extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions2(this._client);
    this.threads = new Threads$1(this._client);
  }
  /**
   * Upload a ChatKit file
   *
   * @example
   * ```ts
   * const response = await client.beta.chatkit.uploadFile({
   *   file: fs.createReadStream('path/to/file'),
   * });
   * ```
   */
  uploadFile(body, options2) {
    return this._client.post("/chatkit/files", maybeMultipartFormRequestOptions({ body, ...options2, headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers]) }, this._client));
  }
}
ChatKit.Sessions = Sessions2;
ChatKit.Threads = Threads$1;
class Messages2 extends APIResource {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(threadID, body, options2) {
    return this._client.post(path$4`/threads/${threadID}/messages`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(messageID, params, options2) {
    const { thread_id } = params;
    return this._client.get(path$4`/threads/${thread_id}/messages/${messageID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(messageID, params, options2) {
    const { thread_id, ...body } = params;
    return this._client.post(path$4`/threads/${thread_id}/messages/${messageID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options2) {
    return this._client.getAPIList(path$4`/threads/${threadID}/messages`, CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(messageID, params, options2) {
    const { thread_id } = params;
    return this._client.delete(path$4`/threads/${thread_id}/messages/${messageID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
class Steps extends APIResource {
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(stepID, params, options2) {
    const { thread_id, run_id, ...query } = params;
    return this._client.get(path$4`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(runID, params, options2) {
    const { thread_id, ...query } = params;
    return this._client.getAPIList(path$4`/threads/${thread_id}/runs/${runID}/steps`, CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
const toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes2 = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes2[i] = binaryStr.charCodeAt(i);
    }
    return Array.from(new Float32Array(bytes2.buffer));
  }
};
const readEnv = (env) => {
  var _a3, _b, _c, _d, _e;
  if (typeof globalThis.process !== "undefined") {
    return ((_b = (_a3 = globalThis.process.env) == null ? void 0 : _a3[env]) == null ? void 0 : _b.trim()) ?? void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return (_e = (_d = (_c = globalThis.Deno.env) == null ? void 0 : _c.get) == null ? void 0 : _d.call(_c, env)) == null ? void 0 : _e.trim();
  }
  return void 0;
};
var _AssistantStream_instances, _a$1, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;
class AssistantStream extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader2 = readQueue.shift();
      if (reader2) {
        reader2.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader2 of readQueue) {
        reader2.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader2 of readQueue) {
        reader2.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader2 of readQueue) {
        reader2.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve3, reject) => readQueue.push({ resolve: resolve3, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream2) {
    const runner = new _a$1();
    runner._run(() => runner._fromReadableStream(stream2));
    return runner;
  }
  async _fromReadableStream(readableStream, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream2 = Stream$2.fromReadableStream(readableStream, this.controller);
    for await (const event of stream2) {
      __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a3 = stream2.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream2 = new Stream$2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream2.toReadableStream();
  }
  static createToolAssistantStream(runId, runs, params, options2) {
    const runner = new _a$1();
    runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, runId, params, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream2 = await run.submitToolOutputs(runId, body, {
      ...options2,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream2) {
      __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a3 = stream2.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options2) {
    const runner = new _a$1();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options2) {
    const runner = new _a$1();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet$1(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet$1(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet$1(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet$1(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet$1(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet$1(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream2 = await thread.createAndRun(body, { ...options2, signal: this.controller.signal });
    this._connected();
    for await (const event of stream2) {
      __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a3 = stream2.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream2 = await run.create(threadId, body, { ...options2, signal: this.controller.signal });
    this._connected();
    for await (const event of stream2) {
      __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a3 = stream2.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index2 = deltaEntry["index"];
          if (index2 == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index2 !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index2}`);
          }
          const accEntry = accValue[index2];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index2] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options2) {
    return await this._createThreadAssistantStream(thread, params, options2);
  }
  async _runAssistantStream(threadId, runs, params, options2) {
    return await this._createAssistantStream(runs, threadId, params, options2);
  }
  async _runToolAssistantStream(runId, runs, params, options2) {
    return await this._createToolAssistantStream(runs, runId, params, options2);
  }
}
_a$1 = AssistantStream, _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet$1(this, _AssistantStream_currentEvent, event);
  __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet$1(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet$1(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet$1(this, _AssistantStream_messageSnapshot, accumulatedMessage);
  __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet$1(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet$1(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet$1(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet$1(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet$1(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet$1(this, _AssistantStream_currentContentIndex, content.index);
          }
          __classPrivateFieldSet$1(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index]);
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet$1(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet$1(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet$1(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet$1(this, _AssistantStream_messageSnapshot, void 0);
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet$1(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep);
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet$1(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet$1(this, _AssistantStream_currentToolCallIndex, toolCall.index);
            __classPrivateFieldSet$1(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
            if (__classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet$1(this, _AssistantStream_currentRunStepSnapshot, void 0);
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet$1(this, _AssistantStream_currentToolCall, void 0);
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet$1(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = _a$1.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet$1(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet$1(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return _a$1.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet$1(this, _AssistantStream_currentRunSnapshot, event.data);
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      __classPrivateFieldSet$1(this, _AssistantStream_finalRun, event.data);
      if (__classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet$1(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet$1(this, _AssistantStream_currentToolCall, void 0);
      }
      break;
  }
};
let Runs$1 = class Runs extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadID, params, options2) {
    const { include, ...body } = params;
    return this._client.post(path$4`/threads/${threadID}/runs`, {
      query: { include },
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(runID, params, options2) {
    const { thread_id } = params;
    return this._client.get(path$4`/threads/${thread_id}/runs/${runID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(runID, params, options2) {
    const { thread_id, ...body } = params;
    return this._client.post(path$4`/threads/${thread_id}/runs/${runID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options2) {
    return this._client.getAPIList(path$4`/threads/${threadID}/runs`, CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(runID, params, options2) {
    const { thread_id } = params;
    return this._client.post(path$4`/threads/${thread_id}/runs/${runID}/cancel`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options2) {
    const run = await this.create(threadId, body, options2);
    return await this.poll(run.id, { thread_id: threadId }, options2);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options2) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options2);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(runId, params, options2) {
    var _a3;
    const headers = buildHeaders([
      options2 == null ? void 0 : options2.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((_a3 = options2 == null ? void 0 : options2.pollIntervalMs) == null ? void 0 : _a3.toString()) ?? void 0
      }
    ]);
    while (true) {
      const { data: run, response: response2 } = await this.retrieve(runId, params, {
        ...options2,
        headers: { ...options2 == null ? void 0 : options2.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options2 == null ? void 0 : options2.pollIntervalMs) {
            sleepInterval = options2.pollIntervalMs;
          } else {
            const headerInterval = response2.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep$1(sleepInterval);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options2) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options2);
  }
  submitToolOutputs(runID, params, options2) {
    const { thread_id, ...body } = params;
    return this._client.post(path$4`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(runId, params, options2) {
    const run = await this.submitToolOutputs(runId, params, options2);
    return await this.poll(run.id, params, options2);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(runId, params, options2) {
    return AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options2);
  }
};
Runs$1.Steps = Steps;
class Threads2 extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs$1(this._client);
    this.messages = new Messages2(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(body = {}, options2) {
    return this._client.post("/threads", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadID, options2) {
    return this._client.get(path$4`/threads/${threadID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadID, body, options2) {
    return this._client.post(path$4`/threads/${threadID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(threadID, options2) {
    return this._client.delete(path$4`/threads/${threadID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  createAndRun(body, options2) {
    return this._client.post("/threads/runs", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]),
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options2) {
    const run = await this.createAndRun(body, options2);
    return await this.runs.poll(run.id, { thread_id: run.thread_id }, options2);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options2) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options2);
  }
}
Threads2.Runs = Runs$1;
Threads2.Messages = Messages2;
class Beta extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime$1(this._client);
    this.chatkit = new ChatKit(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads2(this._client);
  }
}
Beta.Realtime = Realtime$1;
Beta.ChatKit = ChatKit;
Beta.Assistants = Assistants;
Beta.Threads = Threads2;
class Completions2 extends APIResource {
  create(body, options2) {
    return this._client.post("/completions", { body, ...options2, stream: body.stream ?? false });
  }
}
class Content extends APIResource {
  /**
   * Retrieve Container File Content
   */
  retrieve(fileID, params, options2) {
    const { container_id } = params;
    return this._client.get(path$4`/containers/${container_id}/files/${fileID}/content`, {
      ...options2,
      headers: buildHeaders([{ Accept: "application/binary" }, options2 == null ? void 0 : options2.headers]),
      __binaryResponse: true
    });
  }
}
let Files$2 = class Files extends APIResource {
  constructor() {
    super(...arguments);
    this.content = new Content(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(containerID, body, options2) {
    return this._client.post(path$4`/containers/${containerID}/files`, multipartFormRequestOptions({ body, ...options2 }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(fileID, params, options2) {
    const { container_id } = params;
    return this._client.get(path$4`/containers/${container_id}/files/${fileID}`, options2);
  }
  /**
   * List Container files
   */
  list(containerID, query = {}, options2) {
    return this._client.getAPIList(path$4`/containers/${containerID}/files`, CursorPage, {
      query,
      ...options2
    });
  }
  /**
   * Delete Container File
   */
  delete(fileID, params, options2) {
    const { container_id } = params;
    return this._client.delete(path$4`/containers/${container_id}/files/${fileID}`, {
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
};
Files$2.Content = Content;
class Containers extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files$2(this._client);
  }
  /**
   * Create Container
   */
  create(body, options2) {
    return this._client.post("/containers", { body, ...options2 });
  }
  /**
   * Retrieve Container
   */
  retrieve(containerID, options2) {
    return this._client.get(path$4`/containers/${containerID}`, options2);
  }
  /**
   * List Containers
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/containers", CursorPage, { query, ...options2 });
  }
  /**
   * Delete Container
   */
  delete(containerID, options2) {
    return this._client.delete(path$4`/containers/${containerID}`, {
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
Containers.Files = Files$2;
class Items extends APIResource {
  /**
   * Create items in a conversation with the given ID.
   */
  create(conversationID, params, options2) {
    const { include, ...body } = params;
    return this._client.post(path$4`/conversations/${conversationID}/items`, {
      query: { include },
      body,
      ...options2
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(itemID, params, options2) {
    const { conversation_id, ...query } = params;
    return this._client.get(path$4`/conversations/${conversation_id}/items/${itemID}`, { query, ...options2 });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(conversationID, query = {}, options2) {
    return this._client.getAPIList(path$4`/conversations/${conversationID}/items`, ConversationCursorPage, { query, ...options2 });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(itemID, params, options2) {
    const { conversation_id } = params;
    return this._client.delete(path$4`/conversations/${conversation_id}/items/${itemID}`, options2);
  }
}
class Conversations extends APIResource {
  constructor() {
    super(...arguments);
    this.items = new Items(this._client);
  }
  /**
   * Create a conversation.
   */
  create(body = {}, options2) {
    return this._client.post("/conversations", { body, ...options2 });
  }
  /**
   * Get a conversation
   */
  retrieve(conversationID, options2) {
    return this._client.get(path$4`/conversations/${conversationID}`, options2);
  }
  /**
   * Update a conversation
   */
  update(conversationID, body, options2) {
    return this._client.post(path$4`/conversations/${conversationID}`, { body, ...options2 });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(conversationID, options2) {
    return this._client.delete(path$4`/conversations/${conversationID}`, options2);
  }
}
Conversations.Items = Items;
class Embeddings extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(body, options2) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      loggerFor(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
    }
    const response2 = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options2
    });
    if (hasUserProvidedEncodingFormat) {
      return response2;
    }
    loggerFor(this._client).debug("embeddings/decoding base64 embeddings from base64");
    return response2._thenUnwrap((response3) => {
      if (response3 && response3.data) {
        response3.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response3;
    });
  }
}
class OutputItems extends APIResource {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(outputItemID, params, options2) {
    const { eval_id, run_id } = params;
    return this._client.get(path$4`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options2);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(runID, params, options2) {
    const { eval_id, ...query } = params;
    return this._client.getAPIList(path$4`/evals/${eval_id}/runs/${runID}/output_items`, CursorPage, { query, ...options2 });
  }
}
class Runs2 extends APIResource {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(evalID, body, options2) {
    return this._client.post(path$4`/evals/${evalID}/runs`, { body, ...options2 });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(runID, params, options2) {
    const { eval_id } = params;
    return this._client.get(path$4`/evals/${eval_id}/runs/${runID}`, options2);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(evalID, query = {}, options2) {
    return this._client.getAPIList(path$4`/evals/${evalID}/runs`, CursorPage, {
      query,
      ...options2
    });
  }
  /**
   * Delete an eval run.
   */
  delete(runID, params, options2) {
    const { eval_id } = params;
    return this._client.delete(path$4`/evals/${eval_id}/runs/${runID}`, options2);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(runID, params, options2) {
    const { eval_id } = params;
    return this._client.post(path$4`/evals/${eval_id}/runs/${runID}`, options2);
  }
}
Runs2.OutputItems = OutputItems;
class Evals extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(body, options2) {
    return this._client.post("/evals", { body, ...options2 });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(evalID, options2) {
    return this._client.get(path$4`/evals/${evalID}`, options2);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(evalID, body, options2) {
    return this._client.post(path$4`/evals/${evalID}`, { body, ...options2 });
  }
  /**
   * List evaluations for a project.
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/evals", CursorPage, { query, ...options2 });
  }
  /**
   * Delete an evaluation.
   */
  delete(evalID, options2) {
    return this._client.delete(path$4`/evals/${evalID}`, options2);
  }
}
Evals.Runs = Runs2;
let Files$1 = class Files2 extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 1 TB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options2) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options2 }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileID, options2) {
    return this._client.get(path$4`/files/${fileID}`, options2);
  }
  /**
   * Returns a list of files.
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/files", CursorPage, { query, ...options2 });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(fileID, options2) {
    return this._client.delete(path$4`/files/${fileID}`, options2);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileID, options2) {
    return this._client.get(path$4`/files/${fileID}/content`, {
      ...options2,
      headers: buildHeaders([{ Accept: "application/binary" }, options2 == null ? void 0 : options2.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep$1(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
class Methods extends APIResource {
}
let Graders$1 = class Graders extends APIResource {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(body, options2) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options2 });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(body, options2) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options2 });
  }
};
class Alpha extends APIResource {
  constructor() {
    super(...arguments);
    this.graders = new Graders$1(this._client);
  }
}
Alpha.Graders = Graders$1;
class Permissions extends APIResource {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(fineTunedModelCheckpoint, body, options2) {
    return this._client.getAPIList(path$4`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, Page, { body, method: "post", ...options2 });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(fineTunedModelCheckpoint, query = {}, options2) {
    return this._client.get(path$4`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options2
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(permissionID, params, options2) {
    const { fine_tuned_model_checkpoint } = params;
    return this._client.delete(path$4`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options2);
  }
}
let Checkpoints$1 = class Checkpoints extends APIResource {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
};
Checkpoints$1.Permissions = Permissions;
class Checkpoints2 extends APIResource {
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(fineTuningJobID, query = {}, options2) {
    return this._client.getAPIList(path$4`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, CursorPage, { query, ...options2 });
  }
}
class Jobs extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(body, options2) {
    return this._client.post("/fine_tuning/jobs", { body, ...options2 });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(fineTuningJobID, options2) {
    return this._client.get(path$4`/fine_tuning/jobs/${fineTuningJobID}`, options2);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/fine_tuning/jobs", CursorPage, { query, ...options2 });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(fineTuningJobID, options2) {
    return this._client.post(path$4`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options2);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(fineTuningJobID, query = {}, options2) {
    return this._client.getAPIList(path$4`/fine_tuning/jobs/${fineTuningJobID}/events`, CursorPage, { query, ...options2 });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(fineTuningJobID, options2) {
    return this._client.post(path$4`/fine_tuning/jobs/${fineTuningJobID}/pause`, options2);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(fineTuningJobID, options2) {
    return this._client.post(path$4`/fine_tuning/jobs/${fineTuningJobID}/resume`, options2);
  }
}
Jobs.Checkpoints = Checkpoints2;
class FineTuning extends APIResource {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints$1(this._client);
    this.alpha = new Alpha(this._client);
  }
}
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.Checkpoints = Checkpoints$1;
FineTuning.Alpha = Alpha;
class GraderModels extends APIResource {
}
class Graders2 extends APIResource {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
}
Graders2.GraderModels = GraderModels;
class Images extends APIResource {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(body, options2) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options2 }, this._client));
  }
  edit(body, options2) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options2, stream: body.stream ?? false }, this._client));
  }
  generate(body, options2) {
    return this._client.post("/images/generations", { body, ...options2, stream: body.stream ?? false });
  }
}
class Models extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options2) {
    return this._client.get(path$4`/models/${model}`, options2);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options2) {
    return this._client.getAPIList("/models", Page, options2);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(model, options2) {
    return this._client.delete(path$4`/models/${model}`, options2);
  }
}
class Moderations extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options2) {
    return this._client.post("/moderations", { body, ...options2 });
  }
}
class Calls extends APIResource {
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(callID, body, options2) {
    return this._client.post(path$4`/realtime/calls/${callID}/accept`, {
      body,
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(callID, options2) {
    return this._client.post(path$4`/realtime/calls/${callID}/hangup`, {
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(callID, body, options2) {
    return this._client.post(path$4`/realtime/calls/${callID}/refer`, {
      body,
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(callID, body = {}, options2) {
    return this._client.post(path$4`/realtime/calls/${callID}/reject`, {
      body,
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
class ClientSecrets extends APIResource {
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(body, options2) {
    return this._client.post("/realtime/client_secrets", { body, ...options2 });
  }
}
class Realtime2 extends APIResource {
  constructor() {
    super(...arguments);
    this.clientSecrets = new ClientSecrets(this._client);
    this.calls = new Calls(this._client);
  }
}
Realtime2.ClientSecrets = ClientSecrets;
Realtime2.Calls = Calls;
function maybeParseResponse(response2, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...response2,
      output_parsed: null,
      output: response2.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response2, params);
}
function parseResponse(response2, params) {
  const output = response2.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response2, { output });
  if (!Object.getOwnPropertyDescriptor(response2, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  var _a3, _b, _c, _d;
  if (((_b = (_a3 = params.text) == null ? void 0 : _a3.format) == null ? void 0 : _b.type) !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in ((_c = params.text) == null ? void 0 : _c.format)) {
    const text_format = (_d = params.text) == null ? void 0 : _d.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput(params) {
  var _a3;
  if (isAutoParsableResponseFormat((_a3 = params.text) == null ? void 0 : _a3.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool(tool) {
  return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : (inputTool == null ? void 0 : inputTool.strict) ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}
var _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;
class ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, void 0);
    _ResponseStream_currentResponseSnapshot.set(this, void 0);
    _ResponseStream_finalResponse.set(this, void 0);
    __classPrivateFieldSet$1(this, _ResponseStream_params, params);
  }
  static createResponse(client2, params, options2) {
    const runner = new ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client2, params, {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client2, params, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$1(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream2;
    let starting_after = null;
    if ("response_id" in params) {
      stream2 = await client2.responses.retrieve(params.response_id, { stream: true }, { ...options2, signal: this.controller.signal, stream: true });
      starting_after = params.starting_after ?? null;
    } else {
      stream2 = await client2.responses.create({ ...params, stream: true }, { ...options2, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream2) {
      __classPrivateFieldGet$1(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if ((_a3 = stream2.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return __classPrivateFieldGet$1(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet$1(this, _ResponseStream_currentResponseSnapshot, void 0);
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = (name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    };
    const response2 = __classPrivateFieldGet$1(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response2.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response2.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet$1(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet$1(this, _ResponseStream_currentResponseSnapshot, void 0);
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet$1(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet$1(this, _ResponseStream_finalResponse, parsedResponse);
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
    var _a3;
    let snapshot = __classPrivateFieldGet$1(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet$1(this, _ResponseStream_currentResponseSnapshot, event.response);
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        const type3 = output.type;
        const part = event.part;
        if (type3 === "message" && part.type !== "reasoning_text") {
          output.content.push(part);
        } else if (type3 === "reasoning" && part.type === "reasoning_text") {
          if (!output.content) {
            output.content = [];
          }
          output.content.push(part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.reasoning_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "reasoning") {
          const content = (_a3 = output.content) == null ? void 0 : _a3[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "reasoning_text") {
            throw new OpenAIError(`expected content to be 'reasoning_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet$1(this, _ResponseStream_currentResponseSnapshot, event.response);
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader2 = readQueue.shift();
      if (reader2) {
        reader2.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader2 of readQueue) {
        reader2.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader2 of readQueue) {
        reader2.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader2 of readQueue) {
        reader2.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve3, reject) => readQueue.push({ resolve: resolve3, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const response2 = __classPrivateFieldGet$1(this, _ResponseStream_finalResponse, "f");
    if (!response2)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response2;
  }
}
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}
class InputItems extends APIResource {
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(responseID, query = {}, options2) {
    return this._client.getAPIList(path$4`/responses/${responseID}/input_items`, CursorPage, { query, ...options2 });
  }
}
class Responses extends APIResource {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
  }
  create(body, options2) {
    return this._client.post("/responses", { body, ...options2, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseID, query = {}, options2) {
    return this._client.get(path$4`/responses/${responseID}`, {
      query,
      ...options2,
      stream: (query == null ? void 0 : query.stream) ?? false
    })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(responseID, options2) {
    return this._client.delete(path$4`/responses/${responseID}`, {
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
  parse(body, options2) {
    return this._client.responses.create(body, options2)._thenUnwrap((response2) => parseResponse(response2, body));
  }
  /**
   * Creates a model response stream
   */
  stream(body, options2) {
    return ResponseStream.createResponse(this._client, body, options2);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(responseID, options2) {
    return this._client.post(path$4`/responses/${responseID}/cancel`, options2);
  }
}
Responses.InputItems = InputItems;
class Parts extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadID, body, options2) {
    return this._client.post(path$4`/uploads/${uploadID}/parts`, multipartFormRequestOptions({ body, ...options2 }, this._client));
  }
}
class Uploads extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options2) {
    return this._client.post("/uploads", { body, ...options2 });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadID, options2) {
    return this._client.post(path$4`/uploads/${uploadID}/cancel`, options2);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadID, body, options2) {
    return this._client.post(path$4`/uploads/${uploadID}/complete`, { body, ...options2 });
  }
}
Uploads.Parts = Parts;
const allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};
class FileBatches extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreID, body, options2) {
    return this._client.post(path$4`/vector_stores/${vectorStoreID}/file_batches`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(batchID, params, options2) {
    const { vector_store_id } = params;
    return this._client.get(path$4`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(batchID, params, options2) {
    const { vector_store_id } = params;
    return this._client.post(path$4`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options2) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options2);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(batchID, params, options2) {
    const { vector_store_id, ...query } = params;
    return this._client.getAPIList(path$4`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, CursorPage, { query, ...options2, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreID, batchID, options2) {
    var _a3;
    const headers = buildHeaders([
      options2 == null ? void 0 : options2.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((_a3 = options2 == null ? void 0 : options2.pollIntervalMs) == null ? void 0 : _a3.toString()) ?? void 0
      }
    ]);
    while (true) {
      const { data: batch, response: response2 } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
        ...options2,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options2 == null ? void 0 : options2.pollIntervalMs) {
            sleepInterval = options2.pollIntervalMs;
          } else {
            const headerInterval = response2.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep$1(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options2) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = (options2 == null ? void 0 : options2.maxConcurrency) ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client2 = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator2) {
      for (let item of iterator2) {
        const fileObj = await client2.files.create({ file: item, purpose: "assistants" }, options2);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
}
class Files3 extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreID, body, options2) {
    return this._client.post(path$4`/vector_stores/${vectorStoreID}/files`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(fileID, params, options2) {
    const { vector_store_id } = params;
    return this._client.get(path$4`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(fileID, params, options2) {
    const { vector_store_id, ...body } = params;
    return this._client.post(path$4`/vector_stores/${vector_store_id}/files/${fileID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(vectorStoreID, query = {}, options2) {
    return this._client.getAPIList(path$4`/vector_stores/${vectorStoreID}/files`, CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(fileID, params, options2) {
    const { vector_store_id } = params;
    return this._client.delete(path$4`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options2) {
    const file = await this.create(vectorStoreId, body, options2);
    return await this.poll(vectorStoreId, file.id, options2);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreID, fileID, options2) {
    var _a3;
    const headers = buildHeaders([
      options2 == null ? void 0 : options2.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((_a3 = options2 == null ? void 0 : options2.pollIntervalMs) == null ? void 0 : _a3.toString()) ?? void 0
      }
    ]);
    while (true) {
      const fileResponse = await this.retrieve(fileID, {
        vector_store_id: vectorStoreID
      }, { ...options2, headers }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options2 == null ? void 0 : options2.pollIntervalMs) {
            sleepInterval = options2.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep$1(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options2) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options2);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options2);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options2) {
    const fileInfo = await this.upload(vectorStoreId, file, options2);
    return await this.poll(vectorStoreId, fileInfo.id, options2);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(fileID, params, options2) {
    const { vector_store_id } = params;
    return this._client.getAPIList(path$4`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page, { ...options2, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]) });
  }
}
class VectorStores extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files3(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options2) {
    return this._client.post("/vector_stores", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreID, options2) {
    return this._client.get(path$4`/vector_stores/${vectorStoreID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreID, body, options2) {
    return this._client.post(path$4`/vector_stores/${vectorStoreID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/vector_stores", CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(vectorStoreID, options2) {
    return this._client.delete(path$4`/vector_stores/${vectorStoreID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(vectorStoreID, body, options2) {
    return this._client.getAPIList(path$4`/vector_stores/${vectorStoreID}/search`, Page, {
      body,
      method: "post",
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
VectorStores.Files = Files3;
VectorStores.FileBatches = FileBatches;
class Videos extends APIResource {
  /**
   * Create a video
   */
  create(body, options2) {
    return this._client.post("/videos", maybeMultipartFormRequestOptions({ body, ...options2 }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(videoID, options2) {
    return this._client.get(path$4`/videos/${videoID}`, options2);
  }
  /**
   * List videos
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/videos", ConversationCursorPage, { query, ...options2 });
  }
  /**
   * Delete a video
   */
  delete(videoID, options2) {
    return this._client.delete(path$4`/videos/${videoID}`, options2);
  }
  /**
   * Download video content
   */
  downloadContent(videoID, query = {}, options2) {
    return this._client.get(path$4`/videos/${videoID}/content`, {
      query,
      ...options2,
      headers: buildHeaders([{ Accept: "application/binary" }, options2 == null ? void 0 : options2.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Create a video remix
   */
  remix(videoID, body, options2) {
    return this._client.post(path$4`/videos/${videoID}/remix`, maybeMultipartFormRequestOptions({ body, ...options2 }, this._client));
  }
}
var _Webhooks_instances, _Webhooks_validateSecret, _Webhooks_getRequiredHeader;
class Webhooks extends APIResource {
  constructor() {
    super(...arguments);
    _Webhooks_instances.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    await this.verifySignature(payload, headers, secret, tolerance);
    return JSON.parse(payload);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    }
    __classPrivateFieldGet$1(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
    const headersObj = buildHeaders([headers]).values;
    const signatureHeader = __classPrivateFieldGet$1(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
    const timestamp2 = __classPrivateFieldGet$1(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
    const webhookId = __classPrivateFieldGet$1(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
    const timestampSeconds = parseInt(timestamp2, 10);
    if (isNaN(timestampSeconds)) {
      throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");
    }
    const nowSeconds = Math.floor(Date.now() / 1e3);
    if (nowSeconds - timestampSeconds > tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too old");
    }
    if (timestampSeconds > nowSeconds + tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too new");
    }
    const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
    const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
    const signedPayload = webhookId ? `${webhookId}.${timestamp2}.${payload}` : `${timestamp2}.${payload}`;
    const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
    for (const signature of signatures) {
      try {
        const signatureBytes = Buffer.from(signature, "base64");
        const isValid2 = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
        if (isValid2) {
          return;
        }
      } catch {
        continue;
      }
    }
    throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
  }
}
_Webhooks_instances = /* @__PURE__ */ new WeakSet(), _Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
  if (typeof secret !== "string" || secret.length === 0) {
    throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
  }
}, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name) {
  if (!headers) {
    throw new Error(`Headers are required`);
  }
  const value = headers.get(name);
  if (value === null || value === void 0) {
    throw new Error(`Missing required header: ${name}`);
  }
  return value;
};
var _OpenAI_instances, _a, _OpenAI_encoder, _OpenAI_baseURLOverridden;
class OpenAI {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, webhookSecret = readEnv("OPENAI_WEBHOOK_SECRET") ?? null, ...opts } = {}) {
    _OpenAI_instances.add(this);
    _OpenAI_encoder.set(this, void 0);
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files$1(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.webhooks = new Webhooks(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.realtime = new Realtime2(this);
    this.conversations = new Conversations(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this.videos = new Videos(this);
    if (apiKey === void 0) {
      throw new OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    }
    const options2 = {
      apiKey,
      organization,
      project,
      webhookSecret,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options2.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    this.baseURL = options2.baseURL;
    this.timeout = options2.timeout ?? _a.DEFAULT_TIMEOUT;
    this.logger = options2.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options2.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options2.fetchOptions;
    this.maxRetries = options2.maxRetries ?? 2;
    this.fetch = options2.fetch ?? getDefaultFetch();
    __classPrivateFieldSet$1(this, _OpenAI_encoder, FallbackEncoder);
    this._options = options2;
    this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
    this.organization = organization;
    this.project = project;
    this.webhookSecret = webhookSecret;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options2) {
    const client2 = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...options2
    });
    return client2;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    return;
  }
  async authHeaders(opts) {
    return buildHeaders([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(query) {
    return stringify$1(query, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status3, error2, message, headers) {
    return APIError.generate(status3, error2, message, headers);
  }
  async _callApiKey() {
    const apiKey = this._options.apiKey;
    if (typeof apiKey !== "function")
      return false;
    let token;
    try {
      token = await apiKey();
    } catch (err) {
      if (err instanceof OpenAIError)
        throw err;
      throw new OpenAIError(
        `Failed to get token from 'apiKey' function: ${err.message}`,
        // @ts-ignore
        { cause: err }
      );
    }
    if (typeof token !== "string" || !token) {
      throw new OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
    }
    this.apiKey = token;
    return true;
  }
  buildURL(path3, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet$1(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url2 = isAbsoluteURL(path3) ? new URL(path3) : new URL(baseURL + (baseURL.endsWith("/") && path3.startsWith("/") ? path3.slice(1) : path3));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url2.search = this.stringifyQuery(query);
    }
    return url2.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options2) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request2, { url: url2, options: options2 }) {
  }
  get(path3, opts) {
    return this.methodRequest("get", path3, opts);
  }
  post(path3, opts) {
    return this.methodRequest("post", path3, opts);
  }
  patch(path3, opts) {
    return this.methodRequest("patch", path3, opts);
  }
  put(path3, opts) {
    return this.methodRequest("put", path3, opts);
  }
  delete(path3, opts) {
    return this.methodRequest("delete", path3, opts);
  }
  methodRequest(method2, path3, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method: method2, path: path3, ...opts2 };
    }));
  }
  request(options2, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options2, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    var _a3, _b;
    const options2 = await optionsInput;
    const maxRetries = options2.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options2);
    const { req: req2, url: url2, timeout: timeout2 } = await this.buildRequest(options2, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req2, { url: url2, options: options2 });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options2.method,
      url: url2,
      options: options2,
      headers: req2.headers
    }));
    if ((_a3 = options2.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response2 = await this.fetchWithTimeout(url2, req2, timeout2, controller).catch(castToError);
    const headersTime = Date.now();
    if (response2 instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if ((_b = options2.signal) == null ? void 0 : _b.aborted) {
        throw new APIUserAbortError();
      }
      const isTimeout = isAbortError(response2) || /timed? ?out/i.test(String(response2) + ("cause" in response2 ? String(response2.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url: url2,
          durationMs: headersTime - startTime,
          message: response2.message
        }));
        return this.retryRequest(options2, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url: url2,
        durationMs: headersTime - startTime,
        message: response2.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response2 });
    }
    const specialHeaders = [...response2.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req2.method} ${url2} ${response2.ok ? "succeeded" : "failed"} with status ${response2.status} in ${headersTime - startTime}ms`;
    if (!response2.ok) {
      const shouldRetry = await this.shouldRetry(response2);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response2.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response2.url,
          status: response2.status,
          headers: response2.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options2, retriesRemaining, retryOfRequestLogID ?? requestLogID, response2.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response2.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response2.url,
        status: response2.status,
        headers: response2.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response2.status, errJSON, errMessage, response2.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response2.url,
      status: response2.status,
      headers: response2.headers,
      durationMs: headersTime - startTime
    }));
    return { response: response2, options: options2, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path3, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path: path3, ...opts });
  }
  requestAPIList(Page2, options2) {
    const request2 = this.makeRequest(options2, null, void 0);
    return new PagePromise(this, request2, Page2);
  }
  async fetchWithTimeout(url2, init2, ms2, controller) {
    const { signal, method: method2, ...options2 } = init2 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout2 = setTimeout(() => controller.abort(), ms2);
    const isReadableBody = globalThis.ReadableStream && options2.body instanceof globalThis.ReadableStream || typeof options2.body === "object" && options2.body !== null && Symbol.asyncIterator in options2.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options2
    };
    if (method2) {
      fetchOptions.method = method2.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url2, fetchOptions);
    } finally {
      clearTimeout(timeout2);
    }
  }
  async shouldRetry(response2) {
    const shouldRetryHeader = response2.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response2.status === 408)
      return true;
    if (response2.status === 409)
      return true;
    if (response2.status === 429)
      return true;
    if (response2.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options2, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options2.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep$1(timeoutMillis);
    return this.makeRequest(options2, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options2 = { ...inputOptions };
    const { method: method2, path: path3, query, defaultBaseURL } = options2;
    const url2 = this.buildURL(path3, query, defaultBaseURL);
    if ("timeout" in options2)
      validatePositiveInteger("timeout", options2.timeout);
    options2.timeout = options2.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options: options2 });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method: method2, bodyHeaders, retryCount });
    const req2 = {
      method: method2,
      headers: reqHeaders,
      ...options2.signal && { signal: options2.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options2.fetchOptions ?? {}
    };
    return { req: req2, url: url2, timeout: options2.timeout };
  }
  async buildHeaders({ options: options2, method: method2, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method2 !== "get") {
      if (!options2.idempotencyKey)
        options2.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options2.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options2.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options2.timeout / 1e3)) } : {},
        ...getPlatformHeaders(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(options2),
      this._options.defaultHeaders,
      bodyHeaders,
      options2.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet$1(this, _OpenAI_encoder, "f").call(this, { body, headers });
    }
  }
}
_a = OpenAI, _OpenAI_encoder = /* @__PURE__ */ new WeakMap(), _OpenAI_instances = /* @__PURE__ */ new WeakSet(), _OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
  return this.baseURL !== "https://api.openai.com/v1";
};
OpenAI.OpenAI = _a;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
OpenAI.toFile = toFile;
OpenAI.Completions = Completions2;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files$1;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.Webhooks = Webhooks;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Realtime = Realtime2;
OpenAI.Conversations = Conversations;
OpenAI.Evals = Evals;
OpenAI.Containers = Containers;
OpenAI.Videos = Videos;
function isAutoGLM(modelFamily) {
  return modelFamily === "auto-glm" || modelFamily === "auto-glm-multilingual";
}
function isUITars(modelFamily) {
  return modelFamily === "vlm-ui-tars" || modelFamily === "vlm-ui-tars-doubao" || modelFamily === "vlm-ui-tars-doubao-1.5";
}
class AIResponseParseError extends Error {
  constructor(message, rawResponse, usage) {
    super(message);
    __publicField(this, "usage");
    __publicField(this, "rawResponse");
    this.name = "AIResponseParseError";
    this.rawResponse = rawResponse;
    this.usage = usage;
  }
}
async function createChatClient({
  modelConfig
}) {
  const {
    socksProxy,
    httpProxy,
    modelName,
    openaiBaseURL,
    openaiApiKey,
    openaiExtraConfig,
    modelDescription,
    uiTarsModelVersion,
    modelFamily,
    createOpenAIClient,
    timeout: timeout2
  } = modelConfig;
  let proxyAgent = void 0;
  const debugProxy = getDebug("ai:call:proxy");
  const sanitizeProxyUrl = (url2) => {
    try {
      const parsed = new URL(url2);
      if (parsed.username) {
        parsed.password = "****";
        return parsed.href;
      }
      return url2;
    } catch {
      return url2;
    }
  };
  if (httpProxy) {
    debugProxy("using http proxy", sanitizeProxyUrl(httpProxy));
    if (ifInBrowser) {
      console.warn(
        "HTTP proxy is configured but not supported in browser environment"
      );
    } else {
      const moduleName = "undici";
      const { ProxyAgent } = await import(moduleName);
      proxyAgent = new ProxyAgent({
        uri: httpProxy
        // Note: authentication is handled via the URI (e.g., http://user:pass@proxy.com:8080)
      });
    }
  } else if (socksProxy) {
    debugProxy("using socks proxy", sanitizeProxyUrl(socksProxy));
    if (ifInBrowser) {
      console.warn(
        "SOCKS proxy is configured but not supported in browser environment"
      );
    } else {
      try {
        const moduleName = "fetch-socks";
        const { socksDispatcher } = await import(moduleName);
        const proxyUrl = new URL(socksProxy);
        if (!proxyUrl.hostname) {
          throw new Error("SOCKS proxy URL must include a valid hostname");
        }
        const port = Number.parseInt(proxyUrl.port, 10);
        if (!proxyUrl.port || Number.isNaN(port)) {
          throw new Error("SOCKS proxy URL must include a valid port");
        }
        const protocol3 = proxyUrl.protocol.replace(":", "");
        const socksType = protocol3 === "socks4" ? 4 : protocol3 === "socks5" ? 5 : 5;
        proxyAgent = socksDispatcher({
          type: socksType,
          host: proxyUrl.hostname,
          port,
          ...proxyUrl.username ? {
            userId: decodeURIComponent(proxyUrl.username),
            password: decodeURIComponent(proxyUrl.password || "")
          } : {}
        });
        debugProxy("socks proxy configured successfully", {
          type: socksType,
          host: proxyUrl.hostname,
          port
        });
      } catch (error2) {
        console.error("Failed to configure SOCKS proxy:", error2);
        throw new Error(
          `Invalid SOCKS proxy URL: ${socksProxy}. Expected format: socks4://host:port, socks5://host:port, or with authentication: socks5://user:pass@host:port`
        );
      }
    }
  }
  const openAIOptions = {
    baseURL: openaiBaseURL,
    apiKey: openaiApiKey,
    // Use fetchOptions.dispatcher for fetch-based SDK instead of httpAgent
    // Note: Type assertion needed due to undici version mismatch between dependencies
    ...proxyAgent ? { fetchOptions: { dispatcher: proxyAgent } } : {},
    ...openaiExtraConfig,
    ...typeof timeout2 === "number" ? { timeout: timeout2 } : {},
    dangerouslyAllowBrowser: true
  };
  const baseOpenAI = new OpenAI(openAIOptions);
  let openai = baseOpenAI;
  if (openai && globalConfigManager.getEnvConfigInBoolean(OMNI_LANGSMITH_DEBUG)) {
    if (ifInBrowser) {
      throw new Error("langsmith is not supported in browser");
    }
    console.log("DEBUGGING MODE: langsmith wrapper enabled");
    const langsmithModule = "langsmith/wrappers";
    const { wrapOpenAI } = await import(langsmithModule);
    openai = wrapOpenAI(openai);
  }
  if (openai && globalConfigManager.getEnvConfigInBoolean(OMNI_LANGFUSE_DEBUG)) {
    if (ifInBrowser) {
      throw new Error("langfuse is not supported in browser");
    }
    console.log("DEBUGGING MODE: langfuse wrapper enabled");
    const langfuseModule = "@langfuse/openai";
    const { observeOpenAI } = await import(langfuseModule);
    openai = observeOpenAI(openai);
  }
  if (createOpenAIClient) {
    const wrappedClient = await createOpenAIClient(baseOpenAI, openAIOptions);
    if (wrappedClient) {
      openai = wrappedClient;
    }
  }
  return {
    completion: openai.chat.completions,
    modelName,
    modelDescription,
    uiTarsModelVersion,
    modelFamily
  };
}
async function callAI(messages, modelConfig, options2) {
  var _a3, _b, _c, _d, _e, _f, _g2, _h, _i, _j, _k2, _l;
  const {
    completion,
    modelName,
    modelDescription,
    uiTarsModelVersion,
    modelFamily
  } = await createChatClient({
    modelConfig
  });
  const maxTokens = globalConfigManager.getEnvConfigValueAsNumber(OMNI_MODEL_MAX_TOKENS) ?? globalConfigManager.getEnvConfigValueAsNumber(OPENAI_MAX_TOKENS);
  const debugCall = getDebug("ai:call");
  const debugProfileStats = getDebug("ai:profile:stats");
  const debugProfileDetail = getDebug("ai:profile:detail");
  const startTime = Date.now();
  const temperature = modelConfig.temperature ?? 0;
  const isStreaming = (options2 == null ? void 0 : options2.stream) && (options2 == null ? void 0 : options2.onChunk);
  let content;
  let accumulated = "";
  let accumulatedReasoning = "";
  let usage;
  let timeCost;
  let requestId;
  const buildUsageInfo = (usageData, requestId2) => {
    var _a4;
    if (!usageData) return void 0;
    const cachedInputTokens = (_a4 = usageData == null ? void 0 : usageData.prompt_tokens_details) == null ? void 0 : _a4.cached_tokens;
    return {
      prompt_tokens: usageData.prompt_tokens ?? 0,
      completion_tokens: usageData.completion_tokens ?? 0,
      total_tokens: usageData.total_tokens ?? 0,
      cached_input: cachedInputTokens ?? 0,
      time_cost: timeCost ?? 0,
      model_name: modelName,
      model_description: modelDescription,
      intent: modelConfig.intent,
      request_id: requestId2 ?? void 0
    };
  };
  const commonConfig = {
    temperature,
    stream: !!isStreaming,
    max_tokens: maxTokens,
    ...modelFamily === "qwen2.5-vl" ? {
      vl_high_resolution_images: true
    } : {}
  };
  if (isAutoGLM(modelFamily)) {
    commonConfig.top_p = 0.85;
    commonConfig.frequency_penalty = 0.2;
  }
  const {
    config: deepThinkConfig,
    debugMessage,
    warningMessage
  } = resolveDeepThinkConfig({
    deepThink: options2 == null ? void 0 : options2.deepThink,
    modelFamily
  });
  if (debugMessage) {
    debugCall(debugMessage);
  }
  if (warningMessage) {
    debugCall(warningMessage);
    console.warn(warningMessage);
  }
  try {
    debugCall(
      `sending ${isStreaming ? "streaming " : ""}request to ${modelName}`
    );
    if (isStreaming) {
      const stream2 = await completion.create(
        {
          model: modelName,
          messages,
          ...commonConfig,
          ...deepThinkConfig
        },
        {
          stream: true
        }
      );
      requestId = stream2._request_id;
      for await (const chunk of stream2) {
        const content2 = ((_c = (_b = (_a3 = chunk.choices) == null ? void 0 : _a3[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content) || "";
        const reasoning_content = ((_f = (_e = (_d = chunk.choices) == null ? void 0 : _d[0]) == null ? void 0 : _e.delta) == null ? void 0 : _f.reasoning_content) || "";
        if (chunk.usage) {
          usage = chunk.usage;
        }
        if (content2 || reasoning_content) {
          accumulated += content2;
          accumulatedReasoning += reasoning_content;
          const chunkData = {
            content: content2,
            reasoning_content,
            accumulated,
            isComplete: false,
            usage: void 0
          };
          options2.onChunk(chunkData);
        }
        if ((_h = (_g2 = chunk.choices) == null ? void 0 : _g2[0]) == null ? void 0 : _h.finish_reason) {
          timeCost = Date.now() - startTime;
          if (!usage) {
            const estimatedTokens = Math.max(
              1,
              Math.floor(accumulated.length / 4)
            );
            usage = {
              prompt_tokens: estimatedTokens,
              completion_tokens: estimatedTokens,
              total_tokens: estimatedTokens * 2
            };
          }
          const finalChunk = {
            content: "",
            accumulated,
            reasoning_content: "",
            isComplete: true,
            usage: buildUsageInfo(usage, requestId)
          };
          options2.onChunk(finalChunk);
          break;
        }
      }
      content = accumulated;
      debugProfileStats(
        `streaming model, ${modelName}, mode, ${modelFamily || "default"}, cost-ms, ${timeCost}, temperature, ${temperature ?? ""}`
      );
    } else {
      const retryCount = modelConfig.retryCount ?? 1;
      const retryInterval = modelConfig.retryInterval ?? 2e3;
      const maxAttempts = retryCount + 1;
      let lastError;
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          const result = await completion.create({
            model: modelName,
            messages,
            ...commonConfig,
            ...deepThinkConfig
          });
          timeCost = Date.now() - startTime;
          debugProfileStats(
            `model, ${modelName}, mode, ${modelFamily || "default"}, ui-tars-version, ${uiTarsModelVersion}, prompt-tokens, ${((_i = result.usage) == null ? void 0 : _i.prompt_tokens) || ""}, completion-tokens, ${((_j = result.usage) == null ? void 0 : _j.completion_tokens) || ""}, total-tokens, ${((_k2 = result.usage) == null ? void 0 : _k2.total_tokens) || ""}, cost-ms, ${timeCost}, requestId, ${result._request_id || ""}, temperature, ${temperature ?? ""}`
          );
          debugProfileDetail(
            `model usage detail: ${JSON.stringify(result.usage)}`
          );
          if (!result.choices) {
            throw new Error(
              `invalid response from LLM service: ${JSON.stringify(result)}`
            );
          }
          content = result.choices[0].message.content;
          if (!content) {
            throw new Error("empty content from AI model");
          }
          accumulatedReasoning = ((_l = result.choices[0].message) == null ? void 0 : _l.reasoning_content) || "";
          usage = result.usage;
          requestId = result._request_id;
          break;
        } catch (error2) {
          lastError = error2;
          if (attempt < maxAttempts) {
            console.warn(
              `[Omni] AI call failed (attempt ${attempt}/${maxAttempts}), retrying in ${retryInterval}ms... Error: ${lastError.message}`
            );
            await new Promise((resolve3) => setTimeout(resolve3, retryInterval));
          }
        }
      }
      if (!content) {
        throw lastError;
      }
    }
    debugCall(`response reasoning content: ${accumulatedReasoning}`);
    debugCall(`response content: ${content}`);
    if (isStreaming && !usage) {
      const estimatedTokens = Math.max(
        1,
        Math.floor((content || "").length / 4)
      );
      usage = {
        prompt_tokens: estimatedTokens,
        completion_tokens: estimatedTokens,
        total_tokens: estimatedTokens * 2
      };
    }
    return {
      content: content || "",
      reasoning_content: accumulatedReasoning || void 0,
      usage: buildUsageInfo(usage, requestId),
      isStreamed: !!isStreaming
    };
  } catch (e) {
    console.error(" call AI error", e);
    const newError = new Error(
      `failed to call ${isStreaming ? "streaming " : ""}AI model service (${modelName}): ${e.message}
Trouble shooting: https://Omnijs.com/model-provider.html`,
      {
        cause: e
      }
    );
    throw newError;
  }
}
async function callAIWithObjectResponse(messages, modelConfig, options2) {
  const response2 = await callAI(messages, modelConfig, {
    deepThink: options2 == null ? void 0 : options2.deepThink
  });
  assert(response2, "empty response");
  const modelFamily = modelConfig.modelFamily;
  const jsonContent = safeParseJson(response2.content, modelFamily);
  if (typeof jsonContent !== "object") {
    throw new AIResponseParseError(
      `failed to parse json response from model (${modelConfig.modelName}): ${response2.content}`,
      response2.content,
      response2.usage
    );
  }
  return {
    content: jsonContent,
    contentString: response2.content,
    usage: response2.usage,
    reasoning_content: response2.reasoning_content
  };
}
async function callAIWithStringResponse(msgs, modelConfig) {
  const { content, usage } = await callAI(msgs, modelConfig);
  return { content, usage };
}
function extractJSONFromCodeBlock(response2) {
  try {
    const jsonMatch = response2.match(/^\s*(\{[\s\S]*\})\s*$/);
    if (jsonMatch) {
      return jsonMatch[1];
    }
    const codeBlockMatch = response2.match(
      /```(?:json)?\s*(\{[\s\S]*?\})\s*```/
    );
    if (codeBlockMatch) {
      return codeBlockMatch[1];
    }
    const jsonLikeMatch = response2.match(/\{[\s\S]*\}/);
    if (jsonLikeMatch) {
      return jsonLikeMatch[0];
    }
  } catch {
  }
  return response2;
}
function preprocessDoubaoBboxJson(input) {
  if (input.includes("bbox")) {
    while (/\d+\s+\d+/.test(input)) {
      input = input.replace(/(\d+)\s+(\d+)/g, "$1,$2");
    }
  }
  return input;
}
function resolveDeepThinkConfig({
  deepThink,
  modelFamily
}) {
  const normalizedDeepThink = deepThink === "unset" ? void 0 : deepThink;
  if (normalizedDeepThink === void 0) {
    return { config: {}, debugMessage: void 0 };
  }
  if (modelFamily === "qwen3-vl") {
    return {
      config: { enable_thinking: normalizedDeepThink },
      debugMessage: `deepThink mapped to enable_thinking=${normalizedDeepThink} for qwen3-vl`
    };
  }
  if (modelFamily === "doubao-vision") {
    return {
      config: {
        thinking: { type: normalizedDeepThink ? "enabled" : "disabled" }
      },
      debugMessage: `deepThink mapped to thinking.type=${normalizedDeepThink ? "enabled" : "disabled"} for doubao-vision`
    };
  }
  if (modelFamily === "glm-v") {
    return {
      config: {
        thinking: { type: normalizedDeepThink ? "enabled" : "disabled" }
      },
      debugMessage: `deepThink mapped to thinking.type=${normalizedDeepThink ? "enabled" : "disabled"} for glm-v`
    };
  }
  if (modelFamily === "gpt-5") {
    return {
      config: normalizedDeepThink ? {
        reasoning: { effort: "high" }
      } : {
        reasoning: { effort: "low" }
      },
      debugMessage: normalizedDeepThink ? "deepThink mapped to reasoning.effort=high for gpt-5" : "deepThink disabled for gpt-5"
    };
  }
  return {
    config: {},
    debugMessage: `deepThink ignored: unsupported model_family "${modelFamily ?? "default"}"`,
    warningMessage: `The "deepThink" option is not supported for model_family "${modelFamily ?? "default"}".`
  };
}
function normalizeJsonObject(obj) {
  if (obj === null || obj === void 0) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => normalizeJsonObject(item));
  }
  if (typeof obj === "object") {
    const normalized = {};
    for (const [key, value] of Object.entries(obj)) {
      const trimmedKey = key.trim();
      let normalizedValue = normalizeJsonObject(value);
      if (typeof normalizedValue === "string") {
        normalizedValue = normalizedValue.trim();
      }
      normalized[trimmedKey] = normalizedValue;
    }
    return normalized;
  }
  if (typeof obj === "string") {
    return obj.trim();
  }
  return obj;
}
function safeParseJson(input, modelFamily) {
  var _a3;
  const cleanJsonString = extractJSONFromCodeBlock(input);
  if (cleanJsonString == null ? void 0 : cleanJsonString.match(/\((\d+),(\d+)\)/)) {
    return (_a3 = cleanJsonString.match(/\((\d+),(\d+)\)/)) == null ? void 0 : _a3.slice(1).map(Number);
  }
  let parsed;
  let lastError;
  try {
    parsed = JSON.parse(cleanJsonString);
    return normalizeJsonObject(parsed);
  } catch (error2) {
    lastError = error2;
  }
  try {
    parsed = JSON.parse(jsonrepair(cleanJsonString));
    return normalizeJsonObject(parsed);
  } catch (error2) {
    lastError = error2;
  }
  if (modelFamily === "doubao-vision" || isUITars(modelFamily)) {
    const jsonString = preprocessDoubaoBboxJson(cleanJsonString);
    try {
      parsed = JSON.parse(jsonrepair(jsonString));
      return normalizeJsonObject(parsed);
    } catch (error2) {
      lastError = error2;
    }
  }
  throw Error(
    `failed to parse LLM response into JSON. Error - ${String(
      lastError ?? "unknown error"
    )}. Response - 
 ${input}`
  );
}
function bboxDescription(modelFamily) {
  if (modelFamily === "gemini") {
    return "box_2d bounding box for the target element, should be [ymin, xmin, ymax, xmax] normalized to 0-1000.";
  }
  return "2d bounding box as [xmin, ymin, xmax, ymax]";
}
function systemPromptToLocateElement(modelFamily) {
  const preferredLanguage = getPreferredLanguage();
  const bboxComment = bboxDescription(modelFamily);
  return `
## Role:
You are an AI assistant that helps identify UI elements.

## Objective:
- Identify elements in screenshots that match the user's description.
- Provide the coordinates of the element that matches the user's description.

## Output Format:
\`\`\`json
{
  "bbox": [number, number, number, number],  // ${bboxComment}
  "errors"?: string[]
}
\`\`\`

Fields:
* \`bbox\` is the bounding box of the element that matches the user's description
* \`errors\` is an optional array of error messages (if any)

For example, when an element is found:
\`\`\`json
{
  "bbox": [100, 100, 200, 200],
  "errors": []
}
\`\`\`

When no element is found:
\`\`\`json
{
  "bbox": [],
  "errors": ["I can see ..., but {some element} is not found. Use ${preferredLanguage}."]
}
\`\`\`
`;
}
const findElementPrompt = (targetElementDescription) => `Find: ${targetElementDescription}`;
const PLAYGROUND_SERVER_PORT = 5800;
function generateElementByPoint(center, description, edgeSize = 8) {
  const [centerX, centerY] = center;
  const offset = Math.ceil(edgeSize / 2) - 1;
  const expandedRect = {
    left: Math.max(centerX - offset, 0),
    top: Math.max(centerY - offset, 0),
    width: edgeSize,
    height: edgeSize
  };
  return {
    rect: expandedRect,
    center: [centerX, centerY],
    description: description || ""
  };
}
function generateElementByRect(sourceRect, description, edgeSize = 8) {
  const centerX = sourceRect.left + Math.floor((sourceRect.width - 1) / 2);
  const centerY = sourceRect.top + Math.floor((sourceRect.height - 1) / 2);
  return generateElementByPoint([centerX, centerY], description, edgeSize);
}
const debug$s = getDebug("img");
let photonModule = null;
let isInitialized = false;
let usingCanvasFallback = false;
async function getPhoton() {
  if (photonModule && isInitialized) {
    return photonModule;
  }
  const env = ifInBrowser ? "browser" : ifInWorker ? "worker" : ifInNode ? "node" : "unknown";
  debug$s(`Loading photon module in ${env} environment`);
  try {
    if (ifInBrowser || ifInWorker) {
      const photon = await import("./photon_rs-DJZCdiiK.js");
      if (typeof photon.default === "function") {
        await photon.default();
      }
      debug$s("Photon loaded: @silvia-odwyer/photon (browser/worker)");
      console.log(
        "[midscene:img] Photon loaded: @silvia-odwyer/photon (browser/worker)"
      );
      photonModule = photon;
    } else if (ifInNode) {
      photonModule = await import("./photon_rs-DSo3duun.js").then((n) => n.p);
      debug$s("Photon loaded: @silvia-odwyer/photon-node (node)");
      console.log(
        "[midscene:img] Photon loaded: @silvia-odwyer/photon-node (node)"
      );
    }
    if (!(photonModule == null ? void 0 : photonModule.PhotonImage)) {
      throw new Error("PhotonImage is not available");
    }
    if (!photonModule.PhotonImage.new_from_byteslice && !photonModule.PhotonImage.new_from_base64) {
      throw new Error(
        "PhotonImage.new_from_byteslice or new_from_base64 is not available"
      );
    }
    isInitialized = true;
    return photonModule;
  } catch (error2) {
    debug$s(
      `Photon load failed: ${error2 instanceof Error ? error2.message : String(error2)}`
    );
    if (ifInBrowser) {
      console.warn(
        `[midscene:img] Photon WASM failed to load, falling back to Canvas API. Error: ${error2 instanceof Error ? error2.message : String(error2)}`
      );
      try {
        const { createCanvasFallbackModule } = await import("./canvas-fallback-RoXfwA94.js");
        photonModule = createCanvasFallbackModule();
        usingCanvasFallback = true;
        isInitialized = true;
        return photonModule;
      } catch (fallbackError) {
        debug$s(
          `Canvas fallback also failed: ${fallbackError instanceof Error ? fallbackError.message : String(fallbackError)}`
        );
      }
    }
    throw new Error(
      `Failed to load photon module: ${error2 instanceof Error ? error2.message : String(error2)}`
    );
  }
}
async function imageInfoOfBase64(imageBase64) {
  const { PhotonImage } = await getPhoton();
  const base64Data = imageBase64.replace(/^data:image\/\w+;base64,/, "");
  const image = PhotonImage.new_from_base64(base64Data);
  const width = image.get_width();
  const height = image.get_height();
  image.free();
  assert$1(width && height, "Invalid image: cannot get width or height");
  return { width, height };
}
async function getSharp() {
  if (!ifInNode) {
    throw new Error("Sharp is only available in Node.js environment");
  }
  try {
    const sharp = await import("./index-xzE-Ctdw.js").then((n) => n.i);
    return sharp.default;
  } catch (error2) {
    throw new Error(
      `Failed to load sharp module: ${error2 instanceof Error ? error2.message : String(error2)}`
    );
  }
}
const imgDebug = getDebug("img");
async function resizeAndConvertImgBuffer(inputFormat, inputData, newSize) {
  if (typeof inputData === "string")
    throw Error("inputData is base64, use resizeImgBase64 instead");
  assert$1(
    newSize && newSize.width > 0 && newSize.height > 0,
    "newSize must be positive"
  );
  const resizeStartTime = Date.now();
  imgDebug(`resizeImg start, target size: ${newSize.width}x${newSize.height}`);
  if (ifInNode) {
    try {
      const Sharp = await getSharp();
      const metadata = await Sharp(inputData).metadata();
      const { width: originalWidth2, height: originalHeight2 } = metadata;
      if (!originalWidth2 || !originalHeight2) {
        throw Error("Undefined width or height from the input image.");
      }
      if (newSize.width === originalWidth2 && newSize.height === originalHeight2) {
        return {
          buffer: inputData,
          format: inputFormat
        };
      }
      const resizedBuffer2 = await Sharp(inputData).resize(newSize.width, newSize.height).jpeg({ quality: 90 }).toBuffer();
      const resizeEndTime2 = Date.now();
      imgDebug(
        `resizeImg done (Sharp), target size: ${newSize.width}x${newSize.height}, cost: ${resizeEndTime2 - resizeStartTime}ms`
      );
      return {
        buffer: resizedBuffer2,
        // by Sharp.jpeg()
        format: "jpeg"
      };
    } catch (error2) {
      imgDebug("Sharp failed, falling back to Photon:", error2);
    }
  }
  const { PhotonImage, SamplingFilter, resize } = await getPhoton();
  const inputBytes = new Uint8Array(inputData);
  const inputImage = PhotonImage.new_from_byteslice(inputBytes);
  const originalWidth = inputImage.get_width();
  const originalHeight = inputImage.get_height();
  if (!originalWidth || !originalHeight) {
    inputImage.free();
    throw Error("Undefined width or height from the input image.");
  }
  if (newSize.width === originalWidth && newSize.height === originalHeight) {
    inputImage.free();
    return {
      buffer: inputData,
      format: inputFormat
    };
  }
  const outputImage = resize(
    inputImage,
    newSize.width,
    newSize.height,
    SamplingFilter.CatmullRom
  );
  const outputBytes = outputImage.get_bytes_jpeg(90);
  const resizedBuffer = Buffer$3.from(outputBytes);
  inputImage.free();
  outputImage.free();
  const resizeEndTime = Date.now();
  imgDebug(
    `resizeImg done (Photon), target size: ${newSize.width}x${newSize.height}, cost: ${resizeEndTime - resizeStartTime}ms`
  );
  return {
    buffer: resizedBuffer,
    // by Photon.get_bytes_jpeg()
    format: "jpeg"
  };
}
const createImgBase64ByFormat = (format2, body) => {
  return `data:image/${format2};base64,${body}`;
};
async function resizeImgBase64(inputBase64, newSize) {
  const { body, mimeType } = parseBase64(inputBase64);
  const imageBuffer = Buffer$3.from(body, "base64");
  const { buffer: buffer2, format: format2 } = await resizeAndConvertImgBuffer(
    mimeType.split("/")[1],
    imageBuffer,
    newSize
  );
  return createImgBase64ByFormat(format2, buffer2.toString("base64"));
}
async function photonFromBase64(base64) {
  const { PhotonImage } = await getPhoton();
  const { body } = parseBase64(base64);
  return PhotonImage.new_from_base64(body);
}
async function paddingToMatchBlock(image, blockSize = 28) {
  const width = image.get_width();
  const height = image.get_height();
  const targetWidth = Math.ceil(width / blockSize) * blockSize;
  const targetHeight = Math.ceil(height / blockSize) * blockSize;
  if (targetWidth === width && targetHeight === height) {
    return { width, height, image };
  }
  const { padding_right, padding_bottom, Rgba } = await getPhoton();
  const rightPadding = targetWidth - width;
  const bottomPadding = targetHeight - height;
  let result = image;
  if (rightPadding > 0) {
    const white = new Rgba(255, 255, 255, 255);
    result = padding_right(result, rightPadding, white);
  }
  if (bottomPadding > 0) {
    const white = new Rgba(255, 255, 255, 255);
    const previousResult = result;
    result = padding_bottom(previousResult, bottomPadding, white);
    if (previousResult !== image) {
      previousResult.free();
    }
  }
  return { width: targetWidth, height: targetHeight, image: result };
}
async function paddingToMatchBlockByBase64(imageBase64, blockSize = 28) {
  const photonImage = await photonFromBase64(imageBase64);
  try {
    const paddedResult = await paddingToMatchBlock(photonImage, blockSize);
    const result = {
      width: paddedResult.width,
      height: paddedResult.height,
      imageBase64: await photonToBase64(paddedResult.image)
    };
    if (paddedResult.image !== photonImage) {
      paddedResult.image.free();
    }
    return result;
  } finally {
    photonImage.free();
  }
}
async function cropByRect(imageBase64, rect, paddingImage) {
  const { crop } = await getPhoton();
  const photonImage = await photonFromBase64(imageBase64);
  const { left, top, width, height } = rect;
  const cropped = crop(photonImage, left, top, left + width, top + height);
  photonImage.free();
  try {
    if (paddingImage) {
      const paddedResult = await paddingToMatchBlock(cropped);
      const result = {
        width: paddedResult.width,
        height: paddedResult.height,
        imageBase64: await photonToBase64(paddedResult.image)
      };
      if (paddedResult.image !== cropped) {
        paddedResult.image.free();
      }
      return result;
    }
    return {
      width: cropped.get_width(),
      height: cropped.get_height(),
      imageBase64: await photonToBase64(cropped)
    };
  } finally {
    cropped.free();
  }
}
async function photonToBase64(image, quality = 90) {
  const bytes2 = image.get_bytes_jpeg(quality);
  const base64Body = Buffer$3.from(bytes2).toString("base64");
  return `data:image/jpeg;base64,${base64Body}`;
}
const httpImg2Base64 = async (url2) => {
  const response2 = await fetch(url2);
  if (!response2.ok) {
    throw new Error(`Failed to fetch image: ${url2}`);
  }
  const contentType3 = response2.headers.get("content-type");
  if (!contentType3) {
    throw new Error(`Failed to fetch image: ${url2}`);
  }
  assert$1(
    contentType3.startsWith("image/"),
    `The url ${url2} is not a image, because of content-type in header is ${contentType3}.`
  );
  const buffer2 = Buffer$3.from(await response2.arrayBuffer());
  return `data:${contentType3};base64,${buffer2.toString("base64")}`;
};
const localImg2Base64 = (imgPath, withoutHeader = false) => {
  const body = readFileSync(imgPath).toString("base64");
  if (withoutHeader) {
    return body;
  }
  const type3 = path__default.extname(imgPath).slice(1);
  const finalType = type3 === "svg" ? "svg+xml" : type3 || "jpg";
  return `data:image/${finalType};base64,${body}`;
};
const preProcessImageUrl = async (url2, convertHttpImage2Base64) => {
  if (typeof url2 !== "string") {
    throw new Error(
      `url must be a string, but got ${url2} with type ${typeof url2}`
    );
  }
  if (url2.startsWith("data:")) {
    return url2;
  } else if (url2.startsWith("http://") || url2.startsWith("https://")) {
    if (!convertHttpImage2Base64) {
      return url2;
    }
    return await httpImg2Base64(url2);
  } else {
    return await localImg2Base64(url2);
  }
};
const parseBase64 = (fullBase64String) => {
  try {
    const separator = ";base64,";
    const index2 = fullBase64String.indexOf(separator);
    if (index2 === -1) {
      throw new Error("Invalid base64 string");
    }
    return {
      // 5 means 'data:'
      mimeType: fullBase64String.slice(5, index2),
      body: fullBase64String.slice(index2 + separator.length)
    };
  } catch (e) {
    throw new Error(
      `parseBase64 fail because intput is not a valid base64 string: ${fullBase64String}`,
      {
        cause: e
      }
    );
  }
};
const DIGIT_FONT = {
  "0": [
    [0, 1, 1, 1, 0],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [0, 1, 1, 1, 0]
  ],
  "1": [
    [0, 0, 1, 0, 0],
    [0, 1, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 1, 1, 1, 0]
  ],
  "2": [
    [0, 1, 1, 1, 0],
    [1, 0, 0, 0, 1],
    [0, 0, 0, 0, 1],
    [0, 0, 1, 1, 0],
    [0, 1, 0, 0, 0],
    [1, 0, 0, 0, 0],
    [1, 1, 1, 1, 1]
  ],
  "3": [
    [0, 1, 1, 1, 0],
    [1, 0, 0, 0, 1],
    [0, 0, 0, 0, 1],
    [0, 0, 1, 1, 0],
    [0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [0, 1, 1, 1, 0]
  ],
  "4": [
    [0, 0, 0, 1, 0],
    [0, 0, 1, 1, 0],
    [0, 1, 0, 1, 0],
    [1, 0, 0, 1, 0],
    [1, 1, 1, 1, 1],
    [0, 0, 0, 1, 0],
    [0, 0, 0, 1, 0]
  ],
  "5": [
    [1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0],
    [1, 1, 1, 1, 0],
    [0, 0, 0, 0, 1],
    [0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [0, 1, 1, 1, 0]
  ],
  "6": [
    [0, 1, 1, 1, 0],
    [1, 0, 0, 0, 0],
    [1, 0, 0, 0, 0],
    [1, 1, 1, 1, 0],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [0, 1, 1, 1, 0]
  ],
  "7": [
    [1, 1, 1, 1, 1],
    [0, 0, 0, 0, 1],
    [0, 0, 0, 1, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0]
  ],
  "8": [
    [0, 1, 1, 1, 0],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [0, 1, 1, 1, 0],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [0, 1, 1, 1, 0]
  ],
  "9": [
    [0, 1, 1, 1, 0],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [0, 1, 1, 1, 1],
    [0, 0, 0, 0, 1],
    [0, 0, 0, 0, 1],
    [0, 1, 1, 1, 0]
  ]
};
const FONT_WIDTH = 5;
const FONT_HEIGHT = 7;
const FONT_SCALE = 2;
function drawDigit(pixels, width, height, digit, startX, startY, color) {
  const bitmap = DIGIT_FONT[digit];
  if (!bitmap) return;
  for (let row = 0; row < FONT_HEIGHT; row++) {
    for (let col = 0; col < FONT_WIDTH; col++) {
      if (bitmap[row][col] === 1) {
        for (let sy = 0; sy < FONT_SCALE; sy++) {
          for (let sx = 0; sx < FONT_SCALE; sx++) {
            const x = startX + col * FONT_SCALE + sx;
            const y2 = startY + row * FONT_SCALE + sy;
            if (x >= 0 && x < width && y2 >= 0 && y2 < height) {
              const idx = (y2 * width + x) * 4;
              pixels[idx + 0] = color.r;
              pixels[idx + 1] = color.g;
              pixels[idx + 2] = color.b;
              pixels[idx + 3] = color.a;
            }
          }
        }
      }
    }
  }
}
function drawNumber(pixels, width, height, num, startX, startY, color) {
  const str2 = num.toString();
  let x = startX;
  for (const digit of str2) {
    drawDigit(pixels, width, height, digit, x, startY, color);
    x += FONT_WIDTH * FONT_SCALE + 1;
  }
}
function getNumberWidth(num) {
  return num.toString().length * (FONT_WIDTH * FONT_SCALE + 1) - 1;
}
function drawRect(pixels, width, height, rect, color, thickness) {
  const x = Math.floor(rect.x);
  const y2 = Math.floor(rect.y);
  const w2 = Math.floor(rect.w);
  const h2 = Math.floor(rect.h);
  for (let py = y2; py < y2 + h2 && py < height; py++) {
    for (let px = x; px < x + w2 && px < width; px++) {
      if (px < 0 || py < 0) continue;
      const isLeftBorder = px >= x && px < x + thickness;
      const isRightBorder = px <= x + w2 - 1 && px > x + w2 - thickness - 1;
      const isTopBorder = py >= y2 && py < y2 + thickness;
      const isBottomBorder = py <= y2 + h2 - 1 && py > y2 + h2 - thickness - 1;
      if (isLeftBorder || isRightBorder || isTopBorder || isBottomBorder) {
        const idx = (py * width + px) * 4;
        pixels[idx + 0] = color.r;
        pixels[idx + 1] = color.g;
        pixels[idx + 2] = color.b;
        pixels[idx + 3] = color.a;
      }
    }
  }
}
function fillRect(pixels, width, height, rect, color) {
  const x = Math.floor(rect.x);
  const y2 = Math.floor(rect.y);
  const w2 = Math.floor(rect.w);
  const h2 = Math.floor(rect.h);
  for (let py = y2; py < y2 + h2 && py < height; py++) {
    for (let px = x; px < x + w2 && px < width; px++) {
      if (px < 0 || py < 0) continue;
      const idx = (py * width + px) * 4;
      pixels[idx + 0] = color.r;
      pixels[idx + 1] = color.g;
      pixels[idx + 2] = color.b;
      pixels[idx + 3] = color.a;
    }
  }
}
function blendPixels(basePixels, overlayPixels, width, height) {
  const result = new Uint8Array(basePixels.length);
  for (let i = 0; i < basePixels.length; i += 4) {
    const overlayAlpha = overlayPixels[i + 3] / 255;
    const baseAlpha = basePixels[i + 3] / 255;
    if (overlayAlpha === 0) {
      result[i + 0] = basePixels[i + 0];
      result[i + 1] = basePixels[i + 1];
      result[i + 2] = basePixels[i + 2];
      result[i + 3] = basePixels[i + 3];
    } else {
      const outAlpha = overlayAlpha + baseAlpha * (1 - overlayAlpha);
      if (outAlpha === 0) {
        result[i + 0] = overlayPixels[i + 0];
        result[i + 1] = overlayPixels[i + 1];
        result[i + 2] = overlayPixels[i + 2];
        result[i + 3] = overlayPixels[i + 3];
      } else {
        result[i + 0] = Math.round(
          (overlayPixels[i + 0] * overlayAlpha + basePixels[i + 0] * baseAlpha * (1 - overlayAlpha)) / outAlpha
        );
        result[i + 1] = Math.round(
          (overlayPixels[i + 1] * overlayAlpha + basePixels[i + 1] * baseAlpha * (1 - overlayAlpha)) / outAlpha
        );
        result[i + 2] = Math.round(
          (overlayPixels[i + 2] * overlayAlpha + basePixels[i + 2] * baseAlpha * (1 - overlayAlpha)) / outAlpha
        );
        result[i + 3] = Math.round(outAlpha * 255);
      }
    }
  }
  return result;
}
const createSvgOverlay = async (elements, imageWidth, imageHeight, boxPadding = 5, borderThickness = 2, prompt) => {
  const overlayPixels = new Uint8Array(imageWidth * imageHeight * 4);
  const colors = [
    {
      rect: { r: 198, g: 35, b: 0, a: 255 },
      text: { r: 255, g: 255, b: 255, a: 255 }
    },
    // red, white
    {
      rect: { r: 0, g: 0, b: 255, a: 255 },
      text: { r: 255, g: 255, b: 255, a: 255 }
    },
    // blue, white
    {
      rect: { r: 139, g: 69, b: 19, a: 255 },
      text: { r: 255, g: 255, b: 255, a: 255 }
    },
    // brown, white
    {
      rect: { r: 62, g: 123, b: 39, a: 255 },
      text: { r: 255, g: 255, b: 255, a: 255 }
    },
    // green, white
    {
      rect: { r: 80, g: 0, b: 115, a: 255 },
      text: { r: 255, g: 255, b: 255, a: 255 }
    }
    // purple, white
  ];
  if (prompt) {
    const promptMargin = 20;
    const promptHeight = 30;
    const promptY = imageHeight - promptHeight - promptMargin;
    fillRect(
      overlayPixels,
      imageWidth,
      imageHeight,
      {
        x: 0,
        y: promptY,
        w: imageWidth,
        h: promptHeight
      },
      { r: 0, g: 0, b: 0, a: 204 }
    );
  }
  for (let index2 = 0; index2 < elements.length; index2++) {
    const element = elements[index2];
    const color = colors[index2 % colors.length];
    const paddedLeft = Math.max(0, element.rect.left - boxPadding);
    const paddedTop = Math.max(0, element.rect.top - boxPadding);
    const paddedWidth = Math.min(
      imageWidth - paddedLeft,
      element.rect.width + boxPadding * 2
    );
    const paddedHeight = Math.min(
      imageHeight - paddedTop,
      element.rect.height + boxPadding * 2
    );
    const paddedRect = {
      x: paddedLeft,
      y: paddedTop,
      w: paddedWidth,
      h: paddedHeight
    };
    drawRect(
      overlayPixels,
      imageWidth,
      imageHeight,
      paddedRect,
      color.rect,
      borderThickness
    );
    const indexId = element.indexId;
    if (typeof indexId !== "number") {
      continue;
    }
    const textWidth = getNumberWidth(indexId);
    const textHeight = FONT_HEIGHT * FONT_SCALE;
    const rectWidth = textWidth + 5;
    const rectHeight = textHeight + 4;
    let rectX = paddedLeft - rectWidth;
    let rectY = paddedTop + Math.floor(paddedHeight / 2) - Math.floor(textHeight / 2) - 2;
    const checkOverlap = (x, y2) => {
      return elements.slice(0, index2).some((otherElement) => {
        return x < otherElement.rect.left + otherElement.rect.width && x + rectWidth > otherElement.rect.left && y2 < otherElement.rect.top + otherElement.rect.height && y2 + rectHeight > otherElement.rect.top;
      });
    };
    const isWithinBounds = (x, y2) => {
      return x >= 0 && x + rectWidth <= imageWidth && y2 >= 0 && y2 + rectHeight <= imageHeight;
    };
    if (checkOverlap(rectX, rectY) || !isWithinBounds(rectX, rectY)) {
      if (!checkOverlap(paddedLeft, paddedTop - rectHeight - 2) && isWithinBounds(paddedLeft, paddedTop - rectHeight - 2)) {
        rectX = paddedLeft;
        rectY = paddedTop - rectHeight - 2;
      } else if (!checkOverlap(paddedLeft, paddedTop + paddedHeight + 2) && isWithinBounds(paddedLeft, paddedTop + paddedHeight + 2)) {
        rectX = paddedLeft;
        rectY = paddedTop + paddedHeight + 2;
      } else if (!checkOverlap(paddedLeft + paddedWidth + 2, paddedTop) && isWithinBounds(paddedLeft + paddedWidth + 2, paddedTop)) {
        rectX = paddedLeft + paddedWidth + 2;
        rectY = paddedTop;
      } else {
        rectX = paddedLeft;
        rectY = paddedTop + 2;
      }
    }
    fillRect(
      overlayPixels,
      imageWidth,
      imageHeight,
      {
        x: rectX,
        y: rectY,
        w: rectWidth,
        h: rectHeight
      },
      color.rect
    );
    const textX = rectX + Math.floor((rectWidth - textWidth) / 2);
    const textY = rectY + Math.floor((rectHeight - textHeight) / 2);
    drawNumber(
      overlayPixels,
      imageWidth,
      imageHeight,
      indexId,
      textX,
      textY,
      color.text
    );
  }
  return overlayPixels;
};
const compositeElementInfoImg = async (options2) => {
  assert$1(options2.inputImgBase64, "inputImgBase64 is required");
  const { PhotonImage, SamplingFilter, resize } = await getPhoton();
  let width = 0;
  let height = 0;
  if (options2.size) {
    width = options2.size.width;
    height = options2.size.height;
  }
  let photonImage = await photonFromBase64(options2.inputImgBase64);
  if (!width || !height) {
    width = photonImage.get_width();
    height = photonImage.get_height();
  } else {
    const imageWidth = photonImage.get_width();
    const imageHeight = photonImage.get_height();
    if (imageWidth !== width || imageHeight !== height) {
      const resized = resize(
        photonImage,
        width,
        height,
        SamplingFilter.Nearest
      );
      photonImage.free();
      photonImage = resized;
    }
  }
  if (!width || !height) {
    photonImage.free();
    throw Error("Image processing failed because width or height is undefined");
  }
  const { elementsPositionInfo, prompt } = options2;
  try {
    const basePixels = photonImage.get_raw_pixels();
    const overlayPixels = await createSvgOverlay(
      elementsPositionInfo,
      width,
      height,
      options2.annotationPadding,
      options2.borderThickness,
      prompt
    );
    const blendedPixels = blendPixels(basePixels, overlayPixels, width, height);
    const resultImage = new PhotonImage(blendedPixels, width, height);
    const base64 = await photonToBase64(resultImage, 90);
    resultImage.free();
    return base64;
  } finally {
    photonImage.free();
  }
};
function truncateText(text, maxLength = 150) {
  if (typeof text === "undefined") {
    return "";
  }
  if (typeof text === "object") {
    text = JSON.stringify(text);
  }
  if (typeof text === "number") {
    return text.toString();
  }
  if (typeof text === "string" && text.length > maxLength) {
    return `${text.slice(0, maxLength)}...`;
  }
  if (typeof text === "string") {
    return text.trim();
  }
  return "";
}
function trimAttributes(attributes, truncateTextLength) {
  const tailorAttributes = Object.keys(attributes).reduce(
    (res2, currentKey) => {
      const attributeVal = attributes[currentKey];
      if (currentKey === "style" || currentKey === "htmlTagName" || currentKey === "nodeType") {
        return res2;
      }
      res2[currentKey] = truncateText(attributeVal, truncateTextLength);
      return res2;
    },
    {}
  );
  return tailorAttributes;
}
const nodeSizeThreshold = 4;
function descriptionOfTree(tree, truncateTextLength, filterNonTextContent = false, visibleOnly = true) {
  const attributesString = (kv) => {
    return Object.entries(kv).map(
      ([key, value]) => `${key}="${truncateText(value, truncateTextLength)}"`
    ).join(" ");
  };
  function buildContentTree(node2, indent = 0, visibleOnly2 = true) {
    var _a3;
    let before = "";
    let contentWithIndent = "";
    let after = "";
    let emptyNode = true;
    const indentStr = "  ".repeat(indent);
    let children = "";
    for (let i = 0; i < (node2.children || []).length; i++) {
      const childContent = buildContentTree(
        node2.children[i],
        indent + 1,
        visibleOnly2
      );
      if (childContent) {
        children += `
${childContent}`;
      }
    }
    if (node2.node && node2.node.rect.width > nodeSizeThreshold && node2.node.rect.height > nodeSizeThreshold && (!filterNonTextContent || filterNonTextContent && node2.node.content) && (!visibleOnly2 || visibleOnly2 && node2.node.isVisible)) {
      emptyNode = false;
      let nodeTypeString;
      if ((_a3 = node2.node.attributes) == null ? void 0 : _a3.htmlTagName) {
        nodeTypeString = node2.node.attributes.htmlTagName.replace(/[<>]/g, "");
      } else {
        nodeTypeString = node2.node.attributes.nodeType.replace(/\sNode$/, "").toLowerCase();
      }
      const rectAttribute = node2.node.rect ? {
        left: node2.node.rect.left,
        top: node2.node.rect.top,
        width: node2.node.rect.width,
        height: node2.node.rect.height
      } : {};
      before = `<${nodeTypeString} id="${node2.node.id}" ${attributesString(trimAttributes(node2.node.attributes || {}, truncateTextLength))} ${attributesString(rectAttribute)}>`;
      const content = truncateText(node2.node.content, truncateTextLength);
      contentWithIndent = content ? `
${indentStr}  ${content}` : "";
      after = `</${nodeTypeString}>`;
    } else if (!filterNonTextContent) {
      if (!children.trim().startsWith("<>")) {
        before = "<>";
        contentWithIndent = "";
        after = "</>";
      }
    }
    if (emptyNode && !children.trim()) {
      return "";
    }
    const result2 = `${indentStr}${before}${contentWithIndent}${children}
${indentStr}${after}`;
    if (result2.trim()) {
      return result2;
    }
    return "";
  }
  const result = buildContentTree(tree, 0, visibleOnly);
  return result.replace(/^\s*\n/gm, "");
}
var util$6;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$6 || (util$6 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$6.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util$6.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json3 = JSON.stringify(obj, null, 2);
  return json3.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$6.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$6.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$6.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$6.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$6.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$6.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$6.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path: path3, errorMaps, issueData } = params;
  const fullPath = [...path3, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status3, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status3.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status3.value, value: arrayValue };
  }
  static async mergeObjectAsync(status3, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status3, syncPairs);
  }
  static mergeObjectSync(status3, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status3.dirty();
      if (value.status === "dirty")
        status3.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status3.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value, path3, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path3;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a3, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a3 = message !== null && message !== void 0 ? message : required_error) !== null && _a3 !== void 0 ? _a3 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a3;
    const ctx = {
      common: {
        issues: [],
        async: (_a3 = params === null || params === void 0 ? void 0 : params.async) !== null && _a3 !== void 0 ? _a3 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a3, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a3 = err === null || err === void 0 ? void 0 : err.message) === null || _a3 === void 0 ? void 0 : _a3.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip2, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip2)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip2)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header3] = jwt.split(".");
    const base64 = header3.replace(/-/g, "+").replace(/_/g, "/").padEnd(header3.length + (4 - header3.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a3) {
    return false;
  }
}
function isValidCidr(ip2, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip2)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip2)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status3 = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status3.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a3) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status3.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return { status: status3.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options2) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  cidr(options2) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    var _a3, _b;
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
      offset: (_a3 = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a3 !== void 0 ? _a3 : false,
      local: (_b = options2 === null || options2 === void 0 ? void 0 : options2.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options2
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2 === null || options2 === void 0 ? void 0 : options2.position,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a3;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status3 = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$6.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status3.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return { status: status3.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$6.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a3) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status3 = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status3.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status3.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return { status: status3.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a3;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status3 = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status3.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status3.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return {
      status: status3.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status: status3 } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status3.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status3.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status3.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status3, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status3, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema2, params) => {
  return new ZodArray({
    type: schema2,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema2) {
  if (schema2 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema2.shape) {
      const fieldSchema = schema2.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema2._def,
      shape: () => newShape
    });
  } else if (schema2 instanceof ZodArray) {
    return new ZodArray({
      ...schema2._def,
      type: deepPartialify(schema2.element)
    });
  } else if (schema2 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodTuple) {
    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
  } else {
    return schema2;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$6.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status: status3, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status3.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status3, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status3, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a3, _b, _c, _d;
          const defaultError = (_c = (_b = (_a3 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a3, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema2) {
    return this.augment({ [key]: schema2 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util$6.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$6.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util$6.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$6.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util$6.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type3) => {
  if (type3 instanceof ZodLazy) {
    return getDiscriminator(type3.schema);
  } else if (type3 instanceof ZodEffects) {
    return getDiscriminator(type3.innerType());
  } else if (type3 instanceof ZodLiteral) {
    return [type3.value];
  } else if (type3 instanceof ZodEnum) {
    return type3.options;
  } else if (type3 instanceof ZodNativeEnum) {
    return util$6.objectValues(type3.enum);
  } else if (type3 instanceof ZodDefault) {
    return getDiscriminator(type3._def.innerType);
  } else if (type3 instanceof ZodUndefined) {
    return [void 0];
  } else if (type3 instanceof ZodNull) {
    return [null];
  } else if (type3 instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type3.unwrap())];
  } else if (type3 instanceof ZodNullable) {
    return [null, ...getDiscriminator(type3.unwrap())];
  } else if (type3 instanceof ZodBranded) {
    return getDiscriminator(type3.unwrap());
  } else if (type3 instanceof ZodReadonly) {
    return getDiscriminator(type3.unwrap());
  } else if (type3 instanceof ZodCatch) {
    return getDiscriminator(type3._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options2, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type3 of options2) {
      const discriminatorValues = getDiscriminator(type3.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type3);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util$6.objectKeys(b);
    const sharedKeys = util$6.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status: status3, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status3.dirty();
      }
      return { status: status3.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status: status3, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status3.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema2 = this._def.items[itemIndex] || this._def.rest;
      if (!schema2)
        return null;
      return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status3, results);
      });
    } else {
      return ParseStatus.mergeArray(status3, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status3, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status3, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status3, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status3, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status3.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status3.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status3.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status3.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status: status3, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status3.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status3.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status3.dirty();
        parsedSet.add(element.value);
      }
      return { status: status3.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error2 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error2.addIssue(makeArgsIssue(args, e));
          throw error2;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error2.addIssue(makeReturnsIssue(result, e));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  strictImplement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util$6.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$6.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util$6.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util$6.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util$6.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util$6.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema2, params) => {
  return new ZodPromise({
    type: schema2,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status: status3, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status3.abort();
        } else {
          status3.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status3.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status3.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status3.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status3.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status3.dirty();
        executeRefinement(inner.value);
        return { status: status3.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status3.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status3.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status3.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status3.value, value: result }));
        });
      }
    }
    util$6.assertNever(effect);
  }
}
ZodEffects.create = (schema2, effect, params) => {
  return new ZodEffects({
    schema: schema2,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
  return new ZodEffects({
    schema: schema2,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type3, params) => {
  return new ZodOptional({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type3, params) => {
  return new ZodNullable({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type3, params) => {
  return new ZodDefault({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type3, params) => {
  return new ZodCatch({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status: status3, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status3.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status3.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type3, params) => {
  return new ZodReadonly({
    innerType: type3,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a3, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a4, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a4 = params.fatal) !== null && _a4 !== void 0 ? _a4 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a3 = params.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce$2 = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util$6;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce: coerce$2,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const defaultBboxSize = 20;
const debugInspectUtils = getDebug("ai:common");
function pointToBbox$1(x, y2, bboxSize2 = defaultBboxSize) {
  const halfSize = bboxSize2 / 2;
  const x1 = Math.max(x - halfSize, 0);
  const y1 = Math.max(y2 - halfSize, 0);
  const x2 = Math.min(x + halfSize, 1e3);
  const y22 = Math.min(y2 + halfSize, 1e3);
  return [x1, y1, x2, y22];
}
function fillBboxParam(locate, width, height, modelFamily) {
  if (locate.bbox_2d && !(locate == null ? void 0 : locate.bbox)) {
    locate.bbox = locate.bbox_2d;
    delete locate.bbox_2d;
  }
  if (locate == null ? void 0 : locate.bbox) {
    locate.bbox = adaptBbox(locate.bbox, width, height, modelFamily);
  }
  return locate;
}
function adaptQwen2_5Bbox(bbox) {
  if (bbox.length < 2) {
    const msg = `invalid bbox data for qwen-vl mode: ${JSON.stringify(bbox)} `;
    throw new Error(msg);
  }
  const result = [
    Math.round(bbox[0]),
    Math.round(bbox[1]),
    typeof bbox[2] === "number" ? Math.round(bbox[2]) : Math.round(bbox[0] + defaultBboxSize),
    typeof bbox[3] === "number" ? Math.round(bbox[3]) : Math.round(bbox[1] + defaultBboxSize)
  ];
  return result;
}
function adaptDoubaoBbox(bbox, width, height) {
  assert(
    width > 0 && height > 0,
    "width and height must be greater than 0 in doubao mode"
  );
  if (typeof bbox === "string") {
    assert(
      /^(\d+)\s(\d+)\s(\d+)\s(\d+)$/.test(bbox.trim()),
      `invalid bbox data string for doubao-vision mode: ${bbox}`
    );
    const splitted = bbox.split(" ");
    if (splitted.length === 4) {
      return [
        Math.round(Number(splitted[0]) * width / 1e3),
        Math.round(Number(splitted[1]) * height / 1e3),
        Math.round(Number(splitted[2]) * width / 1e3),
        Math.round(Number(splitted[3]) * height / 1e3)
      ];
    }
    throw new Error(`invalid bbox data string for doubao-vision mode: ${bbox}`);
  }
  let bboxList = [];
  if (Array.isArray(bbox) && typeof bbox[0] === "string") {
    bbox.forEach((item) => {
      if (typeof item === "string" && item.includes(",")) {
        const [x, y2] = item.split(",");
        bboxList.push(Number(x.trim()), Number(y2.trim()));
      } else if (typeof item === "string" && item.includes(" ")) {
        const [x, y2] = item.split(" ");
        bboxList.push(Number(x.trim()), Number(y2.trim()));
      } else {
        bboxList.push(Number(item));
      }
    });
  } else {
    bboxList = bbox;
  }
  if (bboxList.length === 4 || bboxList.length === 5) {
    return [
      Math.round(bboxList[0] * width / 1e3),
      Math.round(bboxList[1] * height / 1e3),
      Math.round(bboxList[2] * width / 1e3),
      Math.round(bboxList[3] * height / 1e3)
    ];
  }
  if (bboxList.length === 6 || bboxList.length === 2 || bboxList.length === 3 || bboxList.length === 7) {
    return [
      Math.max(
        0,
        Math.round(bboxList[0] * width / 1e3) - defaultBboxSize / 2
      ),
      Math.max(
        0,
        Math.round(bboxList[1] * height / 1e3) - defaultBboxSize / 2
      ),
      Math.min(
        width,
        Math.round(bboxList[0] * width / 1e3) + defaultBboxSize / 2
      ),
      Math.min(
        height,
        Math.round(bboxList[1] * height / 1e3) + defaultBboxSize / 2
      )
    ];
  }
  if (bbox.length === 8) {
    return [
      Math.round(bboxList[0] * width / 1e3),
      Math.round(bboxList[1] * height / 1e3),
      Math.round(bboxList[4] * width / 1e3),
      Math.round(bboxList[5] * height / 1e3)
    ];
  }
  const msg = `invalid bbox data for doubao-vision mode: ${JSON.stringify(bbox)} `;
  throw new Error(msg);
}
function normalizeBboxInput(bbox) {
  if (Array.isArray(bbox)) {
    if (Array.isArray(bbox[0])) {
      return bbox[0];
    }
    return bbox;
  }
  return bbox;
}
function adaptBbox(bbox, width, height, modelFamily) {
  const normalizedBbox = normalizeBboxInput(bbox);
  let result = [0, 0, 0, 0];
  if (modelFamily === "doubao-vision" || isUITars(modelFamily)) {
    result = adaptDoubaoBbox(normalizedBbox, width, height);
  } else if (modelFamily === "gemini") {
    result = adaptGeminiBbox(normalizedBbox, width, height);
  } else if (modelFamily === "qwen2.5-vl") {
    result = adaptQwen2_5Bbox(normalizedBbox);
  } else {
    result = normalized01000(normalizedBbox, width, height);
  }
  return result;
}
function normalized01000(bbox, width, height) {
  return [
    Math.round(bbox[0] * width / 1e3),
    Math.round(bbox[1] * height / 1e3),
    Math.round(bbox[2] * width / 1e3),
    Math.round(bbox[3] * height / 1e3)
  ];
}
function adaptGeminiBbox(bbox, width, height) {
  const left = Math.round(bbox[1] * width / 1e3);
  const top = Math.round(bbox[0] * height / 1e3);
  const right = Math.round(bbox[3] * width / 1e3);
  const bottom = Math.round(bbox[2] * height / 1e3);
  return [left, top, right, bottom];
}
function adaptBboxToRect(bbox, width, height, offsetX = 0, offsetY = 0, rightLimit = width, bottomLimit = height, modelFamily) {
  debugInspectUtils(
    "adaptBboxToRect",
    bbox,
    width,
    height,
    "offset",
    offsetX,
    offsetY,
    "limit",
    rightLimit,
    bottomLimit,
    "modelFamily",
    modelFamily
  );
  const [left, top, right, bottom] = adaptBbox(
    bbox,
    width,
    height,
    modelFamily
  );
  const rectLeft = Math.max(0, left);
  const rectTop = Math.max(0, top);
  const boundedRight = Math.min(right, rightLimit);
  const boundedBottom = Math.min(bottom, bottomLimit);
  const rectWidth = boundedRight - rectLeft + 1;
  const rectHeight = boundedBottom - rectTop + 1;
  const rect = {
    left: rectLeft + offsetX,
    top: rectTop + offsetY,
    width: rectWidth,
    height: rectHeight
  };
  debugInspectUtils("adaptBboxToRect, result=", rect);
  return rect;
}
function mergeRects(rects) {
  const minLeft = Math.min(...rects.map((r) => r.left));
  const minTop = Math.min(...rects.map((r) => r.top));
  const maxRight = Math.max(...rects.map((r) => r.left + r.width));
  const maxBottom = Math.max(...rects.map((r) => r.top + r.height));
  return {
    left: minLeft,
    top: minTop,
    width: maxRight - minLeft,
    height: maxBottom - minTop
  };
}
function expandSearchArea(rect, screenSize, modelFamily) {
  let minEdgeSize = 500;
  if (modelFamily === "qwen3-vl") {
    minEdgeSize = 1200;
  }
  const defaultPadding = 160;
  const paddingSizeHorizontal = rect.width < minEdgeSize ? Math.ceil((minEdgeSize - rect.width) / 2) : defaultPadding;
  const paddingSizeVertical = rect.height < minEdgeSize ? Math.ceil((minEdgeSize - rect.height) / 2) : defaultPadding;
  let newWidth = Math.max(minEdgeSize, rect.width + paddingSizeHorizontal * 2);
  let newHeight = Math.max(minEdgeSize, rect.height + paddingSizeVertical * 2);
  let newLeft = rect.left - paddingSizeHorizontal;
  let newTop = rect.top - paddingSizeVertical;
  if (newLeft + newWidth > screenSize.width) {
    newLeft = screenSize.width - newWidth;
  }
  if (newTop + newHeight > screenSize.height) {
    newTop = screenSize.height - newHeight;
  }
  newLeft = Math.max(0, newLeft);
  newTop = Math.max(0, newTop);
  if (newLeft + newWidth > screenSize.width) {
    newWidth = screenSize.width - newLeft;
  }
  if (newTop + newHeight > screenSize.height) {
    newHeight = screenSize.height - newTop;
  }
  rect.left = newLeft;
  rect.top = newTop;
  rect.width = newWidth;
  rect.height = newHeight;
  return rect;
}
function buildYamlFlowFromPlans(plans, actionSpace) {
  const flow = [];
  for (const plan2 of plans) {
    const verb = plan2.type;
    const action = actionSpace.find((action2) => action2.name === verb);
    if (!action) {
      console.warn(
        `Cannot convert action ${verb} to yaml flow. Will ignore it.`
      );
      continue;
    }
    const flowKey = action.interfaceAlias || verb;
    const flowParam = action.paramSchema ? dumpActionParam(plan2.param || {}, action.paramSchema) : {};
    const flowItem = {
      [flowKey]: "",
      ...flowParam
    };
    flow.push(flowItem);
  }
  return flow;
}
const PointSchema = z.object({
  left: z.number(),
  top: z.number()
});
const SizeSchema = z.object({
  width: z.number(),
  height: z.number(),
  dpr: z.number().optional()
});
const RectSchema = PointSchema.and(SizeSchema).and(
  z.object({
    zoom: z.number().optional()
  })
);
const TMultimodalPromptSchema = z.object({
  images: z.array(
    z.object({
      name: z.string(),
      url: z.string()
    })
  ).optional(),
  convertHttpImage2Base64: z.boolean().optional()
});
const TUserPromptSchema = z.union([
  z.string(),
  z.object({
    prompt: z.string()
  }).and(TMultimodalPromptSchema.partial())
]);
const locateFieldFlagName = "OMNI_location_field_flag";
const LocationInput = z.object({
  prompt: TUserPromptSchema,
  deepThink: z.boolean().optional(),
  cacheable: z.boolean().optional(),
  xpath: z.union([z.string(), z.boolean()]).optional()
}).passthrough();
z.object({
  [locateFieldFlagName]: z.literal(true),
  prompt: TUserPromptSchema,
  // optional fields
  deepThink: z.boolean().optional(),
  // only available in vl model
  cacheable: z.boolean().optional(),
  xpath: z.boolean().optional(),
  // preset result for xpath
  // these two fields will only appear in the result
  center: z.tuple([z.number(), z.number()]),
  rect: RectSchema
}).passthrough();
const getLocationSchema = () => {
  return LocationInput;
};
const isLocatorField$1 = (field2) => {
  var _a3, _b;
  let actualField = field2;
  if (((_a3 = actualField._def) == null ? void 0 : _a3.typeName) === "ZodOptional") {
    actualField = actualField._def.innerType;
  }
  if (((_b = actualField._def) == null ? void 0 : _b.typeName) === "ZodObject") {
    const shape = actualField._def.shape();
    if (locateFieldFlagName in shape) {
      return true;
    }
    if ("prompt" in shape && shape.prompt) {
      return true;
    }
  }
  return false;
};
const findAllLocatorField = (zodType, requiredOnly) => {
  var _a3;
  if (!zodType) {
    return [];
  }
  const zodObject = zodType;
  if (((_a3 = zodObject._def) == null ? void 0 : _a3.typeName) === "ZodObject" && zodObject.shape) {
    const keys = Object.keys(zodObject.shape);
    return keys.filter((key) => {
      var _a4;
      const field2 = zodObject.shape[key];
      if (!isLocatorField$1(field2)) {
        return false;
      }
      if (requiredOnly) {
        return ((_a4 = field2._def) == null ? void 0 : _a4.typeName) !== "ZodOptional";
      }
      return true;
    });
  }
  return [];
};
const dumpActionParam = (jsonObject, zodSchema) => {
  if (!isPlainObject(jsonObject)) {
    return {};
  }
  const locatorFields = findAllLocatorField(zodSchema);
  const result = { ...jsonObject };
  for (const fieldName of locatorFields) {
    const fieldValue = result[fieldName];
    if (fieldValue) {
      if (typeof fieldValue === "string") {
        result[fieldName] = fieldValue;
      } else if (typeof fieldValue === "object") {
        if (fieldValue.prompt) {
          if (typeof fieldValue.prompt === "string") {
            result[fieldName] = fieldValue.prompt;
          } else if (typeof fieldValue.prompt === "object" && fieldValue.prompt.prompt) {
            result[fieldName] = fieldValue.prompt.prompt;
          }
        }
      }
    }
  }
  return result;
};
const parseActionParam = (rawParam, zodSchema) => {
  if (!zodSchema) {
    return void 0;
  }
  const param3 = rawParam ?? {};
  const locateFields = findAllLocatorField(zodSchema);
  if (locateFields.length === 0) {
    return zodSchema.parse(param3);
  }
  const locateFieldValues = {};
  for (const fieldName of locateFields) {
    if (fieldName in param3) {
      locateFieldValues[fieldName] = param3[fieldName];
    }
  }
  const paramsForValidation = {};
  for (const key in param3) {
    if (locateFields.includes(key)) {
      paramsForValidation[key] = { prompt: "_dummy_" };
    } else {
      paramsForValidation[key] = param3[key];
    }
  }
  const validated = zodSchema.parse(paramsForValidation);
  for (const fieldName in locateFieldValues) {
    validated[fieldName] = locateFieldValues[fieldName];
  }
  return validated;
};
const getReadableTimeString = (format2 = "YYYY-MM-DD HH:mm:ss", timestamp2) => {
  const now = timestamp2 !== void 0 ? new Date(timestamp2) : /* @__PURE__ */ new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  const timeString = format2.replace("YYYY", String(year)).replace("MM", month).replace("DD", day).replace("HH", hours).replace("mm", minutes).replace("ss", seconds);
  return `${timeString} (${format2})`;
};
const debug$r = getDebug("auto-glm-parser");
const extractValueAfter = (src2, key) => {
  const idx = src2.indexOf(key);
  if (idx === -1) {
    throw new Error(`Missing key ${key} in action payload ${src2}`);
  }
  let rest = src2.slice(idx + key.length).trim();
  if (rest.endsWith('")')) {
    rest = rest.slice(0, -2);
  }
  return rest;
};
function parseAction$1(response2) {
  debug$r("Parsing action:", response2);
  let trimmedResponse = "";
  try {
    trimmedResponse = response2.content.trim();
    if (trimmedResponse.startsWith('do(action="Type"') || trimmedResponse.startsWith('do(action="Type_Name"')) {
      const text = extractValueAfter(trimmedResponse, 'text="');
      return {
        _metadata: "do",
        action: "Type",
        text,
        think: response2.think
      };
    }
    if (trimmedResponse.startsWith("finish(message=")) {
      let message = extractValueAfter(trimmedResponse, 'finish(message="');
      if (message.endsWith(")")) message = message.slice(0, -1);
      return {
        _metadata: "finish",
        message,
        think: response2.think
      };
    }
    if (trimmedResponse.startsWith("do(")) {
      const actionMatch = trimmedResponse.match(/do\(action="([^"]+)"/);
      if (!actionMatch)
        throw new Error(
          `Failed to extract action type from do() call; raw="${trimmedResponse}"`
        );
      const actionType = actionMatch[1];
      const baseAction = { _metadata: "do", think: response2.think };
      switch (actionType) {
        case "Tap": {
          const elementMatch = trimmedResponse.match(/element=\[(\d+),(\d+)\]/);
          if (!elementMatch)
            throw new Error(
              `Failed to extract element coordinates for Tap; raw="${trimmedResponse}"`
            );
          return {
            ...baseAction,
            action: "Tap",
            element: [Number(elementMatch[1]), Number(elementMatch[2])]
          };
        }
        case "Double Tap": {
          const elementMatch = trimmedResponse.match(/element=\[(\d+),(\d+)\]/);
          if (!elementMatch)
            throw new Error(
              `Failed to extract element coordinates for Double Tap; raw="${trimmedResponse}"`
            );
          return {
            ...baseAction,
            action: "Double Tap",
            element: [Number(elementMatch[1]), Number(elementMatch[2])]
          };
        }
        case "Swipe": {
          const startMatch = trimmedResponse.match(/start=\[(\d+),(\d+)\]/);
          const endMatch = trimmedResponse.match(/end=\[(\d+),(\d+)\]/);
          if (!startMatch || !endMatch)
            throw new Error(
              `Failed to extract start/end coordinates for Swipe; raw="${trimmedResponse}"`
            );
          return {
            ...baseAction,
            action: "Swipe",
            start: [Number(startMatch[1]), Number(startMatch[2])],
            end: [Number(endMatch[1]), Number(endMatch[2])]
          };
        }
        case "Long Press": {
          const elementMatch = trimmedResponse.match(/element=\[(\d+),(\d+)\]/);
          if (!elementMatch)
            throw new Error(
              `Failed to extract element coordinates for Long Press; raw="${trimmedResponse}"`
            );
          return {
            ...baseAction,
            action: "Long Press",
            element: [Number(elementMatch[1]), Number(elementMatch[2])]
          };
        }
        case "Launch": {
          const app2 = extractValueAfter(trimmedResponse, 'app="');
          return { ...baseAction, action: "Launch", app: app2 };
        }
        case "Back": {
          return { ...baseAction, action: "Back" };
        }
        case "Home": {
          return { ...baseAction, action: "Home" };
        }
        case "Wait": {
          const durationMatch = trimmedResponse.match(
            /duration=(?:["\[])?(\d+)/
          );
          if (!durationMatch) {
            throw new Error(
              `Failed to extract duration for Wait; raw="${trimmedResponse}"`
            );
          }
          const seconds = Number.parseInt(durationMatch[1], 10);
          const durationMs = seconds * 1e3;
          return {
            ...baseAction,
            action: "Wait",
            durationMs
          };
        }
        case "Interact": {
          return { ...baseAction, action: "Interact" };
        }
        case "Call_API": {
          const instruction = extractValueAfter(
            trimmedResponse,
            'instruction="'
          );
          return {
            ...baseAction,
            action: "Call_API",
            instruction
          };
        }
        case "Take_over": {
          const message = extractValueAfter(trimmedResponse, 'message="');
          return {
            ...baseAction,
            action: "Take_over",
            message
          };
        }
        case "Note": {
          const message = extractValueAfter(trimmedResponse, 'message="');
          return {
            ...baseAction,
            action: "Note",
            message
          };
        }
        default:
          throw new Error(
            `Unknown action type: ${actionType}; raw="${trimmedResponse}"`
          );
      }
    }
    throw new Error(`Failed to parse action: ${trimmedResponse}`);
  } catch (error2) {
    const errorMessage = error2 instanceof Error ? error2.message : String(error2);
    throw new Error(
      `Failed to parse action: ${errorMessage}; raw="${trimmedResponse}"`
    );
  }
}
function parseAutoGLMResponse(content) {
  if (content.includes("finish(message=")) {
    const parts = content.split("finish(message=");
    const think = parts[0].trim();
    const actionContent = `finish(message=${parts[1]}`;
    return { think, content: actionContent };
  }
  if (content.includes("do(action=")) {
    const parts = content.split("do(action=");
    const think = parts[0].trim();
    const actionContent = `do(action=${parts[1]}`;
    return { think, content: actionContent };
  }
  if (content.includes("<answer>")) {
    const parts = content.split("<answer>");
    const think = parts[0].replace(/<think>/g, "").replace(/<\/think>/g, "").trim();
    const actionContent = parts[1].replace(/<\/answer>/g, "").trim();
    return { think, content: actionContent };
  }
  return { think: "", content };
}
function parseAutoGLMLocateResponse(rawResponse) {
  const { think, content: actionContent } = parseAutoGLMResponse(rawResponse);
  if (!actionContent.startsWith('do(action="Tap"')) {
    return {
      think,
      coordinates: null,
      error: `Unexpected action type in auto-glm locate response: ${actionContent}`
    };
  }
  try {
    const elementMatch = actionContent.match(/element=\[(\d+),(\d+)\]/);
    if (!elementMatch) {
      return {
        think,
        coordinates: null,
        error: `Failed to extract element coordinates from auto-glm response: ${actionContent}`
      };
    }
    const x = Number(elementMatch[1]);
    const y2 = Number(elementMatch[2]);
    return { think, coordinates: { x, y: y2 } };
  } catch (e) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return {
      think,
      coordinates: null,
      error: `Failed to parse coordinates "${actionContent}" with errorMessage: ${errorMessage}`
    };
  }
}
function getMultilingualFormattedDate() {
  const today = /* @__PURE__ */ new Date();
  const year = today.getFullYear();
  const month = String(today.getMonth() + 1).padStart(2, "0");
  const date = String(today.getDate()).padStart(2, "0");
  const dayOfWeek = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ][today.getDay()];
  return `${year}-${month}-${date}, ${dayOfWeek}`;
}
function getChineseFormattedDate() {
  return getMultilingualFormattedDate();
}
const getAutoGLMMultilingualPlanPrompt = () => {
  return `
The current date: ${getMultilingualFormattedDate()}

# Output format
<think>{think}</think>
<answer>{action}</answer>

Rules:
- Only one action per response.
- Use the required format strictly.
  `;
};
const getAutoGLMChinesePlanPrompt = () => {
  return `
The current date: ${getChineseFormattedDate()}

# Output format
<think>{think}</think>
<answer>{action}</answer>

Rules:
- Only one action per response.
- Use the required format strictly.
  `;
};
const getAutoGLMPlanPrompt = (modelFamily) => {
  if (modelFamily === "auto-glm-multilingual") {
    return getAutoGLMMultilingualPlanPrompt();
  } else if (modelFamily === "auto-glm") {
    return getAutoGLMChinesePlanPrompt();
  }
  throw new Error(
    `Unsupported modelFamily for Auto-GLM plan prompt: ${modelFamily}`
  );
};
const getAutoGLMLocatePrompt = (modelFamily) => {
  if (modelFamily === "auto-glm-multilingual") {
    return `
The current date: ${getMultilingualFormattedDate()}

# Output format
<think>{think}</think>
<answer>{action}</answer>

Rules:
- Only one action per response.
- Use the required format strictly.
    `;
  } else if (modelFamily === "auto-glm") {
    return `
The current date: ${getChineseFormattedDate()}

# Output format
<think>{think}</think>
<answer>{action}</answer>

Rules:
- Only one action per response.
- Use the required format strictly.
    `;
  }
  throw new Error(
    `Unsupported modelFamily for Auto-GLM locate prompt: ${modelFamily}`
  );
};
function extractXMLTag(xmlString, tagName) {
  const lowerXmlString = xmlString.toLowerCase();
  const lowerTagName = tagName.toLowerCase();
  const closeTag = `</${lowerTagName}>`;
  const openTag = `<${lowerTagName}>`;
  const lastCloseIndex = lowerXmlString.lastIndexOf(closeTag);
  if (lastCloseIndex === -1) {
    return void 0;
  }
  const searchArea = lowerXmlString.substring(0, lastCloseIndex);
  const lastOpenIndex = searchArea.lastIndexOf(openTag);
  if (lastOpenIndex === -1) {
    return void 0;
  }
  const contentStart = lastOpenIndex + openTag.length;
  const contentEnd = lastCloseIndex;
  const content = xmlString.substring(contentStart, contentEnd);
  return content.trim();
}
function parseSubGoalsFromXML(xmlContent) {
  var _a3;
  const subGoals = [];
  const regex = /<sub-goal\s+index="(\d+)"\s+status="(pending|finished)"(?:\s*\/>|>([\s\S]*?)<\/sub-goal>)/gi;
  let match2;
  match2 = regex.exec(xmlContent);
  while (match2 !== null) {
    const index2 = Number.parseInt(match2[1], 10);
    const status3 = match2[2];
    const description = ((_a3 = match2[3]) == null ? void 0 : _a3.trim()) || "";
    subGoals.push({ index: index2, status: status3, description });
    match2 = regex.exec(xmlContent);
  }
  return subGoals;
}
function parseMarkFinishedIndexes(xmlContent) {
  const indexes = [];
  const regex = /<sub-goal\s+index="(\d+)"\s+status="finished"\s*\/>/gi;
  let match2;
  match2 = regex.exec(xmlContent);
  while (match2 !== null) {
    indexes.push(Number.parseInt(match2[1], 10));
    match2 = regex.exec(xmlContent);
  }
  return indexes;
}
function parseXMLExtractionResponse(xmlString) {
  const thought = extractXMLTag(xmlString, "thought");
  const dataJsonStr = extractXMLTag(xmlString, "data-json");
  const errorsStr = extractXMLTag(xmlString, "errors");
  if (!dataJsonStr) {
    throw new Error("Missing required field: data-json");
  }
  let data;
  try {
    data = safeParseJson(dataJsonStr, void 0);
  } catch (e) {
    throw new Error(`Failed to parse data-json: ${e}`);
  }
  let errors2;
  if (errorsStr) {
    try {
      const parsedErrors = safeParseJson(errorsStr, void 0);
      if (Array.isArray(parsedErrors)) {
        errors2 = parsedErrors;
      }
    } catch (e) {
    }
  }
  return {
    ...thought ? { thought } : {},
    data,
    ...errors2 && errors2.length > 0 ? { errors: errors2 } : {}
  };
}
function systemPromptToExtract() {
  const preferredLanguage = getPreferredLanguage();
  return `
You are a versatile professional in software UI design and testing. Your outstanding contributions will impact the user experience of billions of users.

The user will give you a screenshot, the contents of it (optional), and some data requirements in <DATA_DEMAND>. You need to understand the user's requirements and extract the data satisfying the <DATA_DEMAND>.

If a key specifies a JSON data type (such as Number, String, Boolean, Object, Array), ensure the returned value strictly matches that data type.

If the user provides multiple reference images, please carefully review the reference images with the screenshot and provide the correct answer for <DATA_DEMAND>.


Return in the following XML format:
<thought>the thinking process of the extraction, less than 300 words. Use ${preferredLanguage} in this field.</thought>
<data-json>the extracted data as JSON. Make sure both the value and scheme meet the DATA_DEMAND. If you want to write some description in this field, use the same language as the DATA_DEMAND.</data-json>
<errors>optional error messages as JSON array, e.g., ["error1", "error2"]</errors>

# Example 1
For example, if the DATA_DEMAND is:

<DATA_DEMAND>
{
  "name": "name shows on the left panel, string",
  "age": "age shows on the right panel, number",
  "isAdmin": "if the user is admin, boolean"
}
</DATA_DEMAND>

By viewing the screenshot and page contents, you can extract the following data:

<thought>According to the screenshot, i can see ...</thought>
<data-json>
{
  "name": "John",
  "age": 30,
  "isAdmin": true
}
</data-json>

# Example 2
If the DATA_DEMAND is:

<DATA_DEMAND>
the todo items list, string[]
</DATA_DEMAND>

By viewing the screenshot and page contents, you can extract the following data:

<thought>According to the screenshot, i can see ...</thought>
<data-json>
["todo 1", "todo 2", "todo 3"]
</data-json>

# Example 3
If the DATA_DEMAND is:

<DATA_DEMAND>
the page title, string
</DATA_DEMAND>

By viewing the screenshot and page contents, you can extract the following data:

<thought>According to the screenshot, i can see ...</thought>
<data-json>
"todo list"
</data-json>

# Example 4
If the DATA_DEMAND is:

<DATA_DEMAND>
{
  "result": "Boolean, is it currently the SMS page?"
}
</DATA_DEMAND>

By viewing the screenshot and page contents, you can extract the following data:

<thought>According to the screenshot, i can see ...</thought>
<data-json>
{ "result": true }
</data-json>
`;
}
const extractDataQueryPrompt = (pageDescription, dataQuery) => {
  let dataQueryText = "";
  if (typeof dataQuery === "string") {
    dataQueryText = dataQuery;
  } else {
    dataQueryText = JSON.stringify(dataQuery, null, 2);
  }
  return `
<PageDescription>
${pageDescription}
</PageDescription>

<DATA_DEMAND>
${dataQueryText}
</DATA_DEMAND>
  `;
};
function systemPromptToLocateSection(modelFamily) {
  const preferredLanguage = getPreferredLanguage();
  const bboxFormat = bboxDescription(modelFamily);
  return `
## Role:
You are an AI assistant that helps identify UI elements.

## Objective:
- Find a section containing the target element
- If the description mentions reference elements, also locate sections containing those references

## Output Format:
\`\`\`json
{
  "bbox": [number, number, number, number],  // ${bboxFormat}
  "references_bbox"?: [
    [number, number, number, number],
    ...
  ],
  "error"?: string
}
\`\`\`

Fields:
* \`bbox\` - Bounding box of the section containing the target element
* \`references_bbox\` - Optional array of bounding boxes for reference elements
* \`error\` - Optional error message if the section cannot be found. Use ${preferredLanguage}.

Example:
If the description is "delete button on the second row with title 'Peter'", return:
\`\`\`json
{
  "bbox": [100, 100, 200, 200],
  "references_bbox": [[100, 100, 200, 200]]
}
\`\`\`
`;
}
const sectionLocatorInstruction = (sectionDescription) => `Find section containing: ${sectionDescription}`;
const debugInspect = getDebug("ai:inspect");
const debugSection = getDebug("ai:section");
const extraTextFromUserPrompt = (prompt) => {
  if (typeof prompt === "string") {
    return prompt;
  } else {
    return prompt.prompt;
  }
};
const promptsToChatParam = async (multimodalPrompt) => {
  var _a3;
  const msgs = [];
  if ((_a3 = multimodalPrompt == null ? void 0 : multimodalPrompt.images) == null ? void 0 : _a3.length) {
    msgs.push({
      role: "user",
      content: [
        {
          type: "text",
          text: "Next, I will provide all the reference images."
        }
      ]
    });
    for (const item of multimodalPrompt.images) {
      const base64 = await preProcessImageUrl(
        item.url,
        !!multimodalPrompt.convertHttpImage2Base64
      );
      msgs.push({
        role: "user",
        content: [
          {
            type: "text",
            text: `this is the reference image named '${item.name}':`
          }
        ]
      });
      msgs.push({
        role: "user",
        content: [
          {
            type: "image_url",
            image_url: {
              url: base64,
              detail: "high"
            }
          }
        ]
      });
    }
  }
  return msgs;
};
async function AiLocateElement(options2) {
  var _a3, _b, _c, _d, _e, _f, _g2;
  const { context: context2, targetElementDescription, callAIFn, modelConfig } = options2;
  const { modelFamily } = modelConfig;
  const screenshotBase64 = context2.screenshot.base64;
  assert(
    targetElementDescription,
    "cannot find the target element description"
  );
  const targetElementDescriptionText = extraTextFromUserPrompt(
    targetElementDescription
  );
  const userInstructionPrompt = findElementPrompt(targetElementDescriptionText);
  const systemPrompt = isAutoGLM(modelFamily) ? getAutoGLMLocatePrompt(modelFamily) : systemPromptToLocateElement(modelFamily);
  let imagePayload = screenshotBase64;
  let imageWidth = context2.size.width;
  let imageHeight = context2.size.height;
  let originalImageWidth = imageWidth;
  let originalImageHeight = imageHeight;
  if (options2.searchConfig) {
    assert(
      options2.searchConfig.rect,
      "searchArea is provided but its rect cannot be found. Failed to locate element"
    );
    assert(
      options2.searchConfig.imageBase64,
      "searchArea is provided but its imageBase64 cannot be found. Failed to locate element"
    );
    imagePayload = options2.searchConfig.imageBase64;
    imageWidth = (_a3 = options2.searchConfig.rect) == null ? void 0 : _a3.width;
    imageHeight = (_b = options2.searchConfig.rect) == null ? void 0 : _b.height;
    originalImageWidth = imageWidth;
    originalImageHeight = imageHeight;
  } else if (modelFamily === "qwen2.5-vl") {
    const paddedResult = await paddingToMatchBlockByBase64(imagePayload);
    imageWidth = paddedResult.width;
    imageHeight = paddedResult.height;
    imagePayload = paddedResult.imageBase64;
  }
  const msgs = [
    { role: "system", content: systemPrompt },
    {
      role: "user",
      content: [
        {
          type: "image_url",
          image_url: {
            url: imagePayload,
            detail: "high"
          }
        },
        {
          type: "text",
          text: isAutoGLM(modelFamily) ? `Tap: ${userInstructionPrompt}` : userInstructionPrompt
        }
      ]
    }
  ];
  if (typeof targetElementDescription !== "string") {
    const addOns = await promptsToChatParam({
      images: targetElementDescription.images,
      convertHttpImage2Base64: targetElementDescription.convertHttpImage2Base64
    });
    msgs.push(...addOns);
  }
  if (isAutoGLM(modelFamily)) {
    const { content: rawResponseContent, usage } = await callAIWithStringResponse(msgs, modelConfig);
    debugInspect("auto-glm rawResponse:", rawResponseContent);
    const parsed = parseAutoGLMLocateResponse(rawResponseContent);
    debugInspect("auto-glm thinking:", parsed.think);
    debugInspect("auto-glm coordinates:", parsed.coordinates);
    let resRect2;
    let matchedElements2 = [];
    let errors22 = [];
    if (parsed.error || !parsed.coordinates) {
      errors22 = [parsed.error || "Failed to parse auto-glm response"];
      debugInspect("auto-glm parse error:", errors22[0]);
    } else {
      const { x, y: y2 } = parsed.coordinates;
      debugInspect("auto-glm coordinates [0-999]:", { x, y: y2 });
      const pixelX = Math.round(x * imageWidth / 1e3);
      const pixelY = Math.round(y2 * imageHeight / 1e3);
      debugInspect("auto-glm pixel coordinates:", { pixelX, pixelY });
      let finalX = pixelX;
      let finalY = pixelY;
      if ((_c = options2.searchConfig) == null ? void 0 : _c.rect) {
        finalX += options2.searchConfig.rect.left;
        finalY += options2.searchConfig.rect.top;
      }
      const element = generateElementByPoint(
        [finalX, finalY],
        targetElementDescriptionText
      );
      resRect2 = element.rect;
      debugInspect("auto-glm resRect:", resRect2);
      if (element) {
        matchedElements2 = [element];
      }
    }
    return {
      rect: resRect2,
      parseResult: {
        elements: matchedElements2,
        errors: errors22
      },
      rawResponse: rawResponseContent,
      usage,
      reasoning_content: parsed.think
    };
  }
  let res2;
  try {
    res2 = await callAIFn(msgs, modelConfig);
  } catch (callError) {
    const errorMessage = callError instanceof Error ? callError.message : String(callError);
    const rawResponse2 = callError instanceof AIResponseParseError ? callError.rawResponse : errorMessage;
    const usage = callError instanceof AIResponseParseError ? callError.usage : void 0;
    return {
      rect: void 0,
      parseResult: {
        elements: [],
        errors: [`AI call error: ${errorMessage}`]
      },
      rawResponse: rawResponse2,
      usage,
      reasoning_content: void 0
    };
  }
  const rawResponse = JSON.stringify(res2.content);
  let resRect;
  let matchedElements = [];
  let errors2 = "errors" in res2.content ? res2.content.errors : [];
  try {
    if ("bbox" in res2.content && Array.isArray(res2.content.bbox) && res2.content.bbox.length >= 1) {
      resRect = adaptBboxToRect(
        res2.content.bbox,
        imageWidth,
        imageHeight,
        (_e = (_d = options2.searchConfig) == null ? void 0 : _d.rect) == null ? void 0 : _e.left,
        (_g2 = (_f = options2.searchConfig) == null ? void 0 : _f.rect) == null ? void 0 : _g2.top,
        originalImageWidth,
        originalImageHeight,
        modelFamily
      );
      debugInspect("resRect", resRect);
      const element = generateElementByRect(
        resRect,
        targetElementDescriptionText
      );
      errors2 = [];
      if (element) {
        matchedElements = [element];
      }
    }
  } catch (e) {
    const msg = e instanceof Error ? `Failed to parse bbox: ${e.message}` : "unknown error in locate";
    if (!errors2 || (errors2 == null ? void 0 : errors2.length) === 0) {
      errors2 = [msg];
    } else {
      errors2.push(`(${msg})`);
    }
  }
  return {
    rect: resRect,
    parseResult: {
      elements: matchedElements,
      errors: errors2
    },
    rawResponse,
    usage: res2.usage,
    reasoning_content: res2.reasoning_content
  };
}
async function AiLocateSection(options2) {
  const { context: context2, sectionDescription, modelConfig } = options2;
  const { modelFamily } = modelConfig;
  const screenshotBase64 = context2.screenshot.base64;
  const systemPrompt = systemPromptToLocateSection(modelFamily);
  const sectionLocatorInstructionText = sectionLocatorInstruction(
    extraTextFromUserPrompt(sectionDescription)
  );
  const msgs = [
    { role: "system", content: systemPrompt },
    {
      role: "user",
      content: [
        {
          type: "image_url",
          image_url: {
            url: screenshotBase64,
            detail: "high"
          }
        },
        {
          type: "text",
          text: sectionLocatorInstructionText
        }
      ]
    }
  ];
  if (typeof sectionDescription !== "string") {
    const addOns = await promptsToChatParam({
      images: sectionDescription.images,
      convertHttpImage2Base64: sectionDescription.convertHttpImage2Base64
    });
    msgs.push(...addOns);
  }
  let result;
  try {
    result = await callAIWithObjectResponse(
      msgs,
      modelConfig
    );
  } catch (callError) {
    const errorMessage = callError instanceof Error ? callError.message : String(callError);
    const rawResponse = callError instanceof AIResponseParseError ? callError.rawResponse : errorMessage;
    const usage = callError instanceof AIResponseParseError ? callError.usage : void 0;
    return {
      rect: void 0,
      imageBase64: void 0,
      error: `AI call error: ${errorMessage}`,
      rawResponse,
      usage
    };
  }
  let sectionRect;
  const sectionBbox = result.content.bbox;
  if (sectionBbox) {
    const targetRect = adaptBboxToRect(
      sectionBbox,
      context2.size.width,
      context2.size.height,
      0,
      0,
      context2.size.width,
      context2.size.height,
      modelFamily
    );
    debugSection("original targetRect %j", targetRect);
    const referenceBboxList = result.content.references_bbox || [];
    debugSection("referenceBboxList %j", referenceBboxList);
    const referenceRects = referenceBboxList.filter((bbox) => Array.isArray(bbox)).map((bbox) => {
      return adaptBboxToRect(
        bbox,
        context2.size.width,
        context2.size.height,
        0,
        0,
        context2.size.width,
        context2.size.height,
        modelFamily
      );
    });
    debugSection("referenceRects %j", referenceRects);
    const mergedRect = mergeRects([targetRect, ...referenceRects]);
    debugSection("mergedRect %j", mergedRect);
    sectionRect = expandSearchArea(mergedRect, context2.size, modelFamily);
    debugSection("expanded sectionRect %j", sectionRect);
  }
  let imageBase64 = screenshotBase64;
  if (sectionRect) {
    const croppedResult = await cropByRect(
      screenshotBase64,
      sectionRect,
      modelFamily === "qwen2.5-vl"
    );
    imageBase64 = croppedResult.imageBase64;
    sectionRect.width = croppedResult.width;
    sectionRect.height = croppedResult.height;
  }
  return {
    rect: sectionRect,
    imageBase64,
    error: result.content.error,
    rawResponse: JSON.stringify(result.content),
    usage: result.usage
  };
}
async function AiExtractElementInfo(options2) {
  const { dataQuery, context: context2, extractOption, multimodalPrompt, modelConfig } = options2;
  const systemPrompt = systemPromptToExtract();
  const screenshotBase64 = context2.screenshot.base64;
  const extractDataPromptText = extractDataQueryPrompt(
    options2.pageDescription || "",
    dataQuery
  );
  const userContent = [];
  if ((extractOption == null ? void 0 : extractOption.screenshotIncluded) !== false) {
    userContent.push({
      type: "image_url",
      image_url: {
        url: screenshotBase64,
        detail: "high"
      }
    });
  }
  userContent.push({
    type: "text",
    text: extractDataPromptText
  });
  const msgs = [
    { role: "system", content: systemPrompt },
    {
      role: "user",
      content: userContent
    }
  ];
  if (multimodalPrompt) {
    const addOns = await promptsToChatParam({
      images: multimodalPrompt.images,
      convertHttpImage2Base64: multimodalPrompt.convertHttpImage2Base64
    });
    msgs.push(...addOns);
  }
  const {
    content: rawResponse,
    usage,
    reasoning_content
  } = await callAI(msgs, modelConfig);
  let parseResult;
  try {
    parseResult = parseXMLExtractionResponse(rawResponse);
  } catch (parseError) {
    const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
    throw new AIResponseParseError(
      `XML parse error: ${errorMessage}`,
      rawResponse,
      usage
    );
  }
  return {
    parseResult,
    rawResponse,
    usage,
    reasoning_content
  };
}
function unwrapZodField(field2) {
  const f = field2;
  if (!f._def) return f;
  const typeName = f._def.typeName;
  if (typeName === "ZodOptional" || typeName === "ZodNullable" || typeName === "ZodDefault") {
    return unwrapZodField(f._def.innerType);
  }
  if (typeName === "ZodEffects") {
    if (f._def.schema) {
      return unwrapZodField(f._def.schema);
    }
  }
  return f;
}
function isLocatorField(field2) {
  var _a3, _b, _c;
  const actualField = unwrapZodField(field2);
  if (((_a3 = actualField._def) == null ? void 0 : _a3.typeName) === "ZodObject") {
    const shape = (_c = (_b = actualField._def).shape) == null ? void 0 : _c.call(_b);
    if (shape) {
      if ("Omni_location_field_flag" in shape) {
        return true;
      }
      if ("prompt" in shape && shape.prompt) {
        return true;
      }
    }
  }
  return false;
}
function getZodTypeName(field2, locatorTypeDescription) {
  var _a3, _b, _c, _d;
  const actualField = unwrapZodField(field2);
  const fieldTypeName = (_a3 = actualField._def) == null ? void 0 : _a3.typeName;
  if (fieldTypeName === "ZodString") return "string";
  if (fieldTypeName === "ZodNumber") return "number";
  if (fieldTypeName === "ZodBoolean") return "boolean";
  if (fieldTypeName === "ZodArray") return "array";
  if (fieldTypeName === "ZodObject") {
    if (isLocatorField(actualField)) {
      return locatorTypeDescription || "object";
    }
    return "object";
  }
  if (fieldTypeName === "ZodEnum") {
    const values = ((_c = (_b = actualField._def) == null ? void 0 : _b.values) == null ? void 0 : _c.map((option) => String(`'${option}'`)).join(", ")) ?? "enum";
    return `enum(${values})`;
  }
  if (fieldTypeName === "ZodUnion") {
    const options2 = (_d = actualField._def) == null ? void 0 : _d.options;
    if (options2 && options2.length > 0) {
      const types2 = options2.map(
        (opt) => getZodTypeName(opt, locatorTypeDescription)
      );
      return types2.join(" | ");
    }
    return "union";
  }
  return "unknown";
}
function getZodDescription(field2) {
  if ("description" in field2) {
    return field2.description || null;
  }
  const actualField = unwrapZodField(field2);
  if ("description" in actualField) {
    return actualField.description || null;
  }
  if (isLocatorField(actualField)) {
    return "Location information for the target element";
  }
  return null;
}
const vlLocateParam = (modelFamily) => {
  if (modelFamily) {
    return `{bbox: [number, number, number, number], prompt: string } // ${bboxDescription(modelFamily)}`;
  }
  return "{ prompt: string /* description of the target element */ }";
};
const findDefaultValue = (field2) => {
  var _a3, _b, _c;
  let current = field2;
  const visited = /* @__PURE__ */ new Set();
  while (current && !visited.has(current)) {
    visited.add(current);
    const currentWithDef = current;
    if (!((_a3 = currentWithDef._def) == null ? void 0 : _a3.typeName)) break;
    if (currentWithDef._def.typeName === "ZodDefault") {
      return (_c = (_b = currentWithDef._def).defaultValue) == null ? void 0 : _c.call(_b);
    }
    if (currentWithDef._def.typeName === "ZodOptional" || currentWithDef._def.typeName === "ZodNullable") {
      current = currentWithDef._def.innerType;
    } else {
      break;
    }
  }
  return void 0;
};
const descriptionForAction = (action, locatorSchemaTypeDescription) => {
  var _a3;
  const tab = "  ";
  const fields = [];
  fields.push(`- type: "${action.name}"`);
  if (action.paramSchema) {
    const paramLines = [];
    const schema2 = action.paramSchema;
    const isZodObject = ((_a3 = schema2._def) == null ? void 0 : _a3.typeName) === "ZodObject";
    if (isZodObject && schema2.shape) {
      const shape = schema2.shape;
      for (const [key, field2] of Object.entries(shape)) {
        if (field2 && typeof field2 === "object") {
          const isOptional = typeof field2.isOptional === "function" && field2.isOptional();
          const keyWithOptional = isOptional ? `${key}?` : key;
          const typeName = getZodTypeName(field2, locatorSchemaTypeDescription);
          const description = getZodDescription(field2);
          const defaultValue = findDefaultValue(field2);
          const hasDefault = defaultValue !== void 0;
          let paramLine = `${keyWithOptional}: ${typeName}`;
          const comments = [];
          if (description) {
            comments.push(description);
          }
          if (hasDefault) {
            const defaultStr = typeof defaultValue === "string" ? `"${defaultValue}"` : JSON.stringify(defaultValue);
            comments.push(`default: ${defaultStr}`);
          }
          if (comments.length > 0) {
            paramLine += ` // ${comments.join(", ")}`;
          }
          paramLines.push(paramLine);
        }
      }
      if (paramLines.length > 0) {
        fields.push("- param:");
        paramLines.forEach((line) => {
          fields.push(`  - ${line}`);
        });
      }
    } else {
      const typeName = getZodTypeName(schema2);
      const description = getZodDescription(schema2);
      let paramDescription = `- param: ${typeName}`;
      if (description) {
        paramDescription += ` // ${description}`;
      }
      paramDescription += " (pass the value directly, not as an object)";
      fields.push(paramDescription);
    }
  }
  return `- ${action.name}, ${action.description || "No description provided"}
${tab}${fields.join(`
${tab}`)}
`.trim();
};
async function systemPromptToTaskPlanning({
  actionSpace,
  modelFamily,
  includeBbox,
  includeThought,
  includeSubGoals
}) {
  const preferredLanguage = getPreferredLanguage();
  if (includeBbox && !modelFamily) {
    throw new Error(
      "modelFamily cannot be undefined when includeBbox is true. A valid modelFamily is required for bbox-based location."
    );
  }
  const actionDescriptionList = actionSpace.map((action) => {
    return descriptionForAction(
      action,
      vlLocateParam(includeBbox ? modelFamily : void 0)
    );
  });
  const actionList = actionDescriptionList.join("\n");
  const shouldIncludeSubGoals = includeSubGoals ?? false;
  const locateExample1 = includeBbox ? `{
    "prompt": "Add to cart button for Sauce Labs Backpack",
    "bbox": [345, 442, 458, 483]
  }` : `{
    "prompt": "Add to cart button for Sauce Labs Backpack"
  }`;
  const locateNameField = includeBbox ? `{
    "prompt": "Name input field in the registration form",
    "bbox": [120, 180, 380, 210]
  }` : `{
    "prompt": "Name input field in the registration form"
  }`;
  const locateEmailField = includeBbox ? `{
    "prompt": "Email input field in the registration form",
    "bbox": [120, 240, 380, 270]
  }` : `{
    "prompt": "Email input field in the registration form"
  }`;
  const step1Title = shouldIncludeSubGoals ? "## Step 1: Observe and Plan (related tags: <thought>, <update-plan-content>, <mark-sub-goal-done>)" : "## Step 1: Observe (related tags: <thought>)";
  const step1Description = shouldIncludeSubGoals ? "First, observe the current screenshot and previous logs, then break down the user's instruction into multiple high-level sub-goals. Update the status of sub-goals based on what you see in the current screenshot." : "First, observe the current screenshot and previous logs to understand the current state.";
  const explicitInstructionRule = `CRITICAL - Following Explicit Instructions: When the user gives you specific operation steps (not high-level goals), you MUST execute ONLY those exact steps - nothing more, nothing less. Do NOT add extra actions even if they seem logical. For example: "fill out the form" means only fill fields, do NOT submit; "click the button" means only click, do NOT wait for page load or verify results; "type 'hello'" means only type, do NOT press Enter.`;
  const thoughtTagDescription = shouldIncludeSubGoals ? `REQUIRED: You MUST always output the <thought> tag. Never skip it.

Include your thought process in the <thought> tag. It should answer: What is the user's requirement? What is the current state based on the screenshot? Are all sub-goals completed? If not, what should be the next action? Write your thoughts naturally without numbering or section headers.

${explicitInstructionRule}` : `REQUIRED: You MUST always output the <thought> tag. Never skip it.

Include your thought process in the <thought> tag. It should answer: What is the current state based on the screenshot? What should be the next action? Write your thoughts naturally without numbering or section headers.

${explicitInstructionRule}`;
  const subGoalTags = shouldIncludeSubGoals ? `

* <update-plan-content> tag

Use this structure to give or update your plan:

<update-plan-content>
  <sub-goal index="1" status="finished|pending">sub goal description</sub-goal>
  <sub-goal index="2" status="finished|pending">sub goal description</sub-goal>
  ...
</update-plan-content>

* <mark-sub-goal-done> tag

Use this structure to mark a sub-goal as done:

<mark-sub-goal-done>
  <sub-goal index="1" status="finished" />
</mark-sub-goal-done>

IMPORTANT: You MUST only mark a sub-goal as "finished" AFTER you have confirmed the task is actually completed by observing the result in the screenshot. Do NOT mark a sub-goal as done just because you expect the next action will complete it. Wait until you see visual confirmation in the screenshot that the sub-goal has been achieved.

* Note

During execution, you can call <update-plan-content> at any time to update the plan based on the latest screenshot and completed sub-goals.

### Example

If the user wants to "log in to a system using username and password, complete all to-do items, and submit a registration form", you can break it down into the following sub-goals:

<thought>...</thought>
<update-plan-content>
  <sub-goal index="1" status="pending">Log in to the system</sub-goal>
  <sub-goal index="2" status="pending">Complete all to-do items</sub-goal>
  <sub-goal index="3" status="pending">Submit the registration form</sub-goal>
</update-plan-content>

After logging in and seeing the to-do items, you can mark the sub-goal as done:

<mark-sub-goal-done>
  <sub-goal index="1" status="finished" />
</mark-sub-goal-done>

At this point, the status of all sub-goals is:

<update-plan-content>
  <sub-goal index="1" status="finished" />
  <sub-goal index="2" status="pending" />
  <sub-goal index="3" status="pending" />
</update-plan-content>

After some time, when the last sub-goal is also completed, you can mark it as done as well:

<mark-sub-goal-done>
  <sub-goal index="3" status="finished" />
</mark-sub-goal-done>` : "";
  const memoryStepNumber = 2;
  const checkGoalStepNumber = shouldIncludeSubGoals ? 3 : 2;
  const actionStepNumber = shouldIncludeSubGoals ? 4 : 3;
  return `
Target: You are an expert to manipulate the UI to accomplish the user's instruction. User will give you an instruction, some screenshots, background knowledge and previous logs indicating what have been done. Your task is to accomplish the instruction by thinking through the path to complete the task and give the next action to execute.

${step1Title}

${step1Description}

* <thought> tag (REQUIRED)

${thoughtTagDescription}
${subGoalTags}
${shouldIncludeSubGoals ? `
## Step ${memoryStepNumber}: Memory Data from Current Screenshot (related tags: <memory>)

While observing the current screenshot, if you notice any information that might be needed in follow-up actions, record it here. The current screenshot will NOT be available in subsequent steps, so this memory is your only way to preserve essential information. Examples: extracted data, element states, content that needs to be referenced.

Don't use this tag if no information needs to be preserved.
` : ""}
## Step ${checkGoalStepNumber}: Check if Goal is Accomplished (related tags: <complete-goal>)

${shouldIncludeSubGoals ? "Based on the current screenshot and the status of all sub-goals, determine" : "Determine"} if the entire task is completed.

### CRITICAL: The User's Instruction is the Supreme Authority

The user's instruction defines the EXACT scope of what you must accomplish. You MUST follow it precisely - nothing more, nothing less. Violating this rule may cause severe consequences such as data loss, unintended operations, or system failures.

**Explicit instructions vs. High-level goals:**
- If the user gives you **explicit operation steps** (e.g., "click X", "type Y", "fill out the form"), treat them as exact commands. Execute ONLY those steps, nothing more.
- If the user gives you a **high-level goal** (e.g., "log in to the system", "complete the purchase"), you may determine the necessary steps to achieve it.

**What "goal accomplished" means:**
- The goal is accomplished when you have done EXACTLY what the user asked - no extra steps, no assumptions.
- Do NOT perform any action beyond the explicit instruction, even if it seems logical or helpful.

**Examples - Explicit instructions (execute exactly, no extra steps):**
- "fill out the form" ?Goal accomplished when all fields are filled. Do NOT submit the form.
- "click the login button" ?Goal accomplished once clicked. Do NOT wait for page load or verify login success.
- "type 'hello' in the search box" ?Goal accomplished when 'hello' is typed. Do NOT press Enter or trigger search.
- "select the first item" ?Goal accomplished when selected. Do NOT proceed to checkout.

**Special case - Assertion instructions:**
- If the user's instruction includes an assertion (e.g., "verify that...", "check that...", "assert..."), and you observe from the screenshot that the assertion condition is NOT satisfied and cannot be satisfied, mark the goal as failed (success="false").

### Output Rules

- If the task is NOT complete, skip this section and continue to Step ${actionStepNumber}.
- Use the <complete-goal success="true|false">message</complete-goal> tag to output the result if the goal is accomplished or failed.
  - the 'success' attribute is required. ${shouldIncludeSubGoals ? "It means whether the expected goal is accomplished based on what you observe in the current screenshot. " : ""}No matter what actions were executed or what errors occurred during execution, if the expected goal is accomplished, set success="true". If the expected goal is not accomplished and cannot be accomplished, set success="false".
  - the 'message' is the information that will be provided to the user. If the user asks for a specific format, strictly follow that.
- If you output <complete-goal>, do NOT output <action-type> or <action-param-json>. The task ends here.

## Step ${actionStepNumber}: Determine Next Action (related tags: <log>, <action-type>, <action-param-json>, <error>)

ONLY if the task is not complete: Think what the next action is according to the current screenshot${shouldIncludeSubGoals ? " and the plan" : ""}.

- Don't give extra actions or plans beyond the instruction or the plan. For example, don't try to submit the form if the instruction is only to fill something.
- Consider the current screenshot and give the action that is most likely to accomplish the instruction. For example, if the next step is to click a button but it's not visible in the screenshot, you should try to find it first instead of give a click action.
- Make sure the previous actions are completed successfully. Otherwise, retry or do something else to recover.
- Give just the next ONE action you should do (if any)
- If there are some error messages reported by the previous actions, don't give up, try parse a new action to recover. If the error persists for more than 3 times, you should think this is an error and set the "error" field to the error message.

### Supporting actions list

${actionList}

### Log to give user feedback (preamble message)

The <log> tag is a brief preamble message to the user explaining what you're about to do. It should follow these principles and examples:

- **Use ${preferredLanguage}**
- **Keep it concise**: be no more than 1-2 sentences, focused on immediate, tangible next steps. (8?2 words or Chinese characters for quick updates).
- **Build on prior context**: if this is not the first action to be done, use the preamble message to connect the dots with what's been done so far and create a sense of momentum and clarity for the user to understand your next actions.
- **Keep your tone light, friendly and curious**: add small touches of personality in preambles feel collaborative and engaging.

**Examples:**
- <log>Click the login button</log>
- <log>Scroll to find the 'Yes' button in popup</log>
- <log>Previous actions failed to find the 'Yes' button, i will try again</log>
- <log>Go back to find the login button</log>

### If there is some action to do ...

- Use the <action-type> and <action-param-json> tags to output the action to be executed.
- The <action-type> MUST be one of the supporting actions. 'complete-goal' is NOT a valid action-type.
For example:
<action-type>Tap</action-type>
<action-param-json>
{
  "locate": ${locateExample1}
}
</action-param-json>

### If you think there is an error ...

- Use the <error> tag to output the error message.

For example:
<error>Unable to find the required element on the page</error>

### If there is no action to do ...

- Don't output <action-type> or <action-param-json> if there is no action to do.

## Return Format

Return in XML format following this decision flow:

**Always include (REQUIRED):**
<!-- Step 1: Observe${shouldIncludeSubGoals ? " and Plan" : ""} -->
<thought>Your thought process here. NEVER skip this tag.</thought>
${shouldIncludeSubGoals ? `
<!-- required when no update-plan-content is provided in the previous response -->
<update-plan-content>...</update-plan-content>

<!-- required when any sub-goal is completed -->
<mark-sub-goal-done>
  <sub-goal index="1" status="finished" />
</mark-sub-goal-done>
` : ""}${shouldIncludeSubGoals ? `
<!-- Step ${memoryStepNumber}: Memory data from current screenshot if needed -->
<memory>...</memory>
` : ""}
**Then choose ONE of the following paths:**

**Path A: If the goal is accomplished or failed (Step ${checkGoalStepNumber})**
<complete-goal success="true|false">...</complete-goal>

**Path B: If the goal is NOT complete yet (Step ${actionStepNumber})**
<!-- Determine next action -->
<log>...</log>
<action-type>...</action-type>
<action-param-json>...</action-param-json>

<!-- OR if there's an error -->
<error>...</error>
${shouldIncludeSubGoals ? `
## Multi-turn Conversation Example

Below is an example of a multi-turn conversation for "fill out the registration form with name 'John' and email 'john@example.com', then return the filled email address":

### Turn 1 - Initial instruction

**User message:**
<user_instruction>fill out the registration form with name 'John' and email 'john@example.com', then return the filled email address</user_instruction>

**Screenshot:** [Shows a registration form with empty Name and Email fields]

**Your response:**
<thought>The user wants me to fill out the registration form with specific values and return the email address. I can see the form has two fields: Name and Email. Both are currently empty. I'll break this down into sub-goals and start with the Name field. Note: The instruction is to fill the form only (not submit), and return the email at the end.</thought>
<update-plan-content>
  <sub-goal index="1" status="pending">Fill in the Name field with 'John'</sub-goal>
  <sub-goal index="2" status="pending">Fill in the Email field with 'john@example.com'</sub-goal>
  <sub-goal index="3" status="pending">Return the filled email address</sub-goal>
</update-plan-content>
<log>Click on the Name field to start filling the form</log>
<action-type>Tap</action-type>
<action-param-json>
{
  "locate": ${locateNameField}
}
</action-param-json>

### Turn 2 - After clicking Name field

**User message:**
The previous action has been executed, here is the latest screenshot. Please continue according to the instruction.

Sub-goals:
1. Fill in the Name field with 'John' (running)
2. Fill in the Email field with 'john@example.com' (pending)
Current sub-goal is: Fill in the Name field with 'John'

**Screenshot:** [Shows the form with Name field now focused/active]

**Your response:**
<thought>The Name field is now focused. I need to type 'John' into this field. Current sub-goal is running, will be completed after input.</thought>
<log>Typing 'John' into the Name field</log>
<action-type>Input</action-type>
<action-param-json>
{
  "value": "John"
}
</action-param-json>

### Turn 3 - After entering name

**User message:**
The previous action has been executed, here is the latest screenshot. Please continue according to the instruction.

Sub-goals:
1. Fill in the Name field with 'John' (running)
2. Fill in the Email field with 'john@example.com' (pending)
Current sub-goal is: Fill in the Name field with 'John'

**Screenshot:** [Shows the form with Name field containing 'John']

**Your response:**
<thought>The Name field now shows 'John'. Sub-goal 1 is complete. Next, I need to fill the Email field for sub-goal 2.</thought>
<mark-sub-goal-done>
  <sub-goal index="1" status="finished" />
</mark-sub-goal-done>
<memory>Name field has been filled with 'John'</memory>
<log>Moving to the Email field</log>
<action-type>Tap</action-type>
<action-param-json>
{
  "locate": ${locateEmailField}
}
</action-param-json>

### Turn 4 - After clicking Email field

**User message:**
The previous action has been executed, here is the latest screenshot. Please continue according to the instruction.

Sub-goals:
1. Fill in the Name field with 'John' (finished)
2. Fill in the Email field with 'john@example.com' (running)
Current sub-goal is: Fill in the Email field with 'john@example.com'

**Screenshot:** [Shows the form with Name='John' and Email field focused]

**Your response:**
<thought>The Email field is now focused. I'll enter 'john@example.com'. After this, sub-goal 2 will be complete and my task will be done.</thought>
<log>Typing email address into the Email field</log>
<action-type>Input</action-type>
<action-param-json>
{
  "value": "john@example.com"
}
</action-param-json>

### Turn 5 - After entering email (Goal accomplished)

**User message:**
The previous action has been executed, here is the latest screenshot. Please continue according to the instruction.

Sub-goals:
1. Fill in the Name field with 'John' (finished)
2. Fill in the Email field with 'john@example.com' (running)
3. Return the filled email address (pending)
Current sub-goal is: Fill in the Email field with 'john@example.com'

**Screenshot:** [Shows the form with Name='John' and Email='john@example.com']

**Your response:**
<thought>Both fields are now filled: Name shows 'John' and Email shows 'john@example.com'. Sub-goal 2 is complete. The user asked me to return the filled email address, so I need to include 'john@example.com' in my response. All sub-goals are now finished.</thought>
<mark-sub-goal-done>
  <sub-goal index="2" status="finished" />
  <sub-goal index="3" status="finished" />
</mark-sub-goal-done>
<complete-goal success="true">john@example.com</complete-goal>
` : `
## Multi-turn Conversation Example

Below is an example of a multi-turn conversation for "fill out the registration form with name 'John' and email 'john@example.com', then return the filled email address":

### Turn 1 - Initial instruction

**User message:**
<user_instruction>fill out the registration form with name 'John' and email 'john@example.com', then return the filled email address</user_instruction>

**Screenshot:** [Shows a registration form with empty Name and Email fields]

**Your response:**
<thought>The user wants me to fill out the registration form with specific values and return the email address. I can see the form has two fields: Name and Email. Both are currently empty. I should start by clicking on the Name field. Note: The instruction is to fill the form only (not submit), and return the email at the end.</thought>
<log>Click on the Name field to start filling the form</log>
<action-type>Tap</action-type>
<action-param-json>
{
  "locate": ${locateNameField}
}
</action-param-json>

### Turn 2 - After clicking Name field

**User message:**
The previous action has been executed, here is the latest screenshot. Please continue according to the instruction.

**Screenshot:** [Shows the form with Name field now focused/active]

**Your response:**
<thought>The Name field is now focused. I need to type 'John' into this field. After this, I'll need to fill the Email field as well.</thought>
<log>Typing 'John' into the Name field</log>
<action-type>Input</action-type>
<action-param-json>
{
  "value": "John"
}
</action-param-json>

### Turn 3 - After entering name

**User message:**
The previous action has been executed, here is the latest screenshot. Please continue according to the instruction.

**Screenshot:** [Shows the form with Name field containing 'John']

**Your response:**
<thought>The Name field now shows 'John'. Next, I need to fill the Email field with 'john@example.com'. I'll click on the Email field first.</thought>
<log>Moving to the Email field</log>
<action-type>Tap</action-type>
<action-param-json>
{
  "locate": ${locateEmailField}
}
</action-param-json>

### Turn 4 - After clicking Email field

**User message:**
The previous action has been executed, here is the latest screenshot. Please continue according to the instruction.

**Screenshot:** [Shows the form with Name='John' and Email field focused]

**Your response:**
<thought>The Email field is now focused. I'll enter 'john@example.com'. After this, both required fields will be filled and my task will be complete.</thought>
<log>Typing email address into the Email field</log>
<action-type>Input</action-type>
<action-param-json>
{
  "value": "john@example.com"
}
</action-param-json>

### Turn 5 - After entering email (Goal accomplished)

**User message:**
The previous action has been executed, here is the latest screenshot. Please continue according to the instruction.

**Screenshot:** [Shows the form with Name='John' and Email='john@example.com']

**Your response:**
<thought>Both fields are now filled: Name shows 'John' and Email shows 'john@example.com'. The user asked me to return the filled email address, so I should include 'john@example.com' in my response. Goal accomplished.</thought>
<complete-goal success="true">john@example.com</complete-goal>
`}`;
}
const debug$q = getDebug("planning");
function parseXMLPlanningResponse(xmlString, modelFamily) {
  var _a3;
  const thought = extractXMLTag(xmlString, "thought");
  const memory = extractXMLTag(xmlString, "memory");
  const log2 = extractXMLTag(xmlString, "log") || "";
  const error2 = extractXMLTag(xmlString, "error");
  const actionType = extractXMLTag(xmlString, "action-type");
  const actionParamStr = extractXMLTag(xmlString, "action-param-json");
  const completeGoalRegex = /<complete-goal\s+success="(true|false)">([\s\S]*?)<\/complete-goal>/i;
  const completeGoalMatch = xmlString.match(completeGoalRegex);
  let finalizeMessage;
  let finalizeSuccess;
  if (completeGoalMatch) {
    finalizeSuccess = completeGoalMatch[1] === "true";
    finalizeMessage = ((_a3 = completeGoalMatch[2]) == null ? void 0 : _a3.trim()) || void 0;
  }
  const updatePlanContent = extractXMLTag(xmlString, "update-plan-content");
  const markSubGoalDone = extractXMLTag(xmlString, "mark-sub-goal-done");
  const updateSubGoals = updatePlanContent ? parseSubGoalsFromXML(updatePlanContent) : void 0;
  const markFinishedIndexes = markSubGoalDone ? parseMarkFinishedIndexes(markSubGoalDone) : void 0;
  let action = null;
  if (actionType && actionType.toLowerCase() !== "null") {
    const type3 = actionType.trim();
    let param3 = void 0;
    if (actionParamStr) {
      try {
        param3 = safeParseJson(actionParamStr, modelFamily);
      } catch (e) {
        throw new Error(`Failed to parse action-param-json: ${e}`);
      }
    }
    action = {
      type: type3,
      ...param3 !== void 0 ? { param: param3 } : {}
    };
  }
  return {
    ...thought ? { thought } : {},
    ...memory ? { memory } : {},
    log: log2,
    ...error2 ? { error: error2 } : {},
    action,
    ...finalizeMessage !== void 0 ? { finalizeMessage } : {},
    ...finalizeSuccess !== void 0 ? { finalizeSuccess } : {},
    ...(updateSubGoals == null ? void 0 : updateSubGoals.length) ? { updateSubGoals } : {},
    ...(markFinishedIndexes == null ? void 0 : markFinishedIndexes.length) ? { markFinishedIndexes } : {}
  };
}
async function plan(userInstruction, opts) {
  var _a3, _b;
  const { context: context2, modelConfig, conversationHistory } = opts;
  const { size } = context2;
  const screenshotBase64 = context2.screenshot.base64;
  const { modelFamily } = modelConfig;
  const includeSubGoals = opts.deepThink === true;
  const systemPrompt = await systemPromptToTaskPlanning({
    actionSpace: opts.actionSpace,
    modelFamily,
    includeBbox: opts.includeBbox,
    includeThought: true,
    // always include thought
    includeSubGoals
  });
  let imagePayload = screenshotBase64;
  let imageWidth = size.width;
  let imageHeight = size.height;
  if (modelFamily === "qwen2.5-vl") {
    const paddedResult = await paddingToMatchBlockByBase64(imagePayload);
    imageWidth = paddedResult.width;
    imageHeight = paddedResult.height;
    imagePayload = paddedResult.imageBase64;
  }
  const actionContext = opts.actionContext ? `<high_priority_knowledge>${opts.actionContext}</high_priority_knowledge>
` : "";
  const instruction = [
    {
      role: "user",
      content: [
        {
          type: "text",
          text: `${actionContext}<user_instruction>${userInstruction}</user_instruction>`
        }
      ]
    }
  ];
  let latestFeedbackMessage;
  const subGoalsText = includeSubGoals ? conversationHistory.subGoalsToText() : "";
  const subGoalsSection = subGoalsText ? `

${subGoalsText}` : "";
  const memoriesText = conversationHistory.memoriesToText();
  const memoriesSection = memoriesText ? `

${memoriesText}` : "";
  if (conversationHistory.pendingFeedbackMessage) {
    latestFeedbackMessage = {
      role: "user",
      content: [
        {
          type: "text",
          text: `${conversationHistory.pendingFeedbackMessage}. The previous action has been executed, here is the latest screenshot. Please continue according to the instruction.${memoriesSection}${subGoalsSection}`
        },
        {
          type: "image_url",
          image_url: {
            url: imagePayload,
            detail: "high"
          }
        }
      ]
    };
    conversationHistory.resetPendingFeedbackMessageIfExists();
  } else {
    latestFeedbackMessage = {
      role: "user",
      content: [
        {
          type: "text",
          text: `this is the latest screenshot${memoriesSection}${subGoalsSection}`
        },
        {
          type: "image_url",
          image_url: {
            url: imagePayload,
            detail: "high"
          }
        }
      ]
    };
  }
  conversationHistory.append(latestFeedbackMessage);
  conversationHistory.compressHistory(50, 20);
  const historyLog = conversationHistory.snapshot(opts.imagesIncludeCount);
  const msgs = [
    { role: "system", content: systemPrompt },
    ...instruction,
    ...historyLog
  ];
  const {
    content: rawResponse,
    usage,
    reasoning_content
  } = await callAI(msgs, modelConfig, {
    deepThink: opts.deepThink === "unset" ? void 0 : opts.deepThink
  });
  let planFromAI;
  try {
    planFromAI = parseXMLPlanningResponse(rawResponse, modelFamily);
  } catch (parseError) {
    const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
    throw new AIResponseParseError(
      `XML parse error: ${errorMessage}`,
      rawResponse,
      usage
    );
  }
  if (planFromAI.action && planFromAI.finalizeSuccess !== void 0) {
    console.warn(
      "Planning response included both an action and complete-goal; ignoring complete-goal output."
    );
    planFromAI.finalizeMessage = void 0;
    planFromAI.finalizeSuccess = void 0;
  }
  const actions = planFromAI.action ? [planFromAI.action] : [];
  let shouldContinuePlanning = true;
  if (planFromAI.finalizeSuccess !== void 0) {
    debug$q("goal completed via complete-goal tag, stop planning");
    shouldContinuePlanning = false;
    if (includeSubGoals) {
      conversationHistory.markAllSubGoalsFinished();
    }
  }
  const returnValue = {
    ...planFromAI,
    actions,
    rawResponse,
    usage,
    reasoning_content,
    yamlFlow: buildYamlFlowFromPlans(actions, opts.actionSpace),
    shouldContinuePlanning
  };
  assert(planFromAI, "can't get plans from AI");
  actions.forEach((action) => {
    const type3 = action.type;
    const actionInActionSpace = opts.actionSpace.find(
      (action2) => action2.name === type3
    );
    debug$q("actionInActionSpace matched", actionInActionSpace);
    const locateFields = actionInActionSpace ? findAllLocatorField(actionInActionSpace.paramSchema) : [];
    debug$q("locateFields", locateFields);
    locateFields.forEach((field2) => {
      const locateResult = action.param[field2];
      if (locateResult && modelFamily !== void 0) {
        action.param[field2] = fillBboxParam(
          locateResult,
          imageWidth,
          imageHeight,
          modelFamily
        );
      }
    });
  });
  if (includeSubGoals) {
    if ((_a3 = planFromAI.updateSubGoals) == null ? void 0 : _a3.length) {
      conversationHistory.setSubGoals(planFromAI.updateSubGoals);
    }
    if ((_b = planFromAI.markFinishedIndexes) == null ? void 0 : _b.length) {
      for (const index2 of planFromAI.markFinishedIndexes) {
        conversationHistory.markSubGoalFinished(index2);
      }
    }
  }
  if (planFromAI.memory) {
    conversationHistory.appendMemory(planFromAI.memory);
  }
  conversationHistory.append({
    role: "assistant",
    content: [
      {
        type: "text",
        text: rawResponse
      }
    ]
  });
  return returnValue;
}
const debug$p = getDebug("auto-glm-actions");
const AUTO_GLM_COORDINATE_MAX = 1e3;
function autoGLMCoordinateToBbox(x, y2, width, height) {
  const bbox = pointToBbox$1(x, y2, 10);
  return adaptBbox(bbox, width, height, "auto-glm");
}
function transformAutoGLMAction(action, size) {
  try {
    switch (action._metadata) {
      case "finish": {
        const finishAction = action;
        debug$p("Transform finish action:", finishAction);
        return [
          {
            type: "Finished",
            param: {},
            thought: finishAction.message
          }
        ];
      }
      case "do": {
        const doAction = action;
        switch (doAction.action) {
          case "Tap": {
            const tapAction = doAction;
            debug$p("Transform Tap action:", tapAction);
            const [x1, y1, x2, y2] = autoGLMCoordinateToBbox(
              tapAction.element[0],
              tapAction.element[1],
              size.width,
              size.height
            );
            const locate = {
              prompt: "",
              bbox: [x1, y1, x2, y2]
            };
            return [
              {
                type: "Tap",
                param: {
                  locate
                }
              }
            ];
          }
          case "Double Tap": {
            const doubleTapAction = doAction;
            debug$p("Transform Double Tap action:", doubleTapAction);
            const [x1, y1, x2, y2] = autoGLMCoordinateToBbox(
              doubleTapAction.element[0],
              doubleTapAction.element[1],
              size.width,
              size.height
            );
            const locate = {
              prompt: "",
              bbox: [x1, y1, x2, y2]
            };
            return [
              {
                type: "DoubleClick",
                param: {
                  locate
                }
              }
            ];
          }
          case "Type": {
            const typeAction = doAction;
            debug$p("Transform Type action:", typeAction);
            return [
              {
                type: "Input",
                param: {
                  value: typeAction.text
                }
              }
            ];
          }
          case "Swipe": {
            const swipeAction = doAction;
            debug$p("Transform Swipe action:", swipeAction);
            const [x1, y1, x2, y2] = autoGLMCoordinateToBbox(
              swipeAction.start[0],
              swipeAction.start[1],
              size.width,
              size.height
            );
            const locate = {
              prompt: "",
              bbox: [x1, y1, x2, y2]
            };
            const deltaX = swipeAction.end[0] - swipeAction.start[0];
            const deltaY = swipeAction.end[1] - swipeAction.start[1];
            let direction;
            let distance;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);
            if (absDeltaY > absDeltaX) {
              distance = Math.round(
                absDeltaY * size.height / AUTO_GLM_COORDINATE_MAX
              );
              direction = deltaY > 0 ? "up" : "down";
            } else {
              distance = Math.round(
                absDeltaX * size.width / AUTO_GLM_COORDINATE_MAX
              );
              direction = deltaX > 0 ? "left" : "right";
            }
            debug$p(
              `Calculate swipe direction: ${direction}, distance: ${distance}`
            );
            return [
              {
                type: "Scroll",
                param: {
                  locate,
                  // The scrolling direction here all refers to which direction of the page's content will appear on the screen.
                  distance,
                  direction
                },
                thought: swipeAction.think || ""
              }
            ];
          }
          case "Long Press": {
            const longPressAction = doAction;
            debug$p("Transform Long Press action:", longPressAction);
            const [x1, y1, x2, y2] = autoGLMCoordinateToBbox(
              longPressAction.element[0],
              longPressAction.element[1],
              size.width,
              size.height
            );
            const locate = {
              prompt: "",
              bbox: [x1, y1, x2, y2]
            };
            return [
              {
                type: "LongPress",
                param: {
                  locate
                },
                thought: longPressAction.think || ""
              }
            ];
          }
          case "Back": {
            const backAction = doAction;
            debug$p("Transform Back action:", backAction);
            return [
              {
                type: "AndroidBackButton",
                param: {},
                thought: backAction.think || ""
              }
            ];
          }
          case "Home": {
            const homeAction = doAction;
            debug$p("Transform Home action:", homeAction);
            return [
              {
                type: "AndroidHomeButton",
                param: {},
                thought: homeAction.think || ""
              }
            ];
          }
          case "Wait": {
            const waitAction = doAction;
            debug$p("Transform Wait action:", waitAction);
            return [
              {
                type: "Sleep",
                param: {
                  timeMs: waitAction.durationMs
                },
                thought: waitAction.think || ""
              }
            ];
          }
          case "Launch": {
            const launchAction = doAction;
            debug$p("Transform Launch action:", launchAction);
            return [
              {
                type: "Launch",
                param: launchAction.app,
                thought: launchAction.think || ""
              }
            ];
          }
          case "Interact": {
            throw new Error(
              `Action "Interact" from auto-glm is not supported in the current implementation.`
            );
          }
          case "Call_API": {
            throw new Error(
              `Action "Call_API" from auto-glm is not supported in the current implementation.`
            );
          }
          case "Take_over": {
            throw new Error(
              `Action "Take_over" from auto-glm is not supported in the current implementation.`
            );
          }
          case "Note": {
            throw new Error(
              `Action "Note" from auto-glm is not supported in the current implementation.`
            );
          }
          default:
            throw new Error(
              `Unknown do() action type: ${doAction.action}`
            );
        }
      }
      default:
        throw new Error(
          `Unknown action metadata: ${action._metadata}`
        );
    }
  } catch (error2) {
    const errorMessage = error2 instanceof Error ? error2.message : String(error2);
    debug$p("Transform error:", errorMessage);
    throw new Error(`Failed to transform action: ${errorMessage}`);
  }
}
const debug$o = getDebug("auto-glm-planning");
async function autoGLMPlanning(userInstruction, options2) {
  const { conversationHistory, context: context2, modelConfig, actionContext } = options2;
  const systemPrompt = getAutoGLMPlanPrompt(modelConfig.modelFamily) + (actionContext ? `<high_priority_knowledge>${actionContext}</high_priority_knowledge>` : "");
  const imagePayload = context2.screenshot;
  conversationHistory.append({
    role: "user",
    content: [{ type: "text", text: userInstruction }]
  });
  conversationHistory.append({
    role: "user",
    content: [{ type: "image_url", image_url: { url: imagePayload.base64 } }]
  });
  const msgs = [
    { role: "system", content: systemPrompt },
    ...conversationHistory.snapshot(1)
  ];
  const { content: rawResponse, usage } = await callAIWithStringResponse(
    msgs,
    modelConfig
  );
  debug$o("autoGLMPlanning rawResponse:", rawResponse);
  let parsedResponse;
  let transformedActions;
  try {
    parsedResponse = parseAutoGLMResponse(rawResponse);
    debug$o("thinking in response:", parsedResponse.think);
    debug$o("action in response:", parsedResponse.content);
    const parsedAction = parseAction$1(parsedResponse);
    debug$o("Parsed action object:", parsedAction);
    transformedActions = transformAutoGLMAction(parsedAction, context2.size);
    debug$o("Transformed actions:", transformedActions);
  } catch (parseError) {
    const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
    throw new AIResponseParseError(
      `Parse error: ${errorMessage}`,
      JSON.stringify(rawResponse, void 0, 2),
      usage
    );
  }
  conversationHistory.append({
    role: "assistant",
    content: `<think>${parsedResponse.think}</think><answer>${parsedResponse.content}</answer>`
  });
  const shouldContinuePlanning = !parsedResponse.content.startsWith("finish(");
  return {
    actions: transformedActions,
    log: rawResponse,
    usage,
    shouldContinuePlanning,
    rawResponse: JSON.stringify(rawResponse, void 0, 2)
  };
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _keyDefinitions = {
  "0": { keyCode: 48, key: "0", code: "Digit0" },
  "1": { keyCode: 49, key: "1", code: "Digit1" },
  "2": { keyCode: 50, key: "2", code: "Digit2" },
  "3": { keyCode: 51, key: "3", code: "Digit3" },
  "4": { keyCode: 52, key: "4", code: "Digit4" },
  "5": { keyCode: 53, key: "5", code: "Digit5" },
  "6": { keyCode: 54, key: "6", code: "Digit6" },
  "7": { keyCode: 55, key: "7", code: "Digit7" },
  "8": { keyCode: 56, key: "8", code: "Digit8" },
  "9": { keyCode: 57, key: "9", code: "Digit9" },
  Power: { key: "Power", code: "Power" },
  Eject: { key: "Eject", code: "Eject" },
  Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
  Help: { keyCode: 6, code: "Help", key: "Help" },
  Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
  Tab: { keyCode: 9, code: "Tab", key: "Tab" },
  Numpad5: {
    keyCode: 12,
    shiftKeyCode: 101,
    key: "Clear",
    code: "Numpad5",
    shiftKey: "5",
    location: 3
  },
  NumpadEnter: {
    keyCode: 13,
    code: "NumpadEnter",
    key: "Enter",
    text: "\r",
    location: 3
  },
  Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
  ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
  ControlLeft: {
    keyCode: 17,
    code: "ControlLeft",
    key: "Control",
    location: 1
  },
  ControlRight: {
    keyCode: 17,
    code: "ControlRight",
    key: "Control",
    location: 2
  },
  AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
  AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
  Pause: { keyCode: 19, code: "Pause", key: "Pause" },
  CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
  Escape: { keyCode: 27, code: "Escape", key: "Escape" },
  Convert: { keyCode: 28, code: "Convert", key: "Convert" },
  NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
  Space: { keyCode: 32, code: "Space", key: " " },
  Numpad9: {
    keyCode: 33,
    shiftKeyCode: 105,
    key: "PageUp",
    code: "Numpad9",
    shiftKey: "9",
    location: 3
  },
  PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
  Numpad3: {
    keyCode: 34,
    shiftKeyCode: 99,
    key: "PageDown",
    code: "Numpad3",
    shiftKey: "3",
    location: 3
  },
  PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
  End: { keyCode: 35, code: "End", key: "End" },
  Numpad1: {
    keyCode: 35,
    shiftKeyCode: 97,
    key: "End",
    code: "Numpad1",
    shiftKey: "1",
    location: 3
  },
  Home: { keyCode: 36, code: "Home", key: "Home" },
  Numpad7: {
    keyCode: 36,
    shiftKeyCode: 103,
    key: "Home",
    code: "Numpad7",
    shiftKey: "7",
    location: 3
  },
  ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
  Numpad4: {
    keyCode: 37,
    shiftKeyCode: 100,
    key: "ArrowLeft",
    code: "Numpad4",
    shiftKey: "4",
    location: 3
  },
  Numpad8: {
    keyCode: 38,
    shiftKeyCode: 104,
    key: "ArrowUp",
    code: "Numpad8",
    shiftKey: "8",
    location: 3
  },
  ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
  ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
  Numpad6: {
    keyCode: 39,
    shiftKeyCode: 102,
    key: "ArrowRight",
    code: "Numpad6",
    shiftKey: "6",
    location: 3
  },
  Numpad2: {
    keyCode: 40,
    shiftKeyCode: 98,
    key: "ArrowDown",
    code: "Numpad2",
    shiftKey: "2",
    location: 3
  },
  ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
  Select: { keyCode: 41, code: "Select", key: "Select" },
  Open: { keyCode: 43, code: "Open", key: "Execute" },
  PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
  Insert: { keyCode: 45, code: "Insert", key: "Insert" },
  Numpad0: {
    keyCode: 45,
    shiftKeyCode: 96,
    key: "Insert",
    code: "Numpad0",
    shiftKey: "0",
    location: 3
  },
  Delete: { keyCode: 46, code: "Delete", key: "Delete" },
  NumpadDecimal: {
    keyCode: 46,
    shiftKeyCode: 110,
    code: "NumpadDecimal",
    key: "\0",
    shiftKey: ".",
    location: 3
  },
  Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
  Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
  Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
  Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
  Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
  Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
  Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
  Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
  Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
  Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
  KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
  KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
  KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
  KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
  KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
  KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
  KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
  KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
  KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
  KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
  KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
  KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
  KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
  KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
  KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
  KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
  KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
  KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
  KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
  KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
  KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
  KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
  KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
  KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
  KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
  KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
  MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
  MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
  ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
  NumpadMultiply: {
    keyCode: 106,
    code: "NumpadMultiply",
    key: "*",
    location: 3
  },
  NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
  NumpadSubtract: {
    keyCode: 109,
    code: "NumpadSubtract",
    key: "-",
    location: 3
  },
  NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
  F1: { keyCode: 112, code: "F1", key: "F1" },
  F2: { keyCode: 113, code: "F2", key: "F2" },
  F3: { keyCode: 114, code: "F3", key: "F3" },
  F4: { keyCode: 115, code: "F4", key: "F4" },
  F5: { keyCode: 116, code: "F5", key: "F5" },
  F6: { keyCode: 117, code: "F6", key: "F6" },
  F7: { keyCode: 118, code: "F7", key: "F7" },
  F8: { keyCode: 119, code: "F8", key: "F8" },
  F9: { keyCode: 120, code: "F9", key: "F9" },
  F10: { keyCode: 121, code: "F10", key: "F10" },
  F11: { keyCode: 122, code: "F11", key: "F11" },
  F12: { keyCode: 123, code: "F12", key: "F12" },
  F13: { keyCode: 124, code: "F13", key: "F13" },
  F14: { keyCode: 125, code: "F14", key: "F14" },
  F15: { keyCode: 126, code: "F15", key: "F15" },
  F16: { keyCode: 127, code: "F16", key: "F16" },
  F17: { keyCode: 128, code: "F17", key: "F17" },
  F18: { keyCode: 129, code: "F18", key: "F18" },
  F19: { keyCode: 130, code: "F19", key: "F19" },
  F20: { keyCode: 131, code: "F20", key: "F20" },
  F21: { keyCode: 132, code: "F21", key: "F21" },
  F22: { keyCode: 133, code: "F22", key: "F22" },
  F23: { keyCode: 134, code: "F23", key: "F23" },
  F24: { keyCode: 135, code: "F24", key: "F24" },
  NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
  ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
  AudioVolumeMute: {
    keyCode: 173,
    code: "AudioVolumeMute",
    key: "AudioVolumeMute"
  },
  AudioVolumeDown: {
    keyCode: 174,
    code: "AudioVolumeDown",
    key: "AudioVolumeDown"
  },
  AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
  MediaTrackNext: {
    keyCode: 176,
    code: "MediaTrackNext",
    key: "MediaTrackNext"
  },
  MediaTrackPrevious: {
    keyCode: 177,
    code: "MediaTrackPrevious",
    key: "MediaTrackPrevious"
  },
  MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
  MediaPlayPause: {
    keyCode: 179,
    code: "MediaPlayPause",
    key: "MediaPlayPause"
  },
  Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
  Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
  NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
  Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
  Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
  Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
  Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
  Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
  BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
  Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
  BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
  Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
  AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
  Props: { keyCode: 247, code: "Props", key: "CrSel" },
  Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
  Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
  Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
  Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
  Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
  Accept: { keyCode: 30, key: "Accept" },
  ModeChange: { keyCode: 31, key: "ModeChange" },
  " ": { keyCode: 32, key: " ", code: "Space" },
  Print: { keyCode: 42, key: "Print" },
  Execute: { keyCode: 43, key: "Execute", code: "Open" },
  "\0": { keyCode: 46, key: "\0", code: "NumpadDecimal", location: 3 },
  a: { keyCode: 65, key: "a", code: "KeyA" },
  b: { keyCode: 66, key: "b", code: "KeyB" },
  c: { keyCode: 67, key: "c", code: "KeyC" },
  d: { keyCode: 68, key: "d", code: "KeyD" },
  e: { keyCode: 69, key: "e", code: "KeyE" },
  f: { keyCode: 70, key: "f", code: "KeyF" },
  g: { keyCode: 71, key: "g", code: "KeyG" },
  h: { keyCode: 72, key: "h", code: "KeyH" },
  i: { keyCode: 73, key: "i", code: "KeyI" },
  j: { keyCode: 74, key: "j", code: "KeyJ" },
  k: { keyCode: 75, key: "k", code: "KeyK" },
  l: { keyCode: 76, key: "l", code: "KeyL" },
  m: { keyCode: 77, key: "m", code: "KeyM" },
  n: { keyCode: 78, key: "n", code: "KeyN" },
  o: { keyCode: 79, key: "o", code: "KeyO" },
  p: { keyCode: 80, key: "p", code: "KeyP" },
  q: { keyCode: 81, key: "q", code: "KeyQ" },
  r: { keyCode: 82, key: "r", code: "KeyR" },
  s: { keyCode: 83, key: "s", code: "KeyS" },
  t: { keyCode: 84, key: "t", code: "KeyT" },
  u: { keyCode: 85, key: "u", code: "KeyU" },
  v: { keyCode: 86, key: "v", code: "KeyV" },
  w: { keyCode: 87, key: "w", code: "KeyW" },
  x: { keyCode: 88, key: "x", code: "KeyX" },
  y: { keyCode: 89, key: "y", code: "KeyY" },
  z: { keyCode: 90, key: "z", code: "KeyZ" },
  Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
  "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
  "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
  "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
  "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
  ";": { keyCode: 186, key: ";", code: "Semicolon" },
  "=": { keyCode: 187, key: "=", code: "Equal" },
  ",": { keyCode: 188, key: ",", code: "Comma" },
  ".": { keyCode: 190, key: ".", code: "Period" },
  "`": { keyCode: 192, key: "`", code: "Backquote" },
  "[": { keyCode: 219, key: "[", code: "BracketLeft" },
  "\\": { keyCode: 220, key: "\\", code: "Backslash" },
  "]": { keyCode: 221, key: "]", code: "BracketRight" },
  "'": { keyCode: 222, key: "'", code: "Quote" },
  Attn: { keyCode: 246, key: "Attn" },
  CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
  ExSel: { keyCode: 248, key: "ExSel" },
  EraseEof: { keyCode: 249, key: "EraseEof" },
  Play: { keyCode: 250, key: "Play" },
  ZoomOut: { keyCode: 251, key: "ZoomOut" },
  ")": { keyCode: 48, key: ")", code: "Digit0" },
  "!": { keyCode: 49, key: "!", code: "Digit1" },
  "@": { keyCode: 50, key: "@", code: "Digit2" },
  "#": { keyCode: 51, key: "#", code: "Digit3" },
  $: { keyCode: 52, key: "$", code: "Digit4" },
  "%": { keyCode: 53, key: "%", code: "Digit5" },
  "^": { keyCode: 54, key: "^", code: "Digit6" },
  "&": { keyCode: 55, key: "&", code: "Digit7" },
  "(": { keyCode: 57, key: "(", code: "Digit9" },
  A: { keyCode: 65, key: "A", code: "KeyA" },
  B: { keyCode: 66, key: "B", code: "KeyB" },
  C: { keyCode: 67, key: "C", code: "KeyC" },
  D: { keyCode: 68, key: "D", code: "KeyD" },
  E: { keyCode: 69, key: "E", code: "KeyE" },
  F: { keyCode: 70, key: "F", code: "KeyF" },
  G: { keyCode: 71, key: "G", code: "KeyG" },
  H: { keyCode: 72, key: "H", code: "KeyH" },
  I: { keyCode: 73, key: "I", code: "KeyI" },
  J: { keyCode: 74, key: "J", code: "KeyJ" },
  K: { keyCode: 75, key: "K", code: "KeyK" },
  L: { keyCode: 76, key: "L", code: "KeyL" },
  M: { keyCode: 77, key: "M", code: "KeyM" },
  N: { keyCode: 78, key: "N", code: "KeyN" },
  O: { keyCode: 79, key: "O", code: "KeyO" },
  P: { keyCode: 80, key: "P", code: "KeyP" },
  Q: { keyCode: 81, key: "Q", code: "KeyQ" },
  R: { keyCode: 82, key: "R", code: "KeyR" },
  S: { keyCode: 83, key: "S", code: "KeyS" },
  T: { keyCode: 84, key: "T", code: "KeyT" },
  U: { keyCode: 85, key: "U", code: "KeyU" },
  V: { keyCode: 86, key: "V", code: "KeyV" },
  W: { keyCode: 87, key: "W", code: "KeyW" },
  X: { keyCode: 88, key: "X", code: "KeyX" },
  Y: { keyCode: 89, key: "Y", code: "KeyY" },
  Z: { keyCode: 90, key: "Z", code: "KeyZ" },
  ":": { keyCode: 186, key: ":", code: "Semicolon" },
  "<": { keyCode: 188, key: "<", code: "Comma" },
  _: { keyCode: 189, key: "_", code: "Minus" },
  ">": { keyCode: 190, key: ">", code: "Period" },
  "?": { keyCode: 191, key: "?", code: "Slash" },
  "~": { keyCode: 192, key: "~", code: "Backquote" },
  "{": { keyCode: 219, key: "{", code: "BracketLeft" },
  "|": { keyCode: 220, key: "|", code: "Backslash" },
  "}": { keyCode: 221, key: "}", code: "BracketRight" },
  '"': { keyCode: 222, key: '"', code: "Quote" },
  SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
  SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
  Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
  Call: { key: "Call", code: "Call", location: 4 },
  EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
  VolumeDown: {
    keyCode: 182,
    key: "VolumeDown",
    code: "VolumeDown",
    location: 4
  },
  VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
};
const lowerCaseKeyDefinitions = Object.entries(_keyDefinitions).reduce(
  (acc, [key, definition]) => {
    const lowerKey = key.toLowerCase();
    if (lowerKey !== key) {
      acc[lowerKey] = definition;
    }
    return acc;
  },
  {}
);
const getKeyDefinition = (key) => {
  const lowerKey = key.toLowerCase();
  if (lowerCaseKeyDefinitions[lowerKey]) {
    return lowerCaseKeyDefinitions[lowerKey].key;
  }
  return key;
};
const isMac = typeof window !== "undefined" ? /Mac|iPod|iPhone|iPad/.test(window.navigator.platform) : process.platform === "darwin";
const keyMap = {
  return: _keyDefinitions.Enter.key,
  enter: _keyDefinitions.Enter.key,
  ctrl: isMac ? _keyDefinitions.Meta.key : _keyDefinitions.Control.key,
  shift: _keyDefinitions.Shift.key,
  alt: _keyDefinitions.Alt.key,
  space: _keyDefinitions.Space.key,
  "page down": _keyDefinitions.PageDown.key,
  pagedown: _keyDefinitions.PageDown.key,
  "page up": _keyDefinitions.PageUp.key,
  pageup: _keyDefinitions.PageUp.key
};
function transformHotkeyInput(keyInput) {
  if (keyMap[keyInput.toLowerCase()]) {
    return [getKeyDefinition(keyMap[keyInput.toLowerCase()])];
  }
  return keyInput.split(" ").map((key) => {
    return getKeyDefinition(keyMap[key.toLowerCase()] || key);
  });
}
const IMAGE_FACTOR = 28;
const MIN_PIXELS = 100 * IMAGE_FACTOR * IMAGE_FACTOR;
const MAX_PIXELS_V1_5 = 16384 * IMAGE_FACTOR * IMAGE_FACTOR;
const MAX_RATIO = 200;
var vlm_UITarsModelVersion = /* @__PURE__ */ function(UITarsModelVersion2) {
  UITarsModelVersion2["V1_0"] = "1.0";
  UITarsModelVersion2["V1_5"] = "1.5";
  UITarsModelVersion2["DOUBAO_1_5_15B"] = "doubao-1.5-15B";
  UITarsModelVersion2["DOUBAO_1_5_20B"] = "doubao-1.5-20B";
  return UITarsModelVersion2;
}({});
var numberTag = "[object Number]";
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isNumber(value) {
  return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
}
var lodash_isnumber = isNumber;
const lodash_isnumber$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isnumber);
function roundByFactor(num, factor) {
  return Math.round(num / factor) * factor;
}
function floorByFactor(num, factor) {
  return Math.floor(num / factor) * factor;
}
function ceilByFactor(num, factor) {
  return Math.ceil(num / factor) * factor;
}
function smartResizeForV15(height, width, maxRatio = MAX_RATIO, factor = IMAGE_FACTOR, minPixels = MIN_PIXELS, maxPixels = MAX_PIXELS_V1_5) {
  if (Math.max(height, width) / Math.min(height, width) > maxRatio) {
    console.error(`absolute aspect ratio must be smaller than ${maxRatio}, got ${Math.max(height, width) / Math.min(height, width)}`);
    return null;
  }
  let wBar = Math.max(factor, roundByFactor(width, factor));
  let hBar = Math.max(factor, roundByFactor(height, factor));
  if (hBar * wBar > maxPixels) {
    const beta = Math.sqrt(height * width / maxPixels);
    hBar = floorByFactor(height / beta, factor);
    wBar = floorByFactor(width / beta, factor);
  } else if (hBar * wBar < minPixels) {
    const beta = Math.sqrt(minPixels / (height * width));
    hBar = ceilByFactor(height * beta, factor);
    wBar = ceilByFactor(width * beta, factor);
  }
  return [
    wBar,
    hBar
  ];
}
function actionParser(params) {
  const { prediction, factor, mode, screenContext, scaleFactor, modelVer } = params;
  const parsed = parseActionVlm(prediction, Array.isArray(factor) ? factor : [
    factor,
    factor
  ], mode, screenContext, scaleFactor, modelVer);
  return {
    parsed
  };
}
function parseActionVlm(text, factors = [
  1e3,
  1e3
], mode = "bc", screenContext, scaleFactor, modelVer = vlm_UITarsModelVersion.V1_0) {
  let reflection = null;
  let thought = null;
  let actionStr = "";
  let smartResizeFactors = null;
  if (modelVer === vlm_UITarsModelVersion.V1_5 && (null == screenContext ? void 0 : screenContext.height) && (null == screenContext ? void 0 : screenContext.width)) smartResizeFactors = smartResizeForV15(screenContext.height, screenContext.width);
  text = text.trim();
  if ("bc" === mode) {
    if (text.includes("Thought:")) {
      const thoughtMatch = text.match(/Thought: ([\s\S]+?)(?=\s*Action[:]|$)/);
      if (thoughtMatch) thought = thoughtMatch[1].trim();
    } else if (text.startsWith("Reflection:")) {
      const reflectionMatch = text.match(/Reflection: ([\s\S]+?)Action_Summary: ([\s\S]+?)(?=\s*Action[:]|$)/);
      if (reflectionMatch) {
        thought = reflectionMatch[2].trim();
        reflection = reflectionMatch[1].trim();
      }
    } else if (text.startsWith("Action_Summary:")) {
      const summaryMatch = text.match(/Action_Summary: (.+?)(?=\s*Action[:]|$)/);
      if (summaryMatch) thought = summaryMatch[1].trim();
    }
    if ([
      "Action:",
      "Action"
    ].some((keyword) => text.includes(keyword))) {
      const actionParts = text.split(/Action[:]/);
      actionStr = actionParts[actionParts.length - 1];
    } else actionStr = text;
  } else if ("o1" === mode) {
    const thoughtMatch = text.match(/<Thought>\s*(.*?)\s*<\/Thought>/);
    const actionSummaryMatch = text.match(/\nAction_Summary:\s*(.*?)\s*Action:/);
    const actionMatch = text.match(/\nAction:\s*(.*?)\s*<\/Output>/);
    const thoughtContent = thoughtMatch ? thoughtMatch[1] : null;
    const actionSummaryContent = actionSummaryMatch ? actionSummaryMatch[1] : null;
    const actionContent = actionMatch ? actionMatch[1] : null;
    thought = `${thoughtContent}
<Action_Summary>
${actionSummaryContent}`;
    actionStr = actionContent || "";
  }
  const allActions = actionStr.split("\n\n");
  const actions = [];
  for (const rawStr of allActions) {
    const actionInstance = parseAction(rawStr.replace(/\n/g, String.raw`\n`).trimStart());
    let actionType = "";
    let actionInputs = {};
    if (actionInstance) {
      actionType = actionInstance.function;
      const params = actionInstance.args;
      actionInputs = {};
      for (const [paramName, param3] of Object.entries(params)) {
        if (!param3) continue;
        const trimmedParam = param3.trim();
        if (paramName.includes("start_box") || paramName.includes("end_box")) {
          const oriBox = trimmedParam;
          const numbers = oriBox.replace(/[()[\]]/g, "").split(",").filter((ori) => "" !== ori);
          const floatNumbers = numbers.map((num, idx) => {
            const factorIndex = idx % 2;
            if (modelVer === vlm_UITarsModelVersion.V1_5 && smartResizeFactors) return Number.parseFloat(num) / smartResizeFactors[factorIndex];
            return Number.parseFloat(num) / factors[factorIndex];
          });
          if (2 === floatNumbers.length) floatNumbers.push(floatNumbers[0], floatNumbers[1]);
          actionInputs[paramName.trim()] = JSON.stringify(floatNumbers);
          if ((null == screenContext ? void 0 : screenContext.width) && (null == screenContext ? void 0 : screenContext.height)) {
            const boxKey = paramName.includes("start_box") ? "start_coords" : "end_coords";
            const [x1, y1, x2 = x1, y2 = y1] = floatNumbers;
            const [widthFactor, heightFactor] = factors;
            actionInputs[boxKey] = [
              x1,
              y1,
              x2,
              y2
            ].every(lodash_isnumber$1) ? [
              Math.round((x1 + x2) / 2 * (null == screenContext ? void 0 : screenContext.width) * widthFactor) / widthFactor * (scaleFactor ?? 1),
              Math.round((y1 + y2) / 2 * (null == screenContext ? void 0 : screenContext.height) * heightFactor) / heightFactor * (scaleFactor ?? 1)
            ] : [];
          }
        } else actionInputs[paramName.trim()] = trimmedParam;
      }
    }
    actions.push({
      reflection,
      thought: thought || "",
      action_type: actionType,
      action_inputs: actionInputs
    });
  }
  return actions;
}
function parseAction(actionStr) {
  try {
    actionStr = actionStr.replace(/<\|box_start\|>|<\|box_end\|>/g, "");
    actionStr = actionStr.replace(new RegExp("(?<!start_|end_)point=", "g"), "start_box=").replace(/start_point=/g, "start_box=").replace(/end_point=/g, "end_box=");
    const functionPattern = /^(\w+)\((.*)\)$/;
    const match2 = actionStr.trim().match(functionPattern);
    if (!match2) throw new Error("Not a function call");
    const [_, functionName, argsStr] = match2;
    const kwargs = {};
    if (argsStr.trim()) {
      const argPairs = argsStr.match(/([^,']|'[^']*')+/g) || [];
      for (const pair of argPairs) {
        const [key, ...valueParts] = pair.split("=");
        if (!key) continue;
        let value = valueParts.join("=").trim().replace(/^['"]|['"]$/g, "");
        if (value.includes("<bbox>")) {
          value = value.replace(/<bbox>|<\/bbox>/g, "").replace(/\s+/g, ",");
          value = `(${value})`;
        }
        if (value.includes("<point>")) {
          value = value.replace(/<point>|<\/point>/g, "").replace(/\s+/g, ",");
          value = `(${value})`;
        }
        kwargs[key.trim()] = value;
      }
    }
    return {
      function: functionName,
      args: kwargs
    };
  } catch (e) {
    console.error(`Failed to parse action '${actionStr}': ${e}`);
    return null;
  }
}
function getUiTarsPlanningPrompt() {
  const preferredLanguage = getPreferredLanguage();
  return `
You are a GUI agent. You are given a task and your action history, with screenshots. You need to perform the next action to complete the task. 

## Output Format
\`\`\`
Thought: ...
Action: ...
\`\`\`

## Action Space

click(start_box='[x1, y1, x2, y2]')
left_double(start_box='[x1, y1, x2, y2]')
right_single(start_box='[x1, y1, x2, y2]')
drag(start_box='[x1, y1, x2, y2]', end_box='[x3, y3, x4, y4]')
hotkey(key='')
type(content='xxx') # Use escape characters \\', \\", and \\n in content part to ensure we can parse the content in normal python string format. If you want to submit your input, use \\n at the end of content. 
scroll(start_box='[x1, y1, x2, y2]', direction='down or up or right or left')
wait() #Sleep for 5s and take a screenshot to check for any changes.
finished(content='xxx') # Use escape characters \\', \\", and \\n in content part to ensure we can parse the content in normal python string format.


## Note
- Use ${preferredLanguage} in \`Thought\` part.
- Write a small plan and finally summarize your next action (with its target element) in one sentence in \`Thought\` part.

## User Instruction
`;
}
const getSummary = (prediction) => prediction.replace(/Reflection:[\s\S]*?(?=Action_Summary:|Action:|$)/g, "").trim();
const debug$n = getDebug("ui-tars-planning");
const bboxSize = 10;
const pointToBbox = (point, width, height) => {
  return [
    Math.round(Math.max(point.x - bboxSize / 2, 0)),
    Math.round(Math.max(point.y - bboxSize / 2, 0)),
    Math.round(Math.min(point.x + bboxSize / 2, width)),
    Math.round(Math.min(point.y + bboxSize / 2, height))
  ];
};
async function uiTarsPlanning(userInstruction, options2) {
  const { conversationHistory, context: context2, modelConfig, actionContext } = options2;
  const { uiTarsModelVersion } = modelConfig;
  let instruction = userInstruction;
  if (actionContext) {
    instruction = `<high_priority_knowledge>${actionContext}</high_priority_knowledge>
<user_instruction>${userInstruction}</user_instruction>`;
  }
  const systemPrompt = getUiTarsPlanningPrompt() + instruction;
  const screenshotBase64 = context2.screenshot.base64;
  conversationHistory.append({
    role: "user",
    content: [
      {
        type: "image_url",
        image_url: {
          url: screenshotBase64
        }
      }
    ]
  });
  const res2 = await callAIWithStringResponse(
    [
      {
        role: "user",
        content: systemPrompt
      },
      ...conversationHistory.snapshot()
    ],
    modelConfig
  );
  let convertedText;
  let parsed;
  try {
    convertedText = convertBboxToCoordinates(res2.content);
    const { size: size2 } = context2;
    const parseResult = actionParser({
      prediction: convertedText,
      factor: [1e3, 1e3],
      screenContext: {
        width: size2.width,
        height: size2.height
      },
      modelVer: uiTarsModelVersion
    });
    parsed = parseResult.parsed;
  } catch (parseError) {
    const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
    throw new AIResponseParseError(
      `Parse error: ${errorMessage}`,
      JSON.stringify(res2.content, void 0, 2),
      res2.usage
    );
  }
  const { size } = context2;
  debug$n(
    "ui-tars modelVer",
    uiTarsModelVersion,
    ", parsed",
    JSON.stringify(parsed)
  );
  const transformActions = [];
  const unhandledActions = [];
  let shouldContinue = true;
  parsed.forEach((action) => {
    const actionType = (action.action_type || "").toLowerCase();
    if (actionType === "click") {
      assert(action.action_inputs.start_box, "start_box is required");
      const point = getPoint(action.action_inputs.start_box, size);
      const locate = {
        prompt: action.thought || "",
        bbox: pointToBbox(
          { x: point[0], y: point[1] },
          size.width,
          size.height
        )
      };
      transformActions.push({
        type: "Tap",
        param: {
          locate
        }
      });
    } else if (actionType === "left_double") {
      assert(action.action_inputs.start_box, "start_box is required");
      const point = getPoint(action.action_inputs.start_box, size);
      const locate = {
        prompt: action.thought || "",
        bbox: pointToBbox(
          { x: point[0], y: point[1] },
          size.width,
          size.height
        )
      };
      transformActions.push({
        type: "DoubleClick",
        param: {
          locate
        },
        thought: action.thought || ""
      });
    } else if (actionType === "right_single") {
      assert(action.action_inputs.start_box, "start_box is required");
      const point = getPoint(action.action_inputs.start_box, size);
      const locate = {
        prompt: action.thought || "",
        bbox: pointToBbox(
          { x: point[0], y: point[1] },
          size.width,
          size.height
        )
      };
      transformActions.push({
        type: "RightClick",
        param: {
          locate
        },
        thought: action.thought || ""
      });
    } else if (actionType === "drag") {
      assert(action.action_inputs.start_box, "start_box is required");
      assert(action.action_inputs.end_box, "end_box is required");
      const startPoint = getPoint(action.action_inputs.start_box, size);
      const endPoint = getPoint(action.action_inputs.end_box, size);
      transformActions.push({
        type: "DragAndDrop",
        param: {
          from: {
            prompt: action.thought || "",
            bbox: pointToBbox(
              { x: startPoint[0], y: startPoint[1] },
              size.width,
              size.height
            )
          },
          to: {
            prompt: action.thought || "",
            bbox: pointToBbox(
              { x: endPoint[0], y: endPoint[1] },
              size.width,
              size.height
            )
          }
        },
        thought: action.thought || ""
      });
    } else if (actionType === "type") {
      transformActions.push({
        type: "Input",
        param: {
          value: action.action_inputs.content
        },
        thought: action.thought || ""
      });
    } else if (actionType === "scroll") {
      transformActions.push({
        type: "Scroll",
        param: {
          direction: action.action_inputs.direction
        },
        thought: action.thought || ""
      });
    } else if (actionType === "finished") {
      shouldContinue = false;
      transformActions.push({
        type: "Finished",
        param: {},
        thought: action.thought || ""
      });
    } else if (actionType === "hotkey") {
      if (!action.action_inputs.key) {
        console.warn(
          "No key found in action: hotkey. Will not perform action."
        );
      } else {
        const keys = transformHotkeyInput(action.action_inputs.key);
        transformActions.push({
          type: "KeyboardPress",
          param: {
            keyName: keys.join("+")
          },
          thought: action.thought || ""
        });
      }
    } else if (actionType === "wait") {
      transformActions.push({
        type: "Sleep",
        param: {
          timeMs: 1e3
        },
        thought: action.thought || ""
      });
    } else if (actionType) {
      unhandledActions.push({
        type: actionType,
        thought: action.thought || ""
      });
      debug$n("Unhandled action type:", actionType, "thought:", action.thought);
    }
  });
  if (transformActions.length === 0) {
    const errorDetails = [];
    if (parsed.length === 0) {
      errorDetails.push("Action parser returned no actions");
      if (res2.content.includes("Thought:") && !res2.content.includes("Action:")) {
        errorDetails.push(
          'Response contains "Thought:" but missing "Action:" line'
        );
      } else {
        errorDetails.push("Response may be malformed or empty");
      }
    }
    if (unhandledActions.length > 0) {
      const types2 = unhandledActions.map((a) => a.type).join(", ");
      errorDetails.push(`Unhandled action types: ${types2}`);
    }
    const errorMessage = [
      "No actions found in UI-TARS response.",
      ...errorDetails
    ].join("\n");
    throw new AIResponseParseError(
      errorMessage,
      JSON.stringify(res2.content, void 0, 2),
      res2.usage
    );
  }
  debug$n("transformActions", JSON.stringify(transformActions, null, 2));
  const log2 = getSummary(res2.content);
  conversationHistory.append({
    role: "assistant",
    content: log2
  });
  return {
    actions: transformActions,
    log: log2,
    usage: res2.usage,
    rawResponse: JSON.stringify(res2.content, void 0, 2),
    shouldContinuePlanning: shouldContinue
  };
}
function convertBboxToCoordinates(text) {
  const pattern = /<bbox>(\d+)\s+(\d+)\s+(\d+)\s+(\d+)<\/bbox>/g;
  function replaceMatch(match2, x1, y1, x2, y2) {
    const x1Num = Number.parseInt(x1, 10);
    const y1Num = Number.parseInt(y1, 10);
    const x2Num = Number.parseInt(x2, 10);
    const y2Num = Number.parseInt(y2, 10);
    const x = Math.floor((x1Num + x2Num) / 2);
    const y3 = Math.floor((y1Num + y2Num) / 2);
    return `(${x},${y3})`;
  }
  const cleanedText = text.replace(/\[EOS\]/g, "");
  return cleanedText.replace(pattern, replaceMatch).trim();
}
function getPoint(startBox, size) {
  const [x, y2] = JSON.parse(startBox);
  return [x * size.width, y2 * size.height];
}
class ConversationHistory {
  constructor(options2) {
    __publicField(this, "messages", []);
    __publicField(this, "subGoals", []);
    __publicField(this, "memories", []);
    __publicField(this, "pendingFeedbackMessage");
    var _a3;
    if ((_a3 = options2 == null ? void 0 : options2.initialMessages) == null ? void 0 : _a3.length) {
      this.seed(options2.initialMessages);
    }
    this.pendingFeedbackMessage = "";
  }
  resetPendingFeedbackMessageIfExists() {
    if (this.pendingFeedbackMessage) {
      this.pendingFeedbackMessage = "";
    }
  }
  append(message) {
    this.messages.push(message);
  }
  seed(messages) {
    this.reset();
    messages.forEach((message) => {
      this.append(message);
    });
  }
  reset() {
    this.messages.length = 0;
  }
  /**
   * Snapshot the conversation history, and replace the images with text if the number of images exceeds the limit.
   * @param maxImages - The maximum number of images to include in the snapshot. Undefined means no limit.
   * @returns The snapshot of the conversation history.
   */
  snapshot(maxImages) {
    if (maxImages === void 0) {
      return [...this.messages];
    }
    const clonedMessages = structuredClone(this.messages);
    let imageCount = 0;
    for (let i = clonedMessages.length - 1; i >= 0; i--) {
      const message = clonedMessages[i];
      const content = message.content;
      if (Array.isArray(content)) {
        for (let j = 0; j < content.length; j++) {
          const item = content[j];
          if (item.type === "image_url") {
            imageCount++;
            if (imageCount > maxImages) {
              content[j] = {
                type: "text",
                text: "(image ignored due to size optimization)"
              };
            }
          }
        }
      }
    }
    return clonedMessages;
  }
  get length() {
    return this.messages.length;
  }
  [Symbol.iterator]() {
    return this.messages[Symbol.iterator]();
  }
  toJSON() {
    return this.snapshot();
  }
  // Sub-goal management methods
  /**
   * Set all sub-goals, replacing any existing ones.
   * Automatically marks the first pending goal as running.
   */
  setSubGoals(subGoals) {
    this.subGoals = subGoals.map((goal) => ({ ...goal }));
    this.markFirstPendingAsRunning();
  }
  /**
   * Update a single sub-goal by index
   * @returns true if the sub-goal was found and updated, false otherwise
   */
  updateSubGoal(index2, updates) {
    const goal = this.subGoals.find((g) => g.index === index2);
    if (!goal) {
      return false;
    }
    if (updates.status !== void 0) {
      goal.status = updates.status;
    }
    if (updates.description !== void 0) {
      goal.description = updates.description;
    }
    return true;
  }
  /**
   * Mark the first pending sub-goal as running
   */
  markFirstPendingAsRunning() {
    const firstPending = this.subGoals.find((g) => g.status === "pending");
    if (firstPending) {
      firstPending.status = "running";
    }
  }
  /**
   * Mark a sub-goal as finished.
   * Automatically marks the next pending goal as running.
   * @returns true if the sub-goal was found and updated, false otherwise
   */
  markSubGoalFinished(index2) {
    const result = this.updateSubGoal(index2, { status: "finished" });
    if (result) {
      this.markFirstPendingAsRunning();
    }
    return result;
  }
  /**
   * Mark all sub-goals as finished
   */
  markAllSubGoalsFinished() {
    for (const goal of this.subGoals) {
      goal.status = "finished";
    }
  }
  /**
   * Convert sub-goals to text representation
   */
  subGoalsToText() {
    if (this.subGoals.length === 0) {
      return "";
    }
    const lines = this.subGoals.map((goal) => {
      return `${goal.index}. ${goal.description} (${goal.status})`;
    });
    const currentGoal = this.subGoals.find((goal) => goal.status === "running") || this.subGoals.find((goal) => goal.status === "pending");
    const currentGoalText = currentGoal ? `
Current sub-goal is: ${currentGoal.description}` : "";
    return `Sub-goals:
${lines.join("\n")}${currentGoalText}`;
  }
  // Memory management methods
  /**
   * Append a memory to the memories list
   */
  appendMemory(memory) {
    if (memory) {
      this.memories.push(memory);
    }
  }
  /**
   * Get all memories
   */
  getMemories() {
    return [...this.memories];
  }
  /**
   * Convert memories to text representation
   */
  memoriesToText() {
    if (this.memories.length === 0) {
      return "";
    }
    return `Memories from previous steps:
---
${this.memories.join("\n---\n")}
`;
  }
  /**
   * Clear all memories
   */
  clearMemories() {
    this.memories.length = 0;
  }
  /**
   * Compress the conversation history if it exceeds the threshold.
   * Removes the oldest messages and replaces them with a single placeholder message.
   * @param threshold - The number of messages that triggers compression.
   * @param keepCount - The number of recent messages to keep after compression.
   * @returns true if compression was performed, false otherwise.
   */
  compressHistory(threshold, keepCount) {
    if (this.messages.length <= threshold) {
      return false;
    }
    const omittedCount = this.messages.length - keepCount;
    const omittedPlaceholder = {
      role: "user",
      content: `(${omittedCount} previous conversation messages have been omitted)`
    };
    const recentMessages = this.messages.slice(-keepCount);
    this.messages.length = 0;
    this.messages.push(omittedPlaceholder);
    for (const msg of recentMessages) {
      this.messages.push(msg);
    }
    return true;
  }
}
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend$1(target, source) {
  var index2, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key = sourceKeys[index2];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string2, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string2;
  }
  return result;
}
function isNegativeZero(number2) {
  return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend$1;
var common$1 = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer2, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer2.slice(lineStart, lineEnd).replace(/\t/g, "") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string2, max2) {
  return common$1.repeat(" ", max2 - string2.length) + string2;
}
function makeSnippet(mark, options2) {
  options2 = Object.create(options2 || null);
  if (!mark.buffer) return null;
  if (!options2.maxLength) options2.maxLength = 79;
  if (typeof options2.indent !== "number") options2.indent = 1;
  if (typeof options2.linesBefore !== "number") options2.linesBefore = 3;
  if (typeof options2.linesAfter !== "number") options2.linesAfter = 2;
  var re2 = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match2;
  var foundLineNo = -1;
  while (match2 = re2.exec(mark.buffer)) {
    lineEnds.push(match2.index);
    lineStarts.push(match2.index + match2[0].length);
    if (mark.position <= match2.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
  for (i = 1; i <= options2.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common$1.repeat(" ", options2.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common$1.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common$1.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options2.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common$1.repeat(" ", options2.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options2) {
  options2 = options2 || {};
  Object.keys(options2).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options2;
  this.tag = tag;
  this.kind = options2["kind"] || null;
  this.resolve = options2["resolve"] || function() {
    return true;
  };
  this.construct = options2["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options2["instanceOf"] || null;
  this.predicate = options2["predicate"] || null;
  this.represent = options2["represent"] || null;
  this.representName = options2["representName"] || null;
  this.defaultStyle = options2["defaultStyle"] || null;
  this.multi = options2["multi"] || false;
  this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type$1 = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index2, length;
  function collectType(type3) {
    if (type3.multi) {
      result.multi[type3.kind].push(type3);
      result.multi["fallback"].push(type3);
    } else {
      result[type3.kind][type3.tag] = result["fallback"][type3.tag] = type3;
    }
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type$1) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1$1) {
    if (!(type$1$1 instanceof type$1)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1$1.loadKind && type$1$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1$1) {
    if (!(type$1$1 instanceof type$1)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type$1("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type$1("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map$1 = new type$1("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map$1
  ]
});
function resolveYamlNull(data) {
  if (data === null) return true;
  var max2 = data.length;
  return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type$1("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max2 = data.length;
  return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type$1("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max2 = data.length, index2 = 0, hasDigits = false, ch;
  if (!max2) return false;
  ch = data[index2];
  if (ch === "-" || ch === "+") {
    ch = data[++index2];
  }
  if (ch === "0") {
    if (index2 + 1 === max2) return true;
    ch = data[++index2];
    if (ch === "b") {
      index2++;
      for (; index2 < max2; index2++) {
        ch = data[index2];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index2++;
      for (; index2 < max2; index2++) {
        ch = data[index2];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index2))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index2++;
      for (; index2 < max2; index2++) {
        ch = data[index2];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index2))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index2 < max2; index2++) {
    ch = data[index2];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign2 = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign2 = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign2 * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign2 * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign2 * parseInt(value.slice(2), 8);
  }
  return sign2 * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common$1.isNegativeZero(object));
}
var int = new type$1("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign2;
  value = data.replace(/_/g, "").toLowerCase();
  sign2 = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign2 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res2;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common$1.isNegativeZero(object)) {
    return "-0.0";
  }
  res2 = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res2) ? res2.replace("e", ".e") : res2;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$1.isNegativeZero(object));
}
var float = new type$1("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match2 = YAML_DATE_REGEXP.exec(data);
  if (match2 === null) match2 = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match2 === null) throw new Error("Date resolve error");
  year = +match2[1];
  month = +match2[2] - 1;
  day = +match2[3];
  if (!match2[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match2[4];
  minute = +match2[5];
  second = +match2[6];
  if (match2[7]) {
    fraction = match2[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match2[9]) {
    tz_hour = +match2[10];
    tz_minute = +(match2[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match2[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type$1("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge$2 = new type$1("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max2 = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max2; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max2 % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max2 % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary$1 = new type$1("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type$1("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index2, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index2, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    keys = Object.keys(pair);
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type$1("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type$1("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge$2
  ],
  explicit: [
    binary$1,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? "" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i$1 = 0; i$1 < 256; i$1++) {
  simpleEscapeCheck[i$1] = simpleEscapeSequence(i$1) ? 1 : 0;
  simpleEscapeMap[i$1] = simpleEscapeSequence(i$1);
}
function State$1(input, options2) {
  this.input = input;
  this.filename = options2["filename"] || null;
  this.schema = options2["schema"] || _default;
  this.onWarning = options2["onWarning"] || null;
  this.legacy = options2["legacy"] || false;
  this.json = options2["json"] || false;
  this.listener = options2["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match2, major2, minor2;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match2 === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major2 = parseInt(match2[1], 10);
    minor2 = parseInt(match2[2], 10);
    if (major2 !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor2 < 2;
    if (minor2 !== 1 && minor2 !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle3, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle3 = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle3)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle3)) {
      throwError(state, 'there is a previously declared suffix for "' + handle3 + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle3] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position2, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position2 = 0, _length = _result.length; _position2 < _length; _position2 += 1) {
        _character = _result.charCodeAt(_position2);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index2, quantity;
  if (!common$1.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position2 = state.position, ch;
  ch = state.input.charCodeAt(_position2);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position2 + 1) && ch === state.input.charCodeAt(_position2 + 2)) {
    _position2 += 3;
    ch = state.input.charCodeAt(_position2);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common$1.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common$1.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common$1.repeat("\n", emptyLines);
      }
    } else {
      state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position2, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position2 = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position2, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position2 - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position2 = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position2, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position2, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position2 = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position2) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position2, state.position);
  return true;
}
function readAlias(state) {
  var _position2, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position2 = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position2) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position2, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type3, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type3 = state.implicitTypes[typeIndex];
      if (type3.resolve(state.result)) {
        state.result = type3.construct(state.result);
        state.tag = type3.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type3 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type3 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type3 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type3) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type3.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type3.kind + '", not "' + state.kind + '"');
    }
    if (!type3.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type3.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position2, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position2 = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position2, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position2 = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position2, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options2) {
  input = String(input);
  options2 = options2 || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options2);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator2, options2) {
  if (iterator2 !== null && typeof iterator2 === "object" && typeof options2 === "undefined") {
    options2 = iterator2;
    iterator2 = null;
  }
  var documents = loadDocuments(input, options2);
  if (typeof iterator2 !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator2(documents[index2]);
  }
}
function load$1(input, options2) {
  var documents = loadDocuments(input, options2);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index2, length, tag, style, type3;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
    tag = keys[index2];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type3 = schema2.compiledTypeMap["fallback"][tag];
    if (type3 && _hasOwnProperty.call(type3.styleAliases, style)) {
      style = type3.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string2, handle3, length;
  string2 = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle3 = "x";
    length = 2;
  } else if (character <= 65535) {
    handle3 = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle3 = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle3 + common$1.repeat("0", length - string2.length) + string2;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options2) {
  this.schema = options2["schema"] || _default;
  this.indent = Math.max(1, options2["indent"] || 2);
  this.noArrayIndent = options2["noArrayIndent"] || false;
  this.skipInvalid = options2["skipInvalid"] || false;
  this.flowLevel = common$1.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
  this.sortKeys = options2["sortKeys"] || false;
  this.lineWidth = options2["lineWidth"] || 80;
  this.noRefs = options2["noRefs"] || false;
  this.noCompatMode = options2["noCompatMode"] || false;
  this.condenseFlow = options2["condenseFlow"] || false;
  this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options2["forceQuotes"] || false;
  this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string2, spaces) {
  var ind = common$1.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string2.length;
  while (position < length) {
    next = string2.indexOf("\n", position);
    if (next === -1) {
      line = string2.slice(position);
      position = length;
    } else {
      line = string2.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common$1.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index2, length, type3;
  for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
    type3 = state.implicitTypes[index2];
    if (type3.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string2, pos) {
  var first2 = string2.charCodeAt(pos), second;
  if (first2 >= 55296 && first2 <= 56319 && pos + 1 < string2.length) {
    second = string2.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first2 - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first2;
}
function needIndentIndicator(string2) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string2);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string2, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string2, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string2)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string2)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string2, level, iskey, inblock) {
  state.dump = function() {
    if (string2.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string3) {
      return testImplicitResolving(state, string3);
    }
    switch (chooseScalarStyle(
      string2,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string2;
      case STYLE_SINGLE:
        return "'" + string2.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string2) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string2, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
  var clip = string2[string2.length - 1] === "\n";
  var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string2) {
  return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
}
function foldString(string2, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string2.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string2.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string2.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
  var moreIndented;
  var match2;
  while (match2 = lineRe.exec(string2)) {
    var prefix = match2[1], line = match2[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match2;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match2 = breakRe.exec(line)) {
    next = match2.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string2) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string2, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string2[i];
      if (char >= 65536) result += string2[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    value = object[index2];
    if (state.replacer) {
      value = state.replacer.call(object, String(index2), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    value = object[index2];
    if (state.replacer) {
      value = state.replacer.call(object, String(index2), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index2, length, type3, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
    type3 = typeList[index2];
    if ((type3.instanceOf || type3.predicate) && (!type3.instanceOf || typeof object === "object" && object instanceof type3.instanceOf) && (!type3.predicate || type3.predicate(object))) {
      if (explicit) {
        if (type3.multi && type3.representName) {
          state.tag = type3.representName(object);
        } else {
          state.tag = type3.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type3.represent) {
        style = state.styleMap[type3.tag] || type3.defaultStyle;
        if (_toString.call(type3.represent) === "[object Function]") {
          _result = type3.represent(object, style);
        } else if (_hasOwnProperty.call(type3.represent, style)) {
          _result = type3.represent[style](object, style);
        } else {
          throw new exception("!<" + type3.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type3 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type3 === "[object Object]" || type3 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type3 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type3 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type3 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type3 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type3);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index2, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index2]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index2, length;
  if (object !== null && typeof object === "object") {
    index2 = objects.indexOf(object);
    if (index2 !== -1) {
      if (duplicatesIndexes.indexOf(index2) === -1) {
        duplicatesIndexes.push(index2);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          inspectNode(object[index2], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options2) {
  options2 = options2 || {};
  var state = new State(options2);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
var dump_1$1 = dump$1;
var dumper = {
  dump: dump_1$1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type$1;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump$2 = dumper.dump;
var YAMLException = exception;
var types = {
  binary: binary$1,
  float,
  map: map$1,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge: merge$2,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump: dump$2,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
};
const debugUtils = getDebug("yaml:utils");
function interpolateEnvVars(content) {
  const lines = content.split("\n");
  const processedLines = lines.map((line) => {
    const trimmedLine = line.trimStart();
    if (trimmedLine.startsWith("#")) {
      return line;
    }
    return line.replace(/\$\{([^}]+)\}/g, (_, envVar) => {
      const value = process.env[envVar.trim()];
      if (value === void 0) {
        throw new Error(
          `Environment variable "${envVar.trim()}" is not defined`
        );
      }
      return value;
    });
  });
  return processedLines.join("\n");
}
function parseYamlScript(content, filePath) {
  let processedContent = content;
  if (content.indexOf("android") !== -1 && content.match(/deviceId:\s*(\d+)/)) {
    let matchedDeviceId;
    processedContent = content.replace(
      /deviceId:\s*(\d+)/g,
      (match2, deviceId) => {
        matchedDeviceId = deviceId;
        return `deviceId: '${deviceId}'`;
      }
    );
    console.warn(
      `please use string-style deviceId in yaml script, for example: deviceId: "${matchedDeviceId}"`
    );
  }
  const interpolatedContent = interpolateEnvVars(processedContent);
  const obj = jsYaml.load(interpolatedContent, {
    schema: jsYaml.JSON_SCHEMA
  });
  const pathTip = `, failed to load ${filePath}`;
  assert(obj.tasks, `property "tasks" is required in yaml script ${pathTip}`);
  assert(
    Array.isArray(obj.tasks),
    `property "tasks" must be an array in yaml script, but got ${obj.tasks}`
  );
  return obj;
}
function buildDetailedLocateParam(locatePrompt, opt) {
  debugUtils("will call buildDetailedLocateParam", locatePrompt, opt);
  let prompt = locatePrompt || (opt == null ? void 0 : opt.prompt) || (opt == null ? void 0 : opt.locate);
  let deepThink = false;
  let cacheable = true;
  let xpath = void 0;
  if (typeof opt === "object" && opt !== null) {
    deepThink = opt.deepThink ?? false;
    cacheable = opt.cacheable ?? true;
    xpath = opt.xpath;
    if (locatePrompt && opt.prompt && locatePrompt !== opt.prompt) {
      console.warn(
        "conflict prompt for item",
        locatePrompt,
        opt,
        "maybe you put the prompt in the wrong place"
      );
    }
    prompt = prompt || opt.prompt;
  }
  if (!prompt) {
    debugUtils(
      "no prompt, will return undefined in buildDetailedLocateParam",
      opt
    );
    return void 0;
  }
  return {
    prompt,
    deepThink,
    cacheable,
    xpath
  };
}
function buildDetailedLocateParamAndRestParams(locatePrompt, opt, excludeKeys = []) {
  const locateParam = buildDetailedLocateParam(locatePrompt, opt);
  const restParams = {};
  if (typeof opt === "object" && opt !== null) {
    const allKeys = Object.keys(opt);
    const locateParamKeys = Object.keys(locateParam || {});
    for (const key of allKeys) {
      if (!locateParamKeys.includes(key) && !excludeKeys.includes(key) && key !== "locate") {
        restParams[key] = opt[key];
      }
    }
  }
  return {
    locateParam,
    restParams
  };
}
const formatErrorMessage = (e) => {
  const errorMessage = (e == null ? void 0 : e.message) || "";
  if (errorMessage.includes("of different extension")) {
    return "Conflicting extension detected. Please disable the suspicious plugins and refresh the page. Guide: https://midscenejs.com/quick-experience.html#faq";
  }
  if (errorMessage.includes("NOT_IMPLEMENTED_AS_DESIGNED")) {
    return "Further actions cannot be performed in the current environment";
  }
  return errorMessage || "Unknown error";
};
async function parseStructuredParams(action, params, options2 = {}) {
  if (!(action == null ? void 0 : action.paramSchema) || !("shape" in action.paramSchema)) {
    return [params.prompt || "", options2];
  }
  const schema2 = action.paramSchema;
  const keys = schema2 && "shape" in schema2 ? Object.keys(schema2.shape) : [];
  const { deviceOptions: _, ...optionsWithoutDeviceOptions } = options2;
  const paramObj = {
    ...optionsWithoutDeviceOptions,
    ...options2.deviceOptions || {}
  };
  keys.forEach((key) => {
    if (params[key] !== void 0 && params[key] !== null && params[key] !== "") {
      paramObj[key] = params[key];
    }
  });
  if (schema2) {
    const locatorFieldKeys = findAllLocatorField(schema2);
    locatorFieldKeys.forEach((locateKey) => {
      const locatePrompt = params[locateKey];
      if (locatePrompt && typeof locatePrompt === "string") {
        const detailedLocateParam = buildDetailedLocateParam(locatePrompt, {
          deepThink: options2.deepThink,
          cacheable: true
          // Default to true for playground
        });
        if (detailedLocateParam) {
          paramObj[locateKey] = detailedLocateParam;
        }
      }
    });
  }
  return [paramObj];
}
async function executeAction(activeAgent, actionType, actionSpace, value, options2) {
  var _a3;
  const action = actionSpace == null ? void 0 : actionSpace.find(
    (a) => a.interfaceAlias === actionType || a.name === actionType
  );
  if (action && typeof activeAgent.callActionInActionSpace === "function") {
    if (value.params) {
      const parsedParams = await parseStructuredParams(
        action,
        value.params,
        options2
      );
      return await activeAgent.callActionInActionSpace(
        action.name,
        parsedParams[0]
      );
    } else {
      const detailedLocateParam = value.prompt ? buildDetailedLocateParam(value.prompt, {
        deepThink: options2.deepThink,
        cacheable: true
      }) : void 0;
      const { deviceOptions: _, ...optionsWithoutDeviceOptions } = options2;
      const actionParams = {
        locate: detailedLocateParam,
        ...optionsWithoutDeviceOptions,
        ...options2.deviceOptions || {}
      };
      return await activeAgent.callActionInActionSpace(
        action.name,
        actionParams
      );
    }
  } else {
    const prompt = value.prompt;
    if (actionType === "aiAssert") {
      const { pass, thought } = await ((_a3 = activeAgent == null ? void 0 : activeAgent.aiAssert) == null ? void 0 : _a3.call(activeAgent, prompt || "", void 0, {
        keepRawResponse: true,
        ...options2
      })) || {};
      return { pass: pass || false, thought: thought || "" };
    }
    if (activeAgent && typeof activeAgent[actionType] === "function") {
      return await activeAgent[actionType](prompt, options2);
    }
    throw new Error(`Unknown action type: ${actionType}`);
  }
}
const escapeContent = escapeScriptTag;
const unescapeContent = antiEscapeScriptTag;
const STREAMING_CHUNK_SIZE = 64 * 1024;
function streamScanTags(filePath, openTag, closeTag, onMatch) {
  const fd = openSync(filePath, "r");
  const fileSize = statSync(filePath).size;
  const buffer2 = new Uint8Array(STREAMING_CHUNK_SIZE);
  const decoder = new TextDecoder("utf-8");
  let position = 0;
  let leftover = "";
  let capturing = false;
  let currentContent = "";
  try {
    while (position < fileSize) {
      const bytesRead = readSync(fd, buffer2, 0, STREAMING_CHUNK_SIZE, position);
      const chunk = leftover + decoder.decode(buffer2.subarray(0, bytesRead));
      position += bytesRead;
      let searchStart = 0;
      while (searchStart < chunk.length) {
        if (!capturing) {
          const startIdx = chunk.indexOf(openTag, searchStart);
          if (startIdx !== -1) {
            capturing = true;
            currentContent = chunk.slice(startIdx + openTag.length);
            const endIdx = currentContent.indexOf(closeTag);
            if (endIdx !== -1) {
              const shouldStop = onMatch(currentContent.slice(0, endIdx));
              if (shouldStop) return;
              capturing = false;
              currentContent = "";
              searchStart = startIdx + openTag.length + endIdx + closeTag.length;
            } else {
              leftover = currentContent.slice(-closeTag.length);
              currentContent = currentContent.slice(0, -closeTag.length);
              break;
            }
          } else {
            leftover = chunk.slice(-openTag.length);
            break;
          }
        } else {
          const endIdx = chunk.indexOf(closeTag, searchStart);
          if (endIdx !== -1) {
            currentContent += chunk.slice(searchStart, endIdx);
            const shouldStop = onMatch(currentContent);
            if (shouldStop) return;
            capturing = false;
            currentContent = "";
            searchStart = endIdx + closeTag.length;
          } else {
            currentContent += chunk.slice(searchStart, -closeTag.length);
            leftover = chunk.slice(-closeTag.length);
            break;
          }
        }
      }
    }
  } finally {
    closeSync(fd);
  }
}
function extractImageByIdSync(htmlPath, imageId) {
  const targetTag = `<script type="midscene-image" data-id="${imageId}">`;
  const closeTag = "<\/script>";
  let result = null;
  streamScanTags(htmlPath, targetTag, closeTag, (content) => {
    result = unescapeContent(content);
    return true;
  });
  return result;
}
function generateImageScriptTag(id, data) {
  return '<script type="midscene-image" data-id="' + id + '">' + escapeContent(data) + "<\/script>";
}
function generateDumpScriptTag(json3, attributes) {
  let attrString = "";
  return '<script type="midscene_web_dump"' + attrString + ">" + escapeContent(json3) + "<\/script>";
}
class ScreenshotItem {
  // inline mode: HTML file path
  constructor(id, base64) {
    __publicField(this, "_id");
    __publicField(this, "_base64");
    __publicField(this, "_persistedAs", null);
    __publicField(this, "_persistedPath", null);
    // directory mode: PNG file path
    __publicField(this, "_persistedHtmlPath", null);
    this._id = id;
    this._base64 = base64;
  }
  /** Create a new ScreenshotItem from base64 data */
  static create(base64) {
    return new ScreenshotItem(uuid(), base64);
  }
  get id() {
    return this._id;
  }
  get base64() {
    if (this._base64 !== null) {
      return this._base64;
    }
    if (this._persistedPath !== null) {
      const buffer2 = readFileSync(this._persistedPath);
      return `data:image/png;base64,${buffer2.toString("base64")}`;
    }
    if (this._persistedHtmlPath !== null) {
      const data = extractImageByIdSync(this._persistedHtmlPath, this._id);
      if (data) {
        return data;
      }
      throw new Error(
        `Screenshot ${this._id}: cannot recover from HTML (id not found in ${this._persistedHtmlPath})`
      );
    }
    throw new Error(
      `Screenshot ${this._id}: base64 data released without recovery path`
    );
  }
  /** Check if base64 data is still available in memory (not yet released) */
  hasBase64() {
    return this._base64 !== null;
  }
  /**
   * Mark as persisted to HTML (inline mode).
   * Releases base64 memory, but keeps HTML path for lazy loading recovery.
   */
  markPersistedInline(htmlPath) {
    this._persistedAs = { $screenshot: this._id };
    this._persistedHtmlPath = htmlPath;
    this._base64 = null;
  }
  /**
   * Mark as persisted to file (directory mode).
   * Releases base64 memory, but keeps file path for lazy loading recovery.
   */
  markPersistedToPath(relativePath, absolutePath) {
    this._persistedAs = { base64: relativePath };
    this._persistedPath = absolutePath;
    this._base64 = null;
  }
  /** Serialize for JSON - format depends on persistence state */
  toSerializable() {
    return this._persistedAs ?? { $screenshot: this._id };
  }
  /** Check if a value is a serialized ScreenshotItem reference (inline or directory mode) */
  static isSerialized(value) {
    if (typeof value !== "object" || value === null) return false;
    const record = value;
    if ("$screenshot" in record && typeof record.$screenshot === "string") {
      return true;
    }
    if ("base64" in record && typeof record.base64 === "string") {
      return true;
    }
    return false;
  }
  /**
   * Get base64 data without the data URI prefix.
   * Useful for writing raw binary data to files.
   */
  get rawBase64() {
    return this.base64.replace(/^data:image\/(png|jpeg|jpg);base64,/, "");
  }
}
const elementDescriberInstruction = () => {
  return `
Describe the element in the red rectangle for precise identification. Use ${getPreferredLanguage()}.

CRITICAL REQUIREMENTS:
1. UNIQUENESS: The description must uniquely identify this element on the current page
2. UNIVERSALITY: Use generic, reusable selectors that work across different contexts
3. PRECISION: Be specific enough to distinguish from similar elements

DESCRIPTION STRUCTURE:
1. Element type (button, input, link, div, etc.)
2. Primary identifier (in order of preference):
   - Unique text content: "with text 'Login'"
   - Unique attribute: "with aria-label 'Search'"
   - Unique class/ID: "with class 'primary-button'"
   - Unique position: "in header navigation"
3. Secondary identifiers (if needed for uniqueness):
   - Visual features: "blue background", "with icon"
   - Relative position: "below search bar", "in sidebar"
   - Parent context: "in login form", "in main menu"

GUIDELINES:
- Keep description under 25 words
- Prioritize semantic identifiers over visual ones
- Use consistent terminology across similar elements
- Avoid page-specific or temporary content
- Don't mention the red rectangle or selection box
- Focus on stable, reusable characteristics

EXAMPLES:
- "Login button with text 'Sign In'"
- "Search input with placeholder 'Enter keywords'"
- "Navigation link with text 'Home' in header"
- "Submit button in contact form"
- "Menu icon with aria-label 'Open menu'"

Return JSON:
{
  "description": "unique element identifier",
  "error"?: "error message if any"
}`;
};
function restoreImageReferences(data, imageMap) {
  if (typeof data === "string") {
    return data;
  }
  if (Array.isArray(data)) {
    return data.map((item) => restoreImageReferences(item, imageMap));
  }
  if (typeof data === "object" && data !== null) {
    if ("$screenshot" in data) {
      const id = data.$screenshot;
      if (typeof id === "string") {
        if (imageMap[id]) {
          return { base64: imageMap[id] };
        }
        if (id.startsWith("data:image/") || id.startsWith("./") || id.startsWith("/")) {
          return { base64: id };
        }
        return { base64: `./screenshots/${id}.png` };
      }
      console.warn("Invalid $screenshot value type:", typeof id);
      return { base64: "" };
    }
    const result = {};
    for (const [key, value] of Object.entries(data)) {
      result[key] = restoreImageReferences(value, imageMap);
    }
    return result;
  }
  return data;
}
class ServiceError extends Error {
  constructor(message, dump2) {
    super(message);
    __publicField(this, "dump");
    this.name = "ServiceError";
    this.dump = dump2;
  }
}
function replacerForDumpSerialization(_key, value) {
  var _a3, _b;
  if (value && ((_a3 = value.constructor) == null ? void 0 : _a3.name) === "Page") {
    return "[Page object]";
  }
  if (value && ((_b = value.constructor) == null ? void 0 : _b.name) === "Browser") {
    return "[Browser object]";
  }
  if (value && typeof value.toSerializable === "function") {
    return value.toSerializable();
  }
  return value;
}
function reviverForDumpDeserialization(key, value) {
  if (key !== "screenshot" || typeof value !== "object" || value === null) {
    return value;
  }
  if (ScreenshotItem.isSerialized(value)) {
    return value;
  }
  if ("base64" in value && typeof value.base64 === "string") {
    return value;
  }
  return value;
}
class ExecutionDump {
  constructor(data) {
    __publicField(this, "logTime");
    __publicField(this, "name");
    __publicField(this, "description");
    __publicField(this, "tasks");
    __publicField(this, "aiActContext");
    this.logTime = data.logTime;
    this.name = data.name;
    this.description = data.description;
    this.tasks = data.tasks;
    this.aiActContext = data.aiActContext;
  }
  /**
   * Serialize the ExecutionDump to a JSON string
   */
  serialize(indents) {
    return JSON.stringify(this.toJSON(), replacerForDumpSerialization, indents);
  }
  /**
   * Convert to a plain object for JSON serialization
   */
  toJSON() {
    return {
      logTime: this.logTime,
      name: this.name,
      description: this.description,
      tasks: this.tasks.map((task) => ({
        ...task,
        recorder: task.recorder || []
      })),
      aiActContext: this.aiActContext
    };
  }
  /**
   * Create an ExecutionDump instance from a serialized JSON string
   */
  static fromSerializedString(serialized) {
    const parsed = JSON.parse(
      serialized,
      reviverForDumpDeserialization
    );
    return new ExecutionDump(parsed);
  }
  /**
   * Create an ExecutionDump instance from a plain object
   */
  static fromJSON(data) {
    return new ExecutionDump(data);
  }
  /**
   * Collect all ScreenshotItem instances from tasks.
   * Scans through uiContext and recorder items to find screenshots.
   */
  collectScreenshots() {
    var _a3;
    const screenshots = [];
    for (const task of this.tasks) {
      if (((_a3 = task.uiContext) == null ? void 0 : _a3.screenshot) instanceof ScreenshotItem) {
        screenshots.push(task.uiContext.screenshot);
      }
      if (task.recorder) {
        for (const record of task.recorder) {
          if (record.screenshot instanceof ScreenshotItem) {
            screenshots.push(record.screenshot);
          }
        }
      }
    }
    return screenshots;
  }
}
class GroupedActionDump {
  constructor(data) {
    __publicField(this, "sdkVersion");
    __publicField(this, "groupName");
    __publicField(this, "groupDescription");
    __publicField(this, "modelBriefs");
    __publicField(this, "executions");
    this.sdkVersion = data.sdkVersion;
    this.groupName = data.groupName;
    this.groupDescription = data.groupDescription;
    this.modelBriefs = data.modelBriefs;
    this.executions = data.executions.map(
      (exec) => exec instanceof ExecutionDump ? exec : ExecutionDump.fromJSON(exec)
    );
  }
  /**
   * Serialize the GroupedActionDump to a JSON string
   */
  serialize(indents) {
    return JSON.stringify(this.toJSON(), replacerForDumpSerialization, indents);
  }
  /**
   * Serialize the GroupedActionDump with inline screenshots to a JSON string.
   * Each ScreenshotItem is replaced with { base64: "..." }.
   */
  serializeWithInlineScreenshots(indents) {
    const processValue = (obj) => {
      if (obj instanceof ScreenshotItem) {
        return { base64: obj.base64 };
      }
      if (Array.isArray(obj)) {
        return obj.map(processValue);
      }
      if (obj && typeof obj === "object") {
        const entries = Object.entries(obj).map(([key, value]) => [
          key,
          processValue(value)
        ]);
        return Object.fromEntries(entries);
      }
      return obj;
    };
    const data = processValue(this.toJSON());
    return JSON.stringify(data, null, indents);
  }
  /**
   * Convert to a plain object for JSON serialization
   */
  toJSON() {
    return {
      sdkVersion: this.sdkVersion,
      groupName: this.groupName,
      groupDescription: this.groupDescription,
      modelBriefs: this.modelBriefs,
      executions: this.executions.map((exec) => exec.toJSON())
    };
  }
  /**
   * Create a GroupedActionDump instance from a serialized JSON string
   */
  static fromSerializedString(serialized) {
    const parsed = JSON.parse(
      serialized,
      reviverForDumpDeserialization
    );
    return new GroupedActionDump(parsed);
  }
  /**
   * Create a GroupedActionDump instance from a plain object
   */
  static fromJSON(data) {
    return new GroupedActionDump(data);
  }
  /**
   * Collect all ScreenshotItem instances from all executions.
   */
  collectAllScreenshots() {
    const screenshots = [];
    for (const execution of this.executions) {
      screenshots.push(...execution.collectScreenshots());
    }
    return screenshots;
  }
  /**
   * Serialize the dump to files with screenshots as separate PNG files.
   */
  serializeToFiles(basePath2) {
    const screenshotsDir = `${basePath2}.screenshots`;
    if (!existsSync(screenshotsDir)) {
      mkdirSync(screenshotsDir, { recursive: true });
    }
    const screenshotMap = {};
    const screenshots = this.collectAllScreenshots();
    for (const screenshot of screenshots) {
      if (screenshot.hasBase64()) {
        const imagePath = join$3(screenshotsDir, `${screenshot.id}.png`);
        const rawBase64 = screenshot.rawBase64;
        const bytes2 = Buffer.from(rawBase64, "base64");
        writeFileSync(imagePath, new Uint8Array(bytes2));
        screenshotMap[screenshot.id] = imagePath;
      }
    }
    writeFileSync(
      `${basePath2}.screenshots.json`,
      JSON.stringify(screenshotMap),
      "utf-8"
    );
    writeFileSync(basePath2, this.serialize(), "utf-8");
  }
  /**
   * Read dump from files and return JSON string with inline screenshots.
   * Reads the dump JSON and screenshot files, then inlines the base64 data.
   *
   * @param basePath - Base path for the dump file
   * @returns JSON string with inline screenshots ({ base64: "..." } format)
   */
  static fromFilesAsInlineJson(basePath2) {
    const dumpString = readFileSync(basePath2, "utf-8");
    const screenshotsMapPath = `${basePath2}.screenshots.json`;
    if (!existsSync(screenshotsMapPath)) {
      return dumpString;
    }
    const screenshotMap = JSON.parse(
      readFileSync(screenshotsMapPath, "utf-8")
    );
    const imageMap = {};
    for (const [id, filePath] of Object.entries(screenshotMap)) {
      if (existsSync(filePath)) {
        const data = readFileSync(filePath);
        imageMap[id] = `data:image/png;base64,${data.toString("base64")}`;
      }
    }
    const dumpData = JSON.parse(dumpString);
    const processedData = restoreImageReferences(dumpData, imageMap);
    return JSON.stringify(processedData);
  }
  /**
   * Clean up all files associated with a serialized dump.
   */
  static cleanupFiles(basePath2) {
    const filesToClean = [
      basePath2,
      `${basePath2}.screenshots.json`,
      `${basePath2}.screenshots`
    ];
    for (const filePath of filesToClean) {
      try {
        rmSync(filePath, { force: true, recursive: true });
      } catch {
      }
    }
  }
  /**
   * Get all file paths associated with a serialized dump.
   */
  static getFilePaths(basePath2) {
    return [
      basePath2,
      `${basePath2}.screenshots.json`,
      `${basePath2}.screenshots`
    ];
  }
}
function createServiceDump(data) {
  const baseData = {
    logTime: Date.now()
  };
  const finalData = {
    logId: uuid(),
    ...baseData,
    ...data
  };
  return finalData;
}
const debug$m = getDebug("ai:service");
let Service$1 = class Service {
  constructor(context2, opt) {
    __publicField(this, "contextRetrieverFn");
    __publicField(this, "aiVendorFn", callAIWithObjectResponse);
    __publicField(this, "taskInfo");
    assert(context2, "context is required for Service");
    if (typeof context2 === "function") {
      this.contextRetrieverFn = context2;
    } else {
      this.contextRetrieverFn = () => Promise.resolve(context2);
    }
    if (typeof (opt == null ? void 0 : opt.aiVendorFn) !== "undefined") {
      this.aiVendorFn = opt.aiVendorFn;
    }
    if (typeof (opt == null ? void 0 : opt.taskInfo) !== "undefined") {
      this.taskInfo = opt.taskInfo;
    }
  }
  async locate(query, opt, modelConfig) {
    var _a3;
    const queryPrompt = typeof query === "string" ? query : query.prompt;
    assert(queryPrompt, "query is required for locate");
    assert(typeof query === "object", "query should be an object for locate");
    const globalDeepThinkSwitch = globalConfigManager.getEnvConfigInBoolean(
      OMNI_FORCE_DEEP_THINK
    );
    if (globalDeepThinkSwitch) {
      debug$m("globalDeepThinkSwitch", globalDeepThinkSwitch);
    }
    let searchAreaPrompt;
    if (query.deepThink || globalDeepThinkSwitch) {
      searchAreaPrompt = query.prompt;
    }
    const { modelFamily } = modelConfig;
    if (searchAreaPrompt && !modelFamily) {
      console.warn(
        'The "deepThink" feature is not supported with multimodal LLM. Please config VL model for Omni. https://Omnijs.com/model-config'
      );
      searchAreaPrompt = void 0;
    }
    if (searchAreaPrompt && isAutoGLM(modelFamily)) {
      console.warn('The "deepThink" feature is not supported with AutoGLM.');
      searchAreaPrompt = void 0;
    }
    const context2 = (opt == null ? void 0 : opt.context) || await this.contextRetrieverFn();
    let searchArea = void 0;
    let searchAreaRawResponse = void 0;
    let searchAreaUsage = void 0;
    let searchAreaResponse = void 0;
    if (searchAreaPrompt) {
      searchAreaResponse = await AiLocateSection({
        context: context2,
        sectionDescription: searchAreaPrompt,
        modelConfig
      });
      assert(
        searchAreaResponse.rect,
        `cannot find search area for "${searchAreaPrompt}"${searchAreaResponse.error ? `: ${searchAreaResponse.error}` : ""}`
      );
      searchAreaRawResponse = searchAreaResponse.rawResponse;
      searchAreaUsage = searchAreaResponse.usage;
      searchArea = searchAreaResponse.rect;
    }
    const startTime = Date.now();
    const { parseResult, rect, rawResponse, usage, reasoning_content } = await AiLocateElement({
      callAIFn: this.aiVendorFn,
      context: context2,
      targetElementDescription: queryPrompt,
      searchConfig: searchAreaResponse,
      modelConfig
    });
    const timeCost = Date.now() - startTime;
    const taskInfo = {
      ...this.taskInfo ? this.taskInfo : {},
      durationMs: timeCost,
      rawResponse: JSON.stringify(rawResponse),
      formatResponse: JSON.stringify(parseResult),
      usage,
      searchArea,
      searchAreaRawResponse,
      searchAreaUsage,
      reasoning_content
    };
    let errorLog;
    if ((_a3 = parseResult.errors) == null ? void 0 : _a3.length) {
      errorLog = `failed to locate element: 
${parseResult.errors.join("\n")}`;
    }
    const dumpData = {
      type: "locate",
      userQuery: {
        element: queryPrompt
      },
      matchedElement: [],
      matchedRect: rect,
      data: null,
      taskInfo,
      deepThink: !!searchArea,
      error: errorLog
    };
    const elements = parseResult.elements || [];
    const dump2 = createServiceDump({
      ...dumpData,
      matchedElement: elements
    });
    if (errorLog) {
      throw new ServiceError(errorLog, dump2);
    }
    if (elements.length > 1) {
      throw new ServiceError(
        `locate: multiple elements found, length = ${elements.length}`,
        dump2
      );
    }
    if (elements.length === 1) {
      return {
        element: {
          center: elements[0].center,
          rect: elements[0].rect,
          description: elements[0].description
        },
        rect,
        dump: dump2
      };
    }
    return {
      element: null,
      rect,
      dump: dump2
    };
  }
  async extract(dataDemand, modelConfig, opt, pageDescription, multimodalPrompt, context2) {
    var _a3;
    assert(context2, "context is required for extract");
    assert(
      typeof dataDemand === "object" || typeof dataDemand === "string",
      `dataDemand should be object or string, but get ${typeof dataDemand}`
    );
    const startTime = Date.now();
    let parseResult;
    let rawResponse;
    let usage;
    let reasoning_content;
    try {
      const result = await AiExtractElementInfo({
        context: context2,
        dataQuery: dataDemand,
        multimodalPrompt,
        extractOption: opt,
        modelConfig,
        pageDescription
      });
      parseResult = result.parseResult;
      rawResponse = result.rawResponse;
      usage = result.usage;
      reasoning_content = result.reasoning_content;
    } catch (error2) {
      if (error2 instanceof AIResponseParseError) {
        const timeCost2 = Date.now() - startTime;
        const taskInfo2 = {
          ...this.taskInfo ? this.taskInfo : {},
          durationMs: timeCost2,
          rawResponse: error2.rawResponse,
          usage: error2.usage
        };
        const dump22 = createServiceDump({
          type: "extract",
          userQuery: { dataDemand },
          matchedElement: [],
          data: null,
          taskInfo: taskInfo2,
          error: error2.message
        });
        throw new ServiceError(error2.message, dump22);
      }
      throw error2;
    }
    const timeCost = Date.now() - startTime;
    const taskInfo = {
      ...this.taskInfo ? this.taskInfo : {},
      durationMs: timeCost,
      rawResponse,
      formatResponse: JSON.stringify(parseResult),
      usage,
      reasoning_content
    };
    let errorLog;
    if ((_a3 = parseResult.errors) == null ? void 0 : _a3.length) {
      errorLog = `AI response error: 
${parseResult.errors.join("\n")}`;
    }
    const dumpData = {
      type: "extract",
      userQuery: {
        dataDemand
      },
      matchedElement: [],
      data: null,
      taskInfo,
      error: errorLog
    };
    const { data, thought } = parseResult || {};
    const dump2 = createServiceDump({
      ...dumpData,
      data
    });
    if (errorLog && !data) {
      throw new ServiceError(errorLog, dump2);
    }
    return {
      data,
      thought,
      usage,
      reasoning_content,
      dump: dump2
    };
  }
  async describe(target, modelConfig, opt) {
    assert(target, "target is required for service.describe");
    const context2 = await this.contextRetrieverFn();
    const { size } = context2;
    const screenshotBase64 = context2.screenshot.base64;
    assert(screenshotBase64, "screenshot is required for service.describe");
    const { modelFamily } = modelConfig;
    const systemPrompt = elementDescriberInstruction();
    const defaultRectSize = 30;
    const targetRect = Array.isArray(target) ? {
      left: Math.floor(target[0] - defaultRectSize / 2),
      top: Math.floor(target[1] - defaultRectSize / 2),
      width: defaultRectSize,
      height: defaultRectSize
    } : target;
    let imagePayload = await compositeElementInfoImg({
      inputImgBase64: screenshotBase64,
      size,
      elementsPositionInfo: [
        {
          rect: targetRect
        }
      ],
      borderThickness: 3
    });
    if (opt == null ? void 0 : opt.deepThink) {
      const searchArea = expandSearchArea(targetRect, size, modelFamily);
      const widthRatio = searchArea.width / size.width;
      const heightRatio = searchArea.height / size.height;
      if (widthRatio >= 0.5 && heightRatio >= 0.5) {
        debug$m("describe: cropping to searchArea", searchArea);
        const croppedResult = await cropByRect(
          imagePayload,
          searchArea,
          modelFamily === "qwen2.5-vl"
        );
        imagePayload = croppedResult.imageBase64;
      } else {
        debug$m(
          "describe: skip cropping, search area too small (%dx%d on %dx%d)",
          searchArea.width,
          searchArea.height,
          size.width,
          size.height
        );
      }
    }
    const msgs = [
      { role: "system", content: systemPrompt },
      {
        role: "user",
        content: [
          {
            type: "image_url",
            image_url: {
              url: imagePayload,
              detail: "high"
            }
          }
        ]
      }
    ];
    const callAIFn = this.aiVendorFn;
    const res2 = await callAIFn(msgs, modelConfig);
    const { content } = res2;
    assert(!content.error, `describe failed: ${content.error}`);
    assert(content.description, "failed to describe the element");
    return content;
  }
};
const pkgCacheMap = {};
function getRunningPkgInfo(dir) {
  if (ifInBrowser || ifInWorker) {
    return null;
  }
  const dirToCheck = process.cwd();
  if (pkgCacheMap[dirToCheck]) {
    return pkgCacheMap[dirToCheck];
  }
  const pkgDir = findNearestPackageJson(dirToCheck);
  const pkgJsonFile = pkgDir ? join$3(pkgDir, "package.json") : null;
  if (pkgDir && pkgJsonFile) {
    const { name, version: version2 } = JSON.parse(readFileSync(pkgJsonFile, "utf-8"));
    pkgCacheMap[dirToCheck] = {
      name: name || "midscene-unknown-package-name",
      version: version2 || "0.0.0",
      dir: pkgDir
    };
    return pkgCacheMap[dirToCheck];
  }
  return {
    name: "midscene-unknown-package-name",
    version: "0.0.0",
    dir: dirToCheck
  };
}
function findNearestPackageJson(dir) {
  const packageJsonPath = join$3(dir, "package.json");
  if (existsSync(packageJsonPath)) {
    return dir;
  }
  const parentDir = dirname$1(dir);
  if (parentDir === dir) {
    return null;
  }
  return findNearestPackageJson(parentDir);
}
function processCacheConfig(cache, cacheId) {
  if (cache !== void 0) {
    if (cache === false) {
      return void 0;
    }
    if (cache === true) {
      return { id: cacheId };
    }
    if (typeof cache === "object" && cache !== null) {
      if (!cache.id) {
        return { ...cache, id: cacheId };
      }
      return cache;
    }
  }
  const envEnabled = globalConfigManager.getEnvConfigInBoolean(OMNI_CACHE);
  if (envEnabled && cacheId) {
    return { id: cacheId };
  }
  return void 0;
}
function getReportTpl() {
  if (typeof __DEV_REPORT_PATH__ === "string" && __DEV_REPORT_PATH__) {
    return fs$5.readFileSync(__DEV_REPORT_PATH__, "utf-8");
  }
  const reportTpl = "REPLACE_ME_WITH_REPORT_HTML";
  return reportTpl;
}
function reportHTMLContent(dumpData, reportPath, appendReport, withTpl = true) {
  let tpl = "";
  if (withTpl) {
    tpl = getReportTpl();
    if (!tpl) {
      console.warn("reportTpl is not set, will not write report");
      return "";
    }
  }
  let dumpContent = "";
  if (typeof dumpData === "string") {
    dumpContent = // biome-ignore lint/style/useTemplate: <explanation>
    '<script type="midscene_web_dump" type="application/json">\n' + escapeScriptTag(dumpData) + "\n<\/script>";
  } else {
    const { dumpString, attributes } = dumpData;
    const attributesArr = Object.keys(attributes || {}).map((key) => {
      return `${key}="${encodeURIComponent(attributes[key])}"`;
    });
    dumpContent = // do not use template string here, will cause bundle error
    // biome-ignore lint/style/useTemplate: <explanation>
    '<script type="midscene_web_dump" type="application/json" ' + attributesArr.join(" ") + ">\n" + escapeScriptTag(dumpString) + "\n<\/script>";
  }
  return tpl + dumpContent;
}
function getTmpDir() {
  try {
    const runningPkgInfo = getRunningPkgInfo();
    if (!runningPkgInfo) {
      return null;
    }
    const { name } = runningPkgInfo;
    const tmpPath = path$5.join(tmpdir(), name);
    mkdirSync(tmpPath, { recursive: true });
    return tmpPath;
  } catch (e) {
    return null;
  }
}
async function sleep(ms2) {
  return new Promise((resolve3) => setTimeout(resolve3, ms2));
}
function getVersion() {
  return "0.0.0";
}
function debugLog(...message) {
  const debugMode = process.env[OMNI_DEBUG_MODE];
  if (debugMode) {
    console.log("[Omni]", ...message);
  }
}
let gitInfoPromise = null;
function getGitInfoAsync() {
  if (gitInfoPromise) return gitInfoPromise;
  const execFileAsync = promisify$1(execFile);
  gitInfoPromise = Promise.all([
    execFileAsync("git", ["config", "--get", "remote.origin.url"]).then(
      ({ stdout }) => stdout.trim(),
      () => ""
    ),
    execFileAsync("git", ["config", "--get", "user.email"]).then(
      ({ stdout }) => stdout.trim(),
      () => ""
    )
  ]).then(([repoUrl, userEmail]) => ({ repoUrl, userEmail }));
  return gitInfoPromise;
}
let lastReportedRepoUrl = "";
async function uploadTestInfoToServer({
  testUrl,
  serverUrl
}) {
  if (!serverUrl) return;
  const { repoUrl, userEmail } = await getGitInfoAsync();
  if (repoUrl ? repoUrl !== lastReportedRepoUrl : !!testUrl) {
    debugLog("Uploading test info to server", {
      serverUrl,
      repoUrl,
      testUrl,
      userEmail
    });
    fetch(serverUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        repo_url: repoUrl,
        test_url: testUrl,
        user_email: userEmail
      })
    }).then((response2) => response2.json()).then((data) => {
      debugLog("Successfully uploaded test info to server:", data);
    }).catch(
      (error2) => debugLog("Failed to upload test info to server:", error2)
    );
    lastReportedRepoUrl = repoUrl;
  }
}
var dayjs_min = { exports: {} };
(function(module, exports$1) {
  !function(t2, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h2 = "year", d2 = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
      return "[" + t3 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m2 = function(t3, e2, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
    }, v = { s: m2, z: function(t3) {
      var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m2(r2, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t3(e2, n2) {
      if (e2.date() < n2.date()) return -t3(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s3 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s3 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s3 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c, y: h2, w: o, d: a, D: d2, h: u, m: s2, s: i, ms: r, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g = "en", D3 = {};
    D3[g] = M2;
    var p = "$isDayjsObject", S2 = function(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p]);
    }, w2 = function t3(e2, n2, r2) {
      var i2;
      if (!e2) return g;
      if ("string" == typeof e2) {
        var s3 = e2.toLowerCase();
        D3[s3] && (i2 = s3), n2 && (D3[s3] = n2, i2 = s3);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1) return t3(u2[0]);
      } else {
        var a2 = e2.name;
        D3[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function(t3, e2) {
      if (S2(t3)) return t3.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t3, n2.args = arguments, new _(n2);
    }, b = v;
    b.l = w2, b.i = S2, b.w = function(t3, e2) {
      return O(t3, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M3(t3) {
        this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
      }
      var m3 = M3.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e2 = t4.date, n2 = t4.utc;
          if (null === e2) return /* @__PURE__ */ new Date(NaN);
          if (b.u(e2)) return /* @__PURE__ */ new Date();
          if (e2 instanceof Date) return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
            }
          }
          return new Date(e2);
        }(t3), this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return b;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l);
      }, m3.isSame = function(t3, e2) {
        var n2 = O(t3);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m3.isAfter = function(t3, e2) {
        return O(t3) < this.startOf(e2);
      }, m3.isBefore = function(t3, e2) {
        return this.endOf(e2) < O(t3);
      }, m3.$g = function(t3, e2, n2) {
        return b.u(t3) ? this[e2] : this.set(n2, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e2) {
        var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t3), l2 = function(t4, e3) {
          var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t4) : new Date(n2.$y, e3, t4), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function(t4, e3) {
          return b.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h2:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M4) : l2(0, M4 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D4 = (y3 < g2 ? y3 + 7 : y3) - g2;
            return l2(r2 ? m4 - D4 : m4 + (6 - D4), M4);
          case a:
          case d2:
            return $2(v2 + "Hours", 0);
          case u:
            return $2(v2 + "Minutes", 1);
          case s2:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e2) {
        var n2, o2 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d2] = f2 + "Date", n2[c] = f2 + "Month", n2[h2] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s2] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c || o2 === h2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l2]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m3.set = function(t3, e2) {
        return this.clone().$set(t3, e2);
      }, m3.get = function(t3) {
        return this[b.p(t3)]();
      }, m3.add = function(r2, f2) {
        var d3, l2 = this;
        r2 = Number(r2);
        var $2 = b.p(f2), y3 = function(t3) {
          var e2 = O(l2);
          return b.w(e2.date(e2.date() + Math.round(t3 * r2)), l2);
        };
        if ($2 === c) return this.set(c, this.$M + r2);
        if ($2 === h2) return this.set(h2, this.$y + r2);
        if ($2 === a) return y3(1);
        if ($2 === o) return y3(7);
        var M4 = (d3 = {}, d3[s2] = e, d3[u] = n, d3[i] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r2 * M4;
        return b.w(m4, this);
      }, m3.subtract = function(t3, e2) {
        return this.add(-1 * t3, e2);
      }, m3.format = function(t3) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid()) return n2.invalidDate || l;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s3 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h3 = function(t4, n3, i3, s4) {
          return t4 && (t4[n3] || t4(e2, r2)) || i3[n3].slice(0, s4);
        }, d3 = function(t4) {
          return b.s(s3 % 12 || 12, t4, "0");
        }, $2 = f2 || function(t4, e3, n3) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y2, function(t4, r3) {
          return r3 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b.s(a2 + 1, 2, "0");
              case "MMM":
                return h3(n2.monthsShort, a2, c2, 3);
              case "MMMM":
                return h3(c2, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h3(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h3(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s3);
              case "HH":
                return b.s(s3, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $2(s3, u2, true);
              case "A":
                return $2(s3, u2, false);
              case "m":
                return String(u2);
              case "mm":
                return b.s(u2, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b.s(e2.$s, 2, "0");
              case "SSS":
                return b.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t4) || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r2, d3, l2) {
        var $2, y3 = this, M4 = b.p(d3), m4 = O(r2), v2 = (m4.utcOffset() - this.utcOffset()) * e, g2 = this - m4, D4 = function() {
          return b.m(y3, m4);
        };
        switch (M4) {
          case h2:
            $2 = D4() / 12;
            break;
          case c:
            $2 = D4();
            break;
          case f:
            $2 = D4() / 3;
            break;
          case o:
            $2 = (g2 - v2) / 6048e5;
            break;
          case a:
            $2 = (g2 - v2) / 864e5;
            break;
          case u:
            $2 = g2 / n;
            break;
          case s2:
            $2 = g2 / e;
            break;
          case i:
            $2 = g2 / t2;
            break;
          default:
            $2 = g2;
        }
        return l2 ? $2 : b.a($2);
      }, m3.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m3.$locale = function() {
        return D3[this.$L];
      }, m3.locale = function(t3, e2) {
        if (!t3) return this.$L;
        var n2 = this.clone(), r2 = w2(t3, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m3.clone = function() {
        return b.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u], ["$W", a], ["$M", c], ["$y", h2], ["$D", d2]].forEach(function(t3) {
      k[t3[1]] = function(e2) {
        return this.$g(e2, t3[0], t3[1]);
      };
    }), O.extend = function(t3, e2) {
      return t3.$i || (t3(e2, _, O), t3.$i = true), O;
    }, O.locale = w2, O.isDayjs = S2, O.unix = function(t3) {
      return O(1e3 * t3);
    }, O.en = D3[g], O.Ls = D3, O.p = {}, O;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var re$3 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$l = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1$7 = debug$l;
(function(module, exports$1) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants$1;
  const debug2 = debug_1$7;
  exports$1 = module.exports = {};
  const re2 = exports$1.re = [];
  const safeRe = exports$1.safeRe = [];
  const src2 = exports$1.src = [];
  const t2 = exports$1.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const safe = value.split("\\s*").join("\\s{0,1}").split("\\s+").join("\\s");
    const index2 = R++;
    debug2(name, index2, value);
    t2[name] = index2;
    src2[index2] = value;
    re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src2[t2.NUMERICIDENTIFIER]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t2.NUMERICIDENTIFIERLOOSE]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src2[t2.PRERELEASEIDENTIFIER]}(?:\\.${src2[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src2[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src2[t2.BUILDIDENTIFIER]}(?:\\.${src2[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src2[t2.MAINVERSION]}${src2[t2.PRERELEASE]}?${src2[t2.BUILD]}?`);
  createToken("FULL", `^${src2[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src2[t2.MAINVERSIONLOOSE]}${src2[t2.PRERELEASELOOSE]}?${src2[t2.BUILD]}?`);
  createToken("LOOSE", `^${src2[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src2[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src2[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:${src2[t2.PRERELEASE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:${src2[t2.PRERELEASELOOSE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src2[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src2[t2.LONETILDE]}\\s+`, true);
  exports$1.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src2[t2.LONECARET]}\\s+`, true);
  exports$1.caretTrimReplace = "$1^";
  createToken("CARET", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src2[t2.GTLT]}\\s*(${src2[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]}|${src2[t2.XRANGEPLAIN]})`, true);
  exports$1.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src2[t2.XRANGEPLAIN]})\\s+-\\s+(${src2[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$3, re$3.exports);
var reExports = re$3.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options2) => {
  if (!options2) {
    return emptyOpts;
  }
  if (typeof options2 !== "object") {
    return looseOption;
  }
  return options2;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$k = debug_1$7;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
const { safeRe: re$2, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version2, options2) {
    options2 = parseOptions(options2);
    if (version2 instanceof SemVer) {
      if (version2.loose === !!options2.loose && version2.includePrerelease === !!options2.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug$k("SemVer", version2, options2);
    this.options = options2;
    this.loose = !!options2.loose;
    this.includePrerelease = !!options2.includePrerelease;
    const m2 = version2.trim().match(options2.loose ? re$2[t$1.LOOSE] : re$2[t$1.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$k("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug$k("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug$k("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$2 = SemVer$d;
const SemVer$c = semver$2;
const parse$g = (version2, options2, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options2);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$g;
const parse$f = parse_1;
const valid$2 = (version2, options2) => {
  const v = parse$f(version2, options2);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$e = parse_1;
const clean$1 = (version2, options2) => {
  const s2 = parse$e(version2.trim().replace(/^[=v]+/, ""), options2);
  return s2 ? s2.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$2;
const inc$1 = (version2, release, options2, identifier, identifierBase) => {
  if (typeof options2 === "string") {
    identifierBase = identifier;
    identifier = options2;
    options2 = void 0;
  }
  try {
    return new SemVer$b(
      version2 instanceof SemVer$b ? version2.version : version2,
      options2
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$d = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$d(version1, null, true);
  const v2 = parse$d(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (highVersion.patch) {
      return "patch";
    }
    if (highVersion.minor) {
      return "minor";
    }
    return "major";
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$2;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$2;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$2;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;
const parse$c = parse_1;
const prerelease$1 = (version2, options2) => {
  const parsed = parse$c(version2, options2);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$2;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$2;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$2;
const parse$b = parse_1;
const { safeRe: re$1, t } = reExports;
const coerce$1 = (version2, options2) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options2 = options2 || {};
  let match2 = null;
  if (!options2.rtl) {
    match2 = version2.match(re$1[t.COERCE]);
  } else {
    let next;
    while ((next = re$1[t.COERCERTL].exec(version2)) && (!match2 || match2.index + match2[0].length !== version2.length)) {
      if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
        match2 = next;
      }
      re$1[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re$1[t.COERCERTL].lastIndex = -1;
  }
  if (match2 === null) {
    return null;
  }
  return parse$b(`${match2[2]}.${match2[3] || "0"}.${match2[4] || "0"}`, options2);
};
var coerce_1 = coerce$1;
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator) return iterator;
  hasRequiredIterator = 1;
  iterator = function(Yallist2) {
    Yallist2.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self2.push(arguments[i]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node2) {
  if (node2.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node2.next;
  var prev = node2.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node2 === this.head) {
    this.head = next;
  }
  if (node2 === this.tail) {
    this.tail = prev;
  }
  node2.list.length--;
  node2.next = null;
  node2.prev = null;
  node2.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node2) {
  if (node2 === this.head) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var head = this.head;
  node2.list = this;
  node2.next = head;
  if (head) {
    head.prev = node2;
  }
  this.head = node2;
  if (!this.tail) {
    this.tail = node2;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node2) {
  if (node2 === this.tail) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var tail = this.tail;
  node2.list = this;
  node2.prev = tail;
  if (tail) {
    tail.next = node2;
  }
  this.tail = node2;
  if (!this.head) {
    this.head = node2;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res2 = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res2;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res2 = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res2;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res2 = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res2.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res2;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res2 = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res2.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res2;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node2, value) {
  var inserted = node2 === self2.head ? new Node(value, null, node2, self2) : new Node(value, node2, node2.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  requireIterator()(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options2) {
    if (typeof options2 === "number")
      options2 = { max: options2 };
    if (!options2)
      options2 = {};
    if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options2.max || Infinity;
    const lc = options2.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options2.stale || false;
    if (options2.maxAge && typeof options2.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options2.maxAge || 0;
    this[DISPOSE] = options2.dispose;
    this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node2 = this[CACHE].get(key);
      const item = node2.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry$2(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key)) return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get$1(this, key, true);
  }
  peek(key) {
    return get$1(this, key, false);
  }
  pop() {
    const node2 = this[LRU_LIST].tail;
    if (!node2)
      return null;
    del(this, node2);
    return node2.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get$1(this, key, false));
  }
}
const get$1 = (self2, key, doUse) => {
  const node2 = self2[CACHE].get(key);
  if (node2) {
    const hit = node2.value;
    if (isStale(self2, hit)) {
      del(self2, node2);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node2.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node2);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node2) => {
  if (node2) {
    const hit = node2.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node2);
  }
};
let Entry$2 = class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
};
const forEachStep = (self2, fn, node2, thisp) => {
  let hit = node2.value;
  if (isStale(self2, hit)) {
    del(self2, node2);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
var range$1;
var hasRequiredRange$1;
function requireRange$1() {
  if (hasRequiredRange$1) return range$1;
  hasRequiredRange$1 = 1;
  class Range2 {
    constructor(range3, options2) {
      options2 = parseOptions2(options2);
      if (range3 instanceof Range2) {
        if (range3.loose === !!options2.loose && range3.includePrerelease === !!options2.includePrerelease) {
          return range3;
        } else {
          return new Range2(range3.raw, options2);
        }
      }
      if (range3 instanceof Comparator2) {
        this.raw = range3.value;
        this.set = [[range3]];
        this.format();
        return this;
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range3.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r)).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first2 = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first2];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range3) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range3;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range3 = range3.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range3);
      range3 = range3.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range3);
      range3 = range3.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      range3 = range3.replace(re2[t2.CARETTRIM], caretTrimReplace);
      let rangeList = range3.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range3, options2) {
      if (!(range3 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options2) && range3.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range$1 = Range2;
  const LRU = lruCache;
  const cache = new LRU({ max: 1e3 });
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1$7;
  const SemVer3 = semver$2;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options2) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options2);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options2) => {
    debug2("comp", comp, options2);
    comp = replaceCarets(comp, options2);
    debug2("caret", comp);
    comp = replaceTildes(comp, options2);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options2);
    debug2("xrange", comp);
    comp = replaceStars(comp, options2);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options2)).join(" ");
  };
  const replaceTilde = (comp, options2) => {
    const r = options2.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M2, m2, p, pr) => {
      debug2("tilde", comp, _, M2, m2, p, pr);
      let ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M2}.${m2}.${p} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options2)).join(" ");
  };
  const replaceCaret = (comp, options2) => {
    debug2("caret", comp, options2);
    const r = options2.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z2 = options2.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M2, m2, p, pr) => {
      debug2("caret", comp, _, M2, m2, p, pr);
      let ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M2}.0.0${z2} <${+M2 + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M2 === "0") {
          ret = `>=${M2}.${m2}.0${z2} <${M2}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m2}.0${z2} <${+M2 + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p}-${pr} <${+M2 + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p}${z2} <${M2}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p}${z2} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p} <${+M2 + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options2) => {
    debug2("replaceXRanges", comp, options2);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options2)).join(" ");
  };
  const replaceXRange = (comp, options2) => {
    comp = comp.trim();
    const r = options2.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M2, m2, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M2, m2, p, pr);
      const xM = isX(M2);
      const xm = xM || isX(m2);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options2.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M2}.${m2}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options2) => {
    debug2("replaceStars", comp, options2);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options2) => {
    debug2("replaceGTE0", comp, options2);
    return comp.trim().replace(re2[options2.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set2, version2, options2) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options2.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug2(set2[i].semver);
        if (set2[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range$1;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options2) {
      options2 = parseOptions2(options2);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m2 = comp.match(r);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options2) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options2).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options2).test(comp.semver);
      }
      options2 = parseOptions2(options2);
      if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1$7;
  const SemVer3 = semver$2;
  const Range2 = requireRange$1();
  return comparator;
}
const Range$9 = requireRange$1();
const satisfies$4 = (version2, range3, options2) => {
  try {
    range3 = new Range$9(range3, options2);
  } catch (er) {
    return false;
  }
  return range3.test(version2);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange$1();
const toComparators$1 = (range3, options2) => new Range$8(range3, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$2;
const Range$7 = requireRange$1();
const maxSatisfying$1 = (versions, range3, options2) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range3, options2);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max2 || maxSV.compare(v) === -1) {
        max2 = v;
        maxSV = new SemVer$4(max2, options2);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$2;
const Range$6 = requireRange$1();
const minSatisfying$1 = (versions, range3, options2) => {
  let min2 = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range3, options2);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min2 || minSV.compare(v) === 1) {
        min2 = v;
        minSV = new SemVer$3(min2, options2);
      }
    }
  });
  return min2;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$2;
const Range$5 = requireRange$1();
const gt$2 = gt_1;
const minVersion$1 = (range3, loose) => {
  range3 = new Range$5(range3, loose);
  let minver = new SemVer$2("0.0.0");
  if (range3.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range3.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range3.set.length; ++i) {
    const comparators = range3.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range3.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange$1();
const validRange$1 = (range3, options2) => {
  try {
    return new Range$4(range3, options2).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$2;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange$1();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version2, range3, hilo, options2) => {
  version2 = new SemVer$1(version2, options2);
  range3 = new Range$3(range3, options2);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range3, options2)) {
    return false;
  }
  for (let i = 0; i < range3.set.length; ++i) {
    const comparators = range3.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options2)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options2)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version2, range3, options2) => outside$2(version2, range3, ">", options2);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version2, range3, options2) => outside$1(version2, range3, "<", options2);
var ltr_1 = ltr$1;
const Range$2 = requireRange$1();
const intersects$1 = (r1, r2, options2) => {
  r1 = new Range$2(r1, options2);
  r2 = new Range$2(r2, options2);
  return r1.intersects(r2, options2);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range3, options2) => {
  const set2 = [];
  let first2 = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options2));
  for (const version2 of v) {
    const included = satisfies$2(version2, range3, options2);
    if (included) {
      prev = version2;
      if (!first2) {
        first2 = version2;
      }
    } else {
      if (prev) {
        set2.push([first2, prev]);
      }
      prev = null;
      first2 = null;
    }
  }
  if (first2) {
    set2.push([first2, null]);
  }
  const ranges = [];
  for (const [min2, max2] of set2) {
    if (min2 === max2) {
      ranges.push(min2);
    } else if (!max2 && min2 === v[0]) {
      ranges.push("*");
    } else if (!max2) {
      ranges.push(`>=${min2}`);
    } else if (min2 === v[0]) {
      ranges.push(`<=${max2}`);
    } else {
      ranges.push(`${min2} - ${max2}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range3.raw === "string" ? range3.raw : String(range3);
  return simplified.length < original.length ? simplified : range3;
};
const Range$1 = requireRange$1();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options2 = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options2);
  dom = new Range$1(dom, options2);
  let sawNonNull = false;
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options2);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER;
      }
    }
    if (sawNonNull) {
      return false;
    }
  }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options2) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options2.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options2.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options2);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options2);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options2);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options2)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options2)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options2)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options2.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options2.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options2);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options2)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options2);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options2)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options2) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options2);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options2) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options2);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants = constants$1;
const SemVer2 = semver$2;
const identifiers = identifiers$1;
const parse$a = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange$1();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver = {
  parse: parse$a,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
const semver$1 = /* @__PURE__ */ getDefaultExportFromCjs(semver);
const DEFAULT_CACHE_MAX_FILENAME_LENGTH = 200;
const debug$j = getDebug("cache");
const lowestSupportedOmniVersion = "0.16.10";
const cacheFileExt = ".cache.yaml";
class TaskCache {
  // Track matched records
  constructor(cacheId, isCacheResultUsed, cacheFilePath, options2 = {}) {
    __publicField(this, "cacheId");
    __publicField(this, "cacheFilePath");
    __publicField(this, "cache");
    __publicField(this, "isCacheResultUsed");
    // a flag to indicate if the cache result should be used
    __publicField(this, "cacheOriginalLength");
    __publicField(this, "readOnlyMode");
    // a flag to indicate if the cache is in read-only mode
    __publicField(this, "writeOnlyMode");
    // a flag to indicate if the cache is in write-only mode
    __publicField(this, "matchedCacheIndices", /* @__PURE__ */ new Set());
    assert$1(cacheId, "cacheId is required");
    let safeCacheId = replaceIllegalPathCharsAndSpace(cacheId);
    const cacheMaxFilenameLength = globalConfigManager.getEnvConfigValueAsNumber(
      OMNI_CACHE_MAX_FILENAME_LENGTH
    ) ?? DEFAULT_CACHE_MAX_FILENAME_LENGTH;
    if (Buffer.byteLength(safeCacheId, "utf8") > cacheMaxFilenameLength) {
      const prefix = safeCacheId.slice(0, 32);
      const hash2 = generateHashId(void 0, safeCacheId);
      safeCacheId = `${prefix}-${hash2}`;
    }
    this.cacheId = safeCacheId;
    this.cacheFilePath = ifInBrowser || ifInWorker ? void 0 : cacheFilePath || join$3(getRunSubDir("cache"), `${this.cacheId}${cacheFileExt}`);
    const readOnlyMode = Boolean(options2 == null ? void 0 : options2.readOnly);
    const writeOnlyMode = Boolean(options2 == null ? void 0 : options2.writeOnly);
    if (readOnlyMode && writeOnlyMode) {
      throw new Error("TaskCache cannot be both read-only and write-only");
    }
    this.isCacheResultUsed = writeOnlyMode ? false : isCacheResultUsed;
    this.readOnlyMode = readOnlyMode;
    this.writeOnlyMode = writeOnlyMode;
    let cacheContent;
    if (this.cacheFilePath && !this.writeOnlyMode) {
      cacheContent = this.loadCacheFromFile();
    }
    if (!cacheContent) {
      cacheContent = {
        OmniVersion: getCoreVersion(),
        cacheId: this.cacheId,
        caches: []
      };
    }
    this.cache = cacheContent;
    this.cacheOriginalLength = this.isCacheResultUsed ? this.cache.caches.length : 0;
  }
  matchCache(prompt, type3) {
    if (!this.isCacheResultUsed) {
      return void 0;
    }
    const promptStr = typeof prompt === "string" ? prompt : JSON.stringify(prompt);
    for (let i = 0; i < this.cacheOriginalLength; i++) {
      const item = this.cache.caches[i];
      const key = `${type3}:${promptStr}:${i}`;
      if (item.type === type3 && isDeepStrictEqual(item.prompt, prompt) && !this.matchedCacheIndices.has(key)) {
        if (item.type === "locate") {
          const locateItem = item;
          if (!locateItem.cache && Array.isArray(locateItem.xpaths)) {
            locateItem.cache = { xpaths: locateItem.xpaths };
          }
          if ("xpaths" in locateItem) {
            locateItem.xpaths = void 0;
          }
        }
        this.matchedCacheIndices.add(key);
        debug$j(
          "cache found and marked as used, type: %s, prompt: %s, index: %d",
          type3,
          prompt,
          i
        );
        return {
          cacheContent: item,
          updateFn: (cb) => {
            debug$j(
              "will call updateFn to update cache, type: %s, prompt: %s, index: %d",
              type3,
              prompt,
              i
            );
            cb(item);
            if (this.readOnlyMode) {
              debug$j(
                "read-only mode, cache updated in memory but not flushed to file"
              );
              return;
            }
            debug$j(
              "cache updated, will flush to file, type: %s, prompt: %s, index: %d",
              type3,
              prompt,
              i
            );
            this.flushCacheToFile();
          }
        };
      }
    }
    debug$j("no unused cache found, type: %s, prompt: %s", type3, prompt);
    return void 0;
  }
  matchPlanCache(prompt) {
    return this.matchCache(prompt, "plan");
  }
  matchLocateCache(prompt) {
    return this.matchCache(prompt, "locate");
  }
  appendCache(cache) {
    debug$j("will append cache", cache);
    this.cache.caches.push(cache);
    if (this.readOnlyMode) {
      debug$j("read-only mode, cache appended to memory but not flushed to file");
      return;
    }
    this.flushCacheToFile();
  }
  loadCacheFromFile() {
    const cacheFile = this.cacheFilePath;
    assert$1(cacheFile, "cache file path is required");
    if (!existsSync(cacheFile)) {
      debug$j("no cache file found, path: %s", cacheFile);
      return void 0;
    }
    const jsonTypeCacheFile = cacheFile.replace(cacheFileExt, ".json");
    if (existsSync(jsonTypeCacheFile) && this.isCacheResultUsed) {
      console.warn(
        `An outdated cache file from an earlier version of Omni has been detected. Since version 0.17, we have implemented an improved caching strategy. Please delete the old file located at: ${jsonTypeCacheFile}.`
      );
      return void 0;
    }
    try {
      const data = readFileSync(cacheFile, "utf8");
      const jsonData = jsYaml.load(data);
      const version2 = getCoreVersion();
      if (!version2) {
        debug$j("no Omni version info, will not read cache from file");
        return void 0;
      }
      if (semver$1.lt(jsonData.OmniVersion, lowestSupportedOmniVersion) && !jsonData.OmniVersion.includes("beta")) {
        console.warn(
          `You are using an old version of Omni cache file, and we cannot match any info from it. Starting from Omni v0.17, we changed our strategy to use xpath for cache info, providing better performance.
Please delete the existing cache and rebuild it. Sorry for the inconvenience.
cache file: ${cacheFile}`
        );
        return void 0;
      }
      debug$j(
        "cache loaded from file, path: %s, cache version: %s, record length: %s",
        cacheFile,
        jsonData.OmniVersion,
        jsonData.caches.length
      );
      jsonData.OmniVersion = getCoreVersion();
      return jsonData;
    } catch (err) {
      debug$j(
        "cache file exists but load failed, path: %s, error: %s",
        cacheFile,
        err
      );
      return void 0;
    }
  }
  flushCacheToFile(options2) {
    const version2 = getCoreVersion();
    if (!version2) {
      debug$j("no Omni version info, will not write cache to file");
      return;
    }
    if (!this.cacheFilePath) {
      debug$j("no cache file path, will not write cache to file");
      return;
    }
    if (options2 == null ? void 0 : options2.cleanUnused) {
      if (this.isCacheResultUsed) {
        const originalLength = this.cache.caches.length;
        const usedIndices = /* @__PURE__ */ new Set();
        for (const key of this.matchedCacheIndices) {
          const parts = key.split(":");
          const index2 = Number.parseInt(parts[parts.length - 1], 10);
          if (!Number.isNaN(index2)) {
            usedIndices.add(index2);
          }
        }
        this.cache.caches = this.cache.caches.filter((_, index2) => {
          const isUsed = usedIndices.has(index2);
          const isNew = index2 >= this.cacheOriginalLength;
          return isUsed || isNew;
        });
        const removedCount = originalLength - this.cache.caches.length;
        if (removedCount > 0) {
          debug$j("cleaned %d unused cache record(s)", removedCount);
        } else {
          debug$j("no unused cache to clean");
        }
      } else {
        debug$j("skip cleaning: cache is not used for reading");
      }
    }
    try {
      const dir = dirname$1(this.cacheFilePath);
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
        debug$j("created cache directory: %s", dir);
      }
      const sortedCaches = [...this.cache.caches].sort((a, b) => {
        if (a.type === "plan" && b.type === "locate") return -1;
        if (a.type === "locate" && b.type === "plan") return 1;
        return 0;
      });
      const cacheToWrite = {
        ...this.cache,
        caches: sortedCaches
      };
      const yamlData = jsYaml.dump(cacheToWrite);
      writeFileSync(this.cacheFilePath, yamlData);
      debug$j("cache flushed to file: %s", this.cacheFilePath);
    } catch (err) {
      debug$j(
        "write cache to file failed, path: %s, error: %s",
        this.cacheFilePath,
        err
      );
    }
  }
  updateOrAppendCacheRecord(newRecord, cachedRecord) {
    if (cachedRecord) {
      if (newRecord.type === "plan") {
        cachedRecord.updateFn((cache) => {
          cache.yamlWorkflow = newRecord.yamlWorkflow;
        });
      } else {
        cachedRecord.updateFn((cache) => {
          const locateCache = cache;
          locateCache.cache = newRecord.cache;
          if ("xpaths" in locateCache) {
            locateCache.xpaths = void 0;
          }
        });
      }
    } else {
      this.appendCache(newRecord);
    }
  }
}
const debugProfile = getDebug("web:tool:profile");
async function commonContextParser(interfaceInstance, _opt) {
  var _a3;
  assert(interfaceInstance, "interfaceInstance is required");
  debugProfile("Getting interface description");
  const description = ((_a3 = interfaceInstance.describe) == null ? void 0 : _a3.call(interfaceInstance)) || "";
  debugProfile("Interface description end");
  debugProfile("Uploading test info to server");
  uploadTestInfoToServer({
    testUrl: description,
    serverUrl: _opt.uploadServerUrl
  });
  debugProfile("UploadTestInfoToServer end");
  const screenshotBase64 = await interfaceInstance.screenshotBase64();
  assert(screenshotBase64, "screenshotBase64 is required");
  debugProfile("will get size");
  const size = await interfaceInstance.size();
  debugProfile(`size: ${size.width}x${size.height} dpr: ${size.dpr}`);
  const screenshot = ScreenshotItem.create(screenshotBase64);
  return {
    size,
    screenshot
  };
}
function getReportFileName(tag = "web") {
  const reportTagName = globalConfigManager.getEnvConfigValue(
    OMNI_REPORT_TAG_NAME
  );
  const dateTimeInFileName = dayjs().format("YYYY-MM-DD_HH-mm-ss");
  const uniqueId = uuid().substring(0, 8);
  return `${reportTagName || tag}-${dateTimeInFileName}-${uniqueId}`;
}
function ifPlanLocateParamIsBbox(planLocateParam) {
  return !!(planLocateParam.bbox && Array.isArray(planLocateParam.bbox) && planLocateParam.bbox.length === 4);
}
function matchElementFromPlan(planLocateParam) {
  var _a3;
  if (!planLocateParam) {
    return void 0;
  }
  if (planLocateParam.bbox) {
    const rect = {
      left: planLocateParam.bbox[0],
      top: planLocateParam.bbox[1],
      width: planLocateParam.bbox[2] - planLocateParam.bbox[0] + 1,
      height: planLocateParam.bbox[3] - planLocateParam.bbox[1] + 1
    };
    const element = generateElementByRect(
      rect,
      typeof planLocateParam.prompt === "string" ? planLocateParam.prompt : ((_a3 = planLocateParam.prompt) == null ? void 0 : _a3.prompt) || ""
    );
    return element;
  }
  return void 0;
}
async function matchElementFromCache(context2, cacheEntry, cachePrompt, cacheable) {
  var _a3;
  if (!cacheEntry) {
    return void 0;
  }
  if (cacheable === false) {
    debug$j("cache disabled for prompt: %s", cachePrompt);
    return void 0;
  }
  if (!((_a3 = context2.taskCache) == null ? void 0 : _a3.isCacheResultUsed)) {
    return void 0;
  }
  if (!context2.interfaceInstance.rectMatchesCacheFeature) {
    debug$j(
      "interface does not implement rectMatchesCacheFeature, skip cache"
    );
    return void 0;
  }
  try {
    const rect = await context2.interfaceInstance.rectMatchesCacheFeature(cacheEntry);
    const element = {
      center: [
        Math.round(rect.left + rect.width / 2),
        Math.round(rect.top + rect.height / 2)
      ],
      rect,
      description: typeof cachePrompt === "string" ? cachePrompt : cachePrompt.prompt || ""
    };
    debug$j("cache hit, prompt: %s", cachePrompt);
    return element;
  } catch (error2) {
    debug$j("rectMatchesCacheFeature error: %s", error2);
    return void 0;
  }
}
const getCoreVersion = () => {
  {
    return "0.0.0";
  }
};
const parsePrompt = (prompt) => {
  if (typeof prompt === "string") {
    return {
      textPrompt: prompt,
      multimodalPrompt: void 0
    };
  }
  return {
    textPrompt: prompt.prompt,
    multimodalPrompt: prompt.images ? {
      images: prompt.images,
      convertHttpImage2Base64: !!prompt.convertHttpImage2Base64
    } : void 0
  };
};
const nullReportGenerator = {
  onDumpUpdate: () => {
  },
  flush: async () => {
  },
  finalize: async () => void 0,
  getReportPath: () => void 0
};
class ReportGenerator {
  constructor(options2) {
    __publicField(this, "reportPath");
    __publicField(this, "screenshotMode");
    __publicField(this, "autoPrint");
    __publicField(this, "writtenScreenshots", /* @__PURE__ */ new Set());
    __publicField(this, "imageEndOffset", 0);
    __publicField(this, "initialized", false);
    __publicField(this, "writeQueue", Promise.resolve());
    __publicField(this, "destroyed", false);
    this.reportPath = options2.reportPath;
    this.screenshotMode = options2.screenshotMode;
    this.autoPrint = options2.autoPrint ?? true;
  }
  static create(reportFileName, opts) {
    if (opts.generateReport === false) return nullReportGenerator;
    if (ifInBrowser) return nullReportGenerator;
    if (opts.outputFormat === "html-and-external-assets") {
      const outputDir = join$3(getRunSubDir("report"), reportFileName);
      return new ReportGenerator({
        reportPath: join$3(outputDir, "index.html"),
        screenshotMode: "directory",
        autoPrint: opts.autoPrintReportMsg
      });
    }
    return new ReportGenerator({
      reportPath: join$3(getRunSubDir("report"), `${reportFileName}.html`),
      screenshotMode: "inline",
      autoPrint: opts.autoPrintReportMsg
    });
  }
  onDumpUpdate(dump2) {
    this.writeQueue = this.writeQueue.then(() => {
      if (this.destroyed) return;
      this.doWrite(dump2);
    });
  }
  async flush() {
    await this.writeQueue;
  }
  async finalize(dump2) {
    this.onDumpUpdate(dump2);
    await this.flush();
    this.destroyed = true;
    if (this.autoPrint && this.reportPath) {
      if (this.screenshotMode === "directory") {
        console.log("\n[Omni] Directory report generated.");
        console.log(
          "[Omni] Note: This report must be served via HTTP server due to CORS restrictions."
        );
        console.log(`[Omni] Example: npx serve ${dirname$1(this.reportPath)}`);
      } else {
        logMsg(`Omni - report file updated: ${this.reportPath}`);
      }
    }
    return this.reportPath;
  }
  getReportPath() {
    return this.reportPath;
  }
  doWrite(dump2) {
    if (this.screenshotMode === "inline") {
      this.writeInlineReport(dump2);
    } else {
      this.writeDirectoryReport(dump2);
    }
  }
  writeInlineReport(dump2) {
    const dir = dirname$1(this.reportPath);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
    if (!this.initialized) {
      writeFileSync(this.reportPath, getReportTpl());
      this.imageEndOffset = statSync(this.reportPath).size;
      this.initialized = true;
    }
    truncateSync(this.reportPath, this.imageEndOffset);
    const screenshots = dump2.collectAllScreenshots();
    for (const screenshot of screenshots) {
      if (!this.writtenScreenshots.has(screenshot.id)) {
        appendFileSync(
          this.reportPath,
          `
${generateImageScriptTag(screenshot.id, screenshot.base64)}`
        );
        this.writtenScreenshots.add(screenshot.id);
        screenshot.markPersistedInline(this.reportPath);
      }
    }
    this.imageEndOffset = statSync(this.reportPath).size;
    const serialized = dump2.serialize();
    appendFileSync(this.reportPath, `
${generateDumpScriptTag(serialized)}`);
  }
  writeDirectoryReport(dump2) {
    const dir = dirname$1(this.reportPath);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
    const screenshotsDir = join$3(dir, "screenshots");
    if (!existsSync(screenshotsDir)) {
      mkdirSync(screenshotsDir, { recursive: true });
    }
    const screenshots = dump2.collectAllScreenshots();
    for (const screenshot of screenshots) {
      if (!this.writtenScreenshots.has(screenshot.id)) {
        const absolutePath = join$3(screenshotsDir, `${screenshot.id}.png`);
        const buffer2 = Buffer.from(screenshot.rawBase64, "base64");
        writeFileSync(absolutePath, new Uint8Array(buffer2));
        screenshot.markPersistedToPath(
          `./screenshots/${screenshot.id}.png`,
          absolutePath
        );
        this.writtenScreenshots.add(screenshot.id);
      }
    }
    const serialized = dump2.serialize();
    writeFileSync(this.reportPath, getReportTpl(), { flag: "w" });
    appendFileSync(this.reportPath, `
${generateDumpScriptTag(serialized)}`);
  }
}
const debug$i = getDebug("yaml-player");
const aiTaskHandlerMap = {
  aiQuery: "aiQuery",
  aiNumber: "aiNumber",
  aiString: "aiString",
  aiBoolean: "aiBoolean",
  aiAsk: "aiAsk",
  aiLocate: "aiLocate"
};
const isStringParamSchema = (schema2) => {
  if (!schema2) {
    return false;
  }
  const schemaDef = schema2 == null ? void 0 : schema2._def;
  if (!(schemaDef == null ? void 0 : schemaDef.typeName)) {
    return false;
  }
  switch (schemaDef.typeName) {
    case z.ZodFirstPartyTypeKind.ZodString:
    case z.ZodFirstPartyTypeKind.ZodEnum:
    case z.ZodFirstPartyTypeKind.ZodNativeEnum:
      return true;
    case z.ZodFirstPartyTypeKind.ZodLiteral:
      return typeof schemaDef.value === "string";
    case z.ZodFirstPartyTypeKind.ZodOptional:
    case z.ZodFirstPartyTypeKind.ZodNullable:
    case z.ZodFirstPartyTypeKind.ZodDefault:
      return isStringParamSchema(schemaDef.innerType);
    case z.ZodFirstPartyTypeKind.ZodEffects:
      return isStringParamSchema(schemaDef.schema);
    case z.ZodFirstPartyTypeKind.ZodPipeline:
      return isStringParamSchema(schemaDef.out);
    case z.ZodFirstPartyTypeKind.ZodUnion: {
      const options2 = schemaDef.options;
      return Array.isArray(options2) ? options2.every((option) => isStringParamSchema(option)) : false;
    }
    default:
      return false;
  }
};
class ScriptPlayer {
  constructor(script, setupAgent, onTaskStatusChange, scriptPath) {
    __publicField(this, "currentTaskIndex");
    __publicField(this, "taskStatusList", []);
    __publicField(this, "status", "init");
    __publicField(this, "reportFile");
    __publicField(this, "result");
    __publicField(this, "unnamedResultIndex", 0);
    __publicField(this, "output");
    __publicField(this, "unstableLogContent");
    __publicField(this, "errorInSetup");
    __publicField(this, "interfaceAgent", null);
    __publicField(this, "agentStatusTip");
    __publicField(this, "target");
    __publicField(this, "actionSpace", []);
    __publicField(this, "scriptPath");
    var _a3, _b, _c, _d, _e;
    this.script = script;
    this.setupAgent = setupAgent;
    this.onTaskStatusChange = onTaskStatusChange;
    this.scriptPath = scriptPath;
    this.result = {};
    const resolvedAiActContext = ((_a3 = script.agent) == null ? void 0 : _a3.aiActContext) ?? ((_b = script.agent) == null ? void 0 : _b.aiActionContext);
    if (resolvedAiActContext !== void 0 && script.agent) {
      if (script.agent.aiActContext === void 0 && script.agent.aiActionContext !== void 0) {
        console.warn(
          "agent.aiActionContext is deprecated, please use agent.aiActContext instead. The legacy name is still accepted for backward compatibility."
        );
      }
      script.agent.aiActContext = resolvedAiActContext;
    }
    this.target = script.target || script.web || script.android || script.ios || script.computer || script.config;
    if (ifInBrowser || ifInWorker) {
      this.output = void 0;
      debug$i("output is undefined in browser or worker");
    } else if ((_c = this.target) == null ? void 0 : _c.output) {
      this.output = resolve$3(process.cwd(), this.target.output);
      debug$i("setting output by config.output", this.output);
    } else {
      const scriptName = this.scriptPath ? basename$2(this.scriptPath, ".yaml").replace(/\.(ya?ml)$/i, "") : "script";
      this.output = join$3(
        getRunSubDir("output"),
        `${scriptName}-${Date.now()}.json`
      );
      debug$i("setting output by script path", this.output);
    }
    if (ifInBrowser || ifInWorker) {
      this.unstableLogContent = void 0;
    } else if (typeof ((_d = this.target) == null ? void 0 : _d.unstableLogContent) === "string") {
      this.unstableLogContent = resolve$3(
        process.cwd(),
        this.target.unstableLogContent
      );
    } else if (((_e = this.target) == null ? void 0 : _e.unstableLogContent) === true) {
      this.unstableLogContent = join$3(
        getRunSubDir("output"),
        "unstableLogContent.json"
      );
    }
    this.taskStatusList = (script.tasks || []).map((task, taskIndex) => {
      var _a4;
      return {
        ...task,
        index: taskIndex,
        status: "init",
        totalSteps: ((_a4 = task.flow) == null ? void 0 : _a4.length) || 0
      };
    });
  }
  setResult(key, value) {
    const keyToUse = key || this.unnamedResultIndex++;
    if (this.result[keyToUse]) {
      console.warn(`result key ${keyToUse} already exists, will overwrite`);
    }
    this.result[keyToUse] = value;
    return this.flushResult();
  }
  setPlayerStatus(status3, error2) {
    this.status = status3;
    this.errorInSetup = error2;
  }
  notifyCurrentTaskStatusChange(taskIndex) {
    const taskIndexToNotify = typeof taskIndex === "number" ? taskIndex : this.currentTaskIndex;
    if (typeof taskIndexToNotify !== "number") {
      return;
    }
    const taskStatus = this.taskStatusList[taskIndexToNotify];
    if (this.onTaskStatusChange) {
      this.onTaskStatusChange(taskStatus);
    }
  }
  async setTaskStatus(index2, statusValue, error2) {
    this.taskStatusList[index2].status = statusValue;
    if (error2) {
      this.taskStatusList[index2].error = error2;
    }
    this.notifyCurrentTaskStatusChange(index2);
  }
  setTaskIndex(taskIndex) {
    this.currentTaskIndex = taskIndex;
  }
  flushResult() {
    if (this.output) {
      const output = resolve$3(process.cwd(), this.output);
      const outputDir = dirname$1(output);
      if (!existsSync(outputDir)) {
        mkdirSync(outputDir, { recursive: true });
      }
      writeFileSync(output, JSON.stringify(this.result || {}, void 0, 2));
    }
  }
  flushUnstableLogContent() {
    var _a3;
    if (this.unstableLogContent) {
      const content = (_a3 = this.interfaceAgent) == null ? void 0 : _a3._unstableLogContent();
      const filePath = resolve$3(process.cwd(), this.unstableLogContent);
      const outputDir = dirname$1(filePath);
      if (!existsSync(outputDir)) {
        mkdirSync(outputDir, { recursive: true });
      }
      writeFileSync(filePath, JSON.stringify(content, null, 2));
    }
  }
  async playTask(taskStatus, agent) {
    const { flow } = taskStatus;
    assert(flow, "missing flow in task");
    for (const flowItemIndex in flow) {
      const currentStep = Number.parseInt(flowItemIndex, 10);
      taskStatus.currentStep = currentStep;
      const flowItem = flow[flowItemIndex];
      debug$i(
        `playing step ${flowItemIndex}, flowItem=${JSON.stringify(flowItem)}`
      );
      const simpleAIKey = Object.keys(aiTaskHandlerMap).find((key) => Object.prototype.hasOwnProperty.call(flowItem, key));
      if ("aiAct" in flowItem || "aiAction" in flowItem || "ai" in flowItem) {
        const actionTask = flowItem;
        const { aiAct, aiAction, ai, ...actionOptions } = actionTask;
        const prompt = aiAct || aiAction || ai;
        assert(prompt, "missing prompt for ai (aiAct)");
        await agent.aiAct(prompt, actionOptions);
      } else if ("aiAssert" in flowItem) {
        const assertTask = flowItem;
        const {
          aiAssert: prompt,
          errorMessage: msg,
          name,
          ...restOpts
        } = assertTask;
        assert(prompt, "missing prompt for aiAssert");
        const { pass, thought, message } = await agent.aiAssert(prompt, msg, {
          ...restOpts,
          keepRawResponse: true
        }) || {};
        this.setResult(name, {
          pass,
          thought,
          message
        });
        if (!pass) {
          throw new Error(message);
        }
      } else if (simpleAIKey) {
        const {
          [simpleAIKey]: prompt,
          name,
          ...options2
        } = flowItem;
        assert(prompt, `missing prompt for ${simpleAIKey}`);
        const agentMethod = agent[aiTaskHandlerMap[simpleAIKey]];
        assert(
          typeof agentMethod === "function",
          `missing agent method for ${simpleAIKey}`
        );
        const aiResult = await agentMethod.call(agent, prompt, options2);
        this.setResult(name, aiResult);
      } else if ("aiWaitFor" in flowItem) {
        const waitForTask = flowItem;
        const { aiWaitFor, timeout: timeout2, ...restWaitForOpts } = waitForTask;
        const prompt = aiWaitFor;
        assert(prompt, "missing prompt for aiWaitFor");
        const waitForOptions = {
          ...restWaitForOpts,
          ...timeout2 !== void 0 ? { timeout: timeout2, timeoutMs: timeout2 } : {}
        };
        await agent.aiWaitFor(prompt, waitForOptions);
      } else if ("sleep" in flowItem) {
        const sleepTask = flowItem;
        const ms2 = sleepTask.sleep;
        let msNumber = ms2;
        if (typeof ms2 === "string") {
          msNumber = Number.parseInt(ms2, 10);
        }
        assert(
          msNumber && msNumber > 0,
          `ms for sleep must be greater than 0, but got ${ms2}`
        );
        await new Promise((resolve22) => setTimeout(resolve22, msNumber));
      } else if ("javascript" in flowItem) {
        const evaluateJavaScriptTask = flowItem;
        const result = await agent.evaluateJavaScript(
          evaluateJavaScriptTask.javascript
        );
        this.setResult(evaluateJavaScriptTask.name, result);
      } else if ("logScreenshot" in flowItem || "recordToReport" in flowItem) {
        const recordTask = flowItem;
        const title = recordTask.recordToReport ?? recordTask.logScreenshot ?? "untitled";
        const content = recordTask.content || "";
        await agent.recordToReport(title, { content });
      } else if ("aiInput" in flowItem) {
        const {
          aiInput,
          value: rawValue,
          ...inputTask
        } = flowItem;
        let locatePrompt;
        let value;
        if (inputTask.locate) {
          value = aiInput || rawValue;
          locatePrompt = inputTask.locate;
        } else {
          locatePrompt = aiInput || "";
          value = rawValue;
        }
        await agent.callActionInActionSpace("Input", {
          ...inputTask,
          ...value !== void 0 ? { value: String(value) } : {},
          ...locatePrompt ? { locate: buildDetailedLocateParam(locatePrompt, inputTask) } : {}
        });
      } else if ("aiKeyboardPress" in flowItem) {
        const { aiKeyboardPress, ...keyboardPressTask } = flowItem;
        let locatePrompt;
        let keyName;
        if (keyboardPressTask.locate) {
          keyName = aiKeyboardPress;
          locatePrompt = keyboardPressTask.locate;
        } else if (keyboardPressTask.keyName) {
          keyName = keyboardPressTask.keyName;
          locatePrompt = aiKeyboardPress;
        } else {
          keyName = aiKeyboardPress;
        }
        await agent.callActionInActionSpace("KeyboardPress", {
          ...keyboardPressTask,
          ...keyName ? { keyName } : {},
          ...locatePrompt ? {
            locate: buildDetailedLocateParam(
              locatePrompt,
              keyboardPressTask
            )
          } : {}
        });
      } else if ("aiScroll" in flowItem) {
        const { aiScroll, ...scrollTask } = flowItem;
        const { locate, ...scrollOptions } = scrollTask;
        const locatePrompt = locate ?? aiScroll;
        await agent.aiScroll(locatePrompt, scrollOptions);
      } else {
        const actionSpace = this.actionSpace;
        let locatePromptShortcut;
        let actionParamForMatchedAction;
        const matchedAction = actionSpace.find((action) => {
          const actionInterfaceAlias = action.interfaceAlias;
          if (actionInterfaceAlias && Object.prototype.hasOwnProperty.call(flowItem, actionInterfaceAlias)) {
            actionParamForMatchedAction = flowItem[actionInterfaceAlias];
            if (typeof actionParamForMatchedAction === "string") {
              locatePromptShortcut = actionParamForMatchedAction;
            }
            return true;
          }
          const keyOfActionInActionSpace = action.name;
          if (Object.prototype.hasOwnProperty.call(
            flowItem,
            keyOfActionInActionSpace
          )) {
            actionParamForMatchedAction = flowItem[keyOfActionInActionSpace];
            if (typeof actionParamForMatchedAction === "string") {
              locatePromptShortcut = actionParamForMatchedAction;
            }
            return true;
          }
          return false;
        });
        assert(
          matchedAction,
          `unknown flowItem in yaml: ${JSON.stringify(flowItem)}`
        );
        const schemaIsStringParam = isStringParamSchema(
          matchedAction.paramSchema
        );
        let stringParamToCall;
        if (typeof actionParamForMatchedAction === "string" && schemaIsStringParam) {
          if (matchedAction.paramSchema) {
            const parseResult = matchedAction.paramSchema.safeParse(
              actionParamForMatchedAction
            );
            if (parseResult.success && typeof parseResult.data === "string") {
              stringParamToCall = parseResult.data;
            } else if (!parseResult.success) {
              debug$i(
                `parse failed for action ${matchedAction.name} with string param`,
                parseResult.error
              );
              stringParamToCall = actionParamForMatchedAction;
            }
          } else {
            stringParamToCall = actionParamForMatchedAction;
          }
        }
        if (stringParamToCall !== void 0) {
          debug$i(
            `matchedAction: ${matchedAction.name}`,
            `flowParams: ${JSON.stringify(stringParamToCall)}`
          );
          const result = await agent.callActionInActionSpace(
            matchedAction.name,
            stringParamToCall
          );
          const resultName = flowItem.name;
          if (result !== void 0) {
            this.setResult(resultName, result);
          }
        } else if (typeof actionParamForMatchedAction === "string" && (matchedAction.name === "Launch" || matchedAction.interfaceAlias === "launch") && typeof agent.launch === "function") {
          debug$i(`Calling agent.launch with: ${actionParamForMatchedAction}`);
          const result = await agent.launch(
            actionParamForMatchedAction
          );
          const resultName = flowItem.name;
          if (result !== void 0) {
            this.setResult(resultName, result);
          }
        } else if (typeof actionParamForMatchedAction === "string" && (matchedAction.name === "RunAdbShell" || matchedAction.interfaceAlias === "runAdbShell") && typeof agent.runAdbShell === "function") {
          debug$i(
            `Calling agent.runAdbShell with: ${actionParamForMatchedAction}`
          );
          const result = await agent.runAdbShell(
            actionParamForMatchedAction
          );
          const resultName = flowItem.name;
          if (result !== void 0) {
            this.setResult(resultName, result);
          }
        } else {
          const sourceForParams = locatePromptShortcut && typeof actionParamForMatchedAction === "string" ? { ...flowItem, prompt: locatePromptShortcut } : typeof actionParamForMatchedAction === "object" && actionParamForMatchedAction !== null ? actionParamForMatchedAction : flowItem;
          const { locateParam, restParams } = buildDetailedLocateParamAndRestParams(
            locatePromptShortcut || "",
            sourceForParams,
            [
              matchedAction.name,
              matchedAction.interfaceAlias || "_never_mind_"
            ]
          );
          const flowParams = {
            ...restParams,
            locate: locateParam
          };
          debug$i(
            `matchedAction: ${matchedAction.name}`,
            `flowParams: ${JSON.stringify(flowParams, null, 2)}`
          );
          const result = await agent.callActionInActionSpace(
            matchedAction.name,
            flowParams
          );
          const resultName = flowItem.name;
          if (result !== void 0) {
            this.setResult(resultName, result);
          }
        }
      }
    }
    this.reportFile = agent.reportFile;
    await this.flushUnstableLogContent();
  }
  async run() {
    const { target, web, android, ios, computer, tasks } = this.script;
    const webEnv = web || target;
    const androidEnv = android;
    const iosEnv = ios;
    const computerEnv = computer;
    const platform = webEnv || androidEnv || iosEnv || computerEnv;
    this.setPlayerStatus("running");
    let agent = null;
    let freeFn = [];
    try {
      const { agent: newAgent, freeFn: newFreeFn } = await this.setupAgent(
        platform
      );
      this.actionSpace = await newAgent.getActionSpace();
      agent = newAgent;
      const originalOnTaskStartTip = agent.onTaskStartTip;
      agent.onTaskStartTip = (tip) => {
        if (this.status === "running") {
          this.agentStatusTip = tip;
        }
        originalOnTaskStartTip == null ? void 0 : originalOnTaskStartTip(tip);
      };
      freeFn = [
        ...newFreeFn || [],
        {
          name: "restore-agent-onTaskStartTip",
          fn: () => {
            if (agent) {
              agent.onTaskStartTip = originalOnTaskStartTip;
            }
          }
        }
      ];
    } catch (e) {
      this.setPlayerStatus("error", e);
      return;
    }
    this.interfaceAgent = agent;
    let taskIndex = 0;
    this.setPlayerStatus("running");
    let errorFlag = false;
    while (taskIndex < tasks.length) {
      const taskStatus = this.taskStatusList[taskIndex];
      this.setTaskStatus(taskIndex, "running");
      this.setTaskIndex(taskIndex);
      try {
        await this.playTask(taskStatus, this.interfaceAgent);
        this.setTaskStatus(taskIndex, "done");
      } catch (e) {
        this.setTaskStatus(taskIndex, "error", e);
        if (taskStatus.continueOnError) ;
        else {
          this.reportFile = agent.reportFile;
          errorFlag = true;
          break;
        }
      }
      this.reportFile = agent == null ? void 0 : agent.reportFile;
      taskIndex++;
    }
    if (errorFlag) {
      this.setPlayerStatus("error");
    } else {
      this.setPlayerStatus("done");
    }
    this.agentStatusTip = "";
    for (const fn of freeFn) {
      try {
        await fn.fn();
      } catch (e) {
      }
    }
  }
}
class AbstractInterface {
  constructor() {
    // @deprecated do NOT extend this method
    __publicField(this, "getElementsNodeTree");
    // @deprecated do NOT extend this method
    __publicField(this, "url");
  }
}
const defineAction = (config2) => {
  return config2;
};
const actionTapParamSchema = z.object({
  locate: getLocationSchema().describe("The element to be tapped")
});
const defineActionTap = (call) => {
  return defineAction({
    name: "Tap",
    description: "Tap the element",
    interfaceAlias: "aiTap",
    paramSchema: actionTapParamSchema,
    call
  });
};
z.object({
  locate: getLocationSchema().describe(
    "The element to be right clicked"
  )
});
z.object({
  locate: getLocationSchema().describe(
    "The element to be double clicked"
  )
});
z.object({
  locate: getLocationSchema().describe("The element to be hovered")
});
const inputLocateDescription = "the position of the placeholder or text content in the target input field. If there is no content, locate the center of the input field.";
const actionInputParamSchema = z.object({
  value: z.union([z.string(), z.number()]).transform((val) => String(val)).describe(
    "The text to input. Provide the final content for replace/append modes, or an empty string when using clear mode to remove existing text."
  ),
  locate: getLocationSchema().describe(inputLocateDescription).optional(),
  mode: z.preprocess(
    (val) => val === "append" ? "typeOnly" : val,
    z.enum(["replace", "clear", "typeOnly"]).default("replace").optional().describe(
      'Input mode: "replace" (default) - clear the field and input the value; "typeOnly" - type the value directly without clearing the field first; "clear" - clear the field without inputting new text.'
    )
  )
});
const defineActionInput = (call) => {
  return defineAction({
    name: "Input",
    description: "Input the value into the element",
    interfaceAlias: "aiInput",
    paramSchema: actionInputParamSchema,
    call
  });
};
const actionKeyboardPressParamSchema = z.object({
  locate: getLocationSchema().describe("The element to be clicked before pressing the key").optional(),
  keyName: z.string().describe(
    "The key to be pressed. Use '+' for key combinations, e.g., 'Control+A', 'Shift+Enter'"
  )
});
const defineActionKeyboardPress = (call) => {
  return defineAction({
    name: "KeyboardPress",
    description: 'Press a key or key combination, like "Enter", "Tab", "Escape", or "Control+A", "Shift+Enter". Do not use this to type text.',
    interfaceAlias: "aiKeyboardPress",
    paramSchema: actionKeyboardPressParamSchema,
    call
  });
};
const actionScrollParamSchema = z.object({
  scrollType: z.enum([
    "singleAction",
    "scrollToBottom",
    "scrollToTop",
    "scrollToRight",
    "scrollToLeft"
  ]).default("singleAction").describe(
    'The scroll behavior: "singleAction" for a single scroll action, "scrollToBottom" for scrolling all the way to the bottom by rapidly scrolling 5-10 times (skipping intermediate content until reaching the bottom), "scrollToTop" for scrolling all the way to the top by rapidly scrolling 5-10 times (skipping intermediate content until reaching the top), "scrollToRight" for scrolling all the way to the right by rapidly scrolling multiple times, "scrollToLeft" for scrolling all the way to the left by rapidly scrolling multiple times'
  ),
  direction: z.enum(["down", "up", "right", "left"]).default("down").describe(
    'The direction to scroll. Only effective when scrollType is "singleAction".'
  ),
  distance: z.number().nullable().optional().describe("The distance in pixels to scroll"),
  locate: getLocationSchema().optional().describe(
    'Describe the target element to be scrolled on, like "the table" or "the list" or "the content area" or "the scrollable area". Do NOT provide a general intent like "scroll to find some element"'
  )
});
const defineActionScroll = (call) => {
  return defineAction({
    name: "Scroll",
    description: "Scroll the page or an element. The direction to scroll, the scroll type, and the distance to scroll. The distance is the number of pixels to scroll. If not specified, use `down` direction, `once` scroll type, and `null` distance.",
    interfaceAlias: "aiScroll",
    paramSchema: actionScrollParamSchema,
    call
  });
};
z.object({
  from: getLocationSchema().describe("The position to be dragged"),
  to: getLocationSchema().describe("The position to be dropped")
});
const ActionLongPressParamSchema = z.object({
  locate: getLocationSchema().describe(
    "The element to be long pressed"
  ),
  duration: z.number().default(500).optional().describe("Long press duration in milliseconds")
});
const defineActionLongPress = (call) => {
  return defineAction({
    name: "LongPress",
    description: "Long press the element",
    paramSchema: ActionLongPressParamSchema,
    call
  });
};
const ActionSwipeParamSchema = z.object({
  start: getLocationSchema().optional().describe(
    "Starting point of the swipe gesture, if not specified, the center of the page will be used"
  ),
  direction: z.enum(["up", "down", "left", "right"]).optional().describe(
    "The direction to swipe (required when using distance). The direction means the direction of the finger swipe."
  ),
  distance: z.number().optional().describe("The distance in pixels to swipe (mutually exclusive with end)"),
  end: getLocationSchema().optional().describe(
    "Ending point of the swipe gesture (mutually exclusive with distance)"
  ),
  duration: z.number().default(300).describe("Duration of the swipe gesture in milliseconds"),
  repeat: z.number().optional().describe(
    "The number of times to repeat the swipe gesture. 1 for default, 0 for infinite (e.g. endless swipe until the end of the page)"
  )
});
const defineActionSwipe = (call) => {
  return defineAction({
    name: "Swipe",
    description: 'Perform a swipe gesture. You must specify either "end" (target location) or "distance" + "direction" - they are mutually exclusive. Use "end" for precise location-based swipes, or "distance" + "direction" for relative movement.',
    paramSchema: ActionSwipeParamSchema,
    call
  });
};
z.object({
  locate: getLocationSchema().describe("The input field to be cleared").optional()
});
const ActionSleepParamSchema = z.object({
  timeMs: z.number().default(1e3).optional().describe("Sleep duration in milliseconds, defaults to 1000ms (1 second)")
});
const defineActionSleep = () => {
  return defineAction({
    name: "Sleep",
    description: "Wait for a specified duration before continuing. Defaults to 1 second (1000ms) if not specified.",
    paramSchema: ActionSleepParamSchema,
    call: async (param3) => {
      const duration = (param3 == null ? void 0 : param3.timeMs) ?? 1e3;
      getDebug("device:common-action")(`Sleeping for ${duration}ms`);
      await new Promise((resolve3) => setTimeout(resolve3, duration));
    }
  });
};
const debug$h = getDebug("task-runner");
const UI_CONTEXT_CACHE_TTL_MS = 300;
class TaskRunner {
  constructor(name, uiContextBuilder, options2) {
    __publicField(this, "name");
    __publicField(this, "tasks");
    // status of runner
    __publicField(this, "status");
    __publicField(this, "onTaskStart");
    __publicField(this, "uiContextBuilder");
    __publicField(this, "onTaskUpdate");
    __publicField(this, "lastUiContext");
    this.status = (options2 == null ? void 0 : options2.tasks) && options2.tasks.length > 0 ? "pending" : "init";
    this.name = name;
    this.tasks = ((options2 == null ? void 0 : options2.tasks) || []).map(
      (item) => this.markTaskAsPending(item)
    );
    this.onTaskStart = options2 == null ? void 0 : options2.onTaskStart;
    this.uiContextBuilder = uiContextBuilder;
    this.onTaskUpdate = options2 == null ? void 0 : options2.onTaskUpdate;
  }
  async emitOnTaskUpdate(error2) {
    if (!this.onTaskUpdate) {
      return;
    }
    await this.onTaskUpdate(this, error2);
  }
  async getUiContext(options2) {
    var _a3, _b;
    const now = Date.now();
    const shouldReuse = !(options2 == null ? void 0 : options2.forceRefresh) && this.lastUiContext && now - this.lastUiContext.capturedAt <= UI_CONTEXT_CACHE_TTL_MS;
    if (shouldReuse && ((_a3 = this.lastUiContext) == null ? void 0 : _a3.context)) {
      debug$h(
        `reuse cached uiContext captured ${now - this.lastUiContext.capturedAt}ms ago`
      );
      return (_b = this.lastUiContext) == null ? void 0 : _b.context;
    }
    try {
      const uiContext = await this.uiContextBuilder();
      if (uiContext) {
        this.lastUiContext = {
          context: uiContext,
          capturedAt: Date.now()
        };
      } else {
        this.lastUiContext = void 0;
      }
      return uiContext;
    } catch (error2) {
      this.lastUiContext = void 0;
      throw error2;
    }
  }
  async captureScreenshot() {
    try {
      const uiContext = await this.getUiContext({ forceRefresh: true });
      return uiContext == null ? void 0 : uiContext.screenshot;
    } catch (error2) {
      console.error("error while capturing screenshot", error2);
    }
    return void 0;
  }
  attachRecorderItem(task, screenshot, phase) {
    if (!phase || !screenshot) {
      return;
    }
    const recorderItem = {
      type: "screenshot",
      ts: Date.now(),
      screenshot,
      timing: phase
    };
    if (!task.recorder) {
      task.recorder = [recorderItem];
      return;
    }
    task.recorder.push(recorderItem);
  }
  markTaskAsPending(task) {
    return {
      taskId: uuid(),
      status: "pending",
      ...task
    };
  }
  normalizeStatusFromError(options2, errorMessage) {
    var _a3, _b;
    if (this.status !== "error") {
      return;
    }
    assert(
      options2 == null ? void 0 : options2.allowWhenError,
      errorMessage || `task runner is in error state, cannot proceed
error=${(_a3 = this.latestErrorTask()) == null ? void 0 : _a3.error}
${(_b = this.latestErrorTask()) == null ? void 0 : _b.errorStack}`
    );
    this.status = this.tasks.length > 0 ? "pending" : "init";
  }
  findPreviousNonSubTaskUIContext(currentIndex) {
    for (let i = currentIndex - 1; i >= 0; i--) {
      const candidate = this.tasks[i];
      if (!candidate || candidate.subTask) {
        continue;
      }
      if (candidate.uiContext) {
        return candidate.uiContext;
      }
    }
    return void 0;
  }
  async append(task, options2) {
    var _a3, _b;
    this.normalizeStatusFromError(
      options2,
      `task runner is in error state, cannot append task
error=${(_a3 = this.latestErrorTask()) == null ? void 0 : _a3.error}
${(_b = this.latestErrorTask()) == null ? void 0 : _b.errorStack}`
    );
    if (Array.isArray(task)) {
      this.tasks.push(...task.map((item) => this.markTaskAsPending(item)));
    } else {
      this.tasks.push(this.markTaskAsPending(task));
    }
    if (this.status !== "running") {
      this.status = "pending";
    }
    await this.emitOnTaskUpdate();
  }
  async appendAndFlush(task, options2) {
    await this.append(task, options2);
    return this.flush(options2);
  }
  async flush(options2) {
    if (this.status === "init" && this.tasks.length > 0) {
      console.warn(
        "illegal state for task runner, status is init but tasks are not empty"
      );
    }
    this.normalizeStatusFromError(options2, "task runner is in error state");
    assert(this.status !== "running", "task runner is already running");
    assert(this.status !== "completed", "task runner is already completed");
    const nextPendingIndex = this.tasks.findIndex(
      (task) => task.status === "pending"
    );
    if (nextPendingIndex < 0) {
      return;
    }
    this.status = "running";
    await this.emitOnTaskUpdate();
    let taskIndex = nextPendingIndex;
    let successfullyCompleted = true;
    let previousFindOutput;
    while (taskIndex < this.tasks.length) {
      const task = this.tasks[taskIndex];
      assert(
        task.status === "pending",
        `task status should be pending, but got: ${task.status}`
      );
      task.timing = {
        start: Date.now()
      };
      try {
        task.status = "running";
        await this.emitOnTaskUpdate();
        try {
          if (this.onTaskStart) {
            await this.onTaskStart(task);
          }
        } catch (e) {
          console.error("error in onTaskStart", e);
        }
        assert(
          ["Insight", "Action Space", "Planning"].indexOf(task.type) >= 0,
          `unsupported task type: ${task.type}`
        );
        const { executor, param: param3 } = task;
        assert(executor, `executor is required for task type: ${task.type}`);
        let returnValue;
        let uiContext;
        if (task.subTask) {
          uiContext = this.findPreviousNonSubTaskUIContext(taskIndex);
          assert(
            uiContext,
            "subTask requires uiContext from previous non-subTask task"
          );
        } else {
          const forceRefresh = task.type === "Insight";
          uiContext = await this.getUiContext({ forceRefresh });
        }
        task.uiContext = uiContext;
        const executorContext = {
          task,
          element: previousFindOutput == null ? void 0 : previousFindOutput.element,
          uiContext
        };
        if (task.type === "Insight") {
          assert(
            task.subType === "Query" || task.subType === "Assert" || task.subType === "WaitFor" || task.subType === "Boolean" || task.subType === "Number" || task.subType === "String",
            `unsupported service subType: ${task.subType}`
          );
          returnValue = await task.executor(param3, executorContext);
        } else if (task.type === "Planning") {
          returnValue = await task.executor(param3, executorContext);
          if (task.subType === "Locate") {
            previousFindOutput = returnValue == null ? void 0 : returnValue.output;
          }
        } else if (task.type === "Action Space") {
          returnValue = await task.executor(param3, executorContext);
        } else {
          console.warn(
            `unsupported task type: ${task.type}, will try to execute it directly`
          );
          returnValue = await task.executor(param3, executorContext);
        }
        const isLastTask = taskIndex === this.tasks.length - 1;
        if (isLastTask) {
          const screenshot = await this.captureScreenshot();
          this.attachRecorderItem(task, screenshot, "after-calling");
        }
        Object.assign(task, returnValue);
        task.status = "finished";
        task.timing.end = Date.now();
        task.timing.cost = task.timing.end - task.timing.start;
        await this.emitOnTaskUpdate();
        taskIndex++;
      } catch (e) {
        successfullyCompleted = false;
        task.error = e;
        task.errorMessage = (e == null ? void 0 : e.message) || (typeof e === "string" ? e : "error-without-message");
        task.errorStack = e.stack;
        task.status = "failed";
        task.timing.end = Date.now();
        task.timing.cost = task.timing.end - task.timing.start;
        await this.emitOnTaskUpdate();
        break;
      }
    }
    for (let i = taskIndex + 1; i < this.tasks.length; i++) {
      this.tasks[i].status = "cancelled";
    }
    if (taskIndex + 1 < this.tasks.length) {
      await this.emitOnTaskUpdate();
    }
    let finalizeError;
    if (!successfullyCompleted) {
      this.status = "error";
      const errorTask = this.latestErrorTask();
      const messageBase = (errorTask == null ? void 0 : errorTask.errorMessage) || ((errorTask == null ? void 0 : errorTask.error) ? String(errorTask.error) : "Task execution failed");
      const stack = errorTask == null ? void 0 : errorTask.errorStack;
      const message = stack ? `${messageBase}
${stack}` : messageBase;
      finalizeError = new TaskExecutionError(message, this, errorTask, {
        cause: errorTask == null ? void 0 : errorTask.error
      });
      await this.emitOnTaskUpdate(finalizeError);
    } else {
      this.status = "completed";
      await this.emitOnTaskUpdate();
    }
    if (finalizeError) {
      throw finalizeError;
    }
    if (this.tasks.length) {
      const outputIndex = Math.min(taskIndex, this.tasks.length - 1);
      const { thought, output } = this.tasks[outputIndex];
      return {
        thought,
        output
      };
    }
  }
  isInErrorState() {
    return this.status === "error";
  }
  latestErrorTask() {
    if (this.status !== "error") {
      return null;
    }
    for (let i = this.tasks.length - 1; i >= 0; i--) {
      if (this.tasks[i].status === "failed") {
        return this.tasks[i];
      }
    }
    return null;
  }
  dump() {
    return new ExecutionDump({
      logTime: Date.now(),
      name: this.name,
      tasks: this.tasks
    });
  }
  async appendErrorPlan(errorMsg) {
    const errorTask = {
      type: "Action Space",
      subType: "Error",
      param: {
        thought: errorMsg
      },
      thought: errorMsg,
      executor: async () => {
        throw new Error(errorMsg || "error without thought");
      }
    };
    await this.appendAndFlush(errorTask);
    return {
      output: void 0,
      runner: this
    };
  }
}
class TaskExecutionError extends Error {
  constructor(message, runner, errorTask, options2) {
    super(message, options2);
    __publicField(this, "runner");
    __publicField(this, "errorTask");
    this.runner = runner;
    this.errorTask = errorTask;
  }
}
class ExecutionSession {
  constructor(name, contextProvider, options2) {
    __publicField(this, "runner");
    this.runner = new TaskRunner(name, contextProvider, options2);
  }
  async append(tasks, options2) {
    await this.runner.append(tasks, options2);
  }
  async appendAndRun(tasks, options2) {
    return this.runner.appendAndFlush(tasks, options2);
  }
  async run(options2) {
    return this.runner.flush(options2);
  }
  isInErrorState() {
    return this.runner.isInErrorState();
  }
  latestErrorTask() {
    return this.runner.latestErrorTask();
  }
  appendErrorPlan(errorMsg) {
    return this.runner.appendErrorPlan(errorMsg);
  }
  getRunner() {
    return this.runner;
  }
}
const debug$g = getDebug("agent:task-builder");
function hasNonEmptyCache(cache) {
  return cache !== null && cache !== void 0 && typeof cache === "object" && Object.keys(cache).length > 0;
}
function locatePlanForLocate(param3) {
  const locate = typeof param3 === "string" ? { prompt: param3 } : param3;
  const locatePlan = {
    type: "Locate",
    param: locate,
    thought: ""
  };
  return locatePlan;
}
class TaskBuilder {
  constructor({
    interfaceInstance,
    service: service2,
    taskCache,
    actionSpace,
    waitAfterAction
  }) {
    __publicField(this, "interface");
    __publicField(this, "service");
    __publicField(this, "taskCache");
    __publicField(this, "actionSpace");
    __publicField(this, "waitAfterAction");
    this.interface = interfaceInstance;
    this.service = service2;
    this.taskCache = taskCache;
    this.actionSpace = actionSpace;
    this.waitAfterAction = waitAfterAction;
  }
  async build(plans, modelConfigForPlanning, modelConfigForDefaultIntent, options2) {
    const tasks = [];
    const cacheable = options2 == null ? void 0 : options2.cacheable;
    const context2 = {
      tasks,
      modelConfigForPlanning,
      modelConfigForDefaultIntent,
      cacheable,
      subTask: !!(options2 == null ? void 0 : options2.subTask)
    };
    const planHandlers = /* @__PURE__ */ new Map([
      [
        "Locate",
        (plan2) => this.handleLocatePlan(
          plan2,
          context2
        )
      ],
      ["Finished", (plan2) => this.handleFinishedPlan(plan2, context2)]
    ]);
    const defaultHandler = (plan2) => this.handleActionPlan(plan2, context2);
    for (const plan2 of plans) {
      const handler = planHandlers.get(plan2.type) ?? defaultHandler;
      await handler(plan2);
    }
    return {
      tasks
    };
  }
  handleFinishedPlan(plan2, context2) {
    const taskActionFinished = {
      type: "Action Space",
      subType: "Finished",
      param: null,
      thought: plan2.thought,
      subTask: context2.subTask || void 0,
      executor: async () => {
      }
    };
    context2.tasks.push(taskActionFinished);
  }
  async handleLocatePlan(plan2, context2) {
    const taskLocate = this.createLocateTask(plan2, plan2.param, context2);
    context2.tasks.push(taskLocate);
  }
  async handleActionPlan(plan2, context2) {
    const planType = plan2.type;
    const actionSpace = this.actionSpace;
    const action = actionSpace.find((item) => item.name === planType);
    const param3 = plan2.param;
    if (!action) {
      throw new Error(`Action type '${planType}' not found`);
    }
    const locateFields = action ? findAllLocatorField(action.paramSchema) : [];
    const requiredLocateFields = action ? findAllLocatorField(action.paramSchema, true) : [];
    locateFields.forEach((field2) => {
      if (param3[field2]) {
        const locatePlan = locatePlanForLocate(param3[field2]);
        debug$g(
          "will prepend locate param for field",
          `action.type=${planType}`,
          `param=${JSON.stringify(param3[field2])}`,
          `locatePlan=${JSON.stringify(locatePlan)}`,
          `hasBbox=${ifPlanLocateParamIsBbox(param3[field2])}`
        );
        const locateTask = this.createLocateTask(
          locatePlan,
          param3[field2],
          context2,
          (result) => {
            param3[field2] = result;
          }
        );
        context2.tasks.push(locateTask);
      } else {
        assert(
          !requiredLocateFields.includes(field2),
          `Required locate field '${field2}' is not provided for action ${planType}`
        );
        debug$g(`field '${field2}' is not provided for action ${planType}`);
      }
    });
    const task = {
      type: "Action Space",
      subType: planType,
      thought: plan2.thought,
      param: plan2.param,
      subTask: context2.subTask || void 0,
      executor: async (param22, taskContext) => {
        var _a3;
        debug$g(
          "executing action",
          planType,
          param22,
          `taskContext.element.center: ${(_a3 = taskContext.element) == null ? void 0 : _a3.center}`
        );
        const uiContext = taskContext.uiContext;
        assert(uiContext, "uiContext is required for Action task");
        requiredLocateFields.forEach((field2) => {
          assert(
            param22[field2],
            `field '${field2}' is required for action ${planType} but not provided. Cannot execute action ${planType}.`
          );
        });
        try {
          await Promise.all([
            (async () => {
              if (this.interface.beforeInvokeAction) {
                debug$g('will call "beforeInvokeAction" for interface');
                await this.interface.beforeInvokeAction(action.name, param22);
                debug$g('called "beforeInvokeAction" for interface');
              }
            })(),
            sleep(200)
          ]);
        } catch (originalError) {
          const originalMessage = (originalError == null ? void 0 : originalError.message) || String(originalError);
          throw new Error(
            `error in running beforeInvokeAction for ${action.name}: ${originalMessage}`,
            { cause: originalError }
          );
        }
        if (action.paramSchema) {
          try {
            param22 = parseActionParam(param22, action.paramSchema);
          } catch (error2) {
            throw new Error(
              `Invalid parameters for action ${action.name}: ${error2.message}
Parameters: ${JSON.stringify(param22)}`,
              { cause: error2 }
            );
          }
        }
        debug$g("calling action", action.name);
        const actionFn = action.call.bind(this.interface);
        const actionResult = await actionFn(param22, taskContext);
        debug$g("called action", action.name, "result:", actionResult);
        const delayAfterRunner = action.delayAfterRunner ?? this.waitAfterAction ?? 300;
        if (delayAfterRunner > 0) {
          await sleep(delayAfterRunner);
        }
        try {
          if (this.interface.afterInvokeAction) {
            debug$g('will call "afterInvokeAction" for interface');
            await this.interface.afterInvokeAction(action.name, param22);
            debug$g('called "afterInvokeAction" for interface');
          }
        } catch (originalError) {
          const originalMessage = (originalError == null ? void 0 : originalError.message) || String(originalError);
          throw new Error(
            `error in running afterInvokeAction for ${action.name}: ${originalMessage}`,
            { cause: originalError }
          );
        }
        return {
          output: actionResult
        };
      }
    };
    context2.tasks.push(task);
  }
  createLocateTask(plan2, detailedLocateParam, context2, onResult) {
    const { cacheable, modelConfigForDefaultIntent } = context2;
    let locateParam = detailedLocateParam;
    if (typeof locateParam === "string") {
      locateParam = {
        prompt: locateParam
      };
    }
    if (cacheable !== void 0) {
      locateParam = {
        ...locateParam,
        cacheable
      };
    }
    const taskLocator = {
      type: "Planning",
      subType: "Locate",
      subTask: context2.subTask || void 0,
      param: locateParam,
      thought: plan2.thought,
      executor: async (param3, taskContext) => {
        var _a3, _b, _c, _d, _e;
        const { task } = taskContext;
        let { uiContext } = taskContext;
        assert(
          (param3 == null ? void 0 : param3.prompt) || (param3 == null ? void 0 : param3.bbox),
          `No prompt or id or position or bbox to locate, param=${JSON.stringify(
            param3
          )}`
        );
        if (!uiContext) {
          uiContext = await this.service.contextRetrieverFn();
        }
        assert(uiContext, "uiContext is required for Service task");
        let locateDump;
        let locateResult;
        const applyDump = (dump2) => {
          var _a4, _b2, _c2, _d2;
          if (!dump2) {
            return;
          }
          locateDump = dump2;
          task.log = {
            dump: dump2,
            rawResponse: (_a4 = dump2.taskInfo) == null ? void 0 : _a4.rawResponse
          };
          task.usage = (_b2 = dump2.taskInfo) == null ? void 0 : _b2.usage;
          if ((_c2 = dump2.taskInfo) == null ? void 0 : _c2.searchAreaUsage) {
            task.searchAreaUsage = dump2.taskInfo.searchAreaUsage;
          }
          if ((_d2 = dump2.taskInfo) == null ? void 0 : _d2.reasoning_content) {
            task.reasoning_content = dump2.taskInfo.reasoning_content;
          }
        };
        const elementFromBbox = ifPlanLocateParamIsBbox(param3) ? matchElementFromPlan(param3) : void 0;
        const isPlanHit = !!elementFromBbox;
        let rectFromXpath;
        if (!isPlanHit && param3.xpath && this.interface.rectMatchesCacheFeature) {
          try {
            rectFromXpath = await this.interface.rectMatchesCacheFeature({
              xpaths: [param3.xpath]
            });
          } catch {
          }
        }
        const elementFromXpath = rectFromXpath ? generateElementByRect(
          rectFromXpath,
          typeof param3.prompt === "string" ? param3.prompt : ((_a3 = param3.prompt) == null ? void 0 : _a3.prompt) || ""
        ) : void 0;
        const isXpathHit = !!elementFromXpath;
        const cachePrompt = param3.prompt;
        const locateCacheRecord = (_b = this.taskCache) == null ? void 0 : _b.matchLocateCache(cachePrompt);
        const cacheEntry = (_c = locateCacheRecord == null ? void 0 : locateCacheRecord.cacheContent) == null ? void 0 : _c.cache;
        const elementFromCache = isPlanHit || isXpathHit ? null : await matchElementFromCache(
          {
            taskCache: this.taskCache,
            interfaceInstance: this.interface
          },
          cacheEntry,
          cachePrompt,
          param3.cacheable
        );
        const isCacheHit = !!elementFromCache;
        let elementFromAiLocate;
        if (!isXpathHit && !isCacheHit && !isPlanHit) {
          try {
            locateResult = await this.service.locate(
              param3,
              {
                context: uiContext
              },
              modelConfigForDefaultIntent
            );
            applyDump(locateResult.dump);
            elementFromAiLocate = locateResult.element;
          } catch (error2) {
            if (error2 instanceof ServiceError) {
              applyDump(error2.dump);
            }
            throw error2;
          }
        }
        const element = elementFromBbox || elementFromXpath || elementFromCache || elementFromAiLocate;
        const locateCacheAlreadyExists = hasNonEmptyCache(
          (_d = locateCacheRecord == null ? void 0 : locateCacheRecord.cacheContent) == null ? void 0 : _d.cache
        );
        let currentCacheEntry;
        if (element && this.taskCache && !isCacheHit && (!isPlanHit || !locateCacheAlreadyExists) && (param3 == null ? void 0 : param3.cacheable) !== false) {
          if (this.interface.cacheFeatureForPoint) {
            try {
              const feature = await this.interface.cacheFeatureForPoint(
                element.center,
                {
                  targetDescription: typeof param3.prompt === "string" ? param3.prompt : (_e = param3.prompt) == null ? void 0 : _e.prompt,
                  modelConfig: modelConfigForDefaultIntent
                }
              );
              if (hasNonEmptyCache(feature)) {
                debug$g(
                  "update cache, prompt: %s, cache: %o",
                  cachePrompt,
                  feature
                );
                currentCacheEntry = feature;
                this.taskCache.updateOrAppendCacheRecord(
                  {
                    type: "locate",
                    prompt: cachePrompt,
                    cache: feature
                  },
                  locateCacheRecord
                );
              } else {
                debug$g(
                  "no cache data returned, skip cache update, prompt: %s",
                  cachePrompt
                );
              }
            } catch (error2) {
              debug$g("cacheFeatureForPoint failed: %s", error2);
            }
          } else {
            debug$g("cacheFeatureForPoint is not supported, skip cache update");
          }
        }
        if (!element) {
          if (locateDump) {
            throw new ServiceError(
              `Element not found : ${param3.prompt}`,
              locateDump
            );
          }
          throw new Error(`Element not found: ${param3.prompt}`);
        }
        let hitBy;
        if (isPlanHit) {
          hitBy = {
            from: "Plan",
            context: {
              bbox: param3.bbox
            }
          };
        } else if (isXpathHit) {
          hitBy = {
            from: "User expected path",
            context: {
              xpath: param3.xpath
            }
          };
        } else if (isCacheHit) {
          hitBy = {
            from: "Cache",
            context: {
              cacheEntry,
              cacheToSave: currentCacheEntry
            }
          };
        }
        onResult == null ? void 0 : onResult(element);
        return {
          output: {
            element
          },
          hitBy
        };
      }
    };
    return taskLocator;
  }
}
function typeStr(task) {
  return task.subType || task.type;
}
function locateParamStr(locate) {
  if (!locate) {
    return "";
  }
  if (typeof locate === "string") {
    return locate;
  }
  if (typeof locate === "object") {
    if (typeof locate.prompt === "object" && locate.prompt !== null && locate.prompt.prompt) {
      const prompt = locate.prompt.prompt;
      return prompt;
    }
    if (typeof locate.prompt === "string") {
      return locate.prompt;
    }
    if (typeof locate.description === "string") {
      return locate.description;
    }
  }
  return "";
}
function scrollParamStr(scrollParam) {
  if (!scrollParam) {
    return "";
  }
  return `${scrollParam.direction || "down"}, ${scrollParam.scrollType || "singleAction"}, ${scrollParam.distance || "distance-not-set"}`;
}
function pullParamStr(pullParam) {
  if (!pullParam) {
    return "";
  }
  const parts = [];
  parts.push(`direction: ${pullParam.direction || "down"}`);
  if (pullParam.distance) {
    parts.push(`distance: ${pullParam.distance}`);
  }
  if (pullParam.duration) {
    parts.push(`duration: ${pullParam.duration}ms`);
  }
  return parts.join(", ");
}
function extractInsightParam(taskParam) {
  if (!taskParam) {
    return { content: "" };
  }
  const extractImages = (source) => {
    var _a3;
    return ((_a3 = source == null ? void 0 : source.multimodalPrompt) == null ? void 0 : _a3.images) && Array.isArray(source.multimodalPrompt.images) ? source.multimodalPrompt.images : void 0;
  };
  const toContent = (value) => typeof value === "string" ? value : JSON.stringify(value);
  if (taskParam.demand) {
    return {
      content: toContent(taskParam.demand),
      images: extractImages(taskParam)
    };
  }
  if (taskParam.assertion) {
    return {
      content: toContent(taskParam.assertion),
      images: extractImages(taskParam)
    };
  }
  if (taskParam.dataDemand) {
    const { dataDemand } = taskParam;
    if (typeof dataDemand === "string") {
      return { content: dataDemand };
    }
    if (typeof dataDemand === "object") {
      return {
        content: toContent(dataDemand.demand || dataDemand),
        images: extractImages(dataDemand)
      };
    }
  }
  return { content: "" };
}
function taskTitleStr(type3, prompt) {
  if (prompt) {
    return `${type3} - ${prompt}`;
  }
  return type3;
}
function paramStr(task) {
  var _a3, _b, _c, _d, _e, _f, _g2, _h, _i;
  let value;
  if (task.type === "Planning") {
    if (task.subType === "Locate") {
      value = locateParamStr(task == null ? void 0 : task.param);
    } else {
      const planTask = task;
      value = ((_a3 = planTask.output) == null ? void 0 : _a3.log) || ((_b = planTask.param) == null ? void 0 : _b.userInstruction);
    }
  }
  if (task.type === "Insight") {
    value = extractInsightParam(task == null ? void 0 : task.param).content;
  }
  if (task.type === "Action Space") {
    const locate = (_c = task == null ? void 0 : task.param) == null ? void 0 : _c.locate;
    const locateStr = locate ? locateParamStr(locate) : "";
    value = task.thought || "";
    if (typeof ((_d = task == null ? void 0 : task.param) == null ? void 0 : _d.timeMs) === "number") {
      value = `${(_e = task == null ? void 0 : task.param) == null ? void 0 : _e.timeMs}ms`;
    } else if (typeof ((_f = task == null ? void 0 : task.param) == null ? void 0 : _f.scrollType) === "string") {
      value = scrollParamStr(task == null ? void 0 : task.param);
    } else if (typeof ((_g2 = task == null ? void 0 : task.param) == null ? void 0 : _g2.direction) === "string" && (task == null ? void 0 : task.subType) === "PullGesture") {
      value = pullParamStr(task == null ? void 0 : task.param);
    } else if (typeof ((_h = task == null ? void 0 : task.param) == null ? void 0 : _h.value) !== "undefined") {
      value = (_i = task == null ? void 0 : task.param) == null ? void 0 : _i.value;
    } else if ((task == null ? void 0 : task.param) && typeof (task == null ? void 0 : task.param) === "object" && Object.keys((task == null ? void 0 : task.param) || {}).length > 0) {
      value = task == null ? void 0 : task.param;
    }
    if (locateStr) {
      if (value && typeof value !== "object") {
        value = `${locateStr} - ${value}`;
      } else {
        value = locateStr;
      }
    }
  }
  if (typeof value === "undefined") return "";
  if (typeof value === "string") return value;
  if (typeof value === "object") {
    const locateStr = locateParamStr(value);
    if (locateStr) {
      return locateStr;
    }
    return JSON.stringify(value, void 0, 2);
  }
  return String(value);
}
const debug$f = getDebug("device-task-executor");
const maxErrorCountAllowedInOnePlanningLoop = 5;
class TaskExecutor {
  constructor(interfaceInstance, service2, opts) {
    __publicField(this, "interface");
    __publicField(this, "service");
    __publicField(this, "taskCache");
    __publicField(this, "providedActionSpace");
    __publicField(this, "taskBuilder");
    __publicField(this, "conversationHistory");
    __publicField(this, "onTaskStartCallback");
    __publicField(this, "hooks");
    __publicField(this, "replanningCycleLimit");
    __publicField(this, "waitAfterAction");
    __publicField(this, "useDeviceTimestamp");
    this.interface = interfaceInstance;
    this.service = service2;
    this.taskCache = opts.taskCache;
    this.onTaskStartCallback = opts == null ? void 0 : opts.onTaskStart;
    this.replanningCycleLimit = opts.replanningCycleLimit;
    this.waitAfterAction = opts.waitAfterAction;
    this.useDeviceTimestamp = opts.useDeviceTimestamp;
    this.hooks = opts.hooks;
    this.conversationHistory = new ConversationHistory();
    this.providedActionSpace = opts.actionSpace;
    this.taskBuilder = new TaskBuilder({
      interfaceInstance,
      service: service2,
      taskCache: opts.taskCache,
      actionSpace: this.getActionSpace(),
      waitAfterAction: opts.waitAfterAction
    });
  }
  // @deprecated use .interface instead
  get page() {
    return this.interface;
  }
  createExecutionSession(title, options2) {
    var _a3;
    return new ExecutionSession(
      title,
      () => Promise.resolve(this.service.contextRetrieverFn()),
      {
        onTaskStart: this.onTaskStartCallback,
        tasks: options2 == null ? void 0 : options2.tasks,
        onTaskUpdate: (_a3 = this.hooks) == null ? void 0 : _a3.onTaskUpdate
      }
    );
  }
  getActionSpace() {
    return this.providedActionSpace;
  }
  /**
   * Get a readable time string using device time when configured.
   * This method respects the useDeviceTimestamp configuration.
   * @param format - Optional format string
   * @returns A formatted time string
   */
  async getTimeString(format2) {
    const timestamp2 = await getCurrentTime(
      this.interface,
      this.useDeviceTimestamp
    );
    return getReadableTimeString(format2, timestamp2);
  }
  async convertPlanToExecutable(plans, modelConfigForPlanning, modelConfigForDefaultIntent, options2) {
    return this.taskBuilder.build(
      plans,
      modelConfigForPlanning,
      modelConfigForDefaultIntent,
      options2
    );
  }
  async loadYamlFlowAsPlanning(userInstruction, yamlString) {
    const session = this.createExecutionSession(
      taskTitleStr("Act", userInstruction)
    );
    const task = {
      type: "Planning",
      subType: "LoadYaml",
      param: {
        userInstruction
      },
      executor: async (param3, executorContext) => {
        const { uiContext } = executorContext;
        assert(uiContext, "uiContext is required for Planning task");
        return {
          output: {
            actions: [],
            shouldContinuePlanning: false,
            log: "",
            yamlString
          },
          cache: {
            hit: true
          },
          hitBy: {
            from: "Cache",
            context: {
              yamlString
            }
          }
        };
      }
    };
    const runner = session.getRunner();
    await session.appendAndRun(task);
    return {
      runner
    };
  }
  async runPlans(title, plans, modelConfigForPlanning, modelConfigForDefaultIntent) {
    const session = this.createExecutionSession(title);
    const { tasks } = await this.convertPlanToExecutable(
      plans,
      modelConfigForPlanning,
      modelConfigForDefaultIntent
    );
    const runner = session.getRunner();
    const result = await session.appendAndRun(tasks);
    const { output } = result ?? {};
    return {
      output,
      runner
    };
  }
  async action(userPrompt, modelConfigForPlanning, modelConfigForDefaultIntent, includeBboxInPlanning, aiActContext, cacheable, replanningCycleLimitOverride, imagesIncludeCount, deepThink, fileChooserAccept) {
    return withFileChooser(this.interface, fileChooserAccept, async () => {
      return this.runAction(
        userPrompt,
        modelConfigForPlanning,
        modelConfigForDefaultIntent,
        includeBboxInPlanning,
        aiActContext,
        cacheable,
        replanningCycleLimitOverride,
        imagesIncludeCount,
        deepThink
      );
    });
  }
  async runAction(userPrompt, modelConfigForPlanning, modelConfigForDefaultIntent, includeBboxInPlanning, aiActContext, cacheable, replanningCycleLimitOverride, imagesIncludeCount, deepThink) {
    this.conversationHistory.reset();
    const session = this.createExecutionSession(
      taskTitleStr("Act", userPrompt)
    );
    const runner = session.getRunner();
    let replanCount = 0;
    const yamlFlow = [];
    const replanningCycleLimit = replanningCycleLimitOverride ?? this.replanningCycleLimit;
    assert(
      replanningCycleLimit !== void 0,
      "replanningCycleLimit is required for TaskExecutor.action"
    );
    let errorCountInOnePlanningLoop = 0;
    let outputString;
    while (true) {
      const subGoalStatus = this.conversationHistory.subGoalsToText() || void 0;
      const memoriesStatus = this.conversationHistory.memoriesToText() || void 0;
      const result = await session.appendAndRun(
        {
          type: "Planning",
          subType: "Plan",
          param: {
            userInstruction: userPrompt,
            aiActContext,
            imagesIncludeCount,
            deepThink,
            ...subGoalStatus ? { subGoalStatus } : {},
            ...memoriesStatus ? { memoriesStatus } : {}
          },
          executor: async (param3, executorContext) => {
            const { uiContext } = executorContext;
            assert(uiContext, "uiContext is required for Planning task");
            const { modelFamily } = modelConfigForPlanning;
            const actionSpace = this.getActionSpace();
            debug$f(
              "actionSpace for this interface is:",
              actionSpace.map((action) => action.name).join(", ")
            );
            assert(Array.isArray(actionSpace), "actionSpace must be an array");
            if (actionSpace.length === 0) {
              console.warn(
                `ActionSpace for ${this.interface.interfaceType} is empty. This may lead to unexpected behavior.`
              );
            }
            const planImpl = isUITars(modelFamily) ? uiTarsPlanning : isAutoGLM(modelFamily) ? autoGLMPlanning : plan;
            let planResult2;
            try {
              planResult2 = await planImpl(param3.userInstruction, {
                context: uiContext,
                actionContext: param3.aiActContext,
                interfaceType: this.interface.interfaceType,
                actionSpace,
                modelConfig: modelConfigForPlanning,
                conversationHistory: this.conversationHistory,
                includeBbox: includeBboxInPlanning,
                imagesIncludeCount,
                deepThink
              });
            } catch (planError) {
              if (planError instanceof AIResponseParseError) {
                executorContext.task.usage = planError.usage;
                executorContext.task.log = {
                  ...executorContext.task.log || {},
                  rawResponse: planError.rawResponse
                };
              }
              throw planError;
            }
            debug$f("planResult", JSON.stringify(planResult2, null, 2));
            const {
              actions,
              thought,
              log: log2,
              memory,
              error: error2,
              usage,
              rawResponse,
              reasoning_content,
              finalizeSuccess,
              finalizeMessage,
              updateSubGoals,
              markFinishedIndexes
            } = planResult2;
            outputString = finalizeMessage;
            executorContext.task.log = {
              ...executorContext.task.log || {},
              rawResponse
            };
            executorContext.task.usage = usage;
            executorContext.task.reasoning_content = reasoning_content;
            executorContext.task.output = {
              actions: actions || [],
              log: log2,
              thought,
              memory,
              yamlFlow: planResult2.yamlFlow,
              output: finalizeMessage,
              shouldContinuePlanning: planResult2.shouldContinuePlanning,
              updateSubGoals,
              markFinishedIndexes
            };
            executorContext.uiContext = uiContext;
            assert(!error2, `Failed to continue: ${error2}
${log2 || ""}`);
            if (finalizeSuccess === false) {
              assert(
                false,
                `Task failed: ${finalizeMessage || "No error message provided"}
${log2 || ""}`
              );
            }
            return {
              cache: {
                hit: false
              }
            };
          }
        },
        {
          allowWhenError: true
        }
      );
      const planResult = result == null ? void 0 : result.output;
      const plans = (planResult == null ? void 0 : planResult.actions) || [];
      yamlFlow.push(...(planResult == null ? void 0 : planResult.yamlFlow) || []);
      let executables;
      try {
        executables = await this.convertPlanToExecutable(
          plans,
          modelConfigForPlanning,
          modelConfigForDefaultIntent,
          {
            cacheable,
            subTask: true
          }
        );
      } catch (error2) {
        return session.appendErrorPlan(
          `Error converting plans to executable tasks: ${error2}, plans: ${JSON.stringify(
            plans
          )}`
        );
      }
      if (this.conversationHistory.pendingFeedbackMessage) {
        console.warn(
          "unconsumed pending feedback message detected, this may lead to unexpected planning result:",
          this.conversationHistory.pendingFeedbackMessage
        );
      }
      const initialTimeString = await this.getTimeString();
      this.conversationHistory.pendingFeedbackMessage += `Current time: ${initialTimeString}`;
      try {
        await session.appendAndRun(executables.tasks);
      } catch (error2) {
        errorCountInOnePlanningLoop++;
        const timeString = await this.getTimeString();
        this.conversationHistory.pendingFeedbackMessage = `Time: ${timeString}, Error executing running tasks: ${(error2 == null ? void 0 : error2.message) || String(error2)}`;
        debug$f(
          "error when executing running tasks, but continue to run if it is not too many errors:",
          error2 instanceof Error ? error2.message : String(error2),
          "current error count in one planning loop:",
          errorCountInOnePlanningLoop
        );
      }
      if (errorCountInOnePlanningLoop > maxErrorCountAllowedInOnePlanningLoop) {
        return session.appendErrorPlan("Too many errors in one planning loop");
      }
      if (!(planResult == null ? void 0 : planResult.shouldContinuePlanning)) {
        break;
      }
      ++replanCount;
      if (replanCount > replanningCycleLimit) {
        const errorMsg = `Replanned ${replanningCycleLimit} times, exceeding the limit. Please configure a larger value for replanningCycleLimit (or use MIDSCENE_REPLANNING_CYCLE_LIMIT) to handle more complex tasks.`;
        return session.appendErrorPlan(errorMsg);
      }
      if (!this.conversationHistory.pendingFeedbackMessage) {
        const timeString = await this.getTimeString();
        this.conversationHistory.pendingFeedbackMessage = `Time: ${timeString}, I have finished the action previously planned.`;
      }
    }
    return {
      output: {
        yamlFlow,
        output: outputString
      },
      runner
    };
  }
  createTypeQueryTask(type3, demand, modelConfig, opt, multimodalPrompt) {
    const queryTask = {
      type: "Insight",
      subType: type3,
      param: {
        dataDemand: multimodalPrompt ? {
          demand,
          multimodalPrompt
        } : demand
        // for user param presentation in report right sidebar
      },
      executor: async (param3, taskContext) => {
        const { task } = taskContext;
        let queryDump;
        const applyDump = (dump22) => {
          var _a3, _b, _c;
          queryDump = dump22;
          task.log = {
            dump: dump22,
            rawResponse: (_a3 = dump22.taskInfo) == null ? void 0 : _a3.rawResponse
          };
          task.usage = (_b = dump22.taskInfo) == null ? void 0 : _b.usage;
          if ((_c = dump22.taskInfo) == null ? void 0 : _c.reasoning_content) {
            task.reasoning_content = dump22.taskInfo.reasoning_content;
          }
        };
        const uiContext = taskContext.uiContext;
        assert(uiContext, "uiContext is required for Query task");
        const ifTypeRestricted = type3 !== "Query";
        let demandInput = demand;
        let keyOfResult = "result";
        if (ifTypeRestricted && (type3 === "Assert" || type3 === "WaitFor")) {
          keyOfResult = "StatementIsTruthy";
          const booleanPrompt = type3 === "Assert" ? `Boolean, whether the following statement is true: ${demand}` : `Boolean, the user wants to do some 'wait for' operation, please check whether the following statement is true: ${demand}`;
          demandInput = {
            [keyOfResult]: booleanPrompt
          };
        } else if (ifTypeRestricted) {
          demandInput = {
            [keyOfResult]: `${type3}, ${demand}`
          };
        }
        let extractResult;
        let extraPageDescription = "";
        if ((opt == null ? void 0 : opt.domIncluded) && this.interface.getElementsNodeTree) {
          debug$f("appending tree info for page");
          const tree = await this.interface.getElementsNodeTree();
          extraPageDescription = await descriptionOfTree(
            tree,
            200,
            false,
            (opt == null ? void 0 : opt.domIncluded) === "visible-only"
          );
        }
        try {
          extractResult = await this.service.extract(
            demandInput,
            modelConfig,
            opt,
            extraPageDescription,
            multimodalPrompt,
            uiContext
          );
        } catch (error2) {
          if (error2 instanceof ServiceError) {
            applyDump(error2.dump);
          }
          throw error2;
        }
        const { data, thought, dump: dump2 } = extractResult;
        applyDump(dump2);
        let outputResult = data;
        if (ifTypeRestricted) {
          if (typeof data === "string") {
            outputResult = data;
          } else if (type3 === "WaitFor") {
            if (data === null || data === void 0) {
              outputResult = false;
            } else {
              outputResult = data[keyOfResult];
            }
          } else if (data === null || data === void 0) {
            outputResult = null;
          } else {
            assert(
              (data == null ? void 0 : data[keyOfResult]) !== void 0,
              "No result in query data"
            );
            outputResult = data[keyOfResult];
          }
        }
        if (type3 === "Assert" && !outputResult) {
          task.thought = thought;
          throw new Error(`Assertion failed: ${thought}`);
        }
        return {
          output: outputResult,
          log: queryDump,
          thought
        };
      }
    };
    return queryTask;
  }
  async createTypeQueryExecution(type3, demand, modelConfig, opt, multimodalPrompt) {
    const session = this.createExecutionSession(
      taskTitleStr(
        type3,
        typeof demand === "string" ? demand : JSON.stringify(demand)
      )
    );
    const queryTask = await this.createTypeQueryTask(
      type3,
      demand,
      modelConfig,
      opt,
      multimodalPrompt
    );
    const runner = session.getRunner();
    const result = await session.appendAndRun(queryTask);
    if (!result) {
      throw new Error(
        "result of taskExecutor.flush() is undefined in function createTypeQueryTask"
      );
    }
    const { output, thought } = result;
    return {
      output,
      thought,
      runner
    };
  }
  async waitFor(assertion, opt, modelConfig) {
    const { textPrompt, multimodalPrompt } = parsePrompt(assertion);
    const description = `waitFor: ${textPrompt}`;
    const session = this.createExecutionSession(
      taskTitleStr("WaitFor", description)
    );
    const runner = session.getRunner();
    const {
      timeoutMs,
      checkIntervalMs,
      domIncluded,
      screenshotIncluded,
      ...restOpt
    } = opt;
    const serviceExtractOpt = {
      domIncluded,
      screenshotIncluded,
      ...restOpt
    };
    assert(assertion, "No assertion for waitFor");
    assert(timeoutMs, "No timeoutMs for waitFor");
    assert(checkIntervalMs, "No checkIntervalMs for waitFor");
    assert(
      checkIntervalMs <= timeoutMs,
      `wrong config for waitFor: checkIntervalMs must be less than timeoutMs, config: {checkIntervalMs: ${checkIntervalMs}, timeoutMs: ${timeoutMs}}`
    );
    const overallStartTime = Date.now();
    let lastCheckStart = overallStartTime;
    let errorThought = "";
    while (lastCheckStart - overallStartTime <= timeoutMs) {
      const currentCheckStart = Date.now();
      lastCheckStart = currentCheckStart;
      const queryTask = await this.createTypeQueryTask(
        "WaitFor",
        textPrompt,
        modelConfig,
        serviceExtractOpt,
        multimodalPrompt
      );
      const result = await session.appendAndRun(queryTask);
      if (result == null ? void 0 : result.output) {
        return {
          output: void 0,
          runner
        };
      }
      errorThought = (result == null ? void 0 : result.thought) || !result && `No result from assertion: ${textPrompt}` || `unknown error when waiting for assertion: ${textPrompt}`;
      const now = Date.now();
      if (now - currentCheckStart < checkIntervalMs) {
        const elapsed = now - currentCheckStart;
        const timeRemaining = checkIntervalMs - elapsed;
        const thought = `Check interval is ${checkIntervalMs}ms, ${elapsed}ms elapsed since last check, sleeping for ${timeRemaining}ms`;
        const { tasks: sleepTasks } = await this.convertPlanToExecutable(
          [{ type: "Sleep", param: { timeMs: timeRemaining }, thought }],
          modelConfig,
          modelConfig
        );
        if (sleepTasks[0]) {
          await session.appendAndRun(sleepTasks[0]);
        }
      }
    }
    return session.appendErrorPlan(`waitFor timeout: ${errorThought}`);
  }
}
async function withFileChooser(interfaceInstance, fileChooserAccept, action) {
  if (!(fileChooserAccept == null ? void 0 : fileChooserAccept.length)) {
    return action();
  }
  if (!interfaceInstance.registerFileChooserListener) {
    throw new Error(
      `File upload is not supported on ${interfaceInstance.interfaceType}`
    );
  }
  const handler = async (chooser) => {
    await chooser.accept(fileChooserAccept);
  };
  const { dispose, getError } = await interfaceInstance.registerFileChooserListener(handler);
  try {
    const result = await action();
    const error2 = getError();
    if (error2) {
      throw error2;
    }
    return result;
  } finally {
    dispose();
  }
}
const debug$e = getDebug("agent");
const distanceOfTwoPoints = (p1, p2) => {
  const [x1, y1] = p1;
  const [x2, y2] = p2;
  return Math.round(Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2));
};
const includedInRect = (point, rect) => {
  const [x, y2] = point;
  const { left, top, width, height } = rect;
  return x >= left && x <= left + width && y2 >= top && y2 <= top + height;
};
const defaultServiceExtractOption = {
  domIncluded: false,
  screenshotIncluded: true
};
const CACHE_STRATEGIES = [
  "read-only",
  "read-write",
  "write-only"
];
const isValidCacheStrategy = (strategy) => CACHE_STRATEGIES.some((value) => value === strategy);
const CACHE_STRATEGY_VALUES = CACHE_STRATEGIES.map(
  (value) => `"${value}"`
).join(", ");
const legacyScrollTypeMap = {
  once: "singleAction",
  untilBottom: "scrollToBottom",
  untilTop: "scrollToTop",
  untilRight: "scrollToRight",
  untilLeft: "scrollToLeft"
};
const normalizeScrollType = (scrollType) => {
  if (!scrollType) {
    return scrollType;
  }
  if (scrollType in legacyScrollTypeMap) {
    return legacyScrollTypeMap[scrollType];
  }
  return scrollType;
};
const defaultReplanningCycleLimit = 20;
const defaultVlmUiTarsReplanningCycleLimit = 40;
const defaultAutoGlmReplanningCycleLimit = 100;
class Agent {
  constructor(interfaceInstance, opts) {
    __publicField(this, "interface");
    __publicField(this, "service");
    __publicField(this, "dump");
    __publicField(this, "reportFile");
    __publicField(this, "reportFileName");
    __publicField(this, "reportGenerator");
    __publicField(this, "taskExecutor");
    __publicField(this, "opts");
    /**
     * If true, the agent will not perform any actions
     */
    __publicField(this, "dryMode", false);
    __publicField(this, "onTaskStartTip");
    __publicField(this, "taskCache");
    __publicField(this, "dumpUpdateListeners", []);
    __publicField(this, "destroyed", false);
    __publicField(this, "modelConfigManager");
    /**
     * Frozen page context for consistent AI operations
     */
    __publicField(this, "frozenUIContext");
    /**
     * Flag to track if VL model warning has been shown
     */
    __publicField(this, "hasWarnedNonVLModel", false);
    /**
     * Screenshot scale factor derived from actual screenshot dimensions
     */
    __publicField(this, "screenshotScale");
    /**
     * Internal promise to deduplicate screenshot scale computation
     */
    __publicField(this, "screenshotScalePromise");
    __publicField(this, "executionDumpIndexByRunner", /* @__PURE__ */ new WeakMap());
    __publicField(this, "fullActionSpace");
    var _a3;
    this.interface = interfaceInstance;
    const envReplanningCycleLimit = globalConfigManager.getEnvConfigValueAsNumber(
      OMNI_REPLANNING_CYCLE_LIMIT
    );
    this.opts = Object.assign(
      {
        generateReport: true,
        autoPrintReportMsg: true,
        groupName: "Omni Report",
        groupDescription: ""
      },
      opts || {},
      (opts == null ? void 0 : opts.replanningCycleLimit) === void 0 && envReplanningCycleLimit !== void 0 && !Number.isNaN(envReplanningCycleLimit) ? { replanningCycleLimit: envReplanningCycleLimit } : {}
    );
    const resolvedAiActContext = this.opts.aiActContext ?? this.opts.aiActionContext;
    if (resolvedAiActContext !== void 0) {
      this.opts.aiActContext = resolvedAiActContext;
      (_a3 = this.opts).aiActionContext ?? (_a3.aiActionContext = resolvedAiActContext);
    }
    if ((opts == null ? void 0 : opts.modelConfig) && (typeof (opts == null ? void 0 : opts.modelConfig) !== "object" || Array.isArray(opts.modelConfig))) {
      throw new Error(
        `opts.modelConfig must be a plain object map of env keys to values, but got ${typeof (opts == null ? void 0 : opts.modelConfig)}`
      );
    }
    const hasCustomConfig = (opts == null ? void 0 : opts.modelConfig) || (opts == null ? void 0 : opts.createOpenAIClient);
    this.modelConfigManager = hasCustomConfig ? new ModelConfigManager(opts == null ? void 0 : opts.modelConfig, opts == null ? void 0 : opts.createOpenAIClient) : globalModelConfigManager;
    this.onTaskStartTip = this.opts.onTaskStartTip;
    this.service = new Service$1(async () => {
      return this.getUIContext();
    });
    const cacheConfigObj = this.processCacheConfig(opts || {});
    if (cacheConfigObj) {
      this.taskCache = new TaskCache(
        cacheConfigObj.id,
        cacheConfigObj.enabled,
        void 0,
        // cacheFilePath
        {
          readOnly: cacheConfigObj.readOnly,
          writeOnly: cacheConfigObj.writeOnly
        }
      );
    }
    const baseActionSpace = this.interface.actionSpace();
    this.fullActionSpace = [...baseActionSpace, defineActionSleep()];
    this.taskExecutor = new TaskExecutor(this.interface, this.service, {
      taskCache: this.taskCache,
      onTaskStart: this.callbackOnTaskStartTip.bind(this),
      replanningCycleLimit: this.opts.replanningCycleLimit,
      waitAfterAction: this.opts.waitAfterAction,
      useDeviceTimestamp: this.opts.useDeviceTimestamp,
      actionSpace: this.fullActionSpace,
      hooks: {
        onTaskUpdate: (runner) => {
          const executionDump = runner.dump();
          this.appendExecutionDump(executionDump, runner);
          const dumpString = this.dumpDataString();
          for (const listener2 of this.dumpUpdateListeners) {
            try {
              listener2(dumpString, executionDump);
            } catch (error2) {
              console.error("Error in onDumpUpdate listener", error2);
            }
          }
          this.writeOutActionDumps();
        }
      }
    });
    this.dump = this.resetDump();
    this.reportFileName = (opts == null ? void 0 : opts.reportFileName) || getReportFileName((opts == null ? void 0 : opts.testId) || this.interface.interfaceType || "web");
    this.reportGenerator = ReportGenerator.create(this.reportFileName, {
      generateReport: this.opts.generateReport,
      outputFormat: this.opts.outputFormat,
      autoPrintReportMsg: this.opts.autoPrintReportMsg
    });
  }
  get onDumpUpdate() {
    return this.dumpUpdateListeners[0];
  }
  set onDumpUpdate(callback) {
    this.dumpUpdateListeners = [];
    if (callback) {
      this.dumpUpdateListeners.push(callback);
    }
  }
  get aiActContext() {
    return this.opts.aiActContext ?? this.opts.aiActionContext;
  }
  // @deprecated use .interface instead
  get page() {
    return this.interface;
  }
  /**
   * Ensures VL model warning is shown once when needed
   */
  ensureVLModelWarning() {
    if (!this.hasWarnedNonVLModel && this.interface.interfaceType !== "puppeteer" && this.interface.interfaceType !== "playwright" && this.interface.interfaceType !== "static" && this.interface.interfaceType !== "chrome-extension-proxy" && this.interface.interfaceType !== "page-over-chrome-extension-bridge") {
      this.modelConfigManager.throwErrorIfNonVLModel();
      this.hasWarnedNonVLModel = true;
    }
  }
  /**
   * Lazily compute the ratio between the physical screenshot width and the logical page width
   */
  async getScreenshotScale(context2) {
    if (this.screenshotScale !== void 0) {
      return this.screenshotScale;
    }
    if (!this.screenshotScalePromise) {
      this.screenshotScalePromise = (async () => {
        var _a3;
        const pageWidth = (_a3 = context2.size) == null ? void 0 : _a3.width;
        assert(
          pageWidth && pageWidth > 0,
          `Invalid page width when computing screenshot scale: ${pageWidth}`
        );
        debug$e("will get image info of base64");
        const screenshotBase64 = context2.screenshot.base64;
        const { width: screenshotWidth } = await imageInfoOfBase64(screenshotBase64);
        debug$e("image info of base64 done");
        assert(
          Number.isFinite(screenshotWidth) && screenshotWidth > 0,
          `Invalid screenshot width when computing screenshot scale: ${screenshotWidth}`
        );
        const computedScale = screenshotWidth / pageWidth;
        assert(
          Number.isFinite(computedScale) && computedScale > 0,
          `Invalid computed screenshot scale: ${computedScale}`
        );
        debug$e(
          `Computed screenshot scale ${computedScale} from screenshot width ${screenshotWidth} and page width ${pageWidth}`
        );
        return computedScale;
      })();
    }
    try {
      this.screenshotScale = await this.screenshotScalePromise;
      return this.screenshotScale;
    } finally {
      this.screenshotScalePromise = void 0;
    }
  }
  resolveReplanningCycleLimit(modelConfigForPlanning) {
    if (this.opts.replanningCycleLimit !== void 0) {
      return this.opts.replanningCycleLimit;
    }
    return isUITars(modelConfigForPlanning.modelFamily) ? defaultVlmUiTarsReplanningCycleLimit : isAutoGLM(modelConfigForPlanning.modelFamily) ? defaultAutoGlmReplanningCycleLimit : defaultReplanningCycleLimit;
  }
  async getActionSpace() {
    return this.fullActionSpace;
  }
  async getUIContext(action) {
    this.ensureVLModelWarning();
    if (this.frozenUIContext) {
      debug$e("Using frozen page context for action:", action);
      return this.frozenUIContext;
    }
    let context2;
    if (this.interface.getContext) {
      debug$e("Using page.getContext for action:", action);
      context2 = await this.interface.getContext();
    } else {
      debug$e("Using commonContextParser");
      context2 = await commonContextParser(this.interface, {
        uploadServerUrl: this.modelConfigManager.getUploadTestServerUrl()
      });
    }
    debug$e("will get screenshot scale");
    const computedScreenshotScale = await this.getScreenshotScale(context2);
    debug$e("computedScreenshotScale", computedScreenshotScale);
    if (computedScreenshotScale !== 1) {
      const scaleForLog = Number.parseFloat(computedScreenshotScale.toFixed(4));
      debug$e(
        `Applying computed screenshot scale: ${scaleForLog} (resize to logical size)`
      );
      const targetWidth = Math.round(context2.size.width);
      const targetHeight = Math.round(context2.size.height);
      debug$e(`Resizing screenshot to ${targetWidth}x${targetHeight}`);
      const currentScreenshotBase64 = context2.screenshot.base64;
      const resizedBase64 = await resizeImgBase64(currentScreenshotBase64, {
        width: targetWidth,
        height: targetHeight
      });
      context2.screenshot = ScreenshotItem.create(resizedBase64);
    } else {
      debug$e(`screenshot scale=${computedScreenshotScale}`);
    }
    return context2;
  }
  async _snapshotContext() {
    return await this.getUIContext("locate");
  }
  /**
   * @deprecated Use {@link setAIActContext} instead.
   */
  async setAIActionContext(prompt) {
    await this.setAIActContext(prompt);
  }
  async setAIActContext(prompt) {
    if (this.aiActContext) {
      console.warn(
        "aiActContext is already set, and it is called again, will override the previous setting"
      );
    }
    this.opts.aiActContext = prompt;
    this.opts.aiActionContext = prompt;
  }
  resetDump() {
    this.dump = new GroupedActionDump({
      sdkVersion: getVersion(),
      groupName: this.opts.groupName,
      groupDescription: this.opts.groupDescription,
      executions: [],
      modelBriefs: []
    });
    this.executionDumpIndexByRunner = /* @__PURE__ */ new WeakMap();
    return this.dump;
  }
  appendExecutionDump(execution, runner) {
    const currentDump = this.dump;
    if (runner) {
      const existingIndex = this.executionDumpIndexByRunner.get(runner);
      if (existingIndex !== void 0) {
        currentDump.executions[existingIndex] = execution;
        return;
      }
      currentDump.executions.push(execution);
      this.executionDumpIndexByRunner.set(
        runner,
        currentDump.executions.length - 1
      );
      return;
    }
    currentDump.executions.push(execution);
  }
  dumpDataString(opt) {
    this.dump.groupName = this.opts.groupName;
    this.dump.groupDescription = this.opts.groupDescription;
    if (ifInBrowser || (opt == null ? void 0 : opt.inlineScreenshots)) {
      return this.dump.serializeWithInlineScreenshots();
    }
    return this.dump.serialize();
  }
  reportHTMLString(opt) {
    return reportHTMLContent(this.dumpDataString(opt));
  }
  writeOutActionDumps() {
    this.reportGenerator.onDumpUpdate(this.dump);
    this.reportFile = this.reportGenerator.getReportPath();
  }
  async callbackOnTaskStartTip(task) {
    const param3 = paramStr(task);
    const tip = param3 ? `${typeStr(task)} - ${param3}` : typeStr(task);
    if (this.onTaskStartTip) {
      await this.onTaskStartTip(tip);
    }
  }
  wrapActionInActionSpace(name) {
    return async (param3) => {
      return await this.callActionInActionSpace(name, param3);
    };
  }
  async callActionInActionSpace(type3, opt) {
    debug$e("callActionInActionSpace", type3, ",", opt);
    const actionPlan = {
      type: type3,
      param: opt || {},
      thought: ""
    };
    debug$e("actionPlan", actionPlan);
    const plans = [actionPlan].filter(
      Boolean
    );
    const title = taskTitleStr(
      type3,
      locateParamStr((opt == null ? void 0 : opt.locate) || {})
    );
    const defaultIntentModelConfig = this.modelConfigManager.getModelConfig("default");
    const modelConfigForPlanning = this.modelConfigManager.getModelConfig("planning");
    const { output } = await this.taskExecutor.runPlans(
      title,
      plans,
      modelConfigForPlanning,
      defaultIntentModelConfig
    );
    return output;
  }
  async aiTap(locatePrompt, opt) {
    assert(locatePrompt, "missing locate prompt for tap");
    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);
    const fileChooserAccept = (opt == null ? void 0 : opt.fileChooserAccept) ? this.normalizeFileInput(opt.fileChooserAccept) : void 0;
    return withFileChooser(this.interface, fileChooserAccept, async () => {
      return this.callActionInActionSpace("Tap", {
        locate: detailedLocateParam
      });
    });
  }
  async aiRightClick(locatePrompt, opt) {
    assert(locatePrompt, "missing locate prompt for right click");
    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);
    return this.callActionInActionSpace("RightClick", {
      locate: detailedLocateParam
    });
  }
  async aiDoubleClick(locatePrompt, opt) {
    assert(locatePrompt, "missing locate prompt for double click");
    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);
    return this.callActionInActionSpace("DoubleClick", {
      locate: detailedLocateParam
    });
  }
  async aiHover(locatePrompt, opt) {
    assert(locatePrompt, "missing locate prompt for hover");
    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);
    return this.callActionInActionSpace("Hover", {
      locate: detailedLocateParam
    });
  }
  // Implementation
  async aiInput(locatePromptOrValue, locatePromptOrOpt, optOrUndefined) {
    let value;
    let locatePrompt;
    let opt;
    if (typeof locatePromptOrOpt === "object" && locatePromptOrOpt !== null && "value" in locatePromptOrOpt) {
      locatePrompt = locatePromptOrValue;
      const optWithValue = locatePromptOrOpt;
      value = optWithValue.value;
      opt = optWithValue;
    } else {
      value = locatePromptOrValue;
      locatePrompt = locatePromptOrOpt;
      opt = {
        ...optOrUndefined,
        value
      };
    }
    assert(
      typeof value === "string" || typeof value === "number",
      "input value must be a string or number, use empty string if you want to clear the input"
    );
    assert(locatePrompt, "missing locate prompt for input");
    const detailedLocateParam = buildDetailedLocateParam(locatePrompt, opt);
    const stringValue = typeof value === "number" ? String(value) : value;
    return this.callActionInActionSpace("Input", {
      ...opt || {},
      value: stringValue,
      locate: detailedLocateParam
    });
  }
  // Implementation
  async aiKeyboardPress(locatePromptOrKeyName, locatePromptOrOpt, optOrUndefined) {
    let keyName;
    let locatePrompt;
    let opt;
    if (typeof locatePromptOrOpt === "object" && locatePromptOrOpt !== null && "keyName" in locatePromptOrOpt) {
      locatePrompt = locatePromptOrKeyName;
      opt = locatePromptOrOpt;
    } else {
      keyName = locatePromptOrKeyName;
      locatePrompt = locatePromptOrOpt;
      opt = {
        ...optOrUndefined || {},
        keyName
      };
    }
    assert(opt == null ? void 0 : opt.keyName, "missing keyName for keyboard press");
    const detailedLocateParam = locatePrompt ? buildDetailedLocateParam(locatePrompt, opt) : void 0;
    return this.callActionInActionSpace("KeyboardPress", {
      ...opt || {},
      locate: detailedLocateParam
    });
  }
  // Implementation
  async aiScroll(locatePromptOrScrollParam, locatePromptOrOpt, optOrUndefined) {
    let scrollParam;
    let locatePrompt;
    let opt;
    if (typeof locatePromptOrOpt === "object" && ("direction" in locatePromptOrOpt || "scrollType" in locatePromptOrOpt || "distance" in locatePromptOrOpt)) {
      locatePrompt = locatePromptOrScrollParam;
      opt = locatePromptOrOpt;
    } else {
      scrollParam = locatePromptOrScrollParam;
      locatePrompt = locatePromptOrOpt;
      opt = {
        ...optOrUndefined || {},
        ...scrollParam || {}
      };
    }
    if (opt) {
      const normalizedScrollType = normalizeScrollType(
        opt.scrollType
      );
      if (normalizedScrollType !== opt.scrollType) {
        opt = {
          ...opt || {},
          scrollType: normalizedScrollType
        };
      }
    }
    const detailedLocateParam = buildDetailedLocateParam(
      locatePrompt || "",
      opt
    );
    return this.callActionInActionSpace("Scroll", {
      ...opt || {},
      locate: detailedLocateParam
    });
  }
  async aiAct(taskPrompt, opt) {
    const fileChooserAccept = (opt == null ? void 0 : opt.fileChooserAccept) ? this.normalizeFileInput(opt.fileChooserAccept) : void 0;
    const runAiAct = async () => {
      var _a3, _b, _c, _d;
      const modelConfigForPlanning = this.modelConfigManager.getModelConfig("planning");
      const defaultIntentModelConfig = this.modelConfigManager.getModelConfig("default");
      const deepThink = (opt == null ? void 0 : opt.deepThink) === "unset" ? void 0 : opt == null ? void 0 : opt.deepThink;
      const includeBboxInPlanning = !deepThink && modelConfigForPlanning.modelName === defaultIntentModelConfig.modelName && modelConfigForPlanning.openaiBaseURL === defaultIntentModelConfig.openaiBaseURL;
      debug$e("setting includeBboxInPlanning to", includeBboxInPlanning);
      const cacheable = opt == null ? void 0 : opt.cacheable;
      const replanningCycleLimit = this.resolveReplanningCycleLimit(
        modelConfigForPlanning
      );
      const isVlmUiTars = isUITars(modelConfigForPlanning.modelFamily);
      const isAutoGlm = isAutoGLM(modelConfigForPlanning.modelFamily);
      const matchedCache = isVlmUiTars || isAutoGlm || cacheable === false ? void 0 : (_a3 = this.taskCache) == null ? void 0 : _a3.matchPlanCache(taskPrompt);
      if (matchedCache && ((_b = this.taskCache) == null ? void 0 : _b.isCacheResultUsed) && ((_d = (_c = matchedCache.cacheContent) == null ? void 0 : _c.yamlWorkflow) == null ? void 0 : _d.trim())) {
        await this.taskExecutor.loadYamlFlowAsPlanning(
          taskPrompt,
          matchedCache.cacheContent.yamlWorkflow
        );
        debug$e("matched cache, will call .runYaml to run the action");
        const yaml2 = matchedCache.cacheContent.yamlWorkflow;
        await this.runYaml(yaml2);
        return;
      }
      const imagesIncludeCount = deepThink ? void 0 : 2;
      const { output: actionOutput } = await this.taskExecutor.action(
        taskPrompt,
        modelConfigForPlanning,
        defaultIntentModelConfig,
        includeBboxInPlanning,
        this.aiActContext,
        cacheable,
        replanningCycleLimit,
        imagesIncludeCount,
        deepThink,
        fileChooserAccept
      );
      if (this.taskCache && (actionOutput == null ? void 0 : actionOutput.yamlFlow) && cacheable !== false) {
        const yamlContent = {
          tasks: [
            {
              name: taskPrompt,
              flow: actionOutput.yamlFlow
            }
          ]
        };
        const yamlFlowStr = jsYaml.dump(yamlContent);
        this.taskCache.updateOrAppendCacheRecord(
          {
            type: "plan",
            prompt: taskPrompt,
            yamlWorkflow: yamlFlowStr
          },
          matchedCache
        );
      }
      return actionOutput == null ? void 0 : actionOutput.output;
    };
    return await runAiAct();
  }
  /**
   * @deprecated Use {@link Agent.aiAct} instead.
   */
  async aiAction(taskPrompt, opt) {
    return this.aiAct(taskPrompt, opt);
  }
  async aiQuery(demand, opt = defaultServiceExtractOption) {
    const modelConfig = this.modelConfigManager.getModelConfig("insight");
    const { output } = await this.taskExecutor.createTypeQueryExecution(
      "Query",
      demand,
      modelConfig,
      opt
    );
    return output;
  }
  async aiBoolean(prompt, opt = defaultServiceExtractOption) {
    const modelConfig = this.modelConfigManager.getModelConfig("insight");
    const { textPrompt, multimodalPrompt } = parsePrompt(prompt);
    const { output } = await this.taskExecutor.createTypeQueryExecution(
      "Boolean",
      textPrompt,
      modelConfig,
      opt,
      multimodalPrompt
    );
    return output;
  }
  async aiNumber(prompt, opt = defaultServiceExtractOption) {
    const modelConfig = this.modelConfigManager.getModelConfig("insight");
    const { textPrompt, multimodalPrompt } = parsePrompt(prompt);
    const { output } = await this.taskExecutor.createTypeQueryExecution(
      "Number",
      textPrompt,
      modelConfig,
      opt,
      multimodalPrompt
    );
    return output;
  }
  async aiString(prompt, opt = defaultServiceExtractOption) {
    const modelConfig = this.modelConfigManager.getModelConfig("insight");
    const { textPrompt, multimodalPrompt } = parsePrompt(prompt);
    const { output } = await this.taskExecutor.createTypeQueryExecution(
      "String",
      textPrompt,
      modelConfig,
      opt,
      multimodalPrompt
    );
    return output;
  }
  async aiAsk(prompt, opt = defaultServiceExtractOption) {
    return this.aiString(prompt, opt);
  }
  async describeElementAtPoint(center, opt) {
    const { verifyPrompt = true, retryLimit = 3 } = opt || {};
    let success = false;
    let retryCount = 0;
    let resultPrompt = "";
    let deepThink = (opt == null ? void 0 : opt.deepThink) || false;
    let verifyResult;
    while (!success && retryCount < retryLimit) {
      if (retryCount >= 2) {
        deepThink = true;
      }
      debug$e(
        "aiDescribe",
        center,
        "verifyPrompt",
        verifyPrompt,
        "retryCount",
        retryCount,
        "deepThink",
        deepThink
      );
      const modelConfig = this.modelConfigManager.getModelConfig("insight");
      const text = await this.service.describe(center, modelConfig, {
        deepThink
      });
      debug$e("aiDescribe text", text);
      assert(text.description, `failed to describe element at [${center}]`);
      resultPrompt = text.description;
      verifyResult = await this.verifyLocator(
        resultPrompt,
        void 0,
        center,
        opt
      );
      if (verifyResult.pass) {
        success = true;
      } else {
        retryCount++;
      }
    }
    return {
      prompt: resultPrompt,
      deepThink,
      verifyResult
    };
  }
  async verifyLocator(prompt, locateOpt, expectCenter, verifyLocateOption) {
    debug$e("verifyLocator", prompt, locateOpt, expectCenter, verifyLocateOption);
    const { center: verifyCenter, rect: verifyRect } = await this.aiLocate(
      prompt,
      locateOpt
    );
    const distance = distanceOfTwoPoints(expectCenter, verifyCenter);
    const included = includedInRect(expectCenter, verifyRect);
    const pass = distance <= ((verifyLocateOption == null ? void 0 : verifyLocateOption.centerDistanceThreshold) || 20) || included;
    const verifyResult = {
      pass,
      rect: verifyRect,
      center: verifyCenter,
      centerDistance: distance
    };
    debug$e("aiDescribe verifyResult", verifyResult);
    return verifyResult;
  }
  async aiLocate(prompt, opt) {
    const locateParam = buildDetailedLocateParam(prompt, opt);
    assert(locateParam, "cannot get locate param for aiLocate");
    const locatePlan = locatePlanForLocate(locateParam);
    const plans = [locatePlan];
    const defaultIntentModelConfig = this.modelConfigManager.getModelConfig("default");
    const modelConfigForPlanning = this.modelConfigManager.getModelConfig("planning");
    const { output } = await this.taskExecutor.runPlans(
      taskTitleStr("Locate", locateParamStr(locateParam)),
      plans,
      modelConfigForPlanning,
      defaultIntentModelConfig
    );
    const { element } = output;
    const dprValue = await this.interface.size().dpr;
    const dprEntry = dprValue ? {
      dpr: dprValue
    } : {};
    return {
      rect: element == null ? void 0 : element.rect,
      center: element == null ? void 0 : element.center,
      ...dprEntry
    };
  }
  async aiAssert(assertion, msg, opt) {
    const modelConfig = this.modelConfigManager.getModelConfig("insight");
    const serviceOpt = {
      domIncluded: (opt == null ? void 0 : opt.domIncluded) ?? defaultServiceExtractOption.domIncluded,
      screenshotIncluded: (opt == null ? void 0 : opt.screenshotIncluded) ?? defaultServiceExtractOption.screenshotIncluded
    };
    const { textPrompt, multimodalPrompt } = parsePrompt(assertion);
    const assertionText = typeof assertion === "string" ? assertion : assertion.prompt;
    try {
      const { output, thought } = await this.taskExecutor.createTypeQueryExecution(
        "Assert",
        textPrompt,
        modelConfig,
        serviceOpt,
        multimodalPrompt
      );
      const pass = Boolean(output);
      const message = pass ? void 0 : `Assertion failed: ${msg || assertionText}
Reason: ${thought || "(no_reason)"}`;
      if (opt == null ? void 0 : opt.keepRawResponse) {
        return {
          pass,
          thought,
          message
        };
      }
      if (!pass) {
        throw new Error(message);
      }
    } catch (error2) {
      if (error2 instanceof TaskExecutionError) {
        const errorTask = error2.errorTask;
        const thought = errorTask == null ? void 0 : errorTask.thought;
        const rawError = errorTask == null ? void 0 : errorTask.error;
        const rawMessage = (errorTask == null ? void 0 : errorTask.errorMessage) || (rawError instanceof Error ? rawError.message : rawError ? String(rawError) : void 0);
        const reason = thought || rawMessage || "(no_reason)";
        const message = `Assertion failed: ${msg || assertionText}
Reason: ${reason}`;
        if (opt == null ? void 0 : opt.keepRawResponse) {
          return {
            pass: false,
            thought,
            message
          };
        }
        throw new Error(message, {
          cause: rawError ?? error2
        });
      }
      throw error2;
    }
  }
  async aiWaitFor(assertion, opt) {
    const modelConfig = this.modelConfigManager.getModelConfig("insight");
    await this.taskExecutor.waitFor(
      assertion,
      {
        ...opt,
        timeoutMs: (opt == null ? void 0 : opt.timeoutMs) || 15 * 1e3,
        checkIntervalMs: (opt == null ? void 0 : opt.checkIntervalMs) || 3 * 1e3
      },
      modelConfig
    );
  }
  async ai(...args) {
    return this.aiAct(...args);
  }
  async runYaml(yamlScriptContent) {
    const script = parseYamlScript(yamlScriptContent, "yaml");
    const player = new ScriptPlayer(script, async () => {
      return { agent: this, freeFn: [] };
    });
    await player.run();
    if (player.status === "error") {
      const errors2 = player.taskStatusList.filter((task) => task.status === "error").map((task) => {
        var _a3;
        return `task - ${task.name}: ${(_a3 = task.error) == null ? void 0 : _a3.message}`;
      }).join("\n");
      throw new Error(`Error(s) occurred in running yaml script:
${errors2}`);
    }
    return {
      result: player.result
    };
  }
  async evaluateJavaScript(script) {
    assert(
      this.interface.evaluateJavaScript,
      "evaluateJavaScript is not supported in current agent"
    );
    return this.interface.evaluateJavaScript(script);
  }
  /**
   * Add a dump update listener
   * @param listener Listener function
   * @returns A remove function that can be called to remove this listener
   */
  addDumpUpdateListener(listener2) {
    this.dumpUpdateListeners.push(listener2);
    return () => {
      this.removeDumpUpdateListener(listener2);
    };
  }
  /**
   * Remove a dump update listener
   * @param listener The listener function to remove
   */
  removeDumpUpdateListener(listener2) {
    const index2 = this.dumpUpdateListeners.indexOf(listener2);
    if (index2 > -1) {
      this.dumpUpdateListeners.splice(index2, 1);
    }
  }
  /**
   * Clear all dump update listeners
   */
  clearDumpUpdateListeners() {
    this.dumpUpdateListeners = [];
  }
  async destroy() {
    var _a3, _b;
    if (this.destroyed) {
      return;
    }
    await this.reportGenerator.flush();
    await this.reportGenerator.finalize(this.dump);
    this.reportFile = this.reportGenerator.getReportPath();
    await ((_b = (_a3 = this.interface).destroy) == null ? void 0 : _b.call(_a3));
    this.resetDump();
    this.destroyed = true;
  }
  async recordToReport(title, opt) {
    const base64 = await this.interface.screenshotBase64();
    const screenshot = ScreenshotItem.create(base64);
    const now = Date.now();
    const recorder = [
      {
        type: "screenshot",
        ts: now,
        screenshot
      }
    ];
    const task = {
      taskId: uuid(),
      type: "Log",
      subType: "Screenshot",
      status: "finished",
      recorder,
      timing: {
        start: now,
        end: now,
        cost: 0
      },
      param: {
        content: (opt == null ? void 0 : opt.content) || ""
      },
      executor: async () => {
      }
    };
    const executionDump = new ExecutionDump({
      logTime: now,
      name: `Log - ${title || "untitled"}`,
      description: (opt == null ? void 0 : opt.content) || "",
      tasks: [task]
    });
    this.appendExecutionDump(executionDump);
    const dumpString = this.dumpDataString();
    for (const listener2 of this.dumpUpdateListeners) {
      try {
        listener2(dumpString);
      } catch (error2) {
        console.error("Error in onDumpUpdate listener", error2);
      }
    }
    this.writeOutActionDumps();
    await this.reportGenerator.flush();
  }
  /**
   * @deprecated Use {@link Agent.recordToReport} instead.
   */
  async logScreenshot(title, opt) {
    await this.recordToReport(title, opt);
  }
  _unstableLogContent() {
    const { groupName, groupDescription, executions } = this.dump;
    return {
      groupName,
      groupDescription,
      executions: executions || []
    };
  }
  /**
   * Freezes the current page context to be reused in subsequent AI operations
   * This avoids recalculating page context for each operation
   */
  async freezePageContext() {
    debug$e("Freezing page context");
    const context2 = await this._snapshotContext();
    context2._isFrozen = true;
    this.frozenUIContext = context2;
    debug$e("Page context frozen successfully");
  }
  /**
   * Unfreezes the page context, allowing AI operations to calculate context dynamically
   */
  async unfreezePageContext() {
    debug$e("Unfreezing page context");
    this.frozenUIContext = void 0;
    debug$e("Page context unfrozen successfully");
  }
  /**
   * Process cache configuration and return normalized cache settings
   */
  processCacheConfig(opts) {
    if (opts.cache === true) {
      throw new Error(
        'cache: true requires an explicit cache ID. Please provide:\nExample: cache: { id: "my-cache-id" }'
      );
    }
    if (opts.cache && typeof opts.cache === "object" && opts.cache !== null && !opts.cache.id) {
      throw new Error(
        'cache configuration requires an explicit id.\nExample: cache: { id: "my-cache-id" }'
      );
    }
    const cacheConfig = processCacheConfig(
      opts.cache,
      opts.cacheId || opts.testId || "default"
    );
    if (!cacheConfig) {
      return null;
    }
    if (typeof cacheConfig === "object" && cacheConfig !== null) {
      const id = cacheConfig.id;
      const rawStrategy = cacheConfig.strategy;
      let strategyValue;
      if (rawStrategy === void 0) {
        strategyValue = "read-write";
      } else if (typeof rawStrategy === "string") {
        strategyValue = rawStrategy;
      } else {
        throw new Error(
          `cache.strategy must be a string when provided, but received type ${typeof rawStrategy}`
        );
      }
      if (!isValidCacheStrategy(strategyValue)) {
        throw new Error(
          `cache.strategy must be one of ${CACHE_STRATEGY_VALUES}, but received "${strategyValue}"`
        );
      }
      const isReadOnly = strategyValue === "read-only";
      const isWriteOnly = strategyValue === "write-only";
      return {
        id,
        enabled: !isWriteOnly,
        readOnly: isReadOnly,
        writeOnly: isWriteOnly
      };
    }
    return null;
  }
  normalizeFilePaths(files) {
    return files.map((file) => {
      const absolutePath = resolve$3(file);
      if (!existsSync(absolutePath)) {
        throw new Error(`File not found: ${file}`);
      }
      return absolutePath;
    });
  }
  normalizeFileInput(files) {
    const filesArray = Array.isArray(files) ? files : [files];
    return this.normalizeFilePaths(filesArray);
  }
  /**
   * Manually flush cache to file
   * @param options - Optional configuration
   * @param options.cleanUnused - If true, removes unused cache records before flushing
   */
  async flushCache(options2) {
    if (!this.taskCache) {
      throw new Error("Cache is not configured");
    }
    this.taskCache.flushCacheToFile(options2);
  }
}
class OmniDeviceInterface extends AbstractInterface {
  constructor(adapter) {
    super();
    __publicField(this, "interfaceType", "omni");
    this.adapter = adapter;
  }
  async screenshotBase64() {
    return this.adapter.screenshotBase64();
  }
  async size() {
    return this.adapter.size();
  }
  actionSpace() {
    var _a3, _b;
    return ((_b = (_a3 = this.adapter).actionSpace) == null ? void 0 : _b.call(_a3)) || [];
  }
  async destroy() {
    await this.adapter.disconnect();
  }
}
function createAgent(adapter, opts) {
  const iface = new OmniDeviceInterface(adapter);
  return new Agent(iface, opts);
}
function createAgentFromEnv(adapter) {
  const opts = {
    modelConfig: {
      MIDSCENE_MODEL_NAME: process.env.MIDSCENE_MODEL_NAME ?? "",
      MIDSCENE_OPENAI_BASE_URL: process.env.MIDSCENE_OPENAI_BASE_URL ?? "",
      MIDSCENE_OPENAI_API_KEY: process.env.MIDSCENE_OPENAI_API_KEY ?? ""
    }
  };
  return createAgent(adapter, opts);
}
var express$2 = { exports: {} };
var bodyParser = { exports: {} };
/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */
var relative = require$$1$2.relative;
var depd_1 = depd;
var basePath = process.cwd();
function containsNamespace(str2, namespace) {
  var vals = str2.split(/[ ,]+/);
  var ns = String(namespace).toLowerCase();
  for (var i = 0; i < vals.length; i++) {
    var val = vals[i];
    if (val && (val === "*" || val.toLowerCase() === ns)) {
      return true;
    }
  }
  return false;
}
function convertDataDescriptorToAccessor(obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  var value = descriptor.value;
  descriptor.get = function getter() {
    return value;
  };
  if (descriptor.writable) {
    descriptor.set = function setter(val) {
      return value = val;
    };
  }
  delete descriptor.value;
  delete descriptor.writable;
  Object.defineProperty(obj, prop, descriptor);
  return descriptor;
}
function createArgumentsString(arity) {
  var str2 = "";
  for (var i = 0; i < arity; i++) {
    str2 += ", arg" + i;
  }
  return str2.substr(2);
}
function createStackString(stack) {
  var str2 = this.name + ": " + this.namespace;
  if (this.message) {
    str2 += " deprecated " + this.message;
  }
  for (var i = 0; i < stack.length; i++) {
    str2 += "\n    at " + stack[i].toString();
  }
  return str2;
}
function depd(namespace) {
  if (!namespace) {
    throw new TypeError("argument namespace is required");
  }
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  var file = site[0];
  function deprecate2(message) {
    log$1.call(deprecate2, message);
  }
  deprecate2._file = file;
  deprecate2._ignored = isignored(namespace);
  deprecate2._namespace = namespace;
  deprecate2._traced = istraced(namespace);
  deprecate2._warned = /* @__PURE__ */ Object.create(null);
  deprecate2.function = wrapfunction;
  deprecate2.property = wrapproperty;
  return deprecate2;
}
function eehaslisteners(emitter, type3) {
  var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type3).length : emitter.listenerCount(type3);
  return count > 0;
}
function isignored(namespace) {
  if (process.noDeprecation) {
    return true;
  }
  var str2 = process.env.NO_DEPRECATION || "";
  return containsNamespace(str2, namespace);
}
function istraced(namespace) {
  if (process.traceDeprecation) {
    return true;
  }
  var str2 = process.env.TRACE_DEPRECATION || "";
  return containsNamespace(str2, namespace);
}
function log$1(message, site) {
  var haslisteners = eehaslisteners(process, "deprecation");
  if (!haslisteners && this._ignored) {
    return;
  }
  var caller;
  var callFile;
  var callSite;
  var depSite;
  var i = 0;
  var seen = false;
  var stack = getStack();
  var file = this._file;
  if (site) {
    depSite = site;
    callSite = callSiteLocation(stack[1]);
    callSite.name = depSite.name;
    file = callSite[0];
  } else {
    i = 2;
    depSite = callSiteLocation(stack[i]);
    callSite = depSite;
  }
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i]);
    callFile = caller[0];
    if (callFile === file) {
      seen = true;
    } else if (callFile === this._file) {
      file = this._file;
    } else if (seen) {
      break;
    }
  }
  var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
  if (key !== void 0 && key in this._warned) {
    return;
  }
  this._warned[key] = true;
  var msg = message;
  if (!msg) {
    msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
  }
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i));
    process.emit("deprecation", err);
    return;
  }
  var format2 = process.stderr.isTTY ? formatColor : formatPlain;
  var output = format2.call(this, msg, caller, stack.slice(i));
  process.stderr.write(output + "\n", "utf8");
}
function callSiteLocation(callSite) {
  var file = callSite.getFileName() || "<anonymous>";
  var line = callSite.getLineNumber();
  var colm = callSite.getColumnNumber();
  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ", " + file;
  }
  var site = [file, line, colm];
  site.callSite = callSite;
  site.name = callSite.getFunctionName();
  return site;
}
function defaultMessage(site) {
  var callSite = site.callSite;
  var funcName = site.name;
  if (!funcName) {
    funcName = "<anonymous@" + formatLocation(site) + ">";
  }
  var context2 = callSite.getThis();
  var typeName = context2 && callSite.getTypeName();
  if (typeName === "Object") {
    typeName = void 0;
  }
  if (typeName === "Function") {
    typeName = context2.name || typeName;
  }
  return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
}
function formatPlain(msg, caller, stack) {
  var timestamp2 = (/* @__PURE__ */ new Date()).toUTCString();
  var formatted = timestamp2 + " " + this._namespace + " deprecated " + msg;
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += "\n    at " + stack[i].toString();
    }
    return formatted;
  }
  if (caller) {
    formatted += " at " + formatLocation(caller);
  }
  return formatted;
}
function formatColor(msg, caller, stack) {
  var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += "\n    \x1B[36mat " + stack[i].toString() + "\x1B[39m";
    }
    return formatted;
  }
  if (caller) {
    formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
  }
  return formatted;
}
function formatLocation(callSite) {
  return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
}
function getStack() {
  var limit2 = Error.stackTraceLimit;
  var obj = {};
  var prep = Error.prepareStackTrace;
  Error.prepareStackTrace = prepareObjectStackTrace;
  Error.stackTraceLimit = Math.max(10, limit2);
  Error.captureStackTrace(obj);
  var stack = obj.stack.slice(1);
  Error.prepareStackTrace = prep;
  Error.stackTraceLimit = limit2;
  return stack;
}
function prepareObjectStackTrace(obj, stack) {
  return stack;
}
function wrapfunction(fn, message) {
  if (typeof fn !== "function") {
    throw new TypeError("argument fn must be a function");
  }
  var args = createArgumentsString(fn.length);
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  site.name = fn.name;
  var deprecatedfn = new Function(
    "fn",
    "log",
    "deprecate",
    "message",
    "site",
    '"use strict"\nreturn function (' + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}"
  )(fn, log$1, this, message, site);
  return deprecatedfn;
}
function wrapproperty(obj, prop, message) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new TypeError("argument obj must be object");
  }
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  if (!descriptor) {
    throw new TypeError("must call property on owner object");
  }
  if (!descriptor.configurable) {
    throw new TypeError("property must be configurable");
  }
  var deprecate2 = this;
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  site.name = prop;
  if ("value" in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop);
  }
  var get2 = descriptor.get;
  var set2 = descriptor.set;
  if (typeof get2 === "function") {
    descriptor.get = function getter() {
      log$1.call(deprecate2, message, site);
      return get2.apply(this, arguments);
    };
  }
  if (typeof set2 === "function") {
    descriptor.set = function setter() {
      log$1.call(deprecate2, message, site);
      return set2.apply(this, arguments);
    };
  }
  Object.defineProperty(obj, prop, descriptor);
}
function DeprecationError(namespace, message, stack) {
  var error2 = new Error();
  var stackString;
  Object.defineProperty(error2, "constructor", {
    value: DeprecationError
  });
  Object.defineProperty(error2, "message", {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  });
  Object.defineProperty(error2, "name", {
    enumerable: false,
    configurable: true,
    value: "DeprecationError",
    writable: true
  });
  Object.defineProperty(error2, "namespace", {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  });
  Object.defineProperty(error2, "stack", {
    configurable: true,
    enumerable: false,
    get: function() {
      if (stackString !== void 0) {
        return stackString;
      }
      return stackString = createStackString.call(this, stack);
    },
    set: function setter(val) {
      stackString = val;
    }
  });
  return error2;
}
var bytes = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes) return bytes.exports;
  hasRequiredBytes = 1;
  bytes.exports = bytes$1;
  bytes.exports.format = format2;
  bytes.exports.parse = parse2;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map2 = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes$1(value, options2) {
    if (typeof value === "string") {
      return parse2(value);
    }
    if (typeof value === "number") {
      return format2(value, options2);
    }
    return null;
  }
  function format2(value, options2) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options2 && options2.thousandsSeparator || "";
    var unitSeparator = options2 && options2.unitSeparator || "";
    var decimalPlaces = options2 && options2.decimalPlaces !== void 0 ? options2.decimalPlaces : 2;
    var fixedDecimals = Boolean(options2 && options2.fixedDecimals);
    var unit = options2 && options2.unit || "";
    if (!unit || !map2[unit.toLowerCase()]) {
      if (mag >= map2.pb) {
        unit = "PB";
      } else if (mag >= map2.tb) {
        unit = "TB";
      } else if (mag >= map2.gb) {
        unit = "GB";
      } else if (mag >= map2.mb) {
        unit = "MB";
      } else if (mag >= map2.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map2[unit.toLowerCase()];
    var str2 = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str2 = str2.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str2 = str2.split(".").map(function(s2, i) {
        return i === 0 ? s2.replace(formatThousandsRegExp, thousandsSeparator) : s2;
      }).join(".");
    }
    return str2 + unitSeparator + unit;
  }
  function parse2(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map2[unit] * floatValue);
  }
  return bytes.exports;
}
var contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var PARAM_REGEXP$1 = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
var TEXT_REGEXP$1 = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
var TOKEN_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
var QESC_REGEXP$1 = /\\([\u000b\u0020-\u00ff])/g;
var QUOTE_REGEXP$1 = /([\\"])/g;
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
contentType.format = format$2;
contentType.parse = parse$9;
function format$2(obj) {
  if (!obj || typeof obj !== "object") {
    throw new TypeError("argument obj is required");
  }
  var parameters = obj.parameters;
  var type3 = obj.type;
  if (!type3 || !TYPE_REGEXP.test(type3)) {
    throw new TypeError("invalid type");
  }
  var string2 = type3;
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param3 = params[i];
      if (!TOKEN_REGEXP$1.test(param3)) {
        throw new TypeError("invalid parameter name");
      }
      string2 += "; " + param3 + "=" + qstring$2(parameters[param3]);
    }
  }
  return string2;
}
function parse$9(string2) {
  if (!string2) {
    throw new TypeError("argument string is required");
  }
  var header3 = typeof string2 === "object" ? getcontenttype$1(string2) : string2;
  if (typeof header3 !== "string") {
    throw new TypeError("argument string is required to be a string");
  }
  var index2 = header3.indexOf(";");
  var type3 = index2 !== -1 ? header3.slice(0, index2).trim() : header3.trim();
  if (!TYPE_REGEXP.test(type3)) {
    throw new TypeError("invalid media type");
  }
  var obj = new ContentType(type3.toLowerCase());
  if (index2 !== -1) {
    var key;
    var match2;
    var value;
    PARAM_REGEXP$1.lastIndex = index2;
    while (match2 = PARAM_REGEXP$1.exec(header3)) {
      if (match2.index !== index2) {
        throw new TypeError("invalid parameter format");
      }
      index2 += match2[0].length;
      key = match2[1].toLowerCase();
      value = match2[2];
      if (value.charCodeAt(0) === 34) {
        value = value.slice(1, -1);
        if (value.indexOf("\\") !== -1) {
          value = value.replace(QESC_REGEXP$1, "$1");
        }
      }
      obj.parameters[key] = value;
    }
    if (index2 !== header3.length) {
      throw new TypeError("invalid parameter format");
    }
  }
  return obj;
}
function getcontenttype$1(obj) {
  var header3;
  if (typeof obj.getHeader === "function") {
    header3 = obj.getHeader("content-type");
  } else if (typeof obj.headers === "object") {
    header3 = obj.headers && obj.headers["content-type"];
  }
  if (typeof header3 !== "string") {
    throw new TypeError("content-type header is missing from object");
  }
  return header3;
}
function qstring$2(val) {
  var str2 = String(val);
  if (TOKEN_REGEXP$1.test(str2)) {
    return str2;
  }
  if (str2.length > 0 && !TEXT_REGEXP$1.test(str2)) {
    throw new TypeError("invalid parameter value");
  }
  return '"' + str2.replace(QUOTE_REGEXP$1, "\\$1") + '"';
}
function ContentType(type3) {
  this.parameters = /* @__PURE__ */ Object.create(null);
  this.type = type3;
}
var httpErrors = { exports: {} };
var setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto2) {
  obj.__proto__ = proto2;
  return obj;
}
function mixinProperties(obj, proto2) {
  for (var prop in proto2) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto2[prop];
    }
  }
  return obj;
}
const require$$0$2 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var codes$1 = require$$0$2;
var statuses$3 = status;
status.message = codes$1;
status.code = createMessageToStatusCodeMap(codes$1);
status.codes = createStatusCodeList(codes$1);
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};
status.empty = {
  204: true,
  205: true,
  304: true
};
status.retry = {
  502: true,
  503: true,
  504: true
};
function createMessageToStatusCodeMap(codes2) {
  var map2 = {};
  Object.keys(codes2).forEach(function forEachCode(code) {
    var message = codes2[code];
    var status3 = Number(code);
    map2[message.toLowerCase()] = status3;
  });
  return map2;
}
function createStatusCodeList(codes2) {
  return Object.keys(codes2).map(function mapCode(code) {
    return Number(code);
  });
}
function getStatusCode(message) {
  var msg = message.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
    throw new Error('invalid status message: "' + message + '"');
  }
  return status.code[msg];
}
function getStatusMessage(code) {
  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
    throw new Error("invalid status code: " + code);
  }
  return status.message[code];
}
function status(code) {
  if (typeof code === "number") {
    return getStatusMessage(code);
  }
  if (typeof code !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    return getStatusMessage(n);
  }
  return getStatusCode(code);
}
var inherits = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
try {
  var util$5 = require("util");
  if (typeof util$5.inherits !== "function") throw "";
  inherits.exports = util$5.inherits;
} catch (e) {
  inherits.exports = requireInherits_browser();
}
var inheritsExports = inherits.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier = toIdentifier;
function toIdentifier(str2) {
  return str2.split(" ").map(function(token) {
    return token.slice(0, 1).toUpperCase() + token.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module) {
  var deprecate2 = depd_1("http-errors");
  var setPrototypeOf2 = setprototypeof;
  var statuses2 = statuses$3;
  var inherits2 = inheritsExports;
  var toIdentifier2 = toidentifier;
  module.exports = createError2;
  module.exports.HttpError = createHttpErrorConstructor();
  module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
  populateConstructorExports(module.exports, statuses2.codes, module.exports.HttpError);
  function codeClass(status3) {
    return Number(String(status3).charAt(0) + "00");
  }
  function createError2() {
    var err;
    var msg;
    var status3 = 500;
    var props2 = {};
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      var type3 = typeof arg;
      if (type3 === "object" && arg instanceof Error) {
        err = arg;
        status3 = err.status || err.statusCode || status3;
      } else if (type3 === "number" && i === 0) {
        status3 = arg;
      } else if (type3 === "string") {
        msg = arg;
      } else if (type3 === "object") {
        props2 = arg;
      } else {
        throw new TypeError("argument #" + (i + 1) + " unsupported type " + type3);
      }
    }
    if (typeof status3 === "number" && (status3 < 400 || status3 >= 600)) {
      deprecate2("non-error status code; use only 4xx or 5xx status codes");
    }
    if (typeof status3 !== "number" || !statuses2.message[status3] && (status3 < 400 || status3 >= 600)) {
      status3 = 500;
    }
    var HttpError = createError2[status3] || createError2[codeClass(status3)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses2.message[status3]);
      Error.captureStackTrace(err, createError2);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status3) {
      err.expose = status3 < 500;
      err.status = err.statusCode = status3;
    }
    for (var key in props2) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props2[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits2(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ClientError(message) {
      var msg = message != null ? message : statuses2.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf2(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createIsHttpErrorFunction(HttpError) {
    return function isHttpError(val) {
      if (!val || typeof val !== "object") {
        return false;
      }
      if (val instanceof HttpError) {
        return true;
      }
      return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
    };
  }
  function createServerErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ServerError(message) {
      var msg = message != null ? message : statuses2.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf2(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func2, name) {
    var desc = Object.getOwnPropertyDescriptor(func2, "name");
    if (desc && desc.configurable) {
      desc.value = name;
      Object.defineProperty(func2, "name", desc);
    }
  }
  function populateConstructorExports(exports$1, codes2, HttpError) {
    codes2.forEach(function forEachCode(code) {
      var CodeError;
      var name = toIdentifier2(statuses2.message[code]);
      switch (codeClass(code)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name, code);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name, code);
          break;
      }
      if (CodeError) {
        exports$1[code] = CodeError;
        exports$1[name] = CodeError;
      }
    });
  }
  function toClassName(name) {
    return name.slice(-5) === "Error" ? name : name + "Error";
  }
})(httpErrors);
var httpErrorsExports = httpErrors.exports;
var src$1 = { exports: {} };
var browser$1 = { exports: {} };
var debug$d = { exports: {} };
var ms$1;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms$1;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$1 = function(val, options2) {
    options2 = options2 || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options2.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name;
    }
    return Math.ceil(ms2 / n) + " " + name + "s";
  }
  return ms$1;
}
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug$d.exports;
  hasRequiredDebug = 1;
  (function(module, exports$1) {
    exports$1 = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports$1.coerce = coerce2;
    exports$1.disable = disable;
    exports$1.enable = enable;
    exports$1.enabled = enabled;
    exports$1.humanize = requireMs();
    exports$1.names = [];
    exports$1.skips = [];
    exports$1.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash2 = 0, i;
      for (i in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return exports$1.colors[Math.abs(hash2) % exports$1.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled) return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports$1.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%") return match2;
          index2++;
          var formatter = exports$1.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports$1.formatArgs.call(self2, args);
        var logFn = debug2.log || exports$1.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports$1.enabled(namespace);
      debug2.useColors = exports$1.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports$1.init) {
        exports$1.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports$1.save(namespaces);
      exports$1.names = [];
      exports$1.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports$1.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports$1.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports$1.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports$1.skips.length; i < len; i++) {
        if (exports$1.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports$1.names.length; i < len; i++) {
        if (exports$1.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  })(debug$d, debug$d.exports);
  return debug$d.exports;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1.exports;
  hasRequiredBrowser$1 = 1;
  (function(module, exports$1) {
    exports$1 = module.exports = requireDebug();
    exports$1.log = log2;
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load2;
    exports$1.useColors = useColors;
    exports$1.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports$1.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports$1.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports$1.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2) return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports$1.storage.removeItem("debug");
        } else {
          exports$1.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load2() {
      var r;
      try {
        r = exports$1.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports$1.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
var node$1 = { exports: {} };
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module, exports$1) {
    var tty = require$$0$3;
    var util2 = require$$1$1;
    exports$1 = module.exports = requireDebug();
    exports$1.init = init2;
    exports$1.log = log2;
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load2;
    exports$1.useColors = useColors;
    exports$1.colors = [6, 2, 3, 4, 5, 1];
    exports$1.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream2 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty.isatty(fd);
    }
    exports$1.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str2) {
        return str2.trim();
      }).join(" ");
    };
    exports$1.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports$1.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream2.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream22;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream22 = new tty.WriteStream(fd2);
          stream22._type = "tty";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$0$8;
          stream22 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream22._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = require$$0$7;
          stream22 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream22.readable = false;
          stream22.read = null;
          stream22._type = "pipe";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream22.fd = fd2;
      stream22._isStdio = true;
      return stream22;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys = Object.keys(exports$1.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
      }
    }
    exports$1.enable(load2());
  })(node$1, node$1.exports);
  return node$1.exports;
}
if (typeof process !== "undefined" && process.type === "renderer") {
  src$1.exports = requireBrowser$1();
} else {
  src$1.exports = requireNode$1();
}
var srcExports$1 = src$1.exports;
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var EventEmitter = require$$0$9.EventEmitter;
var ReadStream = require$$0$8.ReadStream;
var Stream$1 = require$$1$3;
var Zlib = require$$3$1;
var destroy_1 = destroy$1;
function destroy$1(stream2, suppress) {
  if (isFsReadStream(stream2)) {
    destroyReadStream(stream2);
  } else if (isZlibStream(stream2)) {
    destroyZlibStream(stream2);
  } else if (hasDestroy(stream2)) {
    stream2.destroy();
  }
  if (isEventEmitter(stream2) && suppress) {
    stream2.removeAllListeners("error");
    stream2.addListener("error", noop);
  }
  return stream2;
}
function destroyReadStream(stream2) {
  stream2.destroy();
  if (typeof stream2.close === "function") {
    stream2.on("open", onOpenClose);
  }
}
function closeZlibStream(stream2) {
  if (stream2._hadError === true) {
    var prop = stream2._binding === null ? "_binding" : "_handle";
    stream2[prop] = {
      close: function() {
        this[prop] = null;
      }
    };
  }
  stream2.close();
}
function destroyZlibStream(stream2) {
  if (typeof stream2.destroy === "function") {
    if (stream2._binding) {
      stream2.destroy();
      if (stream2._processing) {
        stream2._needDrain = true;
        stream2.once("drain", onDrainClearBinding);
      } else {
        stream2._binding.clear();
      }
    } else if (stream2._destroy && stream2._destroy !== Stream$1.Transform.prototype._destroy) {
      stream2.destroy();
    } else if (stream2._destroy && typeof stream2.close === "function") {
      stream2.destroyed = true;
      stream2.close();
    } else {
      stream2.destroy();
    }
  } else if (typeof stream2.close === "function") {
    closeZlibStream(stream2);
  }
}
function hasDestroy(stream2) {
  return stream2 instanceof Stream$1 && typeof stream2.destroy === "function";
}
function isEventEmitter(val) {
  return val instanceof EventEmitter;
}
function isFsReadStream(stream2) {
  return stream2 instanceof ReadStream;
}
function isZlibStream(stream2) {
  return stream2 instanceof Zlib.Gzip || stream2 instanceof Zlib.Gunzip || stream2 instanceof Zlib.Deflate || stream2 instanceof Zlib.DeflateRaw || stream2 instanceof Zlib.Inflate || stream2 instanceof Zlib.InflateRaw || stream2 instanceof Zlib.Unzip;
}
function noop() {
}
function onDrainClearBinding() {
  this._binding.clear();
}
function onOpenClose() {
  if (typeof this.fd === "number") {
    this.close();
  }
}
var lib$2 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer2 = require$$0$5;
  var Buffer2 = buffer2.Buffer;
  var safer = {};
  var key;
  for (key in buffer2) {
    if (!buffer2.hasOwnProperty(key)) continue;
    if (key === "SlowBuffer" || key === "Buffer") continue;
    safer[key] = buffer2[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key)) continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding3) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options2) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str2) {
    if (this.addBOM) {
      str2 = BOMChar + str2;
      this.addBOM = false;
    }
    return this.encoder.write(str2);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options2) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options2 || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res2 = this.decoder.write(buf);
    if (this.pass || !res2)
      return res2;
    if (res2[0] === BOMChar) {
      res2 = res2.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res2;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$4.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options2, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options2, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str2) {
    return Buffer2.from(str2, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options2, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str2) {
    str2 = this.prevStr + str2;
    var completeQuads = str2.length - str2.length % 4;
    this.prevStr = str2.slice(completeQuads);
    str2 = str2.slice(0, completeQuads);
    return Buffer2.from(str2, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options2, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length * 3), bufIdx = 0;
    for (var i = 0; i < str2.length; i++) {
      var charCode = str2.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options2, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res2 = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res2 += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res2 += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res2 += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res2 += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res2 += this.defaultCharUnicode;
            else
              res2 += String.fromCharCode(acc);
          }
        } else {
          res2 += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res2;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res2 = 0;
    if (this.contBytes > 0)
      res2 += this.defaultCharUnicode;
    return res2;
  };
  return internal;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    var buf = Buffer2.from(str2, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options2, codec) {
    options2 = options2 || {};
    if (options2.addBOM === void 0)
      options2.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options2);
  }
  Utf16Encoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options2, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options2 || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      var res2 = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res2 + trail : res2;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0; i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options2, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str2) {
    return Buffer2.from(str2.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options2, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex2 = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex2.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res2 += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7Decoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options2, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str2) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str2.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str2.length; i2++) {
      var uChar = str2.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options2, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res2 += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options2, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length);
    for (var i = 0; i < str2.length; i++)
      buf[i] = this.encodeBuf[str2.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options2, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 48; j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129; i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48; i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes2 = [];
    for (; addr > 0; addr >>= 8)
      bytes2.push(addr & 255);
    if (bytes2.length == 0)
      bytes2.push(0);
    var node2 = this.decodeTables[0];
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      var val = node2[bytes2[i2]];
      if (val == UNASSIGNED) {
        node2[bytes2[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq2 = [];
            for (var m2 = 0; m2 < len; m2++)
              seq2.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq2);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq2, dbcsCode) {
    var uCode = seq2[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED) node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j = 1; j < seq2.length - 1; j++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object")
        node2 = oldVal;
      else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0)
          node2[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq2[seq2.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options2, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str2) {
    var newBuf = Buffer2.alloc(str2.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str2.length) break;
        var uCode = str2.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options2, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq2 = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq2.length - 1; k++) {
          uCode = seq2[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq2[seq2.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0$1 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
];
const require$$2$1 = [
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
];
const require$$3 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ]
];
const uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
const gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
const require$$4$1 = {
  uChars,
  gbChars
};
const require$$5 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
];
const require$$6 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
];
const require$$7 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$1;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2$1;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3);
      },
      gb18030: function() {
        return require$$4$1;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [41676]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports$1) {
    var modules = [
      requireInternal(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports$1[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = require$$0$5.Buffer, Transform2 = require$$1$3.Transform;
  streams = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding3, options2) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding3, options2), options2);
    };
    iconv.decodeStream = function decodeStream(encoding3, options2) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding3, options2), options2);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options2) {
    this.conv = conv;
    options2 = options2 || {};
    options2.decodeStrings = false;
    Transform2.call(this, options2);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform2.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding3, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res2 = this.conv.write(chunk);
      if (res2 && res2.length) this.push(res2);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res2 = this.conv.end();
      if (res2 && res2.length) this.push(res2);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options2) {
    this.conv = conv;
    options2 = options2 || {};
    options2.encoding = this.encoding = "utf8";
    Transform2.call(this, options2);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform2.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding3, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res2 = this.conv.write(chunk);
      if (res2 && res2.length) this.push(res2, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res2 = this.conv.end();
      if (res2 && res2.length) this.push(res2, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res2 = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res2 += chunk;
    });
    this.on("end", function() {
      cb(null, res2);
    });
    return this;
  };
  return streams;
}
var extendNode;
var hasRequiredExtendNode;
function requireExtendNode() {
  if (hasRequiredExtendNode) return extendNode;
  hasRequiredExtendNode = 1;
  var Buffer2 = require$$0$5.Buffer;
  extendNode = function(iconv) {
    var original = void 0;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original) return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        "hex": true,
        "utf8": true,
        "utf-8": true,
        "ascii": true,
        "binary": true,
        "base64": true,
        "ucs2": true,
        "ucs-2": true,
        "utf16le": true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = require$$0$5.SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding3, start, end) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.SlowBufferToString.call(this, encoding3, start, end);
        if (typeof start == "undefined") start = 0;
        if (typeof end == "undefined") end = this.length;
        return iconv.decode(this.slice(start, end), encoding3);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string2, offset, length, encoding3) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding3 = length;
            length = void 0;
          }
        } else {
          var swap = encoding3;
          encoding3 = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.SlowBufferWrite.call(this, string2, offset, length, encoding3);
        if (string2.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string2, encoding3);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding3) {
        return Buffer2.isNativeEncoding(encoding3) || iconv.encodingExists(encoding3);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str2, encoding3) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferByteLength.call(this, str2, encoding3);
        return iconv.encode(str2, encoding3).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding3, start, end) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferToString.call(this, encoding3, start, end);
        if (typeof start == "undefined") start = 0;
        if (typeof end == "undefined") end = this.length;
        return iconv.decode(this.slice(start, end), encoding3);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string2, offset, length, encoding3) {
        var _offset = offset, _length = length, _encoding = encoding3;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding3 = length;
            length = void 0;
          }
        } else {
          var swap = encoding3;
          encoding3 = offset;
          offset = length;
          length = swap;
        }
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferWrite.call(this, string2, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string2.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string2, encoding3);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv.supportsStreams) {
        var Readable = require$$1$3.Readable;
        original.ReadableSetEncoding = Readable.prototype.setEncoding;
        Readable.prototype.setEncoding = function setEncoding(enc, options2) {
          this._readableState.decoder = iconv.getDecoder(enc, options2);
          this._readableState.encoding = enc;
        };
        Readable.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = require$$0$5.SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable = require$$1$3.Readable;
        Readable.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable.prototype.collect;
      }
      original = void 0;
    };
  };
  return extendNode;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$2.exports;
  hasRequiredLib$1 = 1;
  (function(module) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling(), iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode2(str2, encoding3, options2) {
      str2 = "" + (str2 || "");
      var encoder = iconv.getEncoder(encoding3, options2);
      var res2 = encoder.write(str2);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res2, trail]) : res2;
    };
    iconv.decode = function decode2(buf, encoding3, options2) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding3, options2);
      var res2 = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res2 + trail : res2;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding3) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings();
      var enc = iconv._canonicalizeEncoding(encoding3);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding3 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding3) {
      return ("" + encoding3).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding3, options2) {
      var codec = iconv.getCodec(encoding3), encoder = new codec.encoder(options2, codec);
      if (codec.bomAware && options2 && options2.addBOM)
        encoder = new bomHandling2.PrependBOM(encoder, options2);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding3, options2) {
      var codec = iconv.getCodec(encoding3), decoder = new codec.decoder(options2, codec);
      if (codec.bomAware && !(options2 && options2.stripBOM === false))
        decoder = new bomHandling2.StripBOM(decoder, options2);
      return decoder;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        requireStreams()(iconv);
      }
      requireExtendNode()(iconv);
    }
  })(lib$2);
  return lib$2.exports;
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var unpipe_1 = unpipe$1;
function hasPipeDataListeners(stream2) {
  var listeners = stream2.listeners("data");
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === "ondata") {
      return true;
    }
  }
  return false;
}
function unpipe$1(stream2) {
  if (!stream2) {
    throw new TypeError("argument stream is required");
  }
  if (typeof stream2.unpipe === "function") {
    stream2.unpipe();
    return;
  }
  if (!hasPipeDataListeners(stream2)) {
    return;
  }
  var listener2;
  var listeners = stream2.listeners("close");
  for (var i = 0; i < listeners.length; i++) {
    listener2 = listeners[i];
    if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
      continue;
    }
    listener2.call(stream2);
  }
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
  if (hasRequiredRawBody) return rawBody;
  hasRequiredRawBody = 1;
  var asyncHooks2 = tryRequireAsyncHooks2();
  var bytes2 = requireBytes();
  var createError2 = httpErrorsExports;
  var iconv = requireLib$1();
  var unpipe2 = unpipe_1;
  rawBody = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding3) {
    if (!encoding3) return null;
    try {
      return iconv.getDecoder(encoding3);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
      throw createError2(415, "specified encoding unsupported", {
        encoding: encoding3,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream2, options2, callback) {
    var done = callback;
    var opts = options2 || {};
    if (stream2 === void 0) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream2 !== "object" || stream2 === null || typeof stream2.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options2 === true || typeof options2 === "string") {
      opts = {
        encoding: options2
      };
    }
    if (typeof options2 === "function") {
      done = options2;
      opts = {};
    }
    if (done !== void 0 && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding3 = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit2 = bytes2.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream(stream2, encoding3, length, limit2, wrap2(done));
    }
    return new Promise(function executor(resolve3, reject) {
      readStream(stream2, encoding3, length, limit2, function onRead(err, buf) {
        if (err) return reject(err);
        resolve3(buf);
      });
    });
  }
  function halt(stream2) {
    unpipe2(stream2);
    if (typeof stream2.pause === "function") {
      stream2.pause();
    }
  }
  function readStream(stream2, encoding3, length, limit2, callback) {
    var complete = false;
    var sync2 = true;
    if (limit2 !== null && length !== null && length > limit2) {
      return done(createError2(413, "request entity too large", {
        expected: length,
        length,
        limit: limit2,
        type: "entity.too.large"
      }));
    }
    var state = stream2._readableState;
    if (stream2._decoder || state && (state.encoding || state.decoder)) {
      return done(createError2(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream2.readable !== "undefined" && !stream2.readable) {
      return done(createError2(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder(encoding3);
    } catch (err) {
      return done(err);
    }
    var buffer2 = decoder ? "" : [];
    stream2.on("aborted", onAborted);
    stream2.on("close", cleanup);
    stream2.on("data", onData);
    stream2.on("end", onEnd);
    stream2.on("error", onEnd);
    sync2 = false;
    function done() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      complete = true;
      if (sync2) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          halt(stream2);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete) return;
      done(createError2(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete) return;
      received += chunk.length;
      if (limit2 !== null && received > limit2) {
        done(createError2(413, "request entity too large", {
          limit: limit2,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder) {
        buffer2 += decoder.write(chunk);
      } else {
        buffer2.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete) return;
      if (err) return done(err);
      if (length !== null && received !== length) {
        done(createError2(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string2 = decoder ? buffer2 + (decoder.end() || "") : Buffer.concat(buffer2);
        done(null, string2);
      }
    }
    function cleanup() {
      buffer2 = null;
      stream2.removeListener("aborted", onAborted);
      stream2.removeListener("data", onData);
      stream2.removeListener("end", onEnd);
      stream2.removeListener("error", onEnd);
      stream2.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks2() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap2(fn) {
    var res2;
    if (asyncHooks2.AsyncResource) {
      res2 = new asyncHooks2.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res2 || !res2.runInAsyncScope) {
      return fn;
    }
    return res2.runInAsyncScope.bind(res2, fn, null);
  }
  return rawBody;
}
var onFinished$4 = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst = first$1;
function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee = arr[0];
    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);
      ee.on(event, fn);
      cleanups.push({
        ee,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done.apply(null, arguments);
  }
  function cleanup() {
    var x;
    for (var i2 = 0; i2 < cleanups.length; i2++) {
      x = cleanups[i2];
      x.ee.removeListener(x.event, x.fn);
    }
  }
  function thunk(fn2) {
    done = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err = event === "error" ? arg1 : null;
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    done(err, ee, event, args);
  };
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
onFinished$4.exports = onFinished$3;
onFinished$4.exports.isFinished = isFinished$1;
var asyncHooks = tryRequireAsyncHooks();
var first = eeFirst;
var defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
function onFinished$3(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$1(listener2, null, msg);
    return msg;
  }
  attachListener(msg, wrap$1(listener2));
  return msg;
}
function isFinished$1(msg) {
  var socket2 = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket2 && !socket2.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket2 || !socket2.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error2) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error2);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket2) {
    msg.removeListener("socket", onSocket);
    if (finished) return;
    if (eeMsg !== eeSocket) return;
    eeSocket = first([[socket2, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err) {
    if (msg.__onFinished === listener2) msg.__onFinished = null;
    if (!listener2.queue) return;
    var queue2 = listener2.queue;
    listener2.queue = null;
    for (var i = 0; i < queue2.length; i++) {
      queue2[i](err, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res2, callback) {
  var assignSocket = res2.assignSocket;
  if (typeof assignSocket !== "function") return;
  res2.assignSocket = function _assignSocket(socket2) {
    assignSocket.call(this, socket2);
    callback(socket2);
  };
}
function tryRequireAsyncHooks() {
  try {
    return require("async_hooks");
  } catch (e) {
    return {};
  }
}
function wrap$1(fn) {
  var res2;
  if (asyncHooks.AsyncResource) {
    res2 = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
  }
  if (!res2 || !res2.runInAsyncScope) {
    return fn;
  }
  return res2.runInAsyncScope.bind(res2, fn, null);
}
var onFinishedExports = onFinished$4.exports;
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var read_1;
var hasRequiredRead;
function requireRead() {
  if (hasRequiredRead) return read_1;
  hasRequiredRead = 1;
  var createError2 = httpErrorsExports;
  var destroy2 = destroy_1;
  var getBody = requireRawBody();
  var iconv = requireLib$1();
  var onFinished2 = onFinishedExports;
  var unpipe2 = unpipe_1;
  var zlib = require$$3$1;
  read_1 = read;
  function read(req2, res2, next, parse2, debug2, options2) {
    var length;
    var opts = options2;
    var stream2;
    req2._body = true;
    var encoding3 = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream2 = contentstream(req2, debug2, opts.inflate);
      length = stream2.length;
      stream2.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding3;
    if (opts.encoding === null && encoding3 !== null && !iconv.encodingExists(encoding3)) {
      return next(createError2(415, 'unsupported charset "' + encoding3.toUpperCase() + '"', {
        charset: encoding3.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug2("read body");
    getBody(stream2, opts, function(error2, body) {
      if (error2) {
        var _error;
        if (error2.type === "encoding.unsupported") {
          _error = createError2(415, 'unsupported charset "' + encoding3.toUpperCase() + '"', {
            charset: encoding3.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError2(400, error2);
        }
        if (stream2 !== req2) {
          unpipe2(req2);
          destroy2(stream2, true);
        }
        dump2(req2, function onfinished() {
          next(createError2(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug2("verify body");
          verify(req2, res2, body, encoding3);
        } catch (err) {
          next(createError2(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str2 = body;
      try {
        debug2("parse body");
        str2 = typeof body !== "string" && encoding3 !== null ? iconv.decode(body, encoding3) : body;
        req2.body = parse2(str2);
      } catch (err) {
        next(createError2(400, err, {
          body: str2,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req2, debug2, inflate2) {
    var encoding3 = (req2.headers["content-encoding"] || "identity").toLowerCase();
    var length = req2.headers["content-length"];
    var stream2;
    debug2('content-encoding "%s"', encoding3);
    if (inflate2 === false && encoding3 !== "identity") {
      throw createError2(415, "content encoding unsupported", {
        encoding: encoding3,
        type: "encoding.unsupported"
      });
    }
    switch (encoding3) {
      case "deflate":
        stream2 = zlib.createInflate();
        debug2("inflate body");
        req2.pipe(stream2);
        break;
      case "gzip":
        stream2 = zlib.createGunzip();
        debug2("gunzip body");
        req2.pipe(stream2);
        break;
      case "identity":
        stream2 = req2;
        stream2.length = length;
        break;
      default:
        throw createError2(415, 'unsupported content encoding "' + encoding3 + '"', {
          encoding: encoding3,
          type: "encoding.unsupported"
        });
    }
    return stream2;
  }
  function dump2(req2, callback) {
    if (onFinished2.isFinished(req2)) {
      callback(null);
    } else {
      onFinished2(req2, callback);
      req2.resume();
    }
  }
  return read_1;
}
var typeIs = { exports: {} };
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
var qescRegExp = /\\([\u0000-\u007f])/g;
var quoteRegExp = /([\\"])/g;
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
mediaTyper.format = format$1;
mediaTyper.parse = parse$8;
function format$1(obj) {
  if (!obj || typeof obj !== "object") {
    throw new TypeError("argument obj is required");
  }
  var parameters = obj.parameters;
  var subtype = obj.subtype;
  var suffix = obj.suffix;
  var type3 = obj.type;
  if (!type3 || !typeNameRegExp.test(type3)) {
    throw new TypeError("invalid type");
  }
  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError("invalid subtype");
  }
  var string2 = type3 + "/" + subtype;
  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError("invalid suffix");
    }
    string2 += "+" + suffix;
  }
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param3 = params[i];
      if (!tokenRegExp.test(param3)) {
        throw new TypeError("invalid parameter name");
      }
      string2 += "; " + param3 + "=" + qstring$1(parameters[param3]);
    }
  }
  return string2;
}
function parse$8(string2) {
  if (!string2) {
    throw new TypeError("argument string is required");
  }
  if (typeof string2 === "object") {
    string2 = getcontenttype(string2);
  }
  if (typeof string2 !== "string") {
    throw new TypeError("argument string is required to be a string");
  }
  var index2 = string2.indexOf(";");
  var type3 = index2 !== -1 ? string2.substr(0, index2) : string2;
  var key;
  var match2;
  var obj = splitType(type3);
  var params = {};
  var value;
  paramRegExp.lastIndex = index2;
  while (match2 = paramRegExp.exec(string2)) {
    if (match2.index !== index2) {
      throw new TypeError("invalid parameter format");
    }
    index2 += match2[0].length;
    key = match2[1].toLowerCase();
    value = match2[2];
    if (value[0] === '"') {
      value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
    }
    params[key] = value;
  }
  if (index2 !== -1 && index2 !== string2.length) {
    throw new TypeError("invalid parameter format");
  }
  obj.parameters = params;
  return obj;
}
function getcontenttype(obj) {
  if (typeof obj.getHeader === "function") {
    return obj.getHeader("content-type");
  }
  if (typeof obj.headers === "object") {
    return obj.headers && obj.headers["content-type"];
  }
}
function qstring$1(val) {
  var str2 = String(val);
  if (tokenRegExp.test(str2)) {
    return str2;
  }
  if (str2.length > 0 && !textRegExp.test(str2)) {
    throw new TypeError("invalid parameter value");
  }
  return '"' + str2.replace(quoteRegExp, "\\$1") + '"';
}
function splitType(string2) {
  var match2 = typeRegExp.exec(string2.toLowerCase());
  if (!match2) {
    throw new TypeError("invalid media type");
  }
  var type3 = match2[1];
  var subtype = match2[2];
  var suffix;
  var index2 = subtype.lastIndexOf("+");
  if (index2 !== -1) {
    suffix = subtype.substr(index2 + 1);
    subtype = subtype.substr(0, index2);
  }
  var obj = {
    type: type3,
    subtype,
    suffix
  };
  return obj;
}
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: true
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: true
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: false
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: true
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: true,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: true,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb = require$$0;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports$1) {
  var db = mimeDb;
  var extname2 = require$$1$2.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports$1.charset = charset3;
  exports$1.charsets = { lookup: charset3 };
  exports$1.contentType = contentType3;
  exports$1.extension = extension;
  exports$1.extensions = /* @__PURE__ */ Object.create(null);
  exports$1.lookup = lookup2;
  exports$1.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports$1.extensions, exports$1.types);
  function charset3(type3) {
    if (!type3 || typeof type3 !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type3);
    var mime2 = match2 && db[match2[1].toLowerCase()];
    if (mime2 && mime2.charset) {
      return mime2.charset;
    }
    if (match2 && TEXT_TYPE_REGEXP.test(match2[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType3(str2) {
    if (!str2 || typeof str2 !== "string") {
      return false;
    }
    var mime2 = str2.indexOf("/") === -1 ? exports$1.lookup(str2) : str2;
    if (!mime2) {
      return false;
    }
    if (mime2.indexOf("charset") === -1) {
      var charset4 = exports$1.charset(mime2);
      if (charset4) mime2 += "; charset=" + charset4.toLowerCase();
    }
    return mime2;
  }
  function extension(type3) {
    if (!type3 || typeof type3 !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type3);
    var exts = match2 && exports$1.extensions[match2[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup2(path3) {
    if (!path3 || typeof path3 !== "string") {
      return false;
    }
    var extension2 = extname2("x." + path3).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports$1.types[extension2] || false;
  }
  function populateMaps(extensions, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type3) {
      var mime2 = db[type3];
      var exts = mime2.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type3] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types2[extension2]) {
          var from = preference.indexOf(db[types2[extension2]].source);
          var to = preference.indexOf(mime2.source);
          if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types2[extension2] = type3;
      }
    });
  }
})(mimeTypes);
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var typer = mediaTyper;
var mime$4 = mimeTypes;
typeIs.exports = typeofrequest;
typeIs.exports.is = typeis$1;
typeIs.exports.hasBody = hasbody;
typeIs.exports.normalize = normalize$1;
typeIs.exports.match = mimeMatch;
function typeis$1(value, types_) {
  var i;
  var types2 = types_;
  var val = tryNormalizeType(value);
  if (!val) {
    return false;
  }
  if (types2 && !Array.isArray(types2)) {
    types2 = new Array(arguments.length - 1);
    for (i = 0; i < types2.length; i++) {
      types2[i] = arguments[i + 1];
    }
  }
  if (!types2 || !types2.length) {
    return val;
  }
  var type3;
  for (i = 0; i < types2.length; i++) {
    if (mimeMatch(normalize$1(type3 = types2[i]), val)) {
      return type3[0] === "+" || type3.indexOf("*") !== -1 ? val : type3;
    }
  }
  return false;
}
function hasbody(req2) {
  return req2.headers["transfer-encoding"] !== void 0 || !isNaN(req2.headers["content-length"]);
}
function typeofrequest(req2, types_) {
  var types2 = types_;
  if (!hasbody(req2)) {
    return null;
  }
  if (arguments.length > 2) {
    types2 = new Array(arguments.length - 1);
    for (var i = 0; i < types2.length; i++) {
      types2[i] = arguments[i + 1];
    }
  }
  var value = req2.headers["content-type"];
  return typeis$1(value, types2);
}
function normalize$1(type3) {
  if (typeof type3 !== "string") {
    return false;
  }
  switch (type3) {
    case "urlencoded":
      return "application/x-www-form-urlencoded";
    case "multipart":
      return "multipart/*";
  }
  if (type3[0] === "+") {
    return "*/*" + type3;
  }
  return type3.indexOf("/") === -1 ? mime$4.lookup(type3) : type3;
}
function mimeMatch(expected, actual) {
  if (expected === false) {
    return false;
  }
  var actualParts = actual.split("/");
  var expectedParts = expected.split("/");
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false;
  }
  if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
    return false;
  }
  if (expectedParts[1].substr(0, 2) === "*+") {
    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
  }
  if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
    return false;
  }
  return true;
}
function normalizeType$1(value) {
  var type3 = typer.parse(value);
  type3.parameters = void 0;
  return typer.format(type3);
}
function tryNormalizeType(value) {
  if (!value) {
    return null;
  }
  try {
    return normalizeType$1(value);
  } catch (err) {
    return null;
  }
}
var typeIsExports = typeIs.exports;
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var json_1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json_1;
  hasRequiredJson = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var createError2 = httpErrorsExports;
  var debug2 = srcExports$1("body-parser:json");
  var read = requireRead();
  var typeis2 = typeIsExports;
  json_1 = json3;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  var JSON_SYNTAX_CHAR = "#";
  var JSON_SYNTAX_REGEXP = /#+/g;
  function json3(options2) {
    var opts = options2 || {};
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var inflate2 = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type3 = opts.type || "application/json";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first2 = firstchar(body);
        if (first2 !== "{" && first2 !== "[") {
          debug2("strict violation");
          throw createStrictSyntaxError(body, first2);
        }
      }
      try {
        debug2("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || "utf-8";
      if (charset3.slice(0, 4) !== "utf-") {
        debug2("invalid charset");
        next(createError2(415, 'unsupported charset "' + charset3.toUpperCase() + '"', {
          charset: charset3,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        encoding: charset3,
        inflate: inflate2,
        limit: limit2,
        verify
      });
    };
  }
  function createStrictSyntaxError(str2, char) {
    var index2 = str2.indexOf(char);
    var partial = "";
    if (index2 !== -1) {
      partial = str2.substring(0, index2) + JSON_SYNTAX_CHAR;
      for (var i = index2 + 1; i < str2.length; i++) {
        partial += JSON_SYNTAX_CHAR;
      }
    }
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
          return str2.substring(index2, index2 + placeholder.length);
        }),
        stack: e.stack
      });
    }
  }
  function firstchar(str2) {
    var match2 = FIRST_CHAR_REGEXP.exec(str2);
    return match2 ? match2[1] : void 0;
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function normalizeJsonSyntaxError(error2, obj) {
    var keys = Object.getOwnPropertyNames(error2);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key !== "stack" && key !== "message") {
        delete error2[key];
      }
    }
    error2.stack = obj.stack.replace(error2.message, obj.message);
    error2.message = obj.message;
    return error2;
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return json_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var raw_1;
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw) return raw_1;
  hasRequiredRaw = 1;
  var bytes2 = requireBytes();
  var debug2 = srcExports$1("body-parser:raw");
  var read = requireRead();
  var typeis2 = typeIsExports;
  raw_1 = raw;
  function raw(options2) {
    var opts = options2 || {};
    var inflate2 = opts.inflate !== false;
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "application/octet-stream";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(buf) {
      return buf;
    }
    return function rawParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        encoding: null,
        inflate: inflate2,
        limit: limit2,
        verify
      });
    };
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return raw_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var text_1;
var hasRequiredText;
function requireText() {
  if (hasRequiredText) return text_1;
  hasRequiredText = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var debug2 = srcExports$1("body-parser:text");
  var read = requireRead();
  var typeis2 = typeIsExports;
  text_1 = text;
  function text(options2) {
    var opts = options2 || {};
    var defaultCharset = opts.defaultCharset || "utf-8";
    var inflate2 = opts.inflate !== false;
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "text/plain";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(buf) {
      return buf;
    }
    return function textParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || defaultCharset;
      read(req2, res2, next, parse2, debug2, {
        encoding: charset3,
        inflate: inflate2,
        limit: limit2,
        verify
      });
    };
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return text_1;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var util_inspect;
var hasRequiredUtil_inspect;
function requireUtil_inspect() {
  if (hasRequiredUtil_inspect) return util_inspect;
  hasRequiredUtil_inspect = 1;
  util_inspect = require$$1$1.inspect;
  return util_inspect;
}
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString2 = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str2) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str2)) {
      return str2;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int2 = num < 0 ? -$floor(-num) : $floor(num);
      if (int2 !== num) {
        var intStr = String(int2);
        var dec = $slice.call(str2, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str2, sepRegex, "$&_");
  }
  var utilInspect = requireUtil_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function inspect_(obj, options2, depth, seen) {
    var opts = options2 || {};
    if (has2(opts, "quoteStyle") && !has2(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has2(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str2 = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str2) : str2;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has2(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s2 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s2 += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s2 += "...";
      }
      s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s2;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber2(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate2(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s2, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s2 + quoteChar;
  }
  function quote(s2) {
    return $replace.call(String(s2), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate2(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber2(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn2 = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has2(obj, key) {
    return hasOwn2.call(obj, key);
  }
  function toStr(obj) {
    return objectToString2.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m2 = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m2) {
      return m2[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s2) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s2) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m2) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s2) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str2, opts) {
    if (str2.length > opts.maxStringLength) {
      var remaining = str2.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str2, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s2 = $replace.call($replace.call(str2, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s2, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str2) {
    return "Object(" + str2 + ")";
  }
  function weakCollectionOf(type3) {
    return type3 + " { ? }";
  }
  function collectionOf(type3, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type3 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has2(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key in obj) {
      if (!has2(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect = requireObjectInspect();
  var $TypeError = requireType();
  var listGetNode = function(list, key, isDelete) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    if (!objects) {
      return void 0;
    }
    var node2 = listGetNode(objects, key);
    return node2 && node2.value;
  };
  var listSet = function(objects, key, value) {
    var node2 = listGetNode(objects, key);
    if (node2) {
      node2.value = value;
    } else {
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key);
  };
  var listDelete = function(objects, key) {
    if (objects) {
      return listGetNode(objects, key, true);
    }
  };
  sideChannelList = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        var root3 = $o && $o.next;
        var deletedNode = listDelete($o, key);
        if (deletedNode && root3 && root3 === deletedNode) {
          $o = void 0;
        }
        return !!deletedNode;
      },
      get: function(key) {
        return listGet($o, key);
      },
      has: function(key) {
        return listHas($o, key);
      },
      set: function(key, value) {
        if (!$o) {
          $o = {
            next: void 0
          };
        }
        listSet(
          /** @type {NonNullable<typeof $o>} */
          $o,
          key,
          value
        );
      }
    };
    return channel;
  };
  return sideChannelList;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign$1;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign$1;
  hasRequiredSign = 1;
  var $isNaN = require_isNaN();
  sign$1 = function sign2(number2) {
    if ($isNaN(number2) || number2 === 0) {
      return number2;
    }
    return number2 < 0 ? -1 : 1;
  };
  return sign$1;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str2 = "";
    for (var i = 0; i < arr.length; i += 1) {
      str2 += arr[i];
      if (i + 1 < arr.length) {
        str2 += joiner;
      }
    }
    return str2;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = requireEsObjectAtoms();
  var $Error = requireEsErrors();
  var $EvalError = require_eval();
  var $RangeError = requireRange();
  var $ReferenceError = requireRef();
  var $SyntaxError = requireSyntax();
  var $TypeError = requireType();
  var $URIError = requireUri();
  var abs2 = requireAbs();
  var floor2 = requireFloor();
  var max2 = requireMax();
  var min2 = requireMin();
  var pow2 = requirePow();
  var round2 = requireRound();
  var sign2 = requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = requireGopd();
  var $defineProperty = requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn2 = requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string2) {
    var first2 = $strSlice(string2, 0, 1);
    var last = $strSlice(string2, -1);
    if (first2 === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string2, rePropName, function(match2, number2, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match2;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn2(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first2 = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first2 === '"' || first2 === "'" || first2 === "`" || (last === '"' || last === "'" || last === "`")) && first2 !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn2(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn2(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBound2 = requireCallBound();
  var inspect = requireObjectInspect();
  var $TypeError = requireType();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var $mapDelete = callBound2("Map.prototype.delete", true);
  var $mapSize = callBound2("Map.prototype.size", true);
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
  function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        if ($m) {
          var result = $mapDelete($m, key);
          if ($mapSize($m) === 0) {
            $m = void 0;
          }
          return result;
        }
        return false;
      },
      get: function(key) {
        if ($m) {
          return $mapGet($m, key);
        }
      },
      has: function(key) {
        if ($m) {
          return $mapHas($m, key);
        }
        return false;
      },
      set: function(key, value) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      }
    };
    return channel;
  };
  return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBound2 = requireCallBound();
  var inspect = requireObjectInspect();
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError = requireType();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
  sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
      var $wm;
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapDelete($wm, key);
            }
          } else if (getSideChannelMap) {
            if ($m) {
              return $m["delete"](key);
            }
          }
          return false;
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          }
          return $m && $m.get(key);
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          }
          return !!$m && $m.has(key);
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if (getSideChannelMap) {
            if (!$m) {
              $m = getSideChannelMap();
            }
            $m.set(key, value);
          }
        }
      };
      return channel;
    }
  ) : getSideChannelMap;
  return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError = requireType();
  var inspect = requireObjectInspect();
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  sideChannel = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        return !!$channelData && $channelData["delete"](key);
      },
      get: function(key) {
        return $channelData && $channelData.get(key);
      },
      has: function(key) {
        return !!$channelData && $channelData.has(key);
      },
      set: function(key, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key, value);
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}
var utils$1;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  var formats2 = requireFormats();
  var getSideChannel = requireSideChannel();
  var has2 = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var overflowChannel = getSideChannel();
  var markOverflow = function markOverflow2(obj, maxIndex) {
    overflowChannel.set(obj, maxIndex);
    return obj;
  };
  var isOverflow = function isOverflow2(obj) {
    return overflowChannel.has(obj);
  };
  var getMaxIndex = function getMaxIndex2(obj) {
    return overflowChannel.get(obj);
  };
  var setMaxIndex = function setMaxIndex2(obj, maxIndex) {
    overflowChannel.set(obj, maxIndex);
  };
  var hexTable = function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue2) {
    while (queue2.length > 1) {
      var item = queue2.pop();
      var obj = item.obj[item.prop];
      if (isArray2(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source, options2) {
    var obj = options2 && options2.plainObjects ? { __proto__: null } : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge2 = function merge3(target, source, options2) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object" && typeof source !== "function") {
      if (isArray2(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (isOverflow(target)) {
          var newIndex = getMaxIndex(target) + 1;
          target[newIndex] = source;
          setMaxIndex(target, newIndex);
        } else if (options2 && (options2.plainObjects || options2.allowPrototypes) || !has2.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      if (isOverflow(source)) {
        var sourceKeys = Object.keys(source);
        var result = options2 && options2.plainObjects ? { __proto__: null, 0: target } : { 0: target };
        for (var m2 = 0; m2 < sourceKeys.length; m2++) {
          var oldKey = parseInt(sourceKeys[m2], 10);
          result[oldKey + 1] = source[sourceKeys[m2]];
        }
        return markOverflow(result, getMaxIndex(source) + 1);
      }
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray2(target) && !isArray2(source)) {
      mergeTarget = arrayToObject(target, options2);
    }
    if (isArray2(target) && isArray2(source)) {
      source.forEach(function(item, i) {
        if (has2.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge3(targetItem, item, options2);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has2.call(acc, key)) {
        acc[key] = merge3(acc[key], value, options2);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode2 = function(str2, defaultDecoder, charset3) {
    var strWithoutPlus = str2.replace(/\+/g, " ");
    if (charset3 === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit2 = 1024;
  var encode2 = function encode3(str2, defaultEncoder, charset3, kind, format2) {
    if (str2.length === 0) {
      return str2;
    }
    var string2 = str2;
    if (typeof str2 === "symbol") {
      string2 = Symbol.prototype.toString.call(str2);
    } else if (typeof str2 !== "string") {
      string2 = String(str2);
    }
    if (charset3 === "iso-8859-1") {
      return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j = 0; j < string2.length; j += limit2) {
      var segment = string2.length >= limit2 ? string2.slice(j, j + limit2) : string2;
      var arr = [];
      for (var i = 0; i < segment.length; ++i) {
        var c = segment.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats2.RFC1738 && (c === 40 || c === 41)) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c < 128) {
          arr[arr.length] = hexTable[c];
          continue;
        }
        if (c < 2048) {
          arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
        arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue2 = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0; i < queue2.length; ++i) {
      var item = queue2[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue2.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue2);
    return value;
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer2(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b, arrayLimit, plainObjects) {
    if (isOverflow(a)) {
      var newIndex = getMaxIndex(a) + 1;
      a[newIndex] = b;
      setMaxIndex(a, newIndex);
      return a;
    }
    var result = [].concat(a, b);
    if (result.length > arrayLimit) {
      return markOverflow(arrayToObject(result, { plainObjects }), result.length - 1);
    }
    return result;
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray2(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  utils$1 = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode: decode2,
    encode: encode2,
    isBuffer,
    isOverflow,
    isRegExp,
    maybeMap,
    merge: merge2
  };
  return utils$1;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = requireUtils();
  var formats2 = requireFormats();
  var has2 = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat2(prefix) {
      return prefix;
    }
  };
  var isArray2 = Array.isArray;
  var push2 = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push2.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults2 = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    filter: void 0,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel2 = {};
  var stringify2 = function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort2, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset3, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel2)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel2) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter2 === "function") {
      obj = filter2(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
      obj = utils2.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults2.encoder, charset3, "key", format2) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults2.encoder, charset3, "key", format2);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults2.encoder, charset3, "value", format2))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray2(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = utils2.maybeMap(obj, encoder);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray2(filter2)) {
      objKeys = filter2;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort2 ? keys.sort(sort2) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j = 0; j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
      var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel2, sideChannel2);
      pushToArray(values, stringify3(
        value,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder,
        filter2,
        sort2,
        allowDots,
        serializeDate,
        format2,
        formatter,
        encodeValuesOnly,
        charset3,
        valueSideChannel
      ));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset3 = opts.charset || defaults2.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format2 = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has2.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format2 = opts.format;
    }
    var formatter = formats2.formatters[format2];
    var filter2 = defaults2.filter;
    if (typeof opts.filter === "function" || isArray2(opts.filter)) {
      filter2 = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults2.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
      arrayFormat,
      charset: charset3,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults2.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
      filter: filter2,
      format: format2,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options2 = normalizeStringifyOptions(opts);
    var objKeys;
    var filter2;
    if (typeof options2.filter === "function") {
      filter2 = options2.filter;
      obj = filter2("", obj);
    } else if (isArray2(options2.filter)) {
      filter2 = options2.filter;
      objKeys = filter2;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options2.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options2.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options2.sort) {
      objKeys.sort(options2.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      var value = obj[key];
      if (options2.skipNulls && value === null) {
        continue;
      }
      pushToArray(keys, stringify2(
        value,
        key,
        generateArrayPrefix,
        commaRoundTrip,
        options2.allowEmptyArrays,
        options2.strictNullHandling,
        options2.skipNulls,
        options2.encodeDotInKeys,
        options2.encode ? options2.encoder : null,
        options2.filter,
        options2.sort,
        options2.allowDots,
        options2.serializeDate,
        options2.format,
        options2.formatter,
        options2.encodeValuesOnly,
        options2.charset,
        sideChannel2
      ));
    }
    var joined = keys.join(options2.delimiter);
    var prefix = options2.addQueryPrefix === true ? "?" : "";
    if (options2.charsetSentinel) {
      if (options2.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse$7;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$7;
  hasRequiredParse = 1;
  var utils2 = requireUtils();
  var has2 = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var defaults2 = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  };
  var interpretNumericEntities = function(str2) {
    return str2.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options2, currentArrayLength) {
    if (val && typeof val === "string" && options2.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    if (options2.throwOnLimitExceeded && currentArrayLength >= options2.arrayLimit) {
      throw new RangeError("Array limit exceeded. Only " + options2.arrayLimit + " element" + (options2.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str2, options2) {
    var obj = { __proto__: null };
    var cleanStr = options2.ignoreQueryPrefix ? str2.replace(/^\?/, "") : str2;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit2 = options2.parameterLimit === Infinity ? void 0 : options2.parameterLimit;
    var parts = cleanStr.split(
      options2.delimiter,
      options2.throwOnLimitExceeded ? limit2 + 1 : limit2
    );
    if (options2.throwOnLimitExceeded && parts.length > limit2) {
      throw new RangeError("Parameter limit exceeded. Only " + limit2 + " parameter" + (limit2 === 1 ? "" : "s") + " allowed.");
    }
    var skipIndex = -1;
    var i;
    var charset3 = options2.charset;
    if (options2.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset3 = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset3 = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key;
      var val;
      if (pos === -1) {
        key = options2.decoder(part, defaults2.decoder, charset3, "key");
        val = options2.strictNullHandling ? null : "";
      } else {
        key = options2.decoder(part.slice(0, pos), defaults2.decoder, charset3, "key");
        if (key !== null) {
          val = utils2.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options2,
              isArray2(obj[key]) ? obj[key].length : 0
            ),
            function(encodedVal) {
              return options2.decoder(encodedVal, defaults2.decoder, charset3, "value");
            }
          );
        }
      }
      if (val && options2.interpretNumericEntities && charset3 === "iso-8859-1") {
        val = interpretNumericEntities(String(val));
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray2(val) ? [val] : val;
      }
      if (key !== null) {
        var existing = has2.call(obj, key);
        if (existing && options2.duplicates === "combine") {
          obj[key] = utils2.combine(
            obj[key],
            val,
            options2.arrayLimit,
            options2.plainObjects
          );
        } else if (!existing || options2.duplicates === "last") {
          obj[key] = val;
        }
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options2, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === "[]") {
      var parentKey = chain.slice(0, -1).join("");
      currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options2, currentArrayLength);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root3 = chain[i];
      if (root3 === "[]" && options2.parseArrays) {
        if (utils2.isOverflow(leaf)) {
          obj = leaf;
        } else {
          obj = options2.allowEmptyArrays && (leaf === "" || options2.strictNullHandling && leaf === null) ? [] : utils2.combine(
            [],
            leaf,
            options2.arrayLimit,
            options2.plainObjects
          );
        }
      } else {
        obj = options2.plainObjects ? { __proto__: null } : {};
        var cleanRoot = root3.charAt(0) === "[" && root3.charAt(root3.length - 1) === "]" ? root3.slice(1, -1) : root3;
        var decodedRoot = options2.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index2 = parseInt(decodedRoot, 10);
        if (!options2.parseArrays && decodedRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index2) && root3 !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && (options2.parseArrays && index2 <= options2.arrayLimit)) {
          obj = [];
          obj[index2] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var splitKeyIntoSegments = function splitKeyIntoSegments2(givenKey, options2) {
    var key = options2.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    if (options2.depth <= 0) {
      if (!options2.plainObjects && has2.call(Object.prototype, key)) {
        if (!options2.allowPrototypes) {
          return;
        }
      }
      return [key];
    }
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options2.plainObjects && has2.call(Object.prototype, parent)) {
        if (!options2.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options2.depth) {
      i += 1;
      var segmentContent = segment[1].slice(1, -1);
      if (!options2.plainObjects && has2.call(Object.prototype, segmentContent)) {
        if (!options2.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options2.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options2.depth + " and strictDepth is true");
      }
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return keys;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options2, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var keys = splitKeyIntoSegments(givenKey, options2);
    if (!keys) {
      return;
    }
    return parseObject(keys, val, options2, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    }
    var charset3 = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults2.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
      charset: charset3,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults2.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults2.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling,
      throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
    };
  };
  parse$7 = function(str2, opts) {
    var options2 = normalizeParseOptions(opts);
    if (str2 === "" || str2 === null || typeof str2 === "undefined") {
      return options2.plainObjects ? { __proto__: null } : {};
    }
    var tempObj = typeof str2 === "string" ? parseValues(str2, options2) : str2;
    var obj = options2.plainObjects ? { __proto__: null } : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options2, typeof str2 === "string");
      obj = utils2.merge(obj, newObj, options2);
    }
    if (options2.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse$7;
}
var lib$1;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$1;
  hasRequiredLib = 1;
  var stringify2 = requireStringify();
  var parse2 = requireParse();
  var formats2 = requireFormats();
  lib$1 = {
    formats: formats2,
    parse: parse2,
    stringify: stringify2
  };
  return lib$1;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var urlencoded_1;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded) return urlencoded_1;
  hasRequiredUrlencoded = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var createError2 = httpErrorsExports;
  var debug2 = srcExports$1("body-parser:urlencoded");
  var deprecate2 = depd_1("body-parser");
  var read = requireRead();
  var typeis2 = typeIsExports;
  urlencoded_1 = urlencoded;
  var parsers = /* @__PURE__ */ Object.create(null);
  function urlencoded(options2) {
    var opts = options2 || {};
    if (opts.extended === void 0) {
      deprecate2("undefined extended: provide extended option");
    }
    var extended = opts.extended !== false;
    var inflate2 = opts.inflate !== false;
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "application/x-www-form-urlencoded";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || "utf-8";
      if (charset3 !== "utf-8") {
        debug2("invalid charset");
        next(createError2(415, 'unsupported charset "' + charset3.toUpperCase() + '"', {
          charset: charset3,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        debug: debug2,
        encoding: charset3,
        inflate: inflate2,
        limit: limit2,
        verify
      });
    };
  }
  function extendedparser(options2) {
    var parameterLimit = options2.parameterLimit !== void 0 ? options2.parameterLimit : 1e3;
    var depth = options2.depth !== void 0 ? options2.depth : 32;
    var parse2 = parser2("qs");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isNaN(depth) || depth < 0) {
      throw new TypeError("option depth must be a zero or a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError2(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = Math.max(100, paramCount);
      debug2("parse extended urlencoding");
      try {
        return parse2(body, {
          allowPrototypes: true,
          arrayLimit,
          depth,
          strictDepth: true,
          parameterLimit
        });
      } catch (err) {
        if (err instanceof RangeError) {
          throw createError2(400, "The input exceeded the depth", {
            type: "querystring.parse.rangeError"
          });
        } else {
          throw err;
        }
      }
    };
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function parameterCount(body, limit2) {
    var count = 0;
    var index2 = 0;
    while ((index2 = body.indexOf("&", index2)) !== -1) {
      count++;
      index2++;
      if (count === limit2) {
        return void 0;
      }
    }
    return count;
  }
  function parser2(name) {
    var mod = parsers[name];
    if (mod !== void 0) {
      return mod.parse;
    }
    switch (name) {
      case "qs":
        mod = requireLib();
        break;
      case "querystring":
        mod = require$$8;
        break;
    }
    parsers[name] = mod;
    return mod.parse;
  }
  function simpleparser(options2) {
    var parameterLimit = options2.parameterLimit !== void 0 ? options2.parameterLimit : 1e3;
    var parse2 = parser2("querystring");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError2(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      debug2("parse urlencoding");
      return parse2(body, void 0, void 0, { maxKeys: parameterLimit });
    };
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return urlencoded_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module, exports$1) {
  var deprecate2 = depd_1("body-parser");
  var parsers = /* @__PURE__ */ Object.create(null);
  exports$1 = module.exports = deprecate2.function(
    bodyParser2,
    "bodyParser: use individual json/urlencoded middlewares"
  );
  Object.defineProperty(exports$1, "json", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("json")
  });
  Object.defineProperty(exports$1, "raw", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("raw")
  });
  Object.defineProperty(exports$1, "text", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("text")
  });
  Object.defineProperty(exports$1, "urlencoded", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("urlencoded")
  });
  function bodyParser2(options2) {
    var opts = Object.create(options2 || null, {
      type: {
        configurable: true,
        enumerable: true,
        value: void 0,
        writable: true
      }
    });
    var _urlencoded = exports$1.urlencoded(opts);
    var _json = exports$1.json(opts);
    return function bodyParser3(req2, res2, next) {
      _json(req2, res2, function(err) {
        if (err) return next(err);
        _urlencoded(req2, res2, next);
      });
    };
  }
  function createParserGetter(name) {
    return function get2() {
      return loadParser(name);
    };
  }
  function loadParser(parserName) {
    var parser2 = parsers[parserName];
    if (parser2 !== void 0) {
      return parser2;
    }
    switch (parserName) {
      case "json":
        parser2 = requireJson();
        break;
      case "raw":
        parser2 = requireRaw();
        break;
      case "text":
        parser2 = requireText();
        break;
      case "urlencoded":
        parser2 = requireUrlencoded();
        break;
    }
    return parsers[parserName] = parser2;
  }
})(bodyParser, bodyParser.exports);
var bodyParserExports = bodyParser.exports;
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var mergeDescriptors = merge$1;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function merge$1(dest, src2, redefine) {
  if (!dest) {
    throw new TypeError("argument dest is required");
  }
  if (!src2) {
    throw new TypeError("argument src is required");
  }
  if (redefine === void 0) {
    redefine = true;
  }
  Object.getOwnPropertyNames(src2).forEach(function forEachOwnPropertyName(name) {
    if (!redefine && hasOwnProperty$2.call(dest, name)) {
      return;
    }
    var descriptor = Object.getOwnPropertyDescriptor(src2, name);
    Object.defineProperty(dest, name, descriptor);
  });
  return dest;
}
var application = { exports: {} };
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl = encodeUrl$3;
var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
function encodeUrl$3(url2) {
  return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml$3;
function escapeHtml$3(string2) {
  var str2 = "" + string2;
  var match2 = matchHtmlRegExp.exec(str2);
  if (!match2) {
    return str2;
  }
  var escape2;
  var html = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match2.index; index2 < str2.length; index2++) {
    switch (str2.charCodeAt(index2)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str2.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escape2;
  }
  return lastIndex !== index2 ? html + str2.substring(lastIndex, index2) : html;
}
var parseurl$1 = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var url = require$$0$a;
var parse$6 = url.parse;
var Url = url.Url;
parseurl$1.exports = parseurl;
parseurl$1.exports.original = originalurl;
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh$3(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh$3(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str2) {
  if (typeof str2 !== "string" || str2.charCodeAt(0) !== 47) {
    return parse$6(str2);
  }
  var pathname = str2;
  var query = null;
  var search = null;
  for (var i = 1; i < str2.length; i++) {
    switch (str2.charCodeAt(i)) {
      case 63:
        if (search === null) {
          pathname = str2.substring(0, i);
          query = str2.substring(i + 1);
          search = str2.substring(i);
        }
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return parse$6(str2);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str2;
  url2.href = str2;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query;
    url2.search = search;
  }
  return url2;
}
function fresh$3(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
var parseurlExports = parseurl$1.exports;
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$c = srcExports$1("finalhandler");
var encodeUrl$2 = encodeurl;
var escapeHtml$2 = escapeHtml_1;
var onFinished$2 = onFinishedExports;
var parseUrl$1 = parseurlExports;
var statuses$2 = statuses$3;
var unpipe = unpipe_1;
var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
var NEWLINE_REGEXP = /\n/g;
var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
var isFinished = onFinished$2.isFinished;
function createHtmlDocument$1(message) {
  var body = escapeHtml$2(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
}
var finalhandler_1 = finalhandler;
function finalhandler(req2, res2, options2) {
  var opts = options2 || {};
  var env = opts.env || process.env.NODE_ENV || "development";
  var onerror = opts.onerror;
  return function(err) {
    var headers;
    var msg;
    var status3;
    if (!err && headersSent$1(res2)) {
      debug$c("cannot 404 after headers sent");
      return;
    }
    if (err) {
      status3 = getErrorStatusCode(err);
      if (status3 === void 0) {
        status3 = getResponseStatusCode(res2);
      } else {
        headers = getErrorHeaders(err);
      }
      msg = getErrorMessage(err, status3, env);
    } else {
      status3 = 404;
      msg = "Cannot " + req2.method + " " + encodeUrl$2(getResourceName(req2));
    }
    debug$c("default %s", status3);
    if (err && onerror) {
      defer(onerror, err, req2, res2);
    }
    if (headersSent$1(res2)) {
      debug$c("cannot %d after headers sent", status3);
      if (req2.socket) {
        req2.socket.destroy();
      }
      return;
    }
    send$3(req2, res2, status3, headers, msg);
  };
}
function getErrorHeaders(err) {
  if (!err.headers || typeof err.headers !== "object") {
    return void 0;
  }
  var headers = /* @__PURE__ */ Object.create(null);
  var keys = Object.keys(err.headers);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    headers[key] = err.headers[key];
  }
  return headers;
}
function getErrorMessage(err, status3, env) {
  var msg;
  if (env !== "production") {
    msg = err.stack;
    if (!msg && typeof err.toString === "function") {
      msg = err.toString();
    }
  }
  return msg || statuses$2.message[status3];
}
function getErrorStatusCode(err) {
  if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
    return err.status;
  }
  if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode;
  }
  return void 0;
}
function getResourceName(req2) {
  try {
    return parseUrl$1.original(req2).pathname;
  } catch (e) {
    return "resource";
  }
}
function getResponseStatusCode(res2) {
  var status3 = res2.statusCode;
  if (typeof status3 !== "number" || status3 < 400 || status3 > 599) {
    status3 = 500;
  }
  return status3;
}
function headersSent$1(res2) {
  return typeof res2.headersSent !== "boolean" ? Boolean(res2._header) : res2.headersSent;
}
function send$3(req2, res2, status3, headers, message) {
  function write() {
    var body = createHtmlDocument$1(message);
    res2.statusCode = status3;
    if (req2.httpVersionMajor < 2) {
      res2.statusMessage = statuses$2.message[status3];
    }
    res2.removeHeader("Content-Encoding");
    res2.removeHeader("Content-Language");
    res2.removeHeader("Content-Range");
    setHeaders$1(res2, headers);
    res2.setHeader("Content-Security-Policy", "default-src 'none'");
    res2.setHeader("X-Content-Type-Options", "nosniff");
    res2.setHeader("Content-Type", "text/html; charset=utf-8");
    res2.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
    if (req2.method === "HEAD") {
      res2.end();
      return;
    }
    res2.end(body, "utf8");
  }
  if (isFinished(req2)) {
    write();
    return;
  }
  unpipe(req2);
  onFinished$2(req2, write);
  req2.resume();
}
function setHeaders$1(res2, headers) {
  if (!headers) {
    return;
  }
  var keys = Object.keys(headers);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    res2.setHeader(key, headers[key]);
  }
}
var router = { exports: {} };
var arrayFlatten_1 = arrayFlatten;
function flattenWithDepth(array, result, depth) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    if (depth > 0 && Array.isArray(value)) {
      flattenWithDepth(value, result, depth - 1);
    } else {
      result.push(value);
    }
  }
  return result;
}
function flattenForever(array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    if (Array.isArray(value)) {
      flattenForever(value, result);
    } else {
      result.push(value);
    }
  }
  return result;
}
function arrayFlatten(array, depth) {
  if (depth == null) {
    return flattenForever(array, []);
  }
  return flattenWithDepth(array, [], depth);
}
var pathToRegexp_1 = pathToRegexp;
var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;
function pathToRegexp(path3, keys, options2) {
  options2 = options2 || {};
  keys = keys || [];
  var strict = options2.strict;
  var end = options2.end !== false;
  var flags = options2.sensitive ? "" : "i";
  var lookahead = options2.lookahead !== false;
  var extraOffset = 0;
  var keysOffset = keys.length;
  var i = 0;
  var name = 0;
  var pos = 0;
  var backtrack = "";
  var m2;
  if (path3 instanceof RegExp) {
    while (m2 = MATCHING_GROUP_REGEXP.exec(path3.source)) {
      if (m2[0][0] === "\\") continue;
      keys.push({
        name: m2[1] || name++,
        optional: false,
        offset: m2.index
      });
    }
    return path3;
  }
  if (Array.isArray(path3)) {
    path3 = path3.map(function(value) {
      return pathToRegexp(value, keys, options2).source;
    });
    return new RegExp(path3.join("|"), flags);
  }
  if (typeof path3 !== "string") {
    throw new TypeError("path must be a string, array of strings, or regular expression");
  }
  path3 = path3.replace(
    /\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g,
    function(match2, slash, format2, key, capture, star, optional, offset) {
      if (match2[0] === "\\") {
        backtrack += match2;
        pos += 2;
        return match2;
      }
      if (match2 === ".") {
        backtrack += "\\.";
        extraOffset += 1;
        pos += 1;
        return "\\.";
      }
      if (slash || format2) {
        backtrack = "";
      } else {
        backtrack += path3.slice(pos, offset);
      }
      pos = offset + match2.length;
      if (match2 === "*") {
        extraOffset += 3;
        return "(.*)";
      }
      if (match2 === "/(") {
        backtrack += "/";
        extraOffset += 2;
        return "/(?:";
      }
      slash = slash || "";
      format2 = format2 ? "\\." : "";
      optional = optional || "";
      capture = capture ? capture.replace(/\\.|\*/, function(m3) {
        return m3 === "*" ? "(.*)" : m3;
      }) : backtrack ? "((?:(?!/|" + backtrack + ").)+?)" : "([^/" + format2 + "]+?)";
      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });
      var result = "(?:" + format2 + slash + capture + (star ? "((?:[/" + format2 + "].+?)?)" : "") + ")" + optional;
      extraOffset += result.length - match2.length;
      return result;
    }
  );
  while (m2 = MATCHING_GROUP_REGEXP.exec(path3)) {
    if (m2[0][0] === "\\") continue;
    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m2.index) {
      keys.splice(keysOffset + i, 0, {
        name: name++,
        // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m2.index
      });
    }
    i++;
  }
  path3 += strict ? "" : path3[path3.length - 1] === "/" ? "?" : "/?";
  if (end) {
    path3 += "$";
  } else if (path3[path3.length - 1] !== "/") {
    path3 += lookahead ? "(?=/|$)" : "(?:/|$)";
  }
  return new RegExp("^" + path3, flags);
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var pathRegexp = pathToRegexp_1;
var debug$b = srcExports$1("express:router:layer");
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var layer = Layer$2;
function Layer$2(path3, options2, fn) {
  if (!(this instanceof Layer$2)) {
    return new Layer$2(path3, options2, fn);
  }
  debug$b("new %o", path3);
  var opts = options2 || {};
  this.handle = fn;
  this.name = fn.name || "<anonymous>";
  this.params = void 0;
  this.path = void 0;
  this.regexp = pathRegexp(path3, this.keys = [], opts);
  this.regexp.fast_star = path3 === "*";
  this.regexp.fast_slash = path3 === "/" && opts.end === false;
}
Layer$2.prototype.handle_error = function handle_error(error2, req2, res2, next) {
  var fn = this.handle;
  if (fn.length !== 4) {
    return next(error2);
  }
  try {
    fn(error2, req2, res2, next);
  } catch (err) {
    next(err);
  }
};
Layer$2.prototype.handle_request = function handle(req2, res2, next) {
  var fn = this.handle;
  if (fn.length > 3) {
    return next();
  }
  try {
    fn(req2, res2, next);
  } catch (err) {
    next(err);
  }
};
Layer$2.prototype.match = function match(path3) {
  var match2;
  if (path3 != null) {
    if (this.regexp.fast_slash) {
      this.params = {};
      this.path = "";
      return true;
    }
    if (this.regexp.fast_star) {
      this.params = { "0": decode_param(path3) };
      this.path = path3;
      return true;
    }
    match2 = this.regexp.exec(path3);
  }
  if (!match2) {
    this.params = void 0;
    this.path = void 0;
    return false;
  }
  this.params = {};
  this.path = match2[0];
  var keys = this.keys;
  var params = this.params;
  for (var i = 1; i < match2.length; i++) {
    var key = keys[i - 1];
    var prop = key.name;
    var val = decode_param(match2[i]);
    if (val !== void 0 || !hasOwnProperty$1.call(params, prop)) {
      params[prop] = val;
    }
  }
  return true;
};
function decode_param(val) {
  if (typeof val !== "string" || val.length === 0) {
    return val;
  }
  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = "Failed to decode param '" + val + "'";
      err.status = err.statusCode = 400;
    }
    throw err;
  }
}
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var http$2 = require$$0$b;
var methods$2 = getCurrentNodeMethods() || getBasicNodeMethods();
function getCurrentNodeMethods() {
  return http$2.METHODS && http$2.METHODS.map(function lowerCaseMethod(method2) {
    return method2.toLowerCase();
  });
}
function getBasicNodeMethods() {
  return [
    "get",
    "post",
    "put",
    "head",
    "delete",
    "options",
    "trace",
    "copy",
    "lock",
    "mkcol",
    "move",
    "purge",
    "propfind",
    "proppatch",
    "unlock",
    "report",
    "mkactivity",
    "checkout",
    "merge",
    "m-search",
    "notify",
    "subscribe",
    "unsubscribe",
    "patch",
    "search",
    "connect"
  ];
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$a = srcExports$1("express:router:route");
var flatten$1 = arrayFlatten_1;
var Layer$1 = layer;
var methods$1 = methods$2;
var slice$1 = Array.prototype.slice;
var toString$2 = Object.prototype.toString;
var route = Route$1;
function Route$1(path3) {
  this.path = path3;
  this.stack = [];
  debug$a("new %o", path3);
  this.methods = {};
}
Route$1.prototype._handles_method = function _handles_method(method2) {
  if (this.methods._all) {
    return true;
  }
  var name = typeof method2 === "string" ? method2.toLowerCase() : method2;
  if (name === "head" && !this.methods["head"]) {
    name = "get";
  }
  return Boolean(this.methods[name]);
};
Route$1.prototype._options = function _options() {
  var methods2 = Object.keys(this.methods);
  if (this.methods.get && !this.methods.head) {
    methods2.push("head");
  }
  for (var i = 0; i < methods2.length; i++) {
    methods2[i] = methods2[i].toUpperCase();
  }
  return methods2;
};
Route$1.prototype.dispatch = function dispatch(req2, res2, done) {
  var idx = 0;
  var stack = this.stack;
  var sync2 = 0;
  if (stack.length === 0) {
    return done();
  }
  var method2 = typeof req2.method === "string" ? req2.method.toLowerCase() : req2.method;
  if (method2 === "head" && !this.methods["head"]) {
    method2 = "get";
  }
  req2.route = this;
  next();
  function next(err) {
    if (err && err === "route") {
      return done();
    }
    if (err && err === "router") {
      return done(err);
    }
    if (++sync2 > 100) {
      return setImmediate(next, err);
    }
    var layer2 = stack[idx++];
    if (!layer2) {
      return done(err);
    }
    if (layer2.method && layer2.method !== method2) {
      next(err);
    } else if (err) {
      layer2.handle_error(err, req2, res2, next);
    } else {
      layer2.handle_request(req2, res2, next);
    }
    sync2 = 0;
  }
};
Route$1.prototype.all = function all() {
  var handles = flatten$1(slice$1.call(arguments));
  for (var i = 0; i < handles.length; i++) {
    var handle3 = handles[i];
    if (typeof handle3 !== "function") {
      var type3 = toString$2.call(handle3);
      var msg = "Route.all() requires a callback function but got a " + type3;
      throw new TypeError(msg);
    }
    var layer2 = Layer$1("/", {}, handle3);
    layer2.method = void 0;
    this.methods._all = true;
    this.stack.push(layer2);
  }
  return this;
};
methods$1.forEach(function(method2) {
  Route$1.prototype[method2] = function() {
    var handles = flatten$1(slice$1.call(arguments));
    for (var i = 0; i < handles.length; i++) {
      var handle3 = handles[i];
      if (typeof handle3 !== "function") {
        var type3 = toString$2.call(handle3);
        var msg = "Route." + method2 + "() requires a callback function but got a " + type3;
        throw new Error(msg);
      }
      debug$a("%s %o", method2, this.path);
      var layer2 = Layer$1("/", {}, handle3);
      layer2.method = method2;
      this.methods[method2] = true;
      this.stack.push(layer2);
    }
    return this;
  };
});
var utilsMerge = { exports: {} };
(function(module, exports$1) {
  module.exports = function(a, b) {
    if (a && b) {
      for (var key in b) {
        a[key] = b[key];
      }
    }
    return a;
  };
})(utilsMerge);
var utilsMergeExports = utilsMerge.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Route = route;
var Layer = layer;
var methods = methods$2;
var mixin = utilsMergeExports;
var debug$9 = srcExports$1("express:router");
var deprecate$3 = depd_1("express");
var flatten = arrayFlatten_1;
var parseUrl = parseurlExports;
var setPrototypeOf$1 = setprototypeof;
var objectRegExp = /^\[object (\S+)\]$/;
var slice = Array.prototype.slice;
var toString$1 = Object.prototype.toString;
var proto = router.exports = function(options2) {
  var opts = options2 || {};
  function router2(req2, res2, next) {
    router2.handle(req2, res2, next);
  }
  setPrototypeOf$1(router2, proto);
  router2.params = {};
  router2._params = [];
  router2.caseSensitive = opts.caseSensitive;
  router2.mergeParams = opts.mergeParams;
  router2.strict = opts.strict;
  router2.stack = [];
  return router2;
};
proto.param = function param(name, fn) {
  if (typeof name === "function") {
    deprecate$3("router.param(fn): Refactor to use path params");
    this._params.push(name);
    return;
  }
  var params = this._params;
  var len = params.length;
  var ret;
  if (name[0] === ":") {
    deprecate$3("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.slice(1)) + ", fn) instead");
    name = name.slice(1);
  }
  for (var i = 0; i < len; ++i) {
    if (ret = params[i](name, fn)) {
      fn = ret;
    }
  }
  if ("function" !== typeof fn) {
    throw new Error("invalid param() call for " + name + ", got " + fn);
  }
  (this.params[name] = this.params[name] || []).push(fn);
  return this;
};
proto.handle = function handle2(req2, res2, out) {
  var self2 = this;
  debug$9("dispatching %s %s", req2.method, req2.url);
  var idx = 0;
  var protohost = getProtohost(req2.url) || "";
  var removed = "";
  var slashAdded = false;
  var sync2 = 0;
  var paramcalled = {};
  var options2 = [];
  var stack = self2.stack;
  var parentParams = req2.params;
  var parentUrl = req2.baseUrl || "";
  var done = restore(out, req2, "baseUrl", "next", "params");
  req2.next = next;
  if (req2.method === "OPTIONS") {
    done = wrap(done, function(old2, err) {
      if (err || options2.length === 0) return old2(err);
      sendOptionsResponse(res2, options2, old2);
    });
  }
  req2.baseUrl = parentUrl;
  req2.originalUrl = req2.originalUrl || req2.url;
  next();
  function next(err) {
    var layerError = err === "route" ? null : err;
    if (slashAdded) {
      req2.url = req2.url.slice(1);
      slashAdded = false;
    }
    if (removed.length !== 0) {
      req2.baseUrl = parentUrl;
      req2.url = protohost + removed + req2.url.slice(protohost.length);
      removed = "";
    }
    if (layerError === "router") {
      setImmediate(done, null);
      return;
    }
    if (idx >= stack.length) {
      setImmediate(done, layerError);
      return;
    }
    if (++sync2 > 100) {
      return setImmediate(next, err);
    }
    var path3 = getPathname(req2);
    if (path3 == null) {
      return done(layerError);
    }
    var layer2;
    var match2;
    var route3;
    while (match2 !== true && idx < stack.length) {
      layer2 = stack[idx++];
      match2 = matchLayer(layer2, path3);
      route3 = layer2.route;
      if (typeof match2 !== "boolean") {
        layerError = layerError || match2;
      }
      if (match2 !== true) {
        continue;
      }
      if (!route3) {
        continue;
      }
      if (layerError) {
        match2 = false;
        continue;
      }
      var method2 = req2.method;
      var has_method = route3._handles_method(method2);
      if (!has_method && method2 === "OPTIONS") {
        appendMethods(options2, route3._options());
      }
      if (!has_method && method2 !== "HEAD") {
        match2 = false;
      }
    }
    if (match2 !== true) {
      return done(layerError);
    }
    if (route3) {
      req2.route = route3;
    }
    req2.params = self2.mergeParams ? mergeParams(layer2.params, parentParams) : layer2.params;
    var layerPath = layer2.path;
    self2.process_params(layer2, paramcalled, req2, res2, function(err2) {
      if (err2) {
        next(layerError || err2);
      } else if (route3) {
        layer2.handle_request(req2, res2, next);
      } else {
        trim_prefix(layer2, layerError, layerPath, path3);
      }
      sync2 = 0;
    });
  }
  function trim_prefix(layer2, layerError, layerPath, path3) {
    if (layerPath.length !== 0) {
      if (layerPath !== path3.slice(0, layerPath.length)) {
        next(layerError);
        return;
      }
      var c = path3[layerPath.length];
      if (c && c !== "/" && c !== ".") return next(layerError);
      debug$9("trim prefix (%s) from url %s", layerPath, req2.url);
      removed = layerPath;
      req2.url = protohost + req2.url.slice(protohost.length + removed.length);
      if (!protohost && req2.url[0] !== "/") {
        req2.url = "/" + req2.url;
        slashAdded = true;
      }
      req2.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
    }
    debug$9("%s %s : %s", layer2.name, layerPath, req2.originalUrl);
    if (layerError) {
      layer2.handle_error(layerError, req2, res2, next);
    } else {
      layer2.handle_request(req2, res2, next);
    }
  }
};
proto.process_params = function process_params(layer2, called, req2, res2, done) {
  var params = this.params;
  var keys = layer2.keys;
  if (!keys || keys.length === 0) {
    return done();
  }
  var i = 0;
  var name;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;
  function param3(err) {
    if (err) {
      return done(err);
    }
    if (i >= keys.length) {
      return done();
    }
    paramIndex = 0;
    key = keys[i++];
    name = key.name;
    paramVal = req2.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];
    if (paramVal === void 0 || !paramCallbacks) {
      return param3();
    }
    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
      req2.params[name] = paramCalled.value;
      return param3(paramCalled.error);
    }
    called[name] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };
    paramCallback();
  }
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];
    paramCalled.value = req2.params[key.name];
    if (err) {
      paramCalled.error = err;
      param3(err);
      return;
    }
    if (!fn) return param3();
    try {
      fn(req2, res2, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }
  param3();
};
proto.use = function use(fn) {
  var offset = 0;
  var path3 = "/";
  if (typeof fn !== "function") {
    var arg = fn;
    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }
    if (typeof arg !== "function") {
      offset = 1;
      path3 = fn;
    }
  }
  var callbacks = flatten(slice.call(arguments, offset));
  if (callbacks.length === 0) {
    throw new TypeError("Router.use() requires a middleware function");
  }
  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];
    if (typeof fn !== "function") {
      throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
    }
    debug$9("use %o %s", path3, fn.name || "<anonymous>");
    var layer2 = new Layer(path3, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);
    layer2.route = void 0;
    this.stack.push(layer2);
  }
  return this;
};
proto.route = function route2(path3) {
  var route3 = new Route(path3);
  var layer2 = new Layer(path3, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route3.dispatch.bind(route3));
  layer2.route = route3;
  this.stack.push(layer2);
  return route3;
};
methods.concat("all").forEach(function(method2) {
  proto[method2] = function(path3) {
    var route3 = this.route(path3);
    route3[method2].apply(route3, slice.call(arguments, 1));
    return this;
  };
});
function appendMethods(list, addition) {
  for (var i = 0; i < addition.length; i++) {
    var method2 = addition[i];
    if (list.indexOf(method2) === -1) {
      list.push(method2);
    }
  }
}
function getPathname(req2) {
  try {
    return parseUrl(req2).pathname;
  } catch (err) {
    return void 0;
  }
}
function getProtohost(url2) {
  if (typeof url2 !== "string" || url2.length === 0 || url2[0] === "/") {
    return void 0;
  }
  var searchIndex = url2.indexOf("?");
  var pathLength = searchIndex !== -1 ? searchIndex : url2.length;
  var fqdnIndex = url2.slice(0, pathLength).indexOf("://");
  return fqdnIndex !== -1 ? url2.substring(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
}
function gettype(obj) {
  var type3 = typeof obj;
  if (type3 !== "object") {
    return type3;
  }
  return toString$1.call(obj).replace(objectRegExp, "$1");
}
function matchLayer(layer2, path3) {
  try {
    return layer2.match(path3);
  } catch (err) {
    return err;
  }
}
function mergeParams(params, parent) {
  if (typeof parent !== "object" || !parent) {
    return params;
  }
  var obj = mixin({}, parent);
  if (!(0 in params) || !(0 in parent)) {
    return mixin(obj, params);
  }
  var i = 0;
  var o = 0;
  while (i in params) {
    i++;
  }
  while (o in parent) {
    o++;
  }
  for (i--; i >= 0; i--) {
    params[i + o] = params[i];
    if (i < o) {
      delete params[i];
    }
  }
  return mixin(obj, params);
}
function restore(fn, obj) {
  var props2 = new Array(arguments.length - 2);
  var vals = new Array(arguments.length - 2);
  for (var i = 0; i < props2.length; i++) {
    props2[i] = arguments[i + 2];
    vals[i] = obj[props2[i]];
  }
  return function() {
    for (var i2 = 0; i2 < props2.length; i2++) {
      obj[props2[i2]] = vals[i2];
    }
    return fn.apply(this, arguments);
  };
}
function sendOptionsResponse(res2, options2, next) {
  try {
    var body = options2.join(",");
    res2.set("Allow", body);
    res2.send(body);
  } catch (err) {
    next(err);
  }
}
function wrap(old2, fn) {
  return function proxy() {
    var args = new Array(arguments.length + 1);
    args[0] = old2;
    for (var i = 0, len = arguments.length; i < len; i++) {
      args[i + 1] = arguments[i];
    }
    fn.apply(this, args);
  };
}
var routerExports = router.exports;
var init$1 = {};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var setPrototypeOf = setprototypeof;
init$1.init = function(app2) {
  return function expressInit(req2, res2, next) {
    if (app2.enabled("x-powered-by")) res2.setHeader("X-Powered-By", "Express");
    req2.res = res2;
    res2.req = req2;
    req2.next = next;
    setPrototypeOf(req2, app2.request);
    setPrototypeOf(res2, app2.response);
    res2.locals = res2.locals || /* @__PURE__ */ Object.create(null);
    next();
  };
};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var query$1;
var hasRequiredQuery;
function requireQuery() {
  if (hasRequiredQuery) return query$1;
  hasRequiredQuery = 1;
  var merge2 = utilsMergeExports;
  var parseUrl2 = parseurlExports;
  var qs = requireLib();
  query$1 = function query(options2) {
    var opts = merge2({}, options2);
    var queryparse = qs.parse;
    if (typeof options2 === "function") {
      queryparse = options2;
      opts = void 0;
    }
    if (opts !== void 0 && opts.allowPrototypes === void 0) {
      opts.allowPrototypes = true;
    }
    return function query2(req2, res2, next) {
      if (!req2.query) {
        var val = parseUrl2(req2).query;
        req2.query = queryparse(val, opts);
      }
      next();
    };
  };
  return query$1;
}
function commonjsRequire(path3) {
  throw new Error('Could not dynamically require "' + path3 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$8 = srcExports$1("express:view");
var path$3 = require$$1$2;
var fs$4 = require$$0$8;
var dirname = path$3.dirname;
var basename$1 = path$3.basename;
var extname$2 = path$3.extname;
var join$2 = path$3.join;
var resolve$2 = path$3.resolve;
var view = View;
function View(name, options2) {
  var opts = options2 || {};
  this.defaultEngine = opts.defaultEngine;
  this.ext = extname$2(name);
  this.name = name;
  this.root = opts.root;
  if (!this.ext && !this.defaultEngine) {
    throw new Error("No default engine was specified and no extension was provided.");
  }
  var fileName = name;
  if (!this.ext) {
    this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
    fileName += this.ext;
  }
  if (!opts.engines[this.ext]) {
    var mod = this.ext.slice(1);
    debug$8('require "%s"', mod);
    var fn = commonjsRequire(mod).__express;
    if (typeof fn !== "function") {
      throw new Error('Module "' + mod + '" does not provide a view engine.');
    }
    opts.engines[this.ext] = fn;
  }
  this.engine = opts.engines[this.ext];
  this.path = this.lookup(fileName);
}
View.prototype.lookup = function lookup(name) {
  var path3;
  var roots = [].concat(this.root);
  debug$8('lookup "%s"', name);
  for (var i = 0; i < roots.length && !path3; i++) {
    var root3 = roots[i];
    var loc = resolve$2(root3, name);
    var dir = dirname(loc);
    var file = basename$1(loc);
    path3 = this.resolve(dir, file);
  }
  return path3;
};
View.prototype.render = function render(options2, callback) {
  debug$8('render "%s"', this.path);
  this.engine(this.path, options2, callback);
};
View.prototype.resolve = function resolve(dir, file) {
  var ext = this.ext;
  var path3 = join$2(dir, file);
  var stat2 = tryStat(path3);
  if (stat2 && stat2.isFile()) {
    return path3;
  }
  path3 = join$2(dir, basename$1(file, ext), "index" + ext);
  stat2 = tryStat(path3);
  if (stat2 && stat2.isFile()) {
    return path3;
  }
};
function tryStat(path3) {
  debug$8('stat "%s"', path3);
  try {
    return fs$4.statSync(path3);
  } catch (e) {
    return void 0;
  }
}
var utils = {};
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports$1) {
  var buffer2 = require$$0$5;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src2, dst) {
    for (var key in src2) {
      dst[key] = src2[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports$1);
    exports$1.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding3) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var contentDisposition$2 = { exports: {} };
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
contentDisposition$2.exports = contentDisposition$1;
contentDisposition$2.exports.parse = parse$5;
var basename = require$$1$2.basename;
var Buffer$2 = safeBufferExports.Buffer;
var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
var QESC_REGEXP = /\\([\u0000-\u007f])/g;
var QUOTE_REGEXP = /([\\"])/g;
var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
function contentDisposition$1(filename, options2) {
  var opts = options2 || {};
  var type3 = opts.type || "attachment";
  var params = createparams(filename, opts.fallback);
  return format(new ContentDisposition(type3, params));
}
function createparams(filename, fallback) {
  if (filename === void 0) {
    return;
  }
  var params = {};
  if (typeof filename !== "string") {
    throw new TypeError("filename must be a string");
  }
  if (fallback === void 0) {
    fallback = true;
  }
  if (typeof fallback !== "string" && typeof fallback !== "boolean") {
    throw new TypeError("fallback must be a string or boolean");
  }
  if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError("fallback must be ISO-8859-1 string");
  }
  var name = basename(filename);
  var isQuotedString = TEXT_REGEXP.test(name);
  var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
  var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
    params["filename*"] = name;
  }
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback ? fallbackName : name;
  }
  return params;
}
function format(obj) {
  var parameters = obj.parameters;
  var type3 = obj.type;
  if (!type3 || typeof type3 !== "string" || !TOKEN_REGEXP.test(type3)) {
    throw new TypeError("invalid type");
  }
  var string2 = String(type3).toLowerCase();
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param3 = params[i];
      var val = param3.substr(-1) === "*" ? ustring(parameters[param3]) : qstring(parameters[param3]);
      string2 += "; " + param3 + "=" + val;
    }
  }
  return string2;
}
function decodefield(str2) {
  var match2 = EXT_VALUE_REGEXP.exec(str2);
  if (!match2) {
    throw new TypeError("invalid extended field value");
  }
  var charset3 = match2[1].toLowerCase();
  var encoded = match2[2];
  var value;
  var binary2 = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
  switch (charset3) {
    case "iso-8859-1":
      value = getlatin1(binary2);
      break;
    case "utf-8":
      value = Buffer$2.from(binary2, "binary").toString("utf8");
      break;
    default:
      throw new TypeError("unsupported charset in extended field");
  }
  return value;
}
function getlatin1(val) {
  return String(val).replace(NON_LATIN1_REGEXP, "?");
}
function parse$5(string2) {
  if (!string2 || typeof string2 !== "string") {
    throw new TypeError("argument string is required");
  }
  var match2 = DISPOSITION_TYPE_REGEXP.exec(string2);
  if (!match2) {
    throw new TypeError("invalid type format");
  }
  var index2 = match2[0].length;
  var type3 = match2[1].toLowerCase();
  var key;
  var names2 = [];
  var params = {};
  var value;
  index2 = PARAM_REGEXP.lastIndex = match2[0].substr(-1) === ";" ? index2 - 1 : index2;
  while (match2 = PARAM_REGEXP.exec(string2)) {
    if (match2.index !== index2) {
      throw new TypeError("invalid parameter format");
    }
    index2 += match2[0].length;
    key = match2[1].toLowerCase();
    value = match2[2];
    if (names2.indexOf(key) !== -1) {
      throw new TypeError("invalid duplicate parameter");
    }
    names2.push(key);
    if (key.indexOf("*") + 1 === key.length) {
      key = key.slice(0, -1);
      value = decodefield(value);
      params[key] = value;
      continue;
    }
    if (typeof params[key] === "string") {
      continue;
    }
    if (value[0] === '"') {
      value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
    }
    params[key] = value;
  }
  if (index2 !== -1 && index2 !== string2.length) {
    throw new TypeError("invalid parameter format");
  }
  return new ContentDisposition(type3, params);
}
function pdecode(str2, hex) {
  return String.fromCharCode(parseInt(hex, 16));
}
function pencode(char) {
  return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
}
function qstring(val) {
  var str2 = String(val);
  return '"' + str2.replace(QUOTE_REGEXP, "\\$1") + '"';
}
function ustring(val) {
  var str2 = String(val);
  var encoded = encodeURIComponent(str2).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
  return "UTF-8''" + encoded;
}
function ContentDisposition(type3, parameters) {
  this.type = type3;
  this.parameters = parameters;
}
var contentDispositionExports = contentDisposition$2.exports;
var send$2 = { exports: {} };
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var etag_1 = etag$1;
var crypto$4 = require$$0$6;
var Stats$1 = require$$0$8.Stats;
var toString2 = Object.prototype.toString;
function entitytag(entity) {
  if (entity.length === 0) {
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  }
  var hash2 = crypto$4.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
  var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
  return '"' + len.toString(16) + "-" + hash2 + '"';
}
function etag$1(entity, options2) {
  if (entity == null) {
    throw new TypeError("argument entity is required");
  }
  var isStats = isstats(entity);
  var weak = options2 && typeof options2.weak === "boolean" ? options2.weak : isStats;
  if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
    throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
  }
  var tag = isStats ? stattag(entity) : entitytag(entity);
  return weak ? "W/" + tag : tag;
}
function isstats(obj) {
  if (typeof Stats$1 === "function" && obj instanceof Stats$1) {
    return true;
  }
  return obj && typeof obj === "object" && "ctime" in obj && toString2.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString2.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
}
function stattag(stat2) {
  var mtime = stat2.mtime.getTime().toString(16);
  var size = stat2.size.toString(16);
  return '"' + size + "-" + mtime + '"';
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
var fresh_1 = fresh$2;
function fresh$2(reqHeaders, resHeaders) {
  var modifiedSince = reqHeaders["if-modified-since"];
  var noneMatch = reqHeaders["if-none-match"];
  if (!modifiedSince && !noneMatch) {
    return false;
  }
  var cacheControl = reqHeaders["cache-control"];
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false;
  }
  if (noneMatch && noneMatch !== "*") {
    var etag3 = resHeaders["etag"];
    if (!etag3) {
      return false;
    }
    var etagStale = true;
    var matches = parseTokenList$1(noneMatch);
    for (var i = 0; i < matches.length; i++) {
      var match2 = matches[i];
      if (match2 === etag3 || match2 === "W/" + etag3 || "W/" + match2 === etag3) {
        etagStale = false;
        break;
      }
    }
    if (etagStale) {
      return false;
    }
  }
  if (modifiedSince) {
    var lastModified = resHeaders["last-modified"];
    var modifiedStale = !lastModified || !(parseHttpDate$1(lastModified) <= parseHttpDate$1(modifiedSince));
    if (modifiedStale) {
      return false;
    }
  }
  return true;
}
function parseHttpDate$1(date) {
  var timestamp2 = date && Date.parse(date);
  return typeof timestamp2 === "number" ? timestamp2 : NaN;
}
function parseTokenList$1(str2) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = str2.length; i < len; i++) {
    switch (str2.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list.push(str2.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list.push(str2.substring(start, end));
  return list;
}
const require$$2 = {
  "application/andrew-inset": [
    "ez"
  ],
  "application/applixware": [
    "aw"
  ],
  "application/atom+xml": [
    "atom"
  ],
  "application/atomcat+xml": [
    "atomcat"
  ],
  "application/atomsvc+xml": [
    "atomsvc"
  ],
  "application/bdoc": [
    "bdoc"
  ],
  "application/ccxml+xml": [
    "ccxml"
  ],
  "application/cdmi-capability": [
    "cdmia"
  ],
  "application/cdmi-container": [
    "cdmic"
  ],
  "application/cdmi-domain": [
    "cdmid"
  ],
  "application/cdmi-object": [
    "cdmio"
  ],
  "application/cdmi-queue": [
    "cdmiq"
  ],
  "application/cu-seeme": [
    "cu"
  ],
  "application/dash+xml": [
    "mpd"
  ],
  "application/davmount+xml": [
    "davmount"
  ],
  "application/docbook+xml": [
    "dbk"
  ],
  "application/dssc+der": [
    "dssc"
  ],
  "application/dssc+xml": [
    "xdssc"
  ],
  "application/ecmascript": [
    "ecma"
  ],
  "application/emma+xml": [
    "emma"
  ],
  "application/epub+zip": [
    "epub"
  ],
  "application/exi": [
    "exi"
  ],
  "application/font-tdpfr": [
    "pfr"
  ],
  "application/font-woff": [],
  "application/font-woff2": [],
  "application/geo+json": [
    "geojson"
  ],
  "application/gml+xml": [
    "gml"
  ],
  "application/gpx+xml": [
    "gpx"
  ],
  "application/gxf": [
    "gxf"
  ],
  "application/gzip": [
    "gz"
  ],
  "application/hyperstudio": [
    "stk"
  ],
  "application/inkml+xml": [
    "ink",
    "inkml"
  ],
  "application/ipfix": [
    "ipfix"
  ],
  "application/java-archive": [
    "jar",
    "war",
    "ear"
  ],
  "application/java-serialized-object": [
    "ser"
  ],
  "application/java-vm": [
    "class"
  ],
  "application/javascript": [
    "js",
    "mjs"
  ],
  "application/json": [
    "json",
    "map"
  ],
  "application/json5": [
    "json5"
  ],
  "application/jsonml+json": [
    "jsonml"
  ],
  "application/ld+json": [
    "jsonld"
  ],
  "application/lost+xml": [
    "lostxml"
  ],
  "application/mac-binhex40": [
    "hqx"
  ],
  "application/mac-compactpro": [
    "cpt"
  ],
  "application/mads+xml": [
    "mads"
  ],
  "application/manifest+json": [
    "webmanifest"
  ],
  "application/marc": [
    "mrc"
  ],
  "application/marcxml+xml": [
    "mrcx"
  ],
  "application/mathematica": [
    "ma",
    "nb",
    "mb"
  ],
  "application/mathml+xml": [
    "mathml"
  ],
  "application/mbox": [
    "mbox"
  ],
  "application/mediaservercontrol+xml": [
    "mscml"
  ],
  "application/metalink+xml": [
    "metalink"
  ],
  "application/metalink4+xml": [
    "meta4"
  ],
  "application/mets+xml": [
    "mets"
  ],
  "application/mods+xml": [
    "mods"
  ],
  "application/mp21": [
    "m21",
    "mp21"
  ],
  "application/mp4": [
    "mp4s",
    "m4p"
  ],
  "application/msword": [
    "doc",
    "dot"
  ],
  "application/mxf": [
    "mxf"
  ],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer"
  ],
  "application/oda": [
    "oda"
  ],
  "application/oebps-package+xml": [
    "opf"
  ],
  "application/ogg": [
    "ogx"
  ],
  "application/omdoc+xml": [
    "omdoc"
  ],
  "application/onenote": [
    "onetoc",
    "onetoc2",
    "onetmp",
    "onepkg"
  ],
  "application/oxps": [
    "oxps"
  ],
  "application/patch-ops-error+xml": [
    "xer"
  ],
  "application/pdf": [
    "pdf"
  ],
  "application/pgp-encrypted": [
    "pgp"
  ],
  "application/pgp-signature": [
    "asc",
    "sig"
  ],
  "application/pics-rules": [
    "prf"
  ],
  "application/pkcs10": [
    "p10"
  ],
  "application/pkcs7-mime": [
    "p7m",
    "p7c"
  ],
  "application/pkcs7-signature": [
    "p7s"
  ],
  "application/pkcs8": [
    "p8"
  ],
  "application/pkix-attr-cert": [
    "ac"
  ],
  "application/pkix-cert": [
    "cer"
  ],
  "application/pkix-crl": [
    "crl"
  ],
  "application/pkix-pkipath": [
    "pkipath"
  ],
  "application/pkixcmp": [
    "pki"
  ],
  "application/pls+xml": [
    "pls"
  ],
  "application/postscript": [
    "ai",
    "eps",
    "ps"
  ],
  "application/prs.cww": [
    "cww"
  ],
  "application/pskc+xml": [
    "pskcxml"
  ],
  "application/raml+yaml": [
    "raml"
  ],
  "application/rdf+xml": [
    "rdf"
  ],
  "application/reginfo+xml": [
    "rif"
  ],
  "application/relax-ng-compact-syntax": [
    "rnc"
  ],
  "application/resource-lists+xml": [
    "rl"
  ],
  "application/resource-lists-diff+xml": [
    "rld"
  ],
  "application/rls-services+xml": [
    "rs"
  ],
  "application/rpki-ghostbusters": [
    "gbr"
  ],
  "application/rpki-manifest": [
    "mft"
  ],
  "application/rpki-roa": [
    "roa"
  ],
  "application/rsd+xml": [
    "rsd"
  ],
  "application/rss+xml": [
    "rss"
  ],
  "application/rtf": [
    "rtf"
  ],
  "application/sbml+xml": [
    "sbml"
  ],
  "application/scvp-cv-request": [
    "scq"
  ],
  "application/scvp-cv-response": [
    "scs"
  ],
  "application/scvp-vp-request": [
    "spq"
  ],
  "application/scvp-vp-response": [
    "spp"
  ],
  "application/sdp": [
    "sdp"
  ],
  "application/set-payment-initiation": [
    "setpay"
  ],
  "application/set-registration-initiation": [
    "setreg"
  ],
  "application/shf+xml": [
    "shf"
  ],
  "application/smil+xml": [
    "smi",
    "smil"
  ],
  "application/sparql-query": [
    "rq"
  ],
  "application/sparql-results+xml": [
    "srx"
  ],
  "application/srgs": [
    "gram"
  ],
  "application/srgs+xml": [
    "grxml"
  ],
  "application/sru+xml": [
    "sru"
  ],
  "application/ssdl+xml": [
    "ssdl"
  ],
  "application/ssml+xml": [
    "ssml"
  ],
  "application/tei+xml": [
    "tei",
    "teicorpus"
  ],
  "application/thraud+xml": [
    "tfi"
  ],
  "application/timestamped-data": [
    "tsd"
  ],
  "application/vnd.3gpp.pic-bw-large": [
    "plb"
  ],
  "application/vnd.3gpp.pic-bw-small": [
    "psb"
  ],
  "application/vnd.3gpp.pic-bw-var": [
    "pvb"
  ],
  "application/vnd.3gpp2.tcap": [
    "tcap"
  ],
  "application/vnd.3m.post-it-notes": [
    "pwn"
  ],
  "application/vnd.accpac.simply.aso": [
    "aso"
  ],
  "application/vnd.accpac.simply.imp": [
    "imp"
  ],
  "application/vnd.acucobol": [
    "acu"
  ],
  "application/vnd.acucorp": [
    "atc",
    "acutc"
  ],
  "application/vnd.adobe.air-application-installer-package+zip": [
    "air"
  ],
  "application/vnd.adobe.formscentral.fcdt": [
    "fcdt"
  ],
  "application/vnd.adobe.fxp": [
    "fxp",
    "fxpl"
  ],
  "application/vnd.adobe.xdp+xml": [
    "xdp"
  ],
  "application/vnd.adobe.xfdf": [
    "xfdf"
  ],
  "application/vnd.ahead.space": [
    "ahead"
  ],
  "application/vnd.airzip.filesecure.azf": [
    "azf"
  ],
  "application/vnd.airzip.filesecure.azs": [
    "azs"
  ],
  "application/vnd.amazon.ebook": [
    "azw"
  ],
  "application/vnd.americandynamics.acc": [
    "acc"
  ],
  "application/vnd.amiga.ami": [
    "ami"
  ],
  "application/vnd.android.package-archive": [
    "apk"
  ],
  "application/vnd.anser-web-certificate-issue-initiation": [
    "cii"
  ],
  "application/vnd.anser-web-funds-transfer-initiation": [
    "fti"
  ],
  "application/vnd.antix.game-component": [
    "atx"
  ],
  "application/vnd.apple.installer+xml": [
    "mpkg"
  ],
  "application/vnd.apple.mpegurl": [
    "m3u8"
  ],
  "application/vnd.apple.pkpass": [
    "pkpass"
  ],
  "application/vnd.aristanetworks.swi": [
    "swi"
  ],
  "application/vnd.astraea-software.iota": [
    "iota"
  ],
  "application/vnd.audiograph": [
    "aep"
  ],
  "application/vnd.blueice.multipass": [
    "mpm"
  ],
  "application/vnd.bmi": [
    "bmi"
  ],
  "application/vnd.businessobjects": [
    "rep"
  ],
  "application/vnd.chemdraw+xml": [
    "cdxml"
  ],
  "application/vnd.chipnuts.karaoke-mmd": [
    "mmd"
  ],
  "application/vnd.cinderella": [
    "cdy"
  ],
  "application/vnd.claymore": [
    "cla"
  ],
  "application/vnd.cloanto.rp9": [
    "rp9"
  ],
  "application/vnd.clonk.c4group": [
    "c4g",
    "c4d",
    "c4f",
    "c4p",
    "c4u"
  ],
  "application/vnd.cluetrust.cartomobile-config": [
    "c11amc"
  ],
  "application/vnd.cluetrust.cartomobile-config-pkg": [
    "c11amz"
  ],
  "application/vnd.commonspace": [
    "csp"
  ],
  "application/vnd.contact.cmsg": [
    "cdbcmsg"
  ],
  "application/vnd.cosmocaller": [
    "cmc"
  ],
  "application/vnd.crick.clicker": [
    "clkx"
  ],
  "application/vnd.crick.clicker.keyboard": [
    "clkk"
  ],
  "application/vnd.crick.clicker.palette": [
    "clkp"
  ],
  "application/vnd.crick.clicker.template": [
    "clkt"
  ],
  "application/vnd.crick.clicker.wordbank": [
    "clkw"
  ],
  "application/vnd.criticaltools.wbs+xml": [
    "wbs"
  ],
  "application/vnd.ctc-posml": [
    "pml"
  ],
  "application/vnd.cups-ppd": [
    "ppd"
  ],
  "application/vnd.curl.car": [
    "car"
  ],
  "application/vnd.curl.pcurl": [
    "pcurl"
  ],
  "application/vnd.dart": [
    "dart"
  ],
  "application/vnd.data-vision.rdz": [
    "rdz"
  ],
  "application/vnd.dece.data": [
    "uvf",
    "uvvf",
    "uvd",
    "uvvd"
  ],
  "application/vnd.dece.ttml+xml": [
    "uvt",
    "uvvt"
  ],
  "application/vnd.dece.unspecified": [
    "uvx",
    "uvvx"
  ],
  "application/vnd.dece.zip": [
    "uvz",
    "uvvz"
  ],
  "application/vnd.denovo.fcselayout-link": [
    "fe_launch"
  ],
  "application/vnd.dna": [
    "dna"
  ],
  "application/vnd.dolby.mlp": [
    "mlp"
  ],
  "application/vnd.dpgraph": [
    "dpg"
  ],
  "application/vnd.dreamfactory": [
    "dfac"
  ],
  "application/vnd.ds-keypoint": [
    "kpxx"
  ],
  "application/vnd.dvb.ait": [
    "ait"
  ],
  "application/vnd.dvb.service": [
    "svc"
  ],
  "application/vnd.dynageo": [
    "geo"
  ],
  "application/vnd.ecowin.chart": [
    "mag"
  ],
  "application/vnd.enliven": [
    "nml"
  ],
  "application/vnd.epson.esf": [
    "esf"
  ],
  "application/vnd.epson.msf": [
    "msf"
  ],
  "application/vnd.epson.quickanime": [
    "qam"
  ],
  "application/vnd.epson.salt": [
    "slt"
  ],
  "application/vnd.epson.ssf": [
    "ssf"
  ],
  "application/vnd.eszigno3+xml": [
    "es3",
    "et3"
  ],
  "application/vnd.ezpix-album": [
    "ez2"
  ],
  "application/vnd.ezpix-package": [
    "ez3"
  ],
  "application/vnd.fdf": [
    "fdf"
  ],
  "application/vnd.fdsn.mseed": [
    "mseed"
  ],
  "application/vnd.fdsn.seed": [
    "seed",
    "dataless"
  ],
  "application/vnd.flographit": [
    "gph"
  ],
  "application/vnd.fluxtime.clip": [
    "ftc"
  ],
  "application/vnd.framemaker": [
    "fm",
    "frame",
    "maker",
    "book"
  ],
  "application/vnd.frogans.fnc": [
    "fnc"
  ],
  "application/vnd.frogans.ltf": [
    "ltf"
  ],
  "application/vnd.fsc.weblaunch": [
    "fsc"
  ],
  "application/vnd.fujitsu.oasys": [
    "oas"
  ],
  "application/vnd.fujitsu.oasys2": [
    "oa2"
  ],
  "application/vnd.fujitsu.oasys3": [
    "oa3"
  ],
  "application/vnd.fujitsu.oasysgp": [
    "fg5"
  ],
  "application/vnd.fujitsu.oasysprs": [
    "bh2"
  ],
  "application/vnd.fujixerox.ddd": [
    "ddd"
  ],
  "application/vnd.fujixerox.docuworks": [
    "xdw"
  ],
  "application/vnd.fujixerox.docuworks.binder": [
    "xbd"
  ],
  "application/vnd.fuzzysheet": [
    "fzs"
  ],
  "application/vnd.genomatix.tuxedo": [
    "txd"
  ],
  "application/vnd.geogebra.file": [
    "ggb"
  ],
  "application/vnd.geogebra.tool": [
    "ggt"
  ],
  "application/vnd.geometry-explorer": [
    "gex",
    "gre"
  ],
  "application/vnd.geonext": [
    "gxt"
  ],
  "application/vnd.geoplan": [
    "g2w"
  ],
  "application/vnd.geospace": [
    "g3w"
  ],
  "application/vnd.gmx": [
    "gmx"
  ],
  "application/vnd.google-apps.document": [
    "gdoc"
  ],
  "application/vnd.google-apps.presentation": [
    "gslides"
  ],
  "application/vnd.google-apps.spreadsheet": [
    "gsheet"
  ],
  "application/vnd.google-earth.kml+xml": [
    "kml"
  ],
  "application/vnd.google-earth.kmz": [
    "kmz"
  ],
  "application/vnd.grafeq": [
    "gqf",
    "gqs"
  ],
  "application/vnd.groove-account": [
    "gac"
  ],
  "application/vnd.groove-help": [
    "ghf"
  ],
  "application/vnd.groove-identity-message": [
    "gim"
  ],
  "application/vnd.groove-injector": [
    "grv"
  ],
  "application/vnd.groove-tool-message": [
    "gtm"
  ],
  "application/vnd.groove-tool-template": [
    "tpl"
  ],
  "application/vnd.groove-vcard": [
    "vcg"
  ],
  "application/vnd.hal+xml": [
    "hal"
  ],
  "application/vnd.handheld-entertainment+xml": [
    "zmm"
  ],
  "application/vnd.hbci": [
    "hbci"
  ],
  "application/vnd.hhe.lesson-player": [
    "les"
  ],
  "application/vnd.hp-hpgl": [
    "hpgl"
  ],
  "application/vnd.hp-hpid": [
    "hpid"
  ],
  "application/vnd.hp-hps": [
    "hps"
  ],
  "application/vnd.hp-jlyt": [
    "jlt"
  ],
  "application/vnd.hp-pcl": [
    "pcl"
  ],
  "application/vnd.hp-pclxl": [
    "pclxl"
  ],
  "application/vnd.hydrostatix.sof-data": [
    "sfd-hdstx"
  ],
  "application/vnd.ibm.minipay": [
    "mpy"
  ],
  "application/vnd.ibm.modcap": [
    "afp",
    "listafp",
    "list3820"
  ],
  "application/vnd.ibm.rights-management": [
    "irm"
  ],
  "application/vnd.ibm.secure-container": [
    "sc"
  ],
  "application/vnd.iccprofile": [
    "icc",
    "icm"
  ],
  "application/vnd.igloader": [
    "igl"
  ],
  "application/vnd.immervision-ivp": [
    "ivp"
  ],
  "application/vnd.immervision-ivu": [
    "ivu"
  ],
  "application/vnd.insors.igm": [
    "igm"
  ],
  "application/vnd.intercon.formnet": [
    "xpw",
    "xpx"
  ],
  "application/vnd.intergeo": [
    "i2g"
  ],
  "application/vnd.intu.qbo": [
    "qbo"
  ],
  "application/vnd.intu.qfx": [
    "qfx"
  ],
  "application/vnd.ipunplugged.rcprofile": [
    "rcprofile"
  ],
  "application/vnd.irepository.package+xml": [
    "irp"
  ],
  "application/vnd.is-xpr": [
    "xpr"
  ],
  "application/vnd.isac.fcs": [
    "fcs"
  ],
  "application/vnd.jam": [
    "jam"
  ],
  "application/vnd.jcp.javame.midlet-rms": [
    "rms"
  ],
  "application/vnd.jisp": [
    "jisp"
  ],
  "application/vnd.joost.joda-archive": [
    "joda"
  ],
  "application/vnd.kahootz": [
    "ktz",
    "ktr"
  ],
  "application/vnd.kde.karbon": [
    "karbon"
  ],
  "application/vnd.kde.kchart": [
    "chrt"
  ],
  "application/vnd.kde.kformula": [
    "kfo"
  ],
  "application/vnd.kde.kivio": [
    "flw"
  ],
  "application/vnd.kde.kontour": [
    "kon"
  ],
  "application/vnd.kde.kpresenter": [
    "kpr",
    "kpt"
  ],
  "application/vnd.kde.kspread": [
    "ksp"
  ],
  "application/vnd.kde.kword": [
    "kwd",
    "kwt"
  ],
  "application/vnd.kenameaapp": [
    "htke"
  ],
  "application/vnd.kidspiration": [
    "kia"
  ],
  "application/vnd.kinar": [
    "kne",
    "knp"
  ],
  "application/vnd.koan": [
    "skp",
    "skd",
    "skt",
    "skm"
  ],
  "application/vnd.kodak-descriptor": [
    "sse"
  ],
  "application/vnd.las.las+xml": [
    "lasxml"
  ],
  "application/vnd.llamagraphics.life-balance.desktop": [
    "lbd"
  ],
  "application/vnd.llamagraphics.life-balance.exchange+xml": [
    "lbe"
  ],
  "application/vnd.lotus-1-2-3": [
    "123"
  ],
  "application/vnd.lotus-approach": [
    "apr"
  ],
  "application/vnd.lotus-freelance": [
    "pre"
  ],
  "application/vnd.lotus-notes": [
    "nsf"
  ],
  "application/vnd.lotus-organizer": [
    "org"
  ],
  "application/vnd.lotus-screencam": [
    "scm"
  ],
  "application/vnd.lotus-wordpro": [
    "lwp"
  ],
  "application/vnd.macports.portpkg": [
    "portpkg"
  ],
  "application/vnd.mcd": [
    "mcd"
  ],
  "application/vnd.medcalcdata": [
    "mc1"
  ],
  "application/vnd.mediastation.cdkey": [
    "cdkey"
  ],
  "application/vnd.mfer": [
    "mwf"
  ],
  "application/vnd.mfmp": [
    "mfm"
  ],
  "application/vnd.micrografx.flo": [
    "flo"
  ],
  "application/vnd.micrografx.igx": [
    "igx"
  ],
  "application/vnd.mif": [
    "mif"
  ],
  "application/vnd.mobius.daf": [
    "daf"
  ],
  "application/vnd.mobius.dis": [
    "dis"
  ],
  "application/vnd.mobius.mbk": [
    "mbk"
  ],
  "application/vnd.mobius.mqy": [
    "mqy"
  ],
  "application/vnd.mobius.msl": [
    "msl"
  ],
  "application/vnd.mobius.plc": [
    "plc"
  ],
  "application/vnd.mobius.txf": [
    "txf"
  ],
  "application/vnd.mophun.application": [
    "mpn"
  ],
  "application/vnd.mophun.certificate": [
    "mpc"
  ],
  "application/vnd.mozilla.xul+xml": [
    "xul"
  ],
  "application/vnd.ms-artgalry": [
    "cil"
  ],
  "application/vnd.ms-cab-compressed": [
    "cab"
  ],
  "application/vnd.ms-excel": [
    "xls",
    "xlm",
    "xla",
    "xlc",
    "xlt",
    "xlw"
  ],
  "application/vnd.ms-excel.addin.macroenabled.12": [
    "xlam"
  ],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": [
    "xlsb"
  ],
  "application/vnd.ms-excel.sheet.macroenabled.12": [
    "xlsm"
  ],
  "application/vnd.ms-excel.template.macroenabled.12": [
    "xltm"
  ],
  "application/vnd.ms-fontobject": [
    "eot"
  ],
  "application/vnd.ms-htmlhelp": [
    "chm"
  ],
  "application/vnd.ms-ims": [
    "ims"
  ],
  "application/vnd.ms-lrm": [
    "lrm"
  ],
  "application/vnd.ms-officetheme": [
    "thmx"
  ],
  "application/vnd.ms-outlook": [
    "msg"
  ],
  "application/vnd.ms-pki.seccat": [
    "cat"
  ],
  "application/vnd.ms-pki.stl": [
    "stl"
  ],
  "application/vnd.ms-powerpoint": [
    "ppt",
    "pps",
    "pot"
  ],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": [
    "ppam"
  ],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": [
    "pptm"
  ],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": [
    "sldm"
  ],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": [
    "ppsm"
  ],
  "application/vnd.ms-powerpoint.template.macroenabled.12": [
    "potm"
  ],
  "application/vnd.ms-project": [
    "mpp",
    "mpt"
  ],
  "application/vnd.ms-word.document.macroenabled.12": [
    "docm"
  ],
  "application/vnd.ms-word.template.macroenabled.12": [
    "dotm"
  ],
  "application/vnd.ms-works": [
    "wps",
    "wks",
    "wcm",
    "wdb"
  ],
  "application/vnd.ms-wpl": [
    "wpl"
  ],
  "application/vnd.ms-xpsdocument": [
    "xps"
  ],
  "application/vnd.mseq": [
    "mseq"
  ],
  "application/vnd.musician": [
    "mus"
  ],
  "application/vnd.muvee.style": [
    "msty"
  ],
  "application/vnd.mynfc": [
    "taglet"
  ],
  "application/vnd.neurolanguage.nlu": [
    "nlu"
  ],
  "application/vnd.nitf": [
    "ntf",
    "nitf"
  ],
  "application/vnd.noblenet-directory": [
    "nnd"
  ],
  "application/vnd.noblenet-sealer": [
    "nns"
  ],
  "application/vnd.noblenet-web": [
    "nnw"
  ],
  "application/vnd.nokia.n-gage.data": [
    "ngdat"
  ],
  "application/vnd.nokia.n-gage.symbian.install": [
    "n-gage"
  ],
  "application/vnd.nokia.radio-preset": [
    "rpst"
  ],
  "application/vnd.nokia.radio-presets": [
    "rpss"
  ],
  "application/vnd.novadigm.edm": [
    "edm"
  ],
  "application/vnd.novadigm.edx": [
    "edx"
  ],
  "application/vnd.novadigm.ext": [
    "ext"
  ],
  "application/vnd.oasis.opendocument.chart": [
    "odc"
  ],
  "application/vnd.oasis.opendocument.chart-template": [
    "otc"
  ],
  "application/vnd.oasis.opendocument.database": [
    "odb"
  ],
  "application/vnd.oasis.opendocument.formula": [
    "odf"
  ],
  "application/vnd.oasis.opendocument.formula-template": [
    "odft"
  ],
  "application/vnd.oasis.opendocument.graphics": [
    "odg"
  ],
  "application/vnd.oasis.opendocument.graphics-template": [
    "otg"
  ],
  "application/vnd.oasis.opendocument.image": [
    "odi"
  ],
  "application/vnd.oasis.opendocument.image-template": [
    "oti"
  ],
  "application/vnd.oasis.opendocument.presentation": [
    "odp"
  ],
  "application/vnd.oasis.opendocument.presentation-template": [
    "otp"
  ],
  "application/vnd.oasis.opendocument.spreadsheet": [
    "ods"
  ],
  "application/vnd.oasis.opendocument.spreadsheet-template": [
    "ots"
  ],
  "application/vnd.oasis.opendocument.text": [
    "odt"
  ],
  "application/vnd.oasis.opendocument.text-master": [
    "odm"
  ],
  "application/vnd.oasis.opendocument.text-template": [
    "ott"
  ],
  "application/vnd.oasis.opendocument.text-web": [
    "oth"
  ],
  "application/vnd.olpc-sugar": [
    "xo"
  ],
  "application/vnd.oma.dd2+xml": [
    "dd2"
  ],
  "application/vnd.openofficeorg.extension": [
    "oxt"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": [
    "pptx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": [
    "sldx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
    "ppsx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.template": [
    "potx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
    "xlsx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
    "xltx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
    "docx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
    "dotx"
  ],
  "application/vnd.osgeo.mapguide.package": [
    "mgp"
  ],
  "application/vnd.osgi.dp": [
    "dp"
  ],
  "application/vnd.osgi.subsystem": [
    "esa"
  ],
  "application/vnd.palm": [
    "pdb",
    "pqa",
    "oprc"
  ],
  "application/vnd.pawaafile": [
    "paw"
  ],
  "application/vnd.pg.format": [
    "str"
  ],
  "application/vnd.pg.osasli": [
    "ei6"
  ],
  "application/vnd.picsel": [
    "efif"
  ],
  "application/vnd.pmi.widget": [
    "wg"
  ],
  "application/vnd.pocketlearn": [
    "plf"
  ],
  "application/vnd.powerbuilder6": [
    "pbd"
  ],
  "application/vnd.previewsystems.box": [
    "box"
  ],
  "application/vnd.proteus.magazine": [
    "mgz"
  ],
  "application/vnd.publishare-delta-tree": [
    "qps"
  ],
  "application/vnd.pvi.ptid1": [
    "ptid"
  ],
  "application/vnd.quark.quarkxpress": [
    "qxd",
    "qxt",
    "qwd",
    "qwt",
    "qxl",
    "qxb"
  ],
  "application/vnd.realvnc.bed": [
    "bed"
  ],
  "application/vnd.recordare.musicxml": [
    "mxl"
  ],
  "application/vnd.recordare.musicxml+xml": [
    "musicxml"
  ],
  "application/vnd.rig.cryptonote": [
    "cryptonote"
  ],
  "application/vnd.rim.cod": [
    "cod"
  ],
  "application/vnd.rn-realmedia": [
    "rm"
  ],
  "application/vnd.rn-realmedia-vbr": [
    "rmvb"
  ],
  "application/vnd.route66.link66+xml": [
    "link66"
  ],
  "application/vnd.sailingtracker.track": [
    "st"
  ],
  "application/vnd.seemail": [
    "see"
  ],
  "application/vnd.sema": [
    "sema"
  ],
  "application/vnd.semd": [
    "semd"
  ],
  "application/vnd.semf": [
    "semf"
  ],
  "application/vnd.shana.informed.formdata": [
    "ifm"
  ],
  "application/vnd.shana.informed.formtemplate": [
    "itp"
  ],
  "application/vnd.shana.informed.interchange": [
    "iif"
  ],
  "application/vnd.shana.informed.package": [
    "ipk"
  ],
  "application/vnd.simtech-mindmapper": [
    "twd",
    "twds"
  ],
  "application/vnd.smaf": [
    "mmf"
  ],
  "application/vnd.smart.teacher": [
    "teacher"
  ],
  "application/vnd.solent.sdkm+xml": [
    "sdkm",
    "sdkd"
  ],
  "application/vnd.spotfire.dxp": [
    "dxp"
  ],
  "application/vnd.spotfire.sfs": [
    "sfs"
  ],
  "application/vnd.stardivision.calc": [
    "sdc"
  ],
  "application/vnd.stardivision.draw": [
    "sda"
  ],
  "application/vnd.stardivision.impress": [
    "sdd"
  ],
  "application/vnd.stardivision.math": [
    "smf"
  ],
  "application/vnd.stardivision.writer": [
    "sdw",
    "vor"
  ],
  "application/vnd.stardivision.writer-global": [
    "sgl"
  ],
  "application/vnd.stepmania.package": [
    "smzip"
  ],
  "application/vnd.stepmania.stepchart": [
    "sm"
  ],
  "application/vnd.sun.wadl+xml": [
    "wadl"
  ],
  "application/vnd.sun.xml.calc": [
    "sxc"
  ],
  "application/vnd.sun.xml.calc.template": [
    "stc"
  ],
  "application/vnd.sun.xml.draw": [
    "sxd"
  ],
  "application/vnd.sun.xml.draw.template": [
    "std"
  ],
  "application/vnd.sun.xml.impress": [
    "sxi"
  ],
  "application/vnd.sun.xml.impress.template": [
    "sti"
  ],
  "application/vnd.sun.xml.math": [
    "sxm"
  ],
  "application/vnd.sun.xml.writer": [
    "sxw"
  ],
  "application/vnd.sun.xml.writer.global": [
    "sxg"
  ],
  "application/vnd.sun.xml.writer.template": [
    "stw"
  ],
  "application/vnd.sus-calendar": [
    "sus",
    "susp"
  ],
  "application/vnd.svd": [
    "svd"
  ],
  "application/vnd.symbian.install": [
    "sis",
    "sisx"
  ],
  "application/vnd.syncml+xml": [
    "xsm"
  ],
  "application/vnd.syncml.dm+wbxml": [
    "bdm"
  ],
  "application/vnd.syncml.dm+xml": [
    "xdm"
  ],
  "application/vnd.tao.intent-module-archive": [
    "tao"
  ],
  "application/vnd.tcpdump.pcap": [
    "pcap",
    "cap",
    "dmp"
  ],
  "application/vnd.tmobile-livetv": [
    "tmo"
  ],
  "application/vnd.trid.tpt": [
    "tpt"
  ],
  "application/vnd.triscape.mxs": [
    "mxs"
  ],
  "application/vnd.trueapp": [
    "tra"
  ],
  "application/vnd.ufdl": [
    "ufd",
    "ufdl"
  ],
  "application/vnd.uiq.theme": [
    "utz"
  ],
  "application/vnd.umajin": [
    "umj"
  ],
  "application/vnd.unity": [
    "unityweb"
  ],
  "application/vnd.uoml+xml": [
    "uoml"
  ],
  "application/vnd.vcx": [
    "vcx"
  ],
  "application/vnd.visio": [
    "vsd",
    "vst",
    "vss",
    "vsw"
  ],
  "application/vnd.visionary": [
    "vis"
  ],
  "application/vnd.vsf": [
    "vsf"
  ],
  "application/vnd.wap.wbxml": [
    "wbxml"
  ],
  "application/vnd.wap.wmlc": [
    "wmlc"
  ],
  "application/vnd.wap.wmlscriptc": [
    "wmlsc"
  ],
  "application/vnd.webturbo": [
    "wtb"
  ],
  "application/vnd.wolfram.player": [
    "nbp"
  ],
  "application/vnd.wordperfect": [
    "wpd"
  ],
  "application/vnd.wqd": [
    "wqd"
  ],
  "application/vnd.wt.stf": [
    "stf"
  ],
  "application/vnd.xara": [
    "xar"
  ],
  "application/vnd.xfdl": [
    "xfdl"
  ],
  "application/vnd.yamaha.hv-dic": [
    "hvd"
  ],
  "application/vnd.yamaha.hv-script": [
    "hvs"
  ],
  "application/vnd.yamaha.hv-voice": [
    "hvp"
  ],
  "application/vnd.yamaha.openscoreformat": [
    "osf"
  ],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": [
    "osfpvg"
  ],
  "application/vnd.yamaha.smaf-audio": [
    "saf"
  ],
  "application/vnd.yamaha.smaf-phrase": [
    "spf"
  ],
  "application/vnd.yellowriver-custom-menu": [
    "cmp"
  ],
  "application/vnd.zul": [
    "zir",
    "zirz"
  ],
  "application/vnd.zzazz.deck+xml": [
    "zaz"
  ],
  "application/voicexml+xml": [
    "vxml"
  ],
  "application/wasm": [
    "wasm"
  ],
  "application/widget": [
    "wgt"
  ],
  "application/winhlp": [
    "hlp"
  ],
  "application/wsdl+xml": [
    "wsdl"
  ],
  "application/wspolicy+xml": [
    "wspolicy"
  ],
  "application/x-7z-compressed": [
    "7z"
  ],
  "application/x-abiword": [
    "abw"
  ],
  "application/x-ace-compressed": [
    "ace"
  ],
  "application/x-apple-diskimage": [],
  "application/x-arj": [
    "arj"
  ],
  "application/x-authorware-bin": [
    "aab",
    "x32",
    "u32",
    "vox"
  ],
  "application/x-authorware-map": [
    "aam"
  ],
  "application/x-authorware-seg": [
    "aas"
  ],
  "application/x-bcpio": [
    "bcpio"
  ],
  "application/x-bdoc": [],
  "application/x-bittorrent": [
    "torrent"
  ],
  "application/x-blorb": [
    "blb",
    "blorb"
  ],
  "application/x-bzip": [
    "bz"
  ],
  "application/x-bzip2": [
    "bz2",
    "boz"
  ],
  "application/x-cbr": [
    "cbr",
    "cba",
    "cbt",
    "cbz",
    "cb7"
  ],
  "application/x-cdlink": [
    "vcd"
  ],
  "application/x-cfs-compressed": [
    "cfs"
  ],
  "application/x-chat": [
    "chat"
  ],
  "application/x-chess-pgn": [
    "pgn"
  ],
  "application/x-chrome-extension": [
    "crx"
  ],
  "application/x-cocoa": [
    "cco"
  ],
  "application/x-conference": [
    "nsc"
  ],
  "application/x-cpio": [
    "cpio"
  ],
  "application/x-csh": [
    "csh"
  ],
  "application/x-debian-package": [
    "udeb"
  ],
  "application/x-dgc-compressed": [
    "dgc"
  ],
  "application/x-director": [
    "dir",
    "dcr",
    "dxr",
    "cst",
    "cct",
    "cxt",
    "w3d",
    "fgd",
    "swa"
  ],
  "application/x-doom": [
    "wad"
  ],
  "application/x-dtbncx+xml": [
    "ncx"
  ],
  "application/x-dtbook+xml": [
    "dtb"
  ],
  "application/x-dtbresource+xml": [
    "res"
  ],
  "application/x-dvi": [
    "dvi"
  ],
  "application/x-envoy": [
    "evy"
  ],
  "application/x-eva": [
    "eva"
  ],
  "application/x-font-bdf": [
    "bdf"
  ],
  "application/x-font-ghostscript": [
    "gsf"
  ],
  "application/x-font-linux-psf": [
    "psf"
  ],
  "application/x-font-pcf": [
    "pcf"
  ],
  "application/x-font-snf": [
    "snf"
  ],
  "application/x-font-type1": [
    "pfa",
    "pfb",
    "pfm",
    "afm"
  ],
  "application/x-freearc": [
    "arc"
  ],
  "application/x-futuresplash": [
    "spl"
  ],
  "application/x-gca-compressed": [
    "gca"
  ],
  "application/x-glulx": [
    "ulx"
  ],
  "application/x-gnumeric": [
    "gnumeric"
  ],
  "application/x-gramps-xml": [
    "gramps"
  ],
  "application/x-gtar": [
    "gtar"
  ],
  "application/x-hdf": [
    "hdf"
  ],
  "application/x-httpd-php": [
    "php"
  ],
  "application/x-install-instructions": [
    "install"
  ],
  "application/x-iso9660-image": [],
  "application/x-java-archive-diff": [
    "jardiff"
  ],
  "application/x-java-jnlp-file": [
    "jnlp"
  ],
  "application/x-latex": [
    "latex"
  ],
  "application/x-lua-bytecode": [
    "luac"
  ],
  "application/x-lzh-compressed": [
    "lzh",
    "lha"
  ],
  "application/x-makeself": [
    "run"
  ],
  "application/x-mie": [
    "mie"
  ],
  "application/x-mobipocket-ebook": [
    "prc",
    "mobi"
  ],
  "application/x-ms-application": [
    "application"
  ],
  "application/x-ms-shortcut": [
    "lnk"
  ],
  "application/x-ms-wmd": [
    "wmd"
  ],
  "application/x-ms-wmz": [
    "wmz"
  ],
  "application/x-ms-xbap": [
    "xbap"
  ],
  "application/x-msaccess": [
    "mdb"
  ],
  "application/x-msbinder": [
    "obd"
  ],
  "application/x-mscardfile": [
    "crd"
  ],
  "application/x-msclip": [
    "clp"
  ],
  "application/x-msdos-program": [],
  "application/x-msdownload": [
    "com",
    "bat"
  ],
  "application/x-msmediaview": [
    "mvb",
    "m13",
    "m14"
  ],
  "application/x-msmetafile": [
    "wmf",
    "emf",
    "emz"
  ],
  "application/x-msmoney": [
    "mny"
  ],
  "application/x-mspublisher": [
    "pub"
  ],
  "application/x-msschedule": [
    "scd"
  ],
  "application/x-msterminal": [
    "trm"
  ],
  "application/x-mswrite": [
    "wri"
  ],
  "application/x-netcdf": [
    "nc",
    "cdf"
  ],
  "application/x-ns-proxy-autoconfig": [
    "pac"
  ],
  "application/x-nzb": [
    "nzb"
  ],
  "application/x-perl": [
    "pl",
    "pm"
  ],
  "application/x-pilot": [],
  "application/x-pkcs12": [
    "p12",
    "pfx"
  ],
  "application/x-pkcs7-certificates": [
    "p7b",
    "spc"
  ],
  "application/x-pkcs7-certreqresp": [
    "p7r"
  ],
  "application/x-rar-compressed": [
    "rar"
  ],
  "application/x-redhat-package-manager": [
    "rpm"
  ],
  "application/x-research-info-systems": [
    "ris"
  ],
  "application/x-sea": [
    "sea"
  ],
  "application/x-sh": [
    "sh"
  ],
  "application/x-shar": [
    "shar"
  ],
  "application/x-shockwave-flash": [
    "swf"
  ],
  "application/x-silverlight-app": [
    "xap"
  ],
  "application/x-sql": [
    "sql"
  ],
  "application/x-stuffit": [
    "sit"
  ],
  "application/x-stuffitx": [
    "sitx"
  ],
  "application/x-subrip": [
    "srt"
  ],
  "application/x-sv4cpio": [
    "sv4cpio"
  ],
  "application/x-sv4crc": [
    "sv4crc"
  ],
  "application/x-t3vm-image": [
    "t3"
  ],
  "application/x-tads": [
    "gam"
  ],
  "application/x-tar": [
    "tar"
  ],
  "application/x-tcl": [
    "tcl",
    "tk"
  ],
  "application/x-tex": [
    "tex"
  ],
  "application/x-tex-tfm": [
    "tfm"
  ],
  "application/x-texinfo": [
    "texinfo",
    "texi"
  ],
  "application/x-tgif": [
    "obj"
  ],
  "application/x-ustar": [
    "ustar"
  ],
  "application/x-virtualbox-hdd": [
    "hdd"
  ],
  "application/x-virtualbox-ova": [
    "ova"
  ],
  "application/x-virtualbox-ovf": [
    "ovf"
  ],
  "application/x-virtualbox-vbox": [
    "vbox"
  ],
  "application/x-virtualbox-vbox-extpack": [
    "vbox-extpack"
  ],
  "application/x-virtualbox-vdi": [
    "vdi"
  ],
  "application/x-virtualbox-vhd": [
    "vhd"
  ],
  "application/x-virtualbox-vmdk": [
    "vmdk"
  ],
  "application/x-wais-source": [
    "src"
  ],
  "application/x-web-app-manifest+json": [
    "webapp"
  ],
  "application/x-x509-ca-cert": [
    "der",
    "crt",
    "pem"
  ],
  "application/x-xfig": [
    "fig"
  ],
  "application/x-xliff+xml": [
    "xlf"
  ],
  "application/x-xpinstall": [
    "xpi"
  ],
  "application/x-xz": [
    "xz"
  ],
  "application/x-zmachine": [
    "z1",
    "z2",
    "z3",
    "z4",
    "z5",
    "z6",
    "z7",
    "z8"
  ],
  "application/xaml+xml": [
    "xaml"
  ],
  "application/xcap-diff+xml": [
    "xdf"
  ],
  "application/xenc+xml": [
    "xenc"
  ],
  "application/xhtml+xml": [
    "xhtml",
    "xht"
  ],
  "application/xml": [
    "xml",
    "xsl",
    "xsd",
    "rng"
  ],
  "application/xml-dtd": [
    "dtd"
  ],
  "application/xop+xml": [
    "xop"
  ],
  "application/xproc+xml": [
    "xpl"
  ],
  "application/xslt+xml": [
    "xslt"
  ],
  "application/xspf+xml": [
    "xspf"
  ],
  "application/xv+xml": [
    "mxml",
    "xhvml",
    "xvml",
    "xvm"
  ],
  "application/yang": [
    "yang"
  ],
  "application/yin+xml": [
    "yin"
  ],
  "application/zip": [
    "zip"
  ],
  "audio/3gpp": [],
  "audio/adpcm": [
    "adp"
  ],
  "audio/basic": [
    "au",
    "snd"
  ],
  "audio/midi": [
    "mid",
    "midi",
    "kar",
    "rmi"
  ],
  "audio/mp3": [],
  "audio/mp4": [
    "m4a",
    "mp4a"
  ],
  "audio/mpeg": [
    "mpga",
    "mp2",
    "mp2a",
    "mp3",
    "m2a",
    "m3a"
  ],
  "audio/ogg": [
    "oga",
    "ogg",
    "spx"
  ],
  "audio/s3m": [
    "s3m"
  ],
  "audio/silk": [
    "sil"
  ],
  "audio/vnd.dece.audio": [
    "uva",
    "uvva"
  ],
  "audio/vnd.digital-winds": [
    "eol"
  ],
  "audio/vnd.dra": [
    "dra"
  ],
  "audio/vnd.dts": [
    "dts"
  ],
  "audio/vnd.dts.hd": [
    "dtshd"
  ],
  "audio/vnd.lucent.voice": [
    "lvp"
  ],
  "audio/vnd.ms-playready.media.pya": [
    "pya"
  ],
  "audio/vnd.nuera.ecelp4800": [
    "ecelp4800"
  ],
  "audio/vnd.nuera.ecelp7470": [
    "ecelp7470"
  ],
  "audio/vnd.nuera.ecelp9600": [
    "ecelp9600"
  ],
  "audio/vnd.rip": [
    "rip"
  ],
  "audio/wav": [
    "wav"
  ],
  "audio/wave": [],
  "audio/webm": [
    "weba"
  ],
  "audio/x-aac": [
    "aac"
  ],
  "audio/x-aiff": [
    "aif",
    "aiff",
    "aifc"
  ],
  "audio/x-caf": [
    "caf"
  ],
  "audio/x-flac": [
    "flac"
  ],
  "audio/x-m4a": [],
  "audio/x-matroska": [
    "mka"
  ],
  "audio/x-mpegurl": [
    "m3u"
  ],
  "audio/x-ms-wax": [
    "wax"
  ],
  "audio/x-ms-wma": [
    "wma"
  ],
  "audio/x-pn-realaudio": [
    "ram",
    "ra"
  ],
  "audio/x-pn-realaudio-plugin": [
    "rmp"
  ],
  "audio/x-realaudio": [],
  "audio/x-wav": [],
  "audio/xm": [
    "xm"
  ],
  "chemical/x-cdx": [
    "cdx"
  ],
  "chemical/x-cif": [
    "cif"
  ],
  "chemical/x-cmdf": [
    "cmdf"
  ],
  "chemical/x-cml": [
    "cml"
  ],
  "chemical/x-csml": [
    "csml"
  ],
  "chemical/x-xyz": [
    "xyz"
  ],
  "font/collection": [
    "ttc"
  ],
  "font/otf": [
    "otf"
  ],
  "font/ttf": [
    "ttf"
  ],
  "font/woff": [
    "woff"
  ],
  "font/woff2": [
    "woff2"
  ],
  "image/apng": [
    "apng"
  ],
  "image/bmp": [
    "bmp"
  ],
  "image/cgm": [
    "cgm"
  ],
  "image/g3fax": [
    "g3"
  ],
  "image/gif": [
    "gif"
  ],
  "image/ief": [
    "ief"
  ],
  "image/jp2": [
    "jp2",
    "jpg2"
  ],
  "image/jpeg": [
    "jpeg",
    "jpg",
    "jpe"
  ],
  "image/jpm": [
    "jpm"
  ],
  "image/jpx": [
    "jpx",
    "jpf"
  ],
  "image/ktx": [
    "ktx"
  ],
  "image/png": [
    "png"
  ],
  "image/prs.btif": [
    "btif"
  ],
  "image/sgi": [
    "sgi"
  ],
  "image/svg+xml": [
    "svg",
    "svgz"
  ],
  "image/tiff": [
    "tiff",
    "tif"
  ],
  "image/vnd.adobe.photoshop": [
    "psd"
  ],
  "image/vnd.dece.graphic": [
    "uvi",
    "uvvi",
    "uvg",
    "uvvg"
  ],
  "image/vnd.djvu": [
    "djvu",
    "djv"
  ],
  "image/vnd.dvb.subtitle": [],
  "image/vnd.dwg": [
    "dwg"
  ],
  "image/vnd.dxf": [
    "dxf"
  ],
  "image/vnd.fastbidsheet": [
    "fbs"
  ],
  "image/vnd.fpx": [
    "fpx"
  ],
  "image/vnd.fst": [
    "fst"
  ],
  "image/vnd.fujixerox.edmics-mmr": [
    "mmr"
  ],
  "image/vnd.fujixerox.edmics-rlc": [
    "rlc"
  ],
  "image/vnd.ms-modi": [
    "mdi"
  ],
  "image/vnd.ms-photo": [
    "wdp"
  ],
  "image/vnd.net-fpx": [
    "npx"
  ],
  "image/vnd.wap.wbmp": [
    "wbmp"
  ],
  "image/vnd.xiff": [
    "xif"
  ],
  "image/webp": [
    "webp"
  ],
  "image/x-3ds": [
    "3ds"
  ],
  "image/x-cmu-raster": [
    "ras"
  ],
  "image/x-cmx": [
    "cmx"
  ],
  "image/x-freehand": [
    "fh",
    "fhc",
    "fh4",
    "fh5",
    "fh7"
  ],
  "image/x-icon": [
    "ico"
  ],
  "image/x-jng": [
    "jng"
  ],
  "image/x-mrsid-image": [
    "sid"
  ],
  "image/x-ms-bmp": [],
  "image/x-pcx": [
    "pcx"
  ],
  "image/x-pict": [
    "pic",
    "pct"
  ],
  "image/x-portable-anymap": [
    "pnm"
  ],
  "image/x-portable-bitmap": [
    "pbm"
  ],
  "image/x-portable-graymap": [
    "pgm"
  ],
  "image/x-portable-pixmap": [
    "ppm"
  ],
  "image/x-rgb": [
    "rgb"
  ],
  "image/x-tga": [
    "tga"
  ],
  "image/x-xbitmap": [
    "xbm"
  ],
  "image/x-xpixmap": [
    "xpm"
  ],
  "image/x-xwindowdump": [
    "xwd"
  ],
  "message/rfc822": [
    "eml",
    "mime"
  ],
  "model/gltf+json": [
    "gltf"
  ],
  "model/gltf-binary": [
    "glb"
  ],
  "model/iges": [
    "igs",
    "iges"
  ],
  "model/mesh": [
    "msh",
    "mesh",
    "silo"
  ],
  "model/vnd.collada+xml": [
    "dae"
  ],
  "model/vnd.dwf": [
    "dwf"
  ],
  "model/vnd.gdl": [
    "gdl"
  ],
  "model/vnd.gtw": [
    "gtw"
  ],
  "model/vnd.mts": [
    "mts"
  ],
  "model/vnd.vtu": [
    "vtu"
  ],
  "model/vrml": [
    "wrl",
    "vrml"
  ],
  "model/x3d+binary": [
    "x3db",
    "x3dbz"
  ],
  "model/x3d+vrml": [
    "x3dv",
    "x3dvz"
  ],
  "model/x3d+xml": [
    "x3d",
    "x3dz"
  ],
  "text/cache-manifest": [
    "appcache",
    "manifest"
  ],
  "text/calendar": [
    "ics",
    "ifb"
  ],
  "text/coffeescript": [
    "coffee",
    "litcoffee"
  ],
  "text/css": [
    "css"
  ],
  "text/csv": [
    "csv"
  ],
  "text/hjson": [
    "hjson"
  ],
  "text/html": [
    "html",
    "htm",
    "shtml"
  ],
  "text/jade": [
    "jade"
  ],
  "text/jsx": [
    "jsx"
  ],
  "text/less": [
    "less"
  ],
  "text/markdown": [
    "markdown",
    "md"
  ],
  "text/mathml": [
    "mml"
  ],
  "text/n3": [
    "n3"
  ],
  "text/plain": [
    "txt",
    "text",
    "conf",
    "def",
    "list",
    "log",
    "in",
    "ini"
  ],
  "text/prs.lines.tag": [
    "dsc"
  ],
  "text/richtext": [
    "rtx"
  ],
  "text/rtf": [],
  "text/sgml": [
    "sgml",
    "sgm"
  ],
  "text/slim": [
    "slim",
    "slm"
  ],
  "text/stylus": [
    "stylus",
    "styl"
  ],
  "text/tab-separated-values": [
    "tsv"
  ],
  "text/troff": [
    "t",
    "tr",
    "roff",
    "man",
    "me",
    "ms"
  ],
  "text/turtle": [
    "ttl"
  ],
  "text/uri-list": [
    "uri",
    "uris",
    "urls"
  ],
  "text/vcard": [
    "vcard"
  ],
  "text/vnd.curl": [
    "curl"
  ],
  "text/vnd.curl.dcurl": [
    "dcurl"
  ],
  "text/vnd.curl.mcurl": [
    "mcurl"
  ],
  "text/vnd.curl.scurl": [
    "scurl"
  ],
  "text/vnd.dvb.subtitle": [
    "sub"
  ],
  "text/vnd.fly": [
    "fly"
  ],
  "text/vnd.fmi.flexstor": [
    "flx"
  ],
  "text/vnd.graphviz": [
    "gv"
  ],
  "text/vnd.in3d.3dml": [
    "3dml"
  ],
  "text/vnd.in3d.spot": [
    "spot"
  ],
  "text/vnd.sun.j2me.app-descriptor": [
    "jad"
  ],
  "text/vnd.wap.wml": [
    "wml"
  ],
  "text/vnd.wap.wmlscript": [
    "wmls"
  ],
  "text/vtt": [
    "vtt"
  ],
  "text/x-asm": [
    "s",
    "asm"
  ],
  "text/x-c": [
    "c",
    "cc",
    "cxx",
    "cpp",
    "h",
    "hh",
    "dic"
  ],
  "text/x-component": [
    "htc"
  ],
  "text/x-fortran": [
    "f",
    "for",
    "f77",
    "f90"
  ],
  "text/x-handlebars-template": [
    "hbs"
  ],
  "text/x-java-source": [
    "java"
  ],
  "text/x-lua": [
    "lua"
  ],
  "text/x-markdown": [
    "mkd"
  ],
  "text/x-nfo": [
    "nfo"
  ],
  "text/x-opml": [
    "opml"
  ],
  "text/x-org": [],
  "text/x-pascal": [
    "p",
    "pas"
  ],
  "text/x-processing": [
    "pde"
  ],
  "text/x-sass": [
    "sass"
  ],
  "text/x-scss": [
    "scss"
  ],
  "text/x-setext": [
    "etx"
  ],
  "text/x-sfv": [
    "sfv"
  ],
  "text/x-suse-ymp": [
    "ymp"
  ],
  "text/x-uuencode": [
    "uu"
  ],
  "text/x-vcalendar": [
    "vcs"
  ],
  "text/x-vcard": [
    "vcf"
  ],
  "text/xml": [],
  "text/yaml": [
    "yaml",
    "yml"
  ],
  "video/3gpp": [
    "3gp",
    "3gpp"
  ],
  "video/3gpp2": [
    "3g2"
  ],
  "video/h261": [
    "h261"
  ],
  "video/h263": [
    "h263"
  ],
  "video/h264": [
    "h264"
  ],
  "video/jpeg": [
    "jpgv"
  ],
  "video/jpm": [
    "jpgm"
  ],
  "video/mj2": [
    "mj2",
    "mjp2"
  ],
  "video/mp2t": [
    "ts"
  ],
  "video/mp4": [
    "mp4",
    "mp4v",
    "mpg4"
  ],
  "video/mpeg": [
    "mpeg",
    "mpg",
    "mpe",
    "m1v",
    "m2v"
  ],
  "video/ogg": [
    "ogv"
  ],
  "video/quicktime": [
    "qt",
    "mov"
  ],
  "video/vnd.dece.hd": [
    "uvh",
    "uvvh"
  ],
  "video/vnd.dece.mobile": [
    "uvm",
    "uvvm"
  ],
  "video/vnd.dece.pd": [
    "uvp",
    "uvvp"
  ],
  "video/vnd.dece.sd": [
    "uvs",
    "uvvs"
  ],
  "video/vnd.dece.video": [
    "uvv",
    "uvvv"
  ],
  "video/vnd.dvb.file": [
    "dvb"
  ],
  "video/vnd.fvt": [
    "fvt"
  ],
  "video/vnd.mpegurl": [
    "mxu",
    "m4u"
  ],
  "video/vnd.ms-playready.media.pyv": [
    "pyv"
  ],
  "video/vnd.uvvu.mp4": [
    "uvu",
    "uvvu"
  ],
  "video/vnd.vivo": [
    "viv"
  ],
  "video/webm": [
    "webm"
  ],
  "video/x-f4v": [
    "f4v"
  ],
  "video/x-fli": [
    "fli"
  ],
  "video/x-flv": [
    "flv"
  ],
  "video/x-m4v": [
    "m4v"
  ],
  "video/x-matroska": [
    "mkv",
    "mk3d",
    "mks"
  ],
  "video/x-mng": [
    "mng"
  ],
  "video/x-ms-asf": [
    "asf",
    "asx"
  ],
  "video/x-ms-vob": [
    "vob"
  ],
  "video/x-ms-wm": [
    "wm"
  ],
  "video/x-ms-wmv": [
    "wmv"
  ],
  "video/x-ms-wmx": [
    "wmx"
  ],
  "video/x-ms-wvx": [
    "wvx"
  ],
  "video/x-msvideo": [
    "avi"
  ],
  "video/x-sgi-movie": [
    "movie"
  ],
  "video/x-smv": [
    "smv"
  ],
  "x-conference/x-cooltalk": [
    "ice"
  ]
};
var fs$3 = require$$0$8;
function Mime() {
  this.types = /* @__PURE__ */ Object.create(null);
  this.extensions = /* @__PURE__ */ Object.create(null);
}
Mime.prototype.define = function(map2) {
  for (var type3 in map2) {
    var exts = map2[type3];
    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts[i]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type3);
      }
      this.types[exts[i]] = type3;
    }
    if (!this.extensions[type3]) {
      this.extensions[type3] = exts[0];
    }
  }
};
Mime.prototype.load = function(file) {
  this._loading = file;
  var map2 = {}, content = fs$3.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
  lines.forEach(function(line) {
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
    map2[fields.shift()] = fields;
  });
  this.define(map2);
  this._loading = null;
};
Mime.prototype.lookup = function(path22, fallback) {
  var ext = path22.replace(/^.*[\.\/\\]/, "").toLowerCase();
  return this.types[ext] || fallback || this.default_type;
};
Mime.prototype.extension = function(mimeType) {
  var type3 = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type3];
};
var mime$3 = new Mime();
mime$3.define(require$$2);
mime$3.default_type = mime$3.lookup("bin");
mime$3.Mime = Mime;
mime$3.charsets = {
  lookup: function(mimeType, fallback) {
    return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
  }
};
var mime_1 = mime$3;
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var rangeParser_1 = rangeParser;
function rangeParser(size, str2, options2) {
  if (typeof str2 !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var index2 = str2.indexOf("=");
  if (index2 === -1) {
    return -2;
  }
  var arr = str2.slice(index2 + 1).split(",");
  var ranges = [];
  ranges.type = str2.slice(0, index2);
  for (var i = 0; i < arr.length; i++) {
    var range3 = arr[i].split("-");
    var start = parseInt(range3[0], 10);
    var end = parseInt(range3[1], 10);
    if (isNaN(start)) {
      start = size - end;
      end = size - 1;
    } else if (isNaN(end)) {
      end = size - 1;
    }
    if (end > size - 1) {
      end = size - 1;
    }
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue;
    }
    ranges.push({
      start,
      end
    });
  }
  if (ranges.length < 1) {
    return -1;
  }
  return options2 && options2.combine ? combineRanges(ranges) : ranges;
}
function combineRanges(ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range3 = ordered[i];
    var current = ordered[j];
    if (range3.start > current.end + 1) {
      ordered[++j] = range3;
    } else if (range3.end > current.end) {
      current.end = range3.end;
      current.index = Math.min(current.index, range3.index);
    }
  }
  ordered.length = j + 1;
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
  combined.type = ranges.type;
  return combined;
}
function mapWithIndex(range3, index2) {
  return {
    start: range3.start,
    end: range3.end,
    index: index2
  };
}
function mapWithoutIndex(range3) {
  return {
    start: range3.start,
    end: range3.end
  };
}
function sortByRangeIndex(a, b) {
  return a.index - b.index;
}
function sortByRangeStart(a, b) {
  return a.start - b.start;
}
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var createError$1 = httpErrorsExports;
var debug$7 = srcExports$1("send");
var deprecate$2 = depd_1("send");
var destroy = destroy_1;
var encodeUrl$1 = encodeurl;
var escapeHtml$1 = escapeHtml_1;
var etag = etag_1;
var fresh$1 = fresh_1;
var fs$2 = require$$0$8;
var mime$2 = mime_1;
var ms = ms$2;
var onFinished$1 = onFinishedExports;
var parseRange$1 = rangeParser_1;
var path$2 = require$$1$2;
var statuses$1 = statuses$3;
var Stream2 = require$$1$3;
var util$4 = require$$1$1;
var extname$1 = path$2.extname;
var join$1 = path$2.join;
var normalize = path$2.normalize;
var resolve$1 = path$2.resolve;
var sep = path$2.sep;
var BYTES_RANGE_REGEXP = /^ *bytes=/;
var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
send$2.exports = send$1;
send$2.exports.mime = mime$2;
function send$1(req2, path3, options2) {
  return new SendStream(req2, path3, options2);
}
function SendStream(req2, path3, options2) {
  Stream2.call(this);
  var opts = options2 || {};
  this.options = opts;
  this.path = path3;
  this.req = req2;
  this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
  this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
  this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
  this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
  if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
  }
  this._hidden = Boolean(opts.hidden);
  if (opts.hidden !== void 0) {
    deprecate$2("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
  }
  if (opts.dotfiles === void 0) {
    this._dotfiles = void 0;
  }
  this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
  this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
  this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
  this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
  this._maxage = opts.maxAge || opts.maxage;
  this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
  this._root = opts.root ? resolve$1(opts.root) : null;
  if (!this._root && opts.from) {
    this.from(opts.from);
  }
}
util$4.inherits(SendStream, Stream2);
SendStream.prototype.etag = deprecate$2.function(function etag2(val) {
  this._etag = Boolean(val);
  debug$7("etag %s", this._etag);
  return this;
}, "send.etag: pass etag as option");
SendStream.prototype.hidden = deprecate$2.function(function hidden(val) {
  this._hidden = Boolean(val);
  this._dotfiles = void 0;
  debug$7("hidden %s", this._hidden);
  return this;
}, "send.hidden: use dotfiles option");
SendStream.prototype.index = deprecate$2.function(function index(paths) {
  var index2 = !paths ? [] : normalizeList(paths, "paths argument");
  debug$7("index %o", paths);
  this._index = index2;
  return this;
}, "send.index: pass index as option");
SendStream.prototype.root = function root(path3) {
  this._root = resolve$1(String(path3));
  debug$7("root %s", this._root);
  return this;
};
SendStream.prototype.from = deprecate$2.function(
  SendStream.prototype.root,
  "send.from: pass root as option"
);
SendStream.prototype.root = deprecate$2.function(
  SendStream.prototype.root,
  "send.root: pass root as option"
);
SendStream.prototype.maxage = deprecate$2.function(function maxage(maxAge) {
  this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
  debug$7("max-age %d", this._maxage);
  return this;
}, "send.maxage: pass maxAge as option");
SendStream.prototype.error = function error(status3, err) {
  if (hasListeners(this, "error")) {
    return this.emit("error", createHttpError(status3, err));
  }
  var res2 = this.res;
  var msg = statuses$1.message[status3] || String(status3);
  var doc = createHtmlDocument("Error", escapeHtml$1(msg));
  clearHeaders(res2);
  if (err && err.headers) {
    setHeaders(res2, err.headers);
  }
  res2.statusCode = status3;
  res2.setHeader("Content-Type", "text/html; charset=UTF-8");
  res2.setHeader("Content-Length", Buffer.byteLength(doc));
  res2.setHeader("Content-Security-Policy", "default-src 'none'");
  res2.setHeader("X-Content-Type-Options", "nosniff");
  res2.end(doc);
};
SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
  return this.path[this.path.length - 1] === "/";
};
SendStream.prototype.isConditionalGET = function isConditionalGET() {
  return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
};
SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
  var req2 = this.req;
  var res2 = this.res;
  var match2 = req2.headers["if-match"];
  if (match2) {
    var etag3 = res2.getHeader("ETag");
    return !etag3 || match2 !== "*" && parseTokenList(match2).every(function(match3) {
      return match3 !== etag3 && match3 !== "W/" + etag3 && "W/" + match3 !== etag3;
    });
  }
  var unmodifiedSince = parseHttpDate(req2.headers["if-unmodified-since"]);
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res2.getHeader("Last-Modified"));
    return isNaN(lastModified) || lastModified > unmodifiedSince;
  }
  return false;
};
SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
  var res2 = this.res;
  res2.removeHeader("Content-Encoding");
  res2.removeHeader("Content-Language");
  res2.removeHeader("Content-Length");
  res2.removeHeader("Content-Range");
  res2.removeHeader("Content-Type");
};
SendStream.prototype.notModified = function notModified() {
  var res2 = this.res;
  debug$7("not modified");
  this.removeContentHeaderFields();
  res2.statusCode = 304;
  res2.end();
};
SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
  var err = new Error("Can't set headers after they are sent.");
  debug$7("headers already sent");
  this.error(500, err);
};
SendStream.prototype.isCachable = function isCachable() {
  var statusCode = this.res.statusCode;
  return statusCode >= 200 && statusCode < 300 || statusCode === 304;
};
SendStream.prototype.onStatError = function onStatError(error2) {
  switch (error2.code) {
    case "ENAMETOOLONG":
    case "ENOENT":
    case "ENOTDIR":
      this.error(404, error2);
      break;
    default:
      this.error(500, error2);
      break;
  }
};
SendStream.prototype.isFresh = function isFresh() {
  return fresh$1(this.req.headers, {
    etag: this.res.getHeader("ETag"),
    "last-modified": this.res.getHeader("Last-Modified")
  });
};
SendStream.prototype.isRangeFresh = function isRangeFresh() {
  var ifRange = this.req.headers["if-range"];
  if (!ifRange) {
    return true;
  }
  if (ifRange.indexOf('"') !== -1) {
    var etag3 = this.res.getHeader("ETag");
    return Boolean(etag3 && ifRange.indexOf(etag3) !== -1);
  }
  var lastModified = this.res.getHeader("Last-Modified");
  return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
};
SendStream.prototype.redirect = function redirect(path3) {
  var res2 = this.res;
  if (hasListeners(this, "directory")) {
    this.emit("directory", res2, path3);
    return;
  }
  if (this.hasTrailingSlash()) {
    this.error(403);
    return;
  }
  var loc = encodeUrl$1(collapseLeadingSlashes(this.path + "/"));
  var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml$1(loc));
  res2.statusCode = 301;
  res2.setHeader("Content-Type", "text/html; charset=UTF-8");
  res2.setHeader("Content-Length", Buffer.byteLength(doc));
  res2.setHeader("Content-Security-Policy", "default-src 'none'");
  res2.setHeader("X-Content-Type-Options", "nosniff");
  res2.setHeader("Location", loc);
  res2.end(doc);
};
SendStream.prototype.pipe = function pipe(res2) {
  var root3 = this._root;
  this.res = res2;
  var path3 = decode$1(this.path);
  if (path3 === -1) {
    this.error(400);
    return res2;
  }
  if (~path3.indexOf("\0")) {
    this.error(400);
    return res2;
  }
  var parts;
  if (root3 !== null) {
    if (path3) {
      path3 = normalize("." + sep + path3);
    }
    if (UP_PATH_REGEXP.test(path3)) {
      debug$7('malicious path "%s"', path3);
      this.error(403);
      return res2;
    }
    parts = path3.split(sep);
    path3 = normalize(join$1(root3, path3));
  } else {
    if (UP_PATH_REGEXP.test(path3)) {
      debug$7('malicious path "%s"', path3);
      this.error(403);
      return res2;
    }
    parts = normalize(path3).split(sep);
    path3 = resolve$1(path3);
  }
  if (containsDotFile(parts)) {
    var access = this._dotfiles;
    if (access === void 0) {
      access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
    }
    debug$7('%s dotfile "%s"', access, path3);
    switch (access) {
      case "allow":
        break;
      case "deny":
        this.error(403);
        return res2;
      case "ignore":
      default:
        this.error(404);
        return res2;
    }
  }
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path3);
    return res2;
  }
  this.sendFile(path3);
  return res2;
};
SendStream.prototype.send = function send(path3, stat2) {
  var len = stat2.size;
  var options2 = this.options;
  var opts = {};
  var res2 = this.res;
  var req2 = this.req;
  var ranges = req2.headers.range;
  var offset = options2.start || 0;
  if (headersSent(res2)) {
    this.headersAlreadySent();
    return;
  }
  debug$7('pipe "%s"', path3);
  this.setHeader(path3, stat2);
  this.type(path3);
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412);
      return;
    }
    if (this.isCachable() && this.isFresh()) {
      this.notModified();
      return;
    }
  }
  len = Math.max(0, len - offset);
  if (options2.end !== void 0) {
    var bytes2 = options2.end - offset + 1;
    if (len > bytes2) len = bytes2;
  }
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    ranges = parseRange$1(len, ranges, {
      combine: true
    });
    if (!this.isRangeFresh()) {
      debug$7("range stale");
      ranges = -2;
    }
    if (ranges === -1) {
      debug$7("range unsatisfiable");
      res2.setHeader("Content-Range", contentRange("bytes", len));
      return this.error(416, {
        headers: { "Content-Range": res2.getHeader("Content-Range") }
      });
    }
    if (ranges !== -2 && ranges.length === 1) {
      debug$7("range %j", ranges);
      res2.statusCode = 206;
      res2.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
      offset += ranges[0].start;
      len = ranges[0].end - ranges[0].start + 1;
    }
  }
  for (var prop in options2) {
    opts[prop] = options2[prop];
  }
  opts.start = offset;
  opts.end = Math.max(offset, offset + len - 1);
  res2.setHeader("Content-Length", len);
  if (req2.method === "HEAD") {
    res2.end();
    return;
  }
  this.stream(path3, opts);
};
SendStream.prototype.sendFile = function sendFile(path3) {
  var i = 0;
  var self2 = this;
  debug$7('stat "%s"', path3);
  fs$2.stat(path3, function onstat(err, stat2) {
    if (err && err.code === "ENOENT" && !extname$1(path3) && path3[path3.length - 1] !== sep) {
      return next(err);
    }
    if (err) return self2.onStatError(err);
    if (stat2.isDirectory()) return self2.redirect(path3);
    self2.emit("file", path3, stat2);
    self2.send(path3, stat2);
  });
  function next(err) {
    if (self2._extensions.length <= i) {
      return err ? self2.onStatError(err) : self2.error(404);
    }
    var p = path3 + "." + self2._extensions[i++];
    debug$7('stat "%s"', p);
    fs$2.stat(p, function(err2, stat2) {
      if (err2) return next(err2);
      if (stat2.isDirectory()) return next();
      self2.emit("file", p, stat2);
      self2.send(p, stat2);
    });
  }
};
SendStream.prototype.sendIndex = function sendIndex(path3) {
  var i = -1;
  var self2 = this;
  function next(err) {
    if (++i >= self2._index.length) {
      if (err) return self2.onStatError(err);
      return self2.error(404);
    }
    var p = join$1(path3, self2._index[i]);
    debug$7('stat "%s"', p);
    fs$2.stat(p, function(err2, stat2) {
      if (err2) return next(err2);
      if (stat2.isDirectory()) return next();
      self2.emit("file", p, stat2);
      self2.send(p, stat2);
    });
  }
  next();
};
SendStream.prototype.stream = function stream(path3, options2) {
  var self2 = this;
  var res2 = this.res;
  var stream2 = fs$2.createReadStream(path3, options2);
  this.emit("stream", stream2);
  stream2.pipe(res2);
  function cleanup() {
    destroy(stream2, true);
  }
  onFinished$1(res2, cleanup);
  stream2.on("error", function onerror(err) {
    cleanup();
    self2.onStatError(err);
  });
  stream2.on("end", function onend() {
    self2.emit("end");
  });
};
SendStream.prototype.type = function type2(path3) {
  var res2 = this.res;
  if (res2.getHeader("Content-Type")) return;
  var type3 = mime$2.lookup(path3);
  if (!type3) {
    debug$7("no content-type");
    return;
  }
  var charset3 = mime$2.charsets.lookup(type3);
  debug$7("content-type %s", type3);
  res2.setHeader("Content-Type", type3 + (charset3 ? "; charset=" + charset3 : ""));
};
SendStream.prototype.setHeader = function setHeader(path3, stat2) {
  var res2 = this.res;
  this.emit("headers", res2, path3, stat2);
  if (this._acceptRanges && !res2.getHeader("Accept-Ranges")) {
    debug$7("accept ranges");
    res2.setHeader("Accept-Ranges", "bytes");
  }
  if (this._cacheControl && !res2.getHeader("Cache-Control")) {
    var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
    if (this._immutable) {
      cacheControl += ", immutable";
    }
    debug$7("cache-control %s", cacheControl);
    res2.setHeader("Cache-Control", cacheControl);
  }
  if (this._lastModified && !res2.getHeader("Last-Modified")) {
    var modified = stat2.mtime.toUTCString();
    debug$7("modified %s", modified);
    res2.setHeader("Last-Modified", modified);
  }
  if (this._etag && !res2.getHeader("ETag")) {
    var val = etag(stat2);
    debug$7("etag %s", val);
    res2.setHeader("ETag", val);
  }
};
function clearHeaders(res2) {
  var headers = getHeaderNames(res2);
  for (var i = 0; i < headers.length; i++) {
    res2.removeHeader(headers[i]);
  }
}
function collapseLeadingSlashes(str2) {
  for (var i = 0; i < str2.length; i++) {
    if (str2[i] !== "/") {
      break;
    }
  }
  return i > 1 ? "/" + str2.substr(i) : str2;
}
function containsDotFile(parts) {
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    if (part.length > 1 && part[0] === ".") {
      return true;
    }
  }
  return false;
}
function contentRange(type3, size, range3) {
  return type3 + " " + (range3 ? range3.start + "-" + range3.end : "*") + "/" + size;
}
function createHtmlDocument(title, body) {
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
}
function createHttpError(status3, err) {
  if (!err) {
    return createError$1(status3);
  }
  return err instanceof Error ? createError$1(status3, err, { expose: false }) : createError$1(status3, err);
}
function decode$1(path3) {
  try {
    return decodeURIComponent(path3);
  } catch (err) {
    return -1;
  }
}
function getHeaderNames(res2) {
  return typeof res2.getHeaderNames !== "function" ? Object.keys(res2._headers || {}) : res2.getHeaderNames();
}
function hasListeners(emitter, type3) {
  var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type3).length : emitter.listenerCount(type3);
  return count > 0;
}
function headersSent(res2) {
  return typeof res2.headersSent !== "boolean" ? Boolean(res2._header) : res2.headersSent;
}
function normalizeList(val, name) {
  var list = [].concat(val || []);
  for (var i = 0; i < list.length; i++) {
    if (typeof list[i] !== "string") {
      throw new TypeError(name + " must be array of strings or false");
    }
  }
  return list;
}
function parseHttpDate(date) {
  var timestamp2 = date && Date.parse(date);
  return typeof timestamp2 === "number" ? timestamp2 : NaN;
}
function parseTokenList(str2) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = str2.length; i < len; i++) {
    switch (str2.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        if (start !== end) {
          list.push(str2.substring(start, end));
        }
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  if (start !== end) {
    list.push(str2.substring(start, end));
  }
  return list;
}
function setHeaders(res2, headers) {
  var keys = Object.keys(headers);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    res2.setHeader(key, headers[key]);
  }
}
var sendExports = send$2.exports;
var proxyAddr = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var forwarded_1 = forwarded$1;
function forwarded$1(req2) {
  if (!req2) {
    throw new TypeError("argument req is required");
  }
  var proxyAddrs = parse$4(req2.headers["x-forwarded-for"] || "");
  var socketAddr = getSocketAddr(req2);
  var addrs = [socketAddr].concat(proxyAddrs);
  return addrs;
}
function getSocketAddr(req2) {
  return req2.socket ? req2.socket.remoteAddress : req2.connection.remoteAddress;
}
function parse$4(header3) {
  var end = header3.length;
  var list = [];
  var start = header3.length;
  for (var i = header3.length - 1; i >= 0; i--) {
    switch (header3.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i;
        }
        break;
      case 44:
        if (start !== end) {
          list.push(header3.substring(start, end));
        }
        start = end = i;
        break;
      default:
        start = i;
        break;
    }
  }
  if (start !== end) {
    list.push(header3.substring(start, end));
  }
  return list;
}
var ipaddr$1 = { exports: {} };
(function(module) {
  (function() {
    var expandIPv6, ipaddr2, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root3, zoneIndex;
    ipaddr2 = {};
    root3 = this;
    if (module !== null && module.exports) {
      module.exports = ipaddr2;
    } else {
      root3["ipaddr"] = ipaddr2;
    }
    matchCIDR = function(first2, second, partSize, cidrBits) {
      var part, shift;
      if (first2.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      part = 0;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first2[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    };
    ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
      var k, len, rangeName, rangeSubnets, subnet;
      if (defaultName == null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        rangeSubnets = rangeList[rangeName];
        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
          rangeSubnets = [rangeSubnets];
        }
        for (k = 0, len = rangeSubnets.length; k < len; k++) {
          subnet = rangeSubnets[k];
          if (address.kind() === subnet[0].kind()) {
            if (address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    ipaddr2.IPv4 = function() {
      function IPv4(octets) {
        var k, len, octet;
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.match = function(other, cidrRange) {
        var ref2;
        if (cidrRange === void 0) {
          ref2 = other, other = ref2[0], cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
        reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
      };
      IPv4.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr2.IPv6.parse("::ffff:" + this.toString());
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, octet, stop, zeros, zerotable;
        zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 3; k >= 0; i = k += -1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      return IPv4;
    }();
    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    ipv4Regexes = {
      fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
      longValue: new RegExp("^" + ipv4Part + "$", "i")
    };
    ipaddr2.IPv4.parser = function(string2) {
      var match2, parseIntAuto, part, shift, value;
      parseIntAuto = function(string3) {
        if (string3[0] === "0" && string3[1] !== "x") {
          return parseInt(string3, 8);
        } else {
          return parseInt(string3);
        }
      };
      if (match2 = string2.match(ipv4Regexes.fourOctet)) {
        return function() {
          var k, len, ref2, results;
          ref2 = match2.slice(1, 6);
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match2 = string2.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match2[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          var k, results;
          results = [];
          for (shift = k = 0; k <= 24; shift = k += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else {
        return null;
      }
    };
    ipaddr2.IPv6 = function() {
      function IPv6(parts, zoneId) {
        var i, k, l, len, part, ref2;
        if (parts.length === 16) {
          this.parts = [];
          for (i = k = 0; k <= 14; i = k += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        ref2 = this.parts;
        for (l = 0, len = ref2.length; l < len; l++) {
          part = ref2[l];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      };
      IPv6.prototype.toRFC5952String = function() {
        var bestMatchIndex, bestMatchLength, match2, regex, string2;
        regex = /((^|:)(0(:|$)){2,})/g;
        string2 = this.toNormalizedString();
        bestMatchIndex = 0;
        bestMatchLength = -1;
        while (match2 = regex.exec(string2)) {
          if (match2[0].length > bestMatchLength) {
            bestMatchIndex = match2.index;
            bestMatchLength = match2[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string2;
        }
        return string2.substring(0, bestMatchIndex) + "::" + string2.substring(bestMatchIndex + bestMatchLength);
      };
      IPv6.prototype.toByteArray = function() {
        var bytes2, k, len, part, ref2;
        bytes2 = [];
        ref2 = this.parts;
        for (k = 0, len = ref2.length; k < len; k++) {
          part = ref2[k];
          bytes2.push(part >> 8);
          bytes2.push(part & 255);
        }
        return bytes2;
      };
      IPv6.prototype.toNormalizedString = function() {
        var addr, part, suffix;
        addr = (function() {
          var k, len, ref2, results;
          ref2 = this.parts;
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(part.toString(16));
          }
          return results;
        }).call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.toFixedLengthString = function() {
        var addr, part, suffix;
        addr = (function() {
          var k, len, ref2, results;
          ref2 = this.parts;
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(part.toString(16).padStart(4, "0"));
          }
          return results;
        }).call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.match = function(other, cidrRange) {
        var ref2;
        if (cidrRange === void 0) {
          ref2 = other, other = ref2[0], cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      };
      IPv6.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.toIPv4Address = function() {
        var high, low, ref2;
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        ref2 = this.parts.slice(-2), high = ref2[0], low = ref2[1];
        return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, part, stop, zeros, zerotable;
        zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 7; k >= 0; i = k += -1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      return IPv6;
    }();
    ipv6Part = "(?:[0-9a-f]+::?)+";
    zoneIndex = "%[0-9a-z]{1,}";
    ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
      transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
    };
    expandIPv6 = function(string2, parts) {
      var colonCount, lastColon, part, replacement, replacementCount, zoneId;
      if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
        return null;
      }
      zoneId = (string2.match(ipv6Regexes["zoneIndex"]) || [])[0];
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string2 = string2.replace(/%.+$/, "");
      }
      colonCount = 0;
      lastColon = -1;
      while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string2.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string2.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string2 = string2.replace("::", replacement);
      if (string2[0] === ":") {
        string2 = string2.slice(1);
      }
      if (string2[string2.length - 1] === ":") {
        string2 = string2.slice(0, -1);
      }
      parts = function() {
        var k, len, ref2, results;
        ref2 = string2.split(":");
        results = [];
        for (k = 0, len = ref2.length; k < len; k++) {
          part = ref2[k];
          results.push(parseInt(part, 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    };
    ipaddr2.IPv6.parser = function(string2) {
      var addr, k, len, match2, octet, octets, zoneId;
      if (ipv6Regexes["native"].test(string2)) {
        return expandIPv6(string2, 8);
      } else if (match2 = string2.match(ipv6Regexes["transitional"])) {
        zoneId = match2[6] || "";
        addr = expandIPv6(match2[1].slice(0, -1) + zoneId, 6);
        if (addr.parts) {
          octets = [parseInt(match2[2]), parseInt(match2[3]), parseInt(match2[4]), parseInt(match2[5])];
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr2.IPv4.isIPv4 = ipaddr2.IPv6.isIPv6 = function(string2) {
      return this.parser(string2) !== null;
    };
    ipaddr2.IPv4.isValid = function(string2) {
      try {
        new this(this.parser(string2));
        return true;
      } catch (error1) {
        return false;
      }
    };
    ipaddr2.IPv4.isValidFourPartDecimal = function(string2) {
      if (ipaddr2.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr2.IPv6.isValid = function(string2) {
      var addr;
      if (typeof string2 === "string" && string2.indexOf(":") === -1) {
        return false;
      }
      try {
        addr = this.parser(string2);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (error1) {
        return false;
      }
    };
    ipaddr2.IPv4.parse = function(string2) {
      var parts;
      parts = this.parser(string2);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(parts);
    };
    ipaddr2.IPv6.parse = function(string2) {
      var addr;
      addr = this.parser(string2);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr2.IPv4.parseCIDR = function(string2) {
      var maskLength, match2, parsed;
      if (match2 = string2.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      var filledOctetCount, j, octets;
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      octets = [0, 0, 0, 0];
      j = 0;
      filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr2.IPv4.broadcastAddressFromCIDR = function(string2) {
      var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string2);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (error1) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv4.networkAddressFromCIDR = function(string2) {
      var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string2);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (error1) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv6.parseCIDR = function(string2) {
      var maskLength, match2, parsed;
      if (match2 = string2.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr2.isValid = function(string2) {
      return ipaddr2.IPv6.isValid(string2) || ipaddr2.IPv4.isValid(string2);
    };
    ipaddr2.parse = function(string2) {
      if (ipaddr2.IPv6.isValid(string2)) {
        return ipaddr2.IPv6.parse(string2);
      } else if (ipaddr2.IPv4.isValid(string2)) {
        return ipaddr2.IPv4.parse(string2);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr2.parseCIDR = function(string2) {
      try {
        return ipaddr2.IPv6.parseCIDR(string2);
      } catch (error1) {
        try {
          return ipaddr2.IPv4.parseCIDR(string2);
        } catch (error12) {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr2.fromByteArray = function(bytes2) {
      var length;
      length = bytes2.length;
      if (length === 4) {
        return new ipaddr2.IPv4(bytes2);
      } else if (length === 16) {
        return new ipaddr2.IPv6(bytes2);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr2.process = function(string2) {
      var addr;
      addr = this.parse(string2);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
  }).call(commonjsGlobal);
})(ipaddr$1);
var ipaddrExports = ipaddr$1.exports;
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
proxyAddr.exports = proxyaddr$1;
proxyAddr.exports.all = alladdrs;
proxyAddr.exports.compile = compile;
var forwarded = forwarded_1;
var ipaddr = ipaddrExports;
var DIGIT_REGEXP = /^[0-9]+$/;
var isip = ipaddr.isValid;
var parseip = ipaddr.parse;
var IP_RANGES = {
  linklocal: ["169.254.0.0/16", "fe80::/10"],
  loopback: ["127.0.0.1/8", "::1/128"],
  uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
};
function alladdrs(req2, trust) {
  var addrs = forwarded(req2);
  if (!trust) {
    return addrs;
  }
  if (typeof trust !== "function") {
    trust = compile(trust);
  }
  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue;
    addrs.length = i + 1;
  }
  return addrs;
}
function compile(val) {
  if (!val) {
    throw new TypeError("argument is required");
  }
  var trust;
  if (typeof val === "string") {
    trust = [val];
  } else if (Array.isArray(val)) {
    trust = val.slice();
  } else {
    throw new TypeError("unsupported trust argument");
  }
  for (var i = 0; i < trust.length; i++) {
    val = trust[i];
    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
      continue;
    }
    val = IP_RANGES[val];
    trust.splice.apply(trust, [i, 1].concat(val));
    i += val.length - 1;
  }
  return compileTrust(compileRangeSubnets(trust));
}
function compileRangeSubnets(arr) {
  var rangeSubnets = new Array(arr.length);
  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i]);
  }
  return rangeSubnets;
}
function compileTrust(rangeSubnets) {
  var len = rangeSubnets.length;
  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}
function parseipNotation(note) {
  var pos = note.lastIndexOf("/");
  var str2 = pos !== -1 ? note.substring(0, pos) : note;
  if (!isip(str2)) {
    throw new TypeError("invalid IP address: " + str2);
  }
  var ip2 = parseip(str2);
  if (pos === -1 && ip2.kind() === "ipv6" && ip2.isIPv4MappedAddress()) {
    ip2 = ip2.toIPv4Address();
  }
  var max2 = ip2.kind() === "ipv6" ? 128 : 32;
  var range3 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
  if (range3 === null) {
    range3 = max2;
  } else if (DIGIT_REGEXP.test(range3)) {
    range3 = parseInt(range3, 10);
  } else if (ip2.kind() === "ipv4" && isip(range3)) {
    range3 = parseNetmask(range3);
  } else {
    range3 = null;
  }
  if (range3 <= 0 || range3 > max2) {
    throw new TypeError("invalid range on address: " + note);
  }
  return [ip2, range3];
}
function parseNetmask(netmask) {
  var ip2 = parseip(netmask);
  var kind = ip2.kind();
  return kind === "ipv4" ? ip2.prefixLengthFromSubnetMask() : null;
}
function proxyaddr$1(req2, trust) {
  if (!req2) {
    throw new TypeError("req argument is required");
  }
  if (!trust) {
    throw new TypeError("trust argument is required");
  }
  var addrs = alladdrs(req2, trust);
  var addr = addrs[addrs.length - 1];
  return addr;
}
function trustNone() {
  return false;
}
function trustMulti(subnets) {
  return function trust(addr) {
    if (!isip(addr)) return false;
    var ip2 = parseip(addr);
    var ipconv;
    var kind = ip2.kind();
    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i];
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetrange = subnet[1];
      var trusted = ip2;
      if (kind !== subnetkind) {
        if (subnetkind === "ipv4" && !ip2.isIPv4MappedAddress()) {
          continue;
        }
        if (!ipconv) {
          ipconv = subnetkind === "ipv4" ? ip2.toIPv4Address() : ip2.toIPv4MappedAddress();
        }
        trusted = ipconv;
      }
      if (trusted.match(subnetip, subnetrange)) {
        return true;
      }
    }
    return false;
  };
}
function trustSingle(subnet) {
  var subnetip = subnet[0];
  var subnetkind = subnetip.kind();
  var subnetisipv4 = subnetkind === "ipv4";
  var subnetrange = subnet[1];
  return function trust(addr) {
    if (!isip(addr)) return false;
    var ip2 = parseip(addr);
    var kind = ip2.kind();
    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip2.isIPv4MappedAddress()) {
        return false;
      }
      ip2 = subnetisipv4 ? ip2.toIPv4Address() : ip2.toIPv4MappedAddress();
    }
    return ip2.match(subnetip, subnetrange);
  };
}
var proxyAddrExports = proxyAddr.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports$1) {
  var Buffer2 = safeBufferExports.Buffer;
  var contentDisposition2 = contentDispositionExports;
  var contentType$1 = contentType;
  var deprecate2 = depd_1("express");
  var flatten2 = arrayFlatten_1;
  var mime2 = sendExports.mime;
  var etag3 = etag_1;
  var proxyaddr2 = proxyAddrExports;
  var qs = requireLib();
  var querystring = require$$8;
  exports$1.etag = createETagGenerator({ weak: false });
  exports$1.wetag = createETagGenerator({ weak: true });
  exports$1.isAbsolute = function(path3) {
    if ("/" === path3[0]) return true;
    if (":" === path3[1] && ("\\" === path3[2] || "/" === path3[2])) return true;
    if ("\\\\" === path3.substring(0, 2)) return true;
  };
  exports$1.flatten = deprecate2.function(
    flatten2,
    "utils.flatten: use array-flatten npm module instead"
  );
  exports$1.normalizeType = function(type3) {
    return ~type3.indexOf("/") ? acceptParams(type3) : { value: mime2.lookup(type3), params: {} };
  };
  exports$1.normalizeTypes = function(types2) {
    var ret = [];
    for (var i = 0; i < types2.length; ++i) {
      ret.push(exports$1.normalizeType(types2[i]));
    }
    return ret;
  };
  exports$1.contentDisposition = deprecate2.function(
    contentDisposition2,
    "utils.contentDisposition: use content-disposition npm module instead"
  );
  function acceptParams(str2) {
    var parts = str2.split(/ *; */);
    var ret = { value: parts[0], quality: 1, params: {} };
    for (var i = 1; i < parts.length; ++i) {
      var pms = parts[i].split(/ *= */);
      if ("q" === pms[0]) {
        ret.quality = parseFloat(pms[1]);
      } else {
        ret.params[pms[0]] = pms[1];
      }
    }
    return ret;
  }
  exports$1.compileETag = function(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "weak":
        fn = exports$1.wetag;
        break;
      case false:
        break;
      case "strong":
        fn = exports$1.etag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + val);
    }
    return fn;
  };
  exports$1.compileQueryParser = function compileQueryParser(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "simple":
        fn = querystring.parse;
        break;
      case false:
        fn = newObject;
        break;
      case "extended":
        fn = parseExtendedQueryString;
        break;
      default:
        throw new TypeError("unknown value for query parser function: " + val);
    }
    return fn;
  };
  exports$1.compileTrust = function(val) {
    if (typeof val === "function") return val;
    if (val === true) {
      return function() {
        return true;
      };
    }
    if (typeof val === "number") {
      return function(a, i) {
        return i < val;
      };
    }
    if (typeof val === "string") {
      val = val.split(",").map(function(v) {
        return v.trim();
      });
    }
    return proxyaddr2.compile(val || []);
  };
  exports$1.setCharset = function setCharset2(type3, charset3) {
    if (!type3 || !charset3) {
      return type3;
    }
    var parsed = contentType$1.parse(type3);
    parsed.parameters.charset = charset3;
    return contentType$1.format(parsed);
  };
  function createETagGenerator(options2) {
    return function generateETag(body, encoding3) {
      var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding3) : body;
      return etag3(buf, options2);
    };
  }
  function parseExtendedQueryString(str2) {
    return qs.parse(str2, {
      allowPrototypes: true
    });
  }
  function newObject() {
    return {};
  }
})(utils);
(function(module, exports$1) {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var finalhandler2 = finalhandler_1;
  var Router = routerExports;
  var methods2 = methods$2;
  var middleware = init$1;
  var query = requireQuery();
  var debug2 = srcExports$1("express:application");
  var View2 = view;
  var http2 = require$$0$b;
  var compileETag = utils.compileETag;
  var compileQueryParser = utils.compileQueryParser;
  var compileTrust2 = utils.compileTrust;
  var deprecate2 = depd_1("express");
  var flatten2 = arrayFlatten_1;
  var merge2 = utilsMergeExports;
  var resolve3 = require$$1$2.resolve;
  var setPrototypeOf2 = setprototypeof;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var slice2 = Array.prototype.slice;
  var app2 = module.exports = {};
  var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
  app2.init = function init2() {
    this.cache = {};
    this.engines = {};
    this.settings = {};
    this.defaultConfiguration();
  };
  app2.defaultConfiguration = function defaultConfiguration() {
    var env = process.env.NODE_ENV || "development";
    this.enable("x-powered-by");
    this.set("etag", "weak");
    this.set("env", env);
    this.set("query parser", "extended");
    this.set("subdomain offset", 2);
    this.set("trust proxy", false);
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
      configurable: true,
      value: true
    });
    debug2("booting in %s mode", env);
    this.on("mount", function onmount(parent) {
      if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
        delete this.settings["trust proxy"];
        delete this.settings["trust proxy fn"];
      }
      setPrototypeOf2(this.request, parent.request);
      setPrototypeOf2(this.response, parent.response);
      setPrototypeOf2(this.engines, parent.engines);
      setPrototypeOf2(this.settings, parent.settings);
    });
    this.locals = /* @__PURE__ */ Object.create(null);
    this.mountpath = "/";
    this.locals.settings = this.settings;
    this.set("view", View2);
    this.set("views", resolve3("views"));
    this.set("jsonp callback name", "callback");
    if (env === "production") {
      this.enable("view cache");
    }
    Object.defineProperty(this, "router", {
      get: function() {
        throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
      }
    });
  };
  app2.lazyrouter = function lazyrouter() {
    if (!this._router) {
      this._router = new Router({
        caseSensitive: this.enabled("case sensitive routing"),
        strict: this.enabled("strict routing")
      });
      this._router.use(query(this.get("query parser fn")));
      this._router.use(middleware.init(this));
    }
  };
  app2.handle = function handle3(req2, res2, callback) {
    var router2 = this._router;
    var done = callback || finalhandler2(req2, res2, {
      env: this.get("env"),
      onerror: logerror.bind(this)
    });
    if (!router2) {
      debug2("no routes defined on app");
      done();
      return;
    }
    router2.handle(req2, res2, done);
  };
  app2.use = function use2(fn) {
    var offset = 0;
    var path22 = "/";
    if (typeof fn !== "function") {
      var arg = fn;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path22 = fn;
      }
    }
    var fns = flatten2(slice2.call(arguments, offset));
    if (fns.length === 0) {
      throw new TypeError("app.use() requires a middleware function");
    }
    this.lazyrouter();
    var router2 = this._router;
    fns.forEach(function(fn2) {
      if (!fn2 || !fn2.handle || !fn2.set) {
        return router2.use(path22, fn2);
      }
      debug2(".use app under %s", path22);
      fn2.mountpath = path22;
      fn2.parent = this;
      router2.use(path22, function mounted_app(req2, res2, next) {
        var orig = req2.app;
        fn2.handle(req2, res2, function(err) {
          setPrototypeOf2(req2, orig.request);
          setPrototypeOf2(res2, orig.response);
          next(err);
        });
      });
      fn2.emit("mount", this);
    }, this);
    return this;
  };
  app2.route = function route3(path22) {
    this.lazyrouter();
    return this._router.route(path22);
  };
  app2.engine = function engine(ext, fn) {
    if (typeof fn !== "function") {
      throw new Error("callback function required");
    }
    var extension = ext[0] !== "." ? "." + ext : ext;
    this.engines[extension] = fn;
    return this;
  };
  app2.param = function param3(name, fn) {
    this.lazyrouter();
    if (Array.isArray(name)) {
      for (var i = 0; i < name.length; i++) {
        this.param(name[i], fn);
      }
      return this;
    }
    this._router.param(name, fn);
    return this;
  };
  app2.set = function set2(setting, val) {
    if (arguments.length === 1) {
      var settings = this.settings;
      while (settings && settings !== Object.prototype) {
        if (hasOwnProperty2.call(settings, setting)) {
          return settings[setting];
        }
        settings = Object.getPrototypeOf(settings);
      }
      return void 0;
    }
    debug2('set "%s" to %o', setting, val);
    this.settings[setting] = val;
    switch (setting) {
      case "etag":
        this.set("etag fn", compileETag(val));
        break;
      case "query parser":
        this.set("query parser fn", compileQueryParser(val));
        break;
      case "trust proxy":
        this.set("trust proxy fn", compileTrust2(val));
        Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
          configurable: true,
          value: false
        });
        break;
    }
    return this;
  };
  app2.path = function path3() {
    return this.parent ? this.parent.path() + this.mountpath : "";
  };
  app2.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
  };
  app2.disabled = function disabled(setting) {
    return !this.set(setting);
  };
  app2.enable = function enable(setting) {
    return this.set(setting, true);
  };
  app2.disable = function disable(setting) {
    return this.set(setting, false);
  };
  methods2.forEach(function(method2) {
    app2[method2] = function(path22) {
      if (method2 === "get" && arguments.length === 1) {
        return this.set(path22);
      }
      this.lazyrouter();
      var route22 = this._router.route(path22);
      route22[method2].apply(route22, slice2.call(arguments, 1));
      return this;
    };
  });
  app2.all = function all2(path22) {
    this.lazyrouter();
    var route22 = this._router.route(path22);
    var args = slice2.call(arguments, 1);
    for (var i = 0; i < methods2.length; i++) {
      route22[methods2[i]].apply(route22, args);
    }
    return this;
  };
  app2.del = deprecate2.function(app2.delete, "app.del: Use app.delete instead");
  app2.render = function render3(name, options2, callback) {
    var cache = this.cache;
    var done = callback;
    var engines = this.engines;
    var opts = options2;
    var renderOptions = {};
    var view2;
    if (typeof options2 === "function") {
      done = options2;
      opts = {};
    }
    merge2(renderOptions, this.locals);
    if (opts._locals) {
      merge2(renderOptions, opts._locals);
    }
    merge2(renderOptions, opts);
    if (renderOptions.cache == null) {
      renderOptions.cache = this.enabled("view cache");
    }
    if (renderOptions.cache) {
      view2 = cache[name];
    }
    if (!view2) {
      var View22 = this.get("view");
      view2 = new View22(name, {
        defaultEngine: this.get("view engine"),
        root: this.get("views"),
        engines
      });
      if (!view2.path) {
        var dirs = Array.isArray(view2.root) && view2.root.length > 1 ? 'directories "' + view2.root.slice(0, -1).join('", "') + '" or "' + view2.root[view2.root.length - 1] + '"' : 'directory "' + view2.root + '"';
        var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
        err.view = view2;
        return done(err);
      }
      if (renderOptions.cache) {
        cache[name] = view2;
      }
    }
    tryRender(view2, renderOptions, done);
  };
  app2.listen = function listen() {
    var server2 = http2.createServer(this);
    return server2.listen.apply(server2, arguments);
  };
  function logerror(err) {
    if (this.get("env") !== "test") console.error(err.stack || err.toString());
  }
  function tryRender(view2, options2, callback) {
    try {
      view2.render(options2, callback);
    } catch (err) {
      callback(err);
    }
  }
})(application);
var applicationExports = application.exports;
var negotiator = { exports: {} };
var charset = { exports: {} };
charset.exports = preferredCharsets$1;
charset.exports.preferredCharsets = preferredCharsets$1;
var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptCharset(accept) {
  var accepts2 = accept.split(",");
  for (var i = 0, j = 0; i < accepts2.length; i++) {
    var charset3 = parseCharset(accepts2[i].trim(), i);
    if (charset3) {
      accepts2[j++] = charset3;
    }
  }
  accepts2.length = j;
  return accepts2;
}
function parseCharset(str2, i) {
  var match2 = simpleCharsetRegExp.exec(str2);
  if (!match2) return null;
  var charset3 = match2[1];
  var q = 1;
  if (match2[2]) {
    var params = match2[2].split(";");
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split("=");
      if (p[0] === "q") {
        q = parseFloat(p[1]);
        break;
      }
    }
  }
  return {
    charset: charset3,
    q,
    i
  };
}
function getCharsetPriority(charset3, accepted, index2) {
  var priority2 = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$3(charset3, accepted[i], index2);
    if (spec && (priority2.s - spec.s || priority2.q - spec.q || priority2.o - spec.o) < 0) {
      priority2 = spec;
    }
  }
  return priority2;
}
function specify$3(charset3, spec, index2) {
  var s2 = 0;
  if (spec.charset.toLowerCase() === charset3.toLowerCase()) {
    s2 |= 1;
  } else if (spec.charset !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredCharsets$1(accept, provided) {
  var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$3).sort(compareSpecs$3).map(getFullCharset);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getCharsetPriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$3).sort(compareSpecs$3).map(function getCharset(priority2) {
    return provided[priorities.indexOf(priority2)];
  });
}
function compareSpecs$3(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullCharset(spec) {
  return spec.charset;
}
function isQuality$3(spec) {
  return spec.q > 0;
}
var charsetExports = charset.exports;
var encoding = { exports: {} };
encoding.exports = preferredEncodings$1;
encoding.exports.preferredEncodings = preferredEncodings$1;
var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptEncoding(accept) {
  var accepts2 = accept.split(",");
  var hasIdentity = false;
  var minQuality = 1;
  for (var i = 0, j = 0; i < accepts2.length; i++) {
    var encoding3 = parseEncoding(accepts2[i].trim(), i);
    if (encoding3) {
      accepts2[j++] = encoding3;
      hasIdentity = hasIdentity || specify$2("identity", encoding3);
      minQuality = Math.min(minQuality, encoding3.q || 1);
    }
  }
  if (!hasIdentity) {
    accepts2[j++] = {
      encoding: "identity",
      q: minQuality,
      i
    };
  }
  accepts2.length = j;
  return accepts2;
}
function parseEncoding(str2, i) {
  var match2 = simpleEncodingRegExp.exec(str2);
  if (!match2) return null;
  var encoding3 = match2[1];
  var q = 1;
  if (match2[2]) {
    var params = match2[2].split(";");
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split("=");
      if (p[0] === "q") {
        q = parseFloat(p[1]);
        break;
      }
    }
  }
  return {
    encoding: encoding3,
    q,
    i
  };
}
function getEncodingPriority(encoding3, accepted, index2) {
  var priority2 = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$2(encoding3, accepted[i], index2);
    if (spec && (priority2.s - spec.s || priority2.q - spec.q || priority2.o - spec.o) < 0) {
      priority2 = spec;
    }
  }
  return priority2;
}
function specify$2(encoding3, spec, index2) {
  var s2 = 0;
  if (spec.encoding.toLowerCase() === encoding3.toLowerCase()) {
    s2 |= 1;
  } else if (spec.encoding !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredEncodings$1(accept, provided) {
  var accepts2 = parseAcceptEncoding(accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$2).sort(compareSpecs$2).map(getFullEncoding);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getEncodingPriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$2).sort(compareSpecs$2).map(function getEncoding(priority2) {
    return provided[priorities.indexOf(priority2)];
  });
}
function compareSpecs$2(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullEncoding(spec) {
  return spec.encoding;
}
function isQuality$2(spec) {
  return spec.q > 0;
}
var encodingExports = encoding.exports;
var language = { exports: {} };
language.exports = preferredLanguages$1;
language.exports.preferredLanguages = preferredLanguages$1;
var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function parseAcceptLanguage(accept) {
  var accepts2 = accept.split(",");
  for (var i = 0, j = 0; i < accepts2.length; i++) {
    var language3 = parseLanguage(accepts2[i].trim(), i);
    if (language3) {
      accepts2[j++] = language3;
    }
  }
  accepts2.length = j;
  return accepts2;
}
function parseLanguage(str2, i) {
  var match2 = simpleLanguageRegExp.exec(str2);
  if (!match2) return null;
  var prefix = match2[1];
  var suffix = match2[2];
  var full = prefix;
  if (suffix) full += "-" + suffix;
  var q = 1;
  if (match2[3]) {
    var params = match2[3].split(";");
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split("=");
      if (p[0] === "q") q = parseFloat(p[1]);
    }
  }
  return {
    prefix,
    suffix,
    q,
    i,
    full
  };
}
function getLanguagePriority(language3, accepted, index2) {
  var priority2 = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$1(language3, accepted[i], index2);
    if (spec && (priority2.s - spec.s || priority2.q - spec.q || priority2.o - spec.o) < 0) {
      priority2 = spec;
    }
  }
  return priority2;
}
function specify$1(language3, spec, index2) {
  var p = parseLanguage(language3);
  if (!p) return null;
  var s2 = 0;
  if (spec.full.toLowerCase() === p.full.toLowerCase()) {
    s2 |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s2 |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s2 |= 1;
  } else if (spec.full !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredLanguages$1(accept, provided) {
  var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$1).sort(compareSpecs$1).map(getFullLanguage);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getLanguagePriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$1).sort(compareSpecs$1).map(function getLanguage(priority2) {
    return provided[priorities.indexOf(priority2)];
  });
}
function compareSpecs$1(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullLanguage(spec) {
  return spec.full;
}
function isQuality$1(spec) {
  return spec.q > 0;
}
var languageExports = language.exports;
var mediaType = { exports: {} };
mediaType.exports = preferredMediaTypes$1;
mediaType.exports.preferredMediaTypes = preferredMediaTypes$1;
var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function parseAccept(accept) {
  var accepts2 = splitMediaTypes(accept);
  for (var i = 0, j = 0; i < accepts2.length; i++) {
    var mediaType3 = parseMediaType(accepts2[i].trim(), i);
    if (mediaType3) {
      accepts2[j++] = mediaType3;
    }
  }
  accepts2.length = j;
  return accepts2;
}
function parseMediaType(str2, i) {
  var match2 = simpleMediaTypeRegExp.exec(str2);
  if (!match2) return null;
  var params = /* @__PURE__ */ Object.create(null);
  var q = 1;
  var subtype = match2[2];
  var type3 = match2[1];
  if (match2[3]) {
    var kvps = splitParameters(match2[3]).map(splitKeyValuePair);
    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];
      var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
      if (key === "q") {
        q = parseFloat(value);
        break;
      }
      params[key] = value;
    }
  }
  return {
    type: type3,
    subtype,
    params,
    q,
    i
  };
}
function getMediaTypePriority(type3, accepted, index2) {
  var priority2 = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type3, accepted[i], index2);
    if (spec && (priority2.s - spec.s || priority2.q - spec.q || priority2.o - spec.o) < 0) {
      priority2 = spec;
    }
  }
  return priority2;
}
function specify(type3, spec, index2) {
  var p = parseMediaType(type3);
  var s2 = 0;
  if (!p) {
    return null;
  }
  if (spec.type.toLowerCase() == p.type.toLowerCase()) {
    s2 |= 4;
  } else if (spec.type != "*") {
    return null;
  }
  if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s2 |= 2;
  } else if (spec.subtype != "*") {
    return null;
  }
  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function(k) {
      return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
    })) {
      s2 |= 1;
    } else {
      return null;
    }
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredMediaTypes$1(accept, provided) {
  var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getMediaTypePriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority2) {
    return provided[priorities.indexOf(priority2)];
  });
}
function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullType(spec) {
  return spec.type + "/" + spec.subtype;
}
function isQuality(spec) {
  return spec.q > 0;
}
function quoteCount(string2) {
  var count = 0;
  var index2 = 0;
  while ((index2 = string2.indexOf('"', index2)) !== -1) {
    count++;
    index2++;
  }
  return count;
}
function splitKeyValuePair(str2) {
  var index2 = str2.indexOf("=");
  var key;
  var val;
  if (index2 === -1) {
    key = str2;
  } else {
    key = str2.substr(0, index2);
    val = str2.substr(index2 + 1);
  }
  return [key, val];
}
function splitMediaTypes(accept) {
  var accepts2 = accept.split(",");
  for (var i = 1, j = 0; i < accepts2.length; i++) {
    if (quoteCount(accepts2[j]) % 2 == 0) {
      accepts2[++j] = accepts2[i];
    } else {
      accepts2[j] += "," + accepts2[i];
    }
  }
  accepts2.length = j + 1;
  return accepts2;
}
function splitParameters(str2) {
  var parameters = str2.split(";");
  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ";" + parameters[i];
    }
  }
  parameters.length = j + 1;
  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }
  return parameters;
}
var mediaTypeExports = mediaType.exports;
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var preferredCharsets = charsetExports;
var preferredEncodings = encodingExports;
var preferredLanguages = languageExports;
var preferredMediaTypes = mediaTypeExports;
negotiator.exports = Negotiator$1;
negotiator.exports.Negotiator = Negotiator$1;
function Negotiator$1(request2) {
  if (!(this instanceof Negotiator$1)) {
    return new Negotiator$1(request2);
  }
  this.request = request2;
}
Negotiator$1.prototype.charset = function charset2(available) {
  var set2 = this.charsets(available);
  return set2 && set2[0];
};
Negotiator$1.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers["accept-charset"], available);
};
Negotiator$1.prototype.encoding = function encoding2(available) {
  var set2 = this.encodings(available);
  return set2 && set2[0];
};
Negotiator$1.prototype.encodings = function encodings2(available) {
  return preferredEncodings(this.request.headers["accept-encoding"], available);
};
Negotiator$1.prototype.language = function language2(available) {
  var set2 = this.languages(available);
  return set2 && set2[0];
};
Negotiator$1.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers["accept-language"], available);
};
Negotiator$1.prototype.mediaType = function mediaType2(available) {
  var set2 = this.mediaTypes(available);
  return set2 && set2[0];
};
Negotiator$1.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
};
Negotiator$1.prototype.preferredCharset = Negotiator$1.prototype.charset;
Negotiator$1.prototype.preferredCharsets = Negotiator$1.prototype.charsets;
Negotiator$1.prototype.preferredEncoding = Negotiator$1.prototype.encoding;
Negotiator$1.prototype.preferredEncodings = Negotiator$1.prototype.encodings;
Negotiator$1.prototype.preferredLanguage = Negotiator$1.prototype.language;
Negotiator$1.prototype.preferredLanguages = Negotiator$1.prototype.languages;
Negotiator$1.prototype.preferredMediaType = Negotiator$1.prototype.mediaType;
Negotiator$1.prototype.preferredMediaTypes = Negotiator$1.prototype.mediaTypes;
var negotiatorExports = negotiator.exports;
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Negotiator = negotiatorExports;
var mime$1 = mimeTypes;
var accepts$1 = Accepts;
function Accepts(req2) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req2);
  }
  this.headers = req2.headers;
  this.negotiator = new Negotiator(req2);
}
Accepts.prototype.type = Accepts.prototype.types = function(types_) {
  var types2 = types_;
  if (types2 && !Array.isArray(types2)) {
    types2 = new Array(arguments.length);
    for (var i = 0; i < types2.length; i++) {
      types2[i] = arguments[i];
    }
  }
  if (!types2 || types2.length === 0) {
    return this.negotiator.mediaTypes();
  }
  if (!this.headers.accept) {
    return types2[0];
  }
  var mimes = types2.map(extToMime);
  var accepts2 = this.negotiator.mediaTypes(mimes.filter(validMime));
  var first2 = accepts2[0];
  return first2 ? types2[mimes.indexOf(first2)] : false;
};
Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
  var encodings3 = encodings_;
  if (encodings3 && !Array.isArray(encodings3)) {
    encodings3 = new Array(arguments.length);
    for (var i = 0; i < encodings3.length; i++) {
      encodings3[i] = arguments[i];
    }
  }
  if (!encodings3 || encodings3.length === 0) {
    return this.negotiator.encodings();
  }
  return this.negotiator.encodings(encodings3)[0] || false;
};
Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
  var charsets2 = charsets_;
  if (charsets2 && !Array.isArray(charsets2)) {
    charsets2 = new Array(arguments.length);
    for (var i = 0; i < charsets2.length; i++) {
      charsets2[i] = arguments[i];
    }
  }
  if (!charsets2 || charsets2.length === 0) {
    return this.negotiator.charsets();
  }
  return this.negotiator.charsets(charsets2)[0] || false;
};
Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
  var languages2 = languages_;
  if (languages2 && !Array.isArray(languages2)) {
    languages2 = new Array(arguments.length);
    for (var i = 0; i < languages2.length; i++) {
      languages2[i] = arguments[i];
    }
  }
  if (!languages2 || languages2.length === 0) {
    return this.negotiator.languages();
  }
  return this.negotiator.languages(languages2)[0] || false;
};
function extToMime(type3) {
  return type3.indexOf("/") === -1 ? mime$1.lookup(type3) : type3;
}
function validMime(type3) {
  return typeof type3 === "string";
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts = accepts$1;
var deprecate$1 = depd_1("express");
var isIP = require$$0$7.isIP;
var typeis = typeIsExports;
var http$1 = require$$0$b;
var fresh = fresh_1;
var parseRange = rangeParser_1;
var parse$3 = parseurlExports;
var proxyaddr = proxyAddrExports;
var req = Object.create(http$1.IncomingMessage.prototype);
var request = req;
req.get = req.header = function header(name) {
  if (!name) {
    throw new TypeError("name argument is required to req.get");
  }
  if (typeof name !== "string") {
    throw new TypeError("name must be a string to req.get");
  }
  var lc = name.toLowerCase();
  switch (lc) {
    case "referer":
    case "referrer":
      return this.headers.referrer || this.headers.referer;
    default:
      return this.headers[lc];
  }
};
req.accepts = function() {
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
};
req.acceptsEncodings = function() {
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
};
req.acceptsEncoding = deprecate$1.function(
  req.acceptsEncodings,
  "req.acceptsEncoding: Use acceptsEncodings instead"
);
req.acceptsCharsets = function() {
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
};
req.acceptsCharset = deprecate$1.function(
  req.acceptsCharsets,
  "req.acceptsCharset: Use acceptsCharsets instead"
);
req.acceptsLanguages = function() {
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
};
req.acceptsLanguage = deprecate$1.function(
  req.acceptsLanguages,
  "req.acceptsLanguage: Use acceptsLanguages instead"
);
req.range = function range2(size, options2) {
  var range3 = this.get("Range");
  if (!range3) return;
  return parseRange(size, range3, options2);
};
req.param = function param2(name, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query = this.query || {};
  var args = arguments.length === 1 ? "name" : "name, default";
  deprecate$1("req.param(" + args + "): Use req.params, req.body, or req.query instead");
  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
  if (null != body[name]) return body[name];
  if (null != query[name]) return query[name];
  return defaultValue;
};
req.is = function is(types2) {
  var arr = types2;
  if (!Array.isArray(types2)) {
    arr = new Array(arguments.length);
    for (var i = 0; i < arr.length; i++) {
      arr[i] = arguments[i];
    }
  }
  return typeis(this, arr);
};
defineGetter(req, "protocol", function protocol() {
  var proto2 = this.connection.encrypted ? "https" : "http";
  var trust = this.app.get("trust proxy fn");
  if (!trust(this.connection.remoteAddress, 0)) {
    return proto2;
  }
  var header3 = this.get("X-Forwarded-Proto") || proto2;
  var index2 = header3.indexOf(",");
  return index2 !== -1 ? header3.substring(0, index2).trim() : header3.trim();
});
defineGetter(req, "secure", function secure() {
  return this.protocol === "https";
});
defineGetter(req, "ip", function ip() {
  var trust = this.app.get("trust proxy fn");
  return proxyaddr(this, trust);
});
defineGetter(req, "ips", function ips() {
  var trust = this.app.get("trust proxy fn");
  var addrs = proxyaddr.all(this, trust);
  addrs.reverse().pop();
  return addrs;
});
defineGetter(req, "subdomains", function subdomains() {
  var hostname2 = this.hostname;
  if (!hostname2) return [];
  var offset = this.app.get("subdomain offset");
  var subdomains2 = !isIP(hostname2) ? hostname2.split(".").reverse() : [hostname2];
  return subdomains2.slice(offset);
});
defineGetter(req, "path", function path() {
  return parse$3(this).pathname;
});
defineGetter(req, "hostname", function hostname() {
  var trust = this.app.get("trust proxy fn");
  var host3 = this.get("X-Forwarded-Host");
  if (!host3 || !trust(this.connection.remoteAddress, 0)) {
    host3 = this.get("Host");
  } else if (host3.indexOf(",") !== -1) {
    host3 = host3.substring(0, host3.indexOf(",")).trimRight();
  }
  if (!host3) return;
  var offset = host3[0] === "[" ? host3.indexOf("]") + 1 : 0;
  var index2 = host3.indexOf(":", offset);
  return index2 !== -1 ? host3.substring(0, index2) : host3;
});
defineGetter(req, "host", deprecate$1.function(function host() {
  return this.hostname;
}, "req.host: Use req.hostname instead"));
defineGetter(req, "fresh", function() {
  var method2 = this.method;
  var res2 = this.res;
  var status3 = res2.statusCode;
  if ("GET" !== method2 && "HEAD" !== method2) return false;
  if (status3 >= 200 && status3 < 300 || 304 === status3) {
    return fresh(this.headers, {
      "etag": res2.get("ETag"),
      "last-modified": res2.get("Last-Modified")
    });
  }
  return false;
});
defineGetter(req, "stale", function stale() {
  return !this.fresh;
});
defineGetter(req, "xhr", function xhr() {
  var val = this.get("X-Requested-With") || "";
  return val.toLowerCase() === "xmlhttprequest";
});
function defineGetter(obj, name, getter) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}
var cookieSignature = {};
(function(exports$1) {
  var crypto2 = require$$0$6;
  exports$1.sign = function(val, secret) {
    if ("string" !== typeof val) throw new TypeError("Cookie value must be provided as a string.");
    if (null == secret) throw new TypeError("Secret key must be provided.");
    return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
  };
  exports$1.unsign = function(val, secret) {
    if ("string" !== typeof val) throw new TypeError("Signed cookie string must be provided.");
    if (null == secret) throw new TypeError("Secret key must be provided.");
    var str2 = val.slice(0, val.lastIndexOf(".")), mac = exports$1.sign(str2, secret);
    return sha12(mac) == sha12(val) ? str2 : false;
  };
  function sha12(str2) {
    return crypto2.createHash("sha1").update(str2).digest("hex");
  }
})(cookieSignature);
var cookie$1 = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
cookie$1.parse = parse$2;
cookie$1.serialize = serialize$1;
var __toString = Object.prototype.toString;
var __hasOwnProperty = Object.prototype.hasOwnProperty;
var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
function parse$2(str2, opt) {
  if (typeof str2 !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var len = str2.length;
  if (len < 2) return obj;
  var dec = opt && opt.decode || decode;
  var index2 = 0;
  var eqIdx = 0;
  var endIdx = 0;
  do {
    eqIdx = str2.indexOf("=", index2);
    if (eqIdx === -1) break;
    endIdx = str2.indexOf(";", index2);
    if (endIdx === -1) {
      endIdx = len;
    } else if (eqIdx > endIdx) {
      index2 = str2.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var keyStartIdx = startIndex(str2, index2, eqIdx);
    var keyEndIdx = endIndex(str2, eqIdx, keyStartIdx);
    var key = str2.slice(keyStartIdx, keyEndIdx);
    if (!__hasOwnProperty.call(obj, key)) {
      var valStartIdx = startIndex(str2, eqIdx + 1, endIdx);
      var valEndIdx = endIndex(str2, endIdx, valStartIdx);
      if (str2.charCodeAt(valStartIdx) === 34 && str2.charCodeAt(valEndIdx - 1) === 34) {
        valStartIdx++;
        valEndIdx--;
      }
      var val = str2.slice(valStartIdx, valEndIdx);
      obj[key] = tryDecode(val, dec);
    }
    index2 = endIdx + 1;
  } while (index2 < len);
  return obj;
}
function startIndex(str2, index2, max2) {
  do {
    var code = str2.charCodeAt(index2);
    if (code !== 32 && code !== 9) return index2;
  } while (++index2 < max2);
  return max2;
}
function endIndex(str2, index2, min2) {
  while (index2 > min2) {
    var code = str2.charCodeAt(--index2);
    if (code !== 32 && code !== 9) return index2 + 1;
  }
  return min2;
}
function serialize$1(name, val, opt) {
  var enc = opt && opt.encode || encodeURIComponent;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!cookieNameRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (!cookieValueRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str2 = name + "=" + value;
  if (!opt) return str2;
  if (null != opt.maxAge) {
    var maxAge = Math.floor(opt.maxAge);
    if (!isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str2 += "; Max-Age=" + maxAge;
  }
  if (opt.domain) {
    if (!domainValueRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str2 += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!pathValueRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str2 += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str2 += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str2 += "; HttpOnly";
  }
  if (opt.secure) {
    str2 += "; Secure";
  }
  if (opt.partitioned) {
    str2 += "; Partitioned";
  }
  if (opt.priority) {
    var priority2 = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority2) {
      case "low":
        str2 += "; Priority=Low";
        break;
      case "medium":
        str2 += "; Priority=Medium";
        break;
      case "high":
        str2 += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str2 += "; SameSite=Strict";
        break;
      case "lax":
        str2 += "; SameSite=Lax";
        break;
      case "strict":
        str2 += "; SameSite=Strict";
        break;
      case "none":
        str2 += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str2;
}
function decode(str2) {
  return str2.indexOf("%") !== -1 ? decodeURIComponent(str2) : str2;
}
function isDate(val) {
  return __toString.call(val) === "[object Date]";
}
function tryDecode(str2, decode2) {
  try {
    return decode2(str2);
  } catch (e) {
    return str2;
  }
}
var vary$2 = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
vary$2.exports = vary$1;
vary$2.exports.append = append;
var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append(header3, field2) {
  if (typeof header3 !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field2) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field2) ? parse$1(String(field2)) : field2;
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header3 === "*") {
    return header3;
  }
  var val = header3;
  var vals = parse$1(header3.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i] : fields[i];
    }
  }
  return val;
}
function parse$1(header3) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = header3.length; i < len; i++) {
    switch (header3.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list.push(header3.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list.push(header3.substring(start, end));
  return list;
}
function vary$1(res2, field2) {
  if (!res2 || !res2.getHeader || !res2.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res2.getHeader("Vary") || "";
  var header3 = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header3, field2)) {
    res2.setHeader("Vary", val);
  }
}
var varyExports = vary$2.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Buffer$1 = safeBufferExports.Buffer;
var contentDisposition = contentDispositionExports;
var createError = httpErrorsExports;
var deprecate = depd_1("express");
var encodeUrl = encodeurl;
var escapeHtml = escapeHtml_1;
var http = require$$0$b;
var isAbsolute = utils.isAbsolute;
var onFinished = onFinishedExports;
var path$1 = require$$1$2;
var statuses = statuses$3;
var merge = utilsMergeExports;
var sign = cookieSignature.sign;
var normalizeType = utils.normalizeType;
var normalizeTypes = utils.normalizeTypes;
var setCharset = utils.setCharset;
var cookie = cookie$1;
var send2 = sendExports;
var extname = path$1.extname;
var mime = send2.mime;
var resolve2 = path$1.resolve;
var vary = varyExports;
var res = Object.create(http.ServerResponse.prototype);
var response = res;
var charsetRegExp = /;\s*charset\s*=/;
res.status = function status2(code) {
  if ((typeof code === "string" || Math.floor(code) !== code) && code > 99 && code < 1e3) {
    deprecate("res.status(" + JSON.stringify(code) + "): use res.status(" + Math.floor(code) + ") instead");
  }
  this.statusCode = code;
  return this;
};
res.links = function(links) {
  var link = this.get("Link") || "";
  if (link) link += ", ";
  return this.set("Link", link + Object.keys(links).map(function(rel) {
    return "<" + links[rel] + '>; rel="' + rel + '"';
  }).join(", "));
};
res.send = function send3(body) {
  var chunk = body;
  var encoding3;
  var req2 = this.req;
  var type3;
  var app2 = this.app;
  if (arguments.length === 2) {
    if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
      deprecate("res.send(body, status): Use res.status(status).send(body) instead");
      this.statusCode = arguments[1];
    } else {
      deprecate("res.send(status, body): Use res.status(status).send(body) instead");
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }
  if (typeof chunk === "number" && arguments.length === 1) {
    if (!this.get("Content-Type")) {
      this.type("txt");
    }
    deprecate("res.send(status): Use res.sendStatus(status) instead");
    this.statusCode = chunk;
    chunk = statuses.message[chunk];
  }
  switch (typeof chunk) {
    case "string":
      if (!this.get("Content-Type")) {
        this.type("html");
      }
      break;
    case "boolean":
    case "number":
    case "object":
      if (chunk === null) {
        chunk = "";
      } else if (Buffer$1.isBuffer(chunk)) {
        if (!this.get("Content-Type")) {
          this.type("bin");
        }
      } else {
        return this.json(chunk);
      }
      break;
  }
  if (typeof chunk === "string") {
    encoding3 = "utf8";
    type3 = this.get("Content-Type");
    if (typeof type3 === "string") {
      this.set("Content-Type", setCharset(type3, "utf-8"));
    }
  }
  var etagFn = app2.get("etag fn");
  var generateETag = !this.get("ETag") && typeof etagFn === "function";
  var len;
  if (chunk !== void 0) {
    if (Buffer$1.isBuffer(chunk)) {
      len = chunk.length;
    } else if (!generateETag && chunk.length < 1e3) {
      len = Buffer$1.byteLength(chunk, encoding3);
    } else {
      chunk = Buffer$1.from(chunk, encoding3);
      encoding3 = void 0;
      len = chunk.length;
    }
    this.set("Content-Length", len);
  }
  var etag3;
  if (generateETag && len !== void 0) {
    if (etag3 = etagFn(chunk, encoding3)) {
      this.set("ETag", etag3);
    }
  }
  if (req2.fresh) this.statusCode = 304;
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader("Content-Type");
    this.removeHeader("Content-Length");
    this.removeHeader("Transfer-Encoding");
    chunk = "";
  }
  if (this.statusCode === 205) {
    this.set("Content-Length", "0");
    this.removeHeader("Transfer-Encoding");
    chunk = "";
  }
  if (req2.method === "HEAD") {
    this.end();
  } else {
    this.end(chunk, encoding3);
  }
  return this;
};
res.json = function json2(obj) {
  var val = obj;
  if (arguments.length === 2) {
    if (typeof arguments[1] === "number") {
      deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
      this.statusCode = arguments[1];
    } else {
      deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }
  var app2 = this.app;
  var escape2 = app2.get("json escape");
  var replacer = app2.get("json replacer");
  var spaces = app2.get("json spaces");
  var body = stringify(val, replacer, spaces, escape2);
  if (!this.get("Content-Type")) {
    this.set("Content-Type", "application/json");
  }
  return this.send(body);
};
res.jsonp = function jsonp(obj) {
  var val = obj;
  if (arguments.length === 2) {
    if (typeof arguments[1] === "number") {
      deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
      this.statusCode = arguments[1];
    } else {
      deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }
  var app2 = this.app;
  var escape2 = app2.get("json escape");
  var replacer = app2.get("json replacer");
  var spaces = app2.get("json spaces");
  var body = stringify(val, replacer, spaces, escape2);
  var callback = this.req.query[app2.get("jsonp callback name")];
  if (!this.get("Content-Type")) {
    this.set("X-Content-Type-Options", "nosniff");
    this.set("Content-Type", "application/json");
  }
  if (Array.isArray(callback)) {
    callback = callback[0];
  }
  if (typeof callback === "string" && callback.length !== 0) {
    this.set("X-Content-Type-Options", "nosniff");
    this.set("Content-Type", "text/javascript");
    callback = callback.replace(/[^\[\]\w$.]/g, "");
    if (body === void 0) {
      body = "";
    } else if (typeof body === "string") {
      body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
  }
  return this.send(body);
};
res.sendStatus = function sendStatus(statusCode) {
  var body = statuses.message[statusCode] || String(statusCode);
  this.statusCode = statusCode;
  this.type("txt");
  return this.send(body);
};
res.sendFile = function sendFile2(path3, options2, callback) {
  var done = callback;
  var req2 = this.req;
  var res2 = this;
  var next = req2.next;
  var opts = options2 || {};
  if (!path3) {
    throw new TypeError("path argument is required to res.sendFile");
  }
  if (typeof path3 !== "string") {
    throw new TypeError("path must be a string to res.sendFile");
  }
  if (typeof options2 === "function") {
    done = options2;
    opts = {};
  }
  if (!opts.root && !isAbsolute(path3)) {
    throw new TypeError("path must be absolute or specify root to res.sendFile");
  }
  var pathname = encodeURI(path3);
  var file = send2(req2, pathname, opts);
  sendfile(res2, file, opts, function(err) {
    if (done) return done(err);
    if (err && err.code === "EISDIR") return next();
    if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
      next(err);
    }
  });
};
res.sendfile = function(path3, options2, callback) {
  var done = callback;
  var req2 = this.req;
  var res2 = this;
  var next = req2.next;
  var opts = options2 || {};
  if (typeof options2 === "function") {
    done = options2;
    opts = {};
  }
  var file = send2(req2, path3, opts);
  sendfile(res2, file, opts, function(err) {
    if (done) return done(err);
    if (err && err.code === "EISDIR") return next();
    if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
      next(err);
    }
  });
};
res.sendfile = deprecate.function(
  res.sendfile,
  "res.sendfile: Use res.sendFile instead"
);
res.download = function download(path3, filename, options2, callback) {
  var done = callback;
  var name = filename;
  var opts = options2 || null;
  if (typeof filename === "function") {
    done = filename;
    name = null;
    opts = null;
  } else if (typeof options2 === "function") {
    done = options2;
    opts = null;
  }
  if (typeof filename === "object" && (typeof options2 === "function" || options2 === void 0)) {
    name = null;
    opts = filename;
  }
  var headers = {
    "Content-Disposition": contentDisposition(name || path3)
  };
  if (opts && opts.headers) {
    var keys = Object.keys(opts.headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key.toLowerCase() !== "content-disposition") {
        headers[key] = opts.headers[key];
      }
    }
  }
  opts = Object.create(opts);
  opts.headers = headers;
  var fullPath = !opts.root ? resolve2(path3) : path3;
  return this.sendFile(fullPath, opts, done);
};
res.contentType = res.type = function contentType2(type3) {
  var ct = type3.indexOf("/") === -1 ? mime.lookup(type3) : type3;
  return this.set("Content-Type", ct);
};
res.format = function(obj) {
  var req2 = this.req;
  var next = req2.next;
  var keys = Object.keys(obj).filter(function(v) {
    return v !== "default";
  });
  var key = keys.length > 0 ? req2.accepts(keys) : false;
  this.vary("Accept");
  if (key) {
    this.set("Content-Type", normalizeType(key).value);
    obj[key](req2, this, next);
  } else if (obj.default) {
    obj.default(req2, this, next);
  } else {
    next(createError(406, {
      types: normalizeTypes(keys).map(function(o) {
        return o.value;
      })
    }));
  }
  return this;
};
res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }
  this.set("Content-Disposition", contentDisposition(filename));
  return this;
};
res.append = function append2(field2, val) {
  var prev = this.get(field2);
  var value = val;
  if (prev) {
    value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
  }
  return this.set(field2, value);
};
res.set = res.header = function header2(field2, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val) ? val.map(String) : String(val);
    if (field2.toLowerCase() === "content-type") {
      if (Array.isArray(value)) {
        throw new TypeError("Content-Type cannot be set to an Array");
      }
      if (!charsetRegExp.test(value)) {
        var charset3 = mime.charsets.lookup(value.split(";")[0]);
        if (charset3) value += "; charset=" + charset3.toLowerCase();
      }
    }
    this.setHeader(field2, value);
  } else {
    for (var key in field2) {
      this.set(key, field2[key]);
    }
  }
  return this;
};
res.get = function(field2) {
  return this.getHeader(field2);
};
res.clearCookie = function clearCookie(name, options2) {
  if (options2) {
    if (options2.maxAge) {
      deprecate('res.clearCookie: Passing "options.maxAge" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
    }
    if (options2.expires) {
      deprecate('res.clearCookie: Passing "options.expires" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
    }
  }
  var opts = merge({ expires: /* @__PURE__ */ new Date(1), path: "/" }, options2);
  return this.cookie(name, "", opts);
};
res.cookie = function(name, value, options2) {
  var opts = merge({}, options2);
  var secret = this.req.secret;
  var signed = opts.signed;
  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }
  var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
  if (signed) {
    val = "s:" + sign(val, secret);
  }
  if (opts.maxAge != null) {
    var maxAge = opts.maxAge - 0;
    if (!isNaN(maxAge)) {
      opts.expires = new Date(Date.now() + maxAge);
      opts.maxAge = Math.floor(maxAge / 1e3);
    }
  }
  if (opts.path == null) {
    opts.path = "/";
  }
  this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
  return this;
};
res.location = function location(url2) {
  var loc;
  if (url2 === "back") {
    deprecate('res.location("back"): use res.location(req.get("Referrer") || "/") and refer to https://dub.sh/security-redirect for best practices');
    loc = this.req.get("Referrer") || "/";
  } else {
    loc = String(url2);
  }
  return this.set("Location", encodeUrl(loc));
};
res.redirect = function redirect2(url2) {
  var address = url2;
  var body;
  var status3 = 302;
  if (arguments.length === 2) {
    if (typeof arguments[0] === "number") {
      status3 = arguments[0];
      address = arguments[1];
    } else {
      deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
      status3 = arguments[1];
    }
  }
  address = this.location(address).get("Location");
  this.format({
    text: function() {
      body = statuses.message[status3] + ". Redirecting to " + address;
    },
    html: function() {
      var u = escapeHtml(address);
      body = "<p>" + statuses.message[status3] + ". Redirecting to " + u + "</p>";
    },
    default: function() {
      body = "";
    }
  });
  this.statusCode = status3;
  this.set("Content-Length", Buffer$1.byteLength(body));
  if (this.req.method === "HEAD") {
    this.end();
  } else {
    this.end(body);
  }
};
res.vary = function(field2) {
  if (!field2 || Array.isArray(field2) && !field2.length) {
    deprecate("res.vary(): Provide a field name");
    return this;
  }
  vary(this, field2);
  return this;
};
res.render = function render2(view2, options2, callback) {
  var app2 = this.req.app;
  var done = callback;
  var opts = options2 || {};
  var req2 = this.req;
  var self2 = this;
  if (typeof options2 === "function") {
    done = options2;
    opts = {};
  }
  opts._locals = self2.locals;
  done = done || function(err, str2) {
    if (err) return req2.next(err);
    self2.send(str2);
  };
  app2.render(view2, opts, done);
};
function sendfile(res2, file, options2, callback) {
  var done = false;
  var streaming;
  function onaborted() {
    if (done) return;
    done = true;
    var err = new Error("Request aborted");
    err.code = "ECONNABORTED";
    callback(err);
  }
  function ondirectory() {
    if (done) return;
    done = true;
    var err = new Error("EISDIR, read");
    err.code = "EISDIR";
    callback(err);
  }
  function onerror(err) {
    if (done) return;
    done = true;
    callback(err);
  }
  function onend() {
    if (done) return;
    done = true;
    callback();
  }
  function onfile() {
    streaming = false;
  }
  function onfinish(err) {
    if (err && err.code === "ECONNRESET") return onaborted();
    if (err) return onerror(err);
    if (done) return;
    setImmediate(function() {
      if (streaming !== false && !done) {
        onaborted();
        return;
      }
      if (done) return;
      done = true;
      callback();
    });
  }
  function onstream() {
    streaming = true;
  }
  file.on("directory", ondirectory);
  file.on("end", onend);
  file.on("error", onerror);
  file.on("file", onfile);
  file.on("stream", onstream);
  onFinished(res2, onfinish);
  if (options2.headers) {
    file.on("headers", function headers(res3) {
      var obj = options2.headers;
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        res3.setHeader(k, obj[k]);
      }
    });
  }
  file.pipe(res2);
}
function stringify(value, replacer, spaces, escape2) {
  var json3 = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
  if (escape2 && typeof json3 === "string") {
    json3 = json3.replace(/[<>&]/g, function(c) {
      switch (c.charCodeAt(0)) {
        case 60:
          return "\\u003c";
        case 62:
          return "\\u003e";
        case 38:
          return "\\u0026";
        default:
          return c;
      }
    });
  }
  return json3;
}
var serveStatic = { exports: {} };
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredServeStatic;
function requireServeStatic() {
  if (hasRequiredServeStatic) return serveStatic.exports;
  hasRequiredServeStatic = 1;
  var encodeUrl2 = encodeurl;
  var escapeHtml2 = escapeHtml_1;
  var parseUrl2 = parseurlExports;
  var resolve3 = require$$1$2.resolve;
  var send4 = sendExports;
  var url2 = require$$0$a;
  serveStatic.exports = serveStatic$1;
  serveStatic.exports.mime = send4.mime;
  function serveStatic$1(root3, options2) {
    if (!root3) {
      throw new TypeError("root path required");
    }
    if (typeof root3 !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options2 || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect3 = opts.redirect !== false;
    var setHeaders2 = opts.setHeaders;
    if (setHeaders2 && typeof setHeaders2 !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve3(root3);
    var onDirectory = redirect3 ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic2(req2, res2, next) {
      if (req2.method !== "GET" && req2.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res2.statusCode = 405;
        res2.setHeader("Allow", "GET, HEAD");
        res2.setHeader("Content-Length", "0");
        res2.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl2.original(req2);
      var path3 = parseUrl2(req2).pathname;
      if (path3 === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path3 = "";
      }
      var stream2 = send4(req2, path3, opts);
      stream2.on("directory", onDirectory);
      if (setHeaders2) {
        stream2.on("headers", setHeaders2);
      }
      if (fallthrough) {
        stream2.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream2.on("error", function error2(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream2.pipe(res2);
    };
  }
  function collapseLeadingSlashes2(str2) {
    for (var i = 0; i < str2.length; i++) {
      if (str2.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str2.substr(i) : str2;
  }
  function createHtmlDocument2(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect3(res2) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl2.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes2(originalUrl.pathname + "/");
      var loc = encodeUrl2(url2.format(originalUrl));
      var doc = createHtmlDocument2("Redirecting", "Redirecting to " + escapeHtml2(loc));
      res2.statusCode = 301;
      res2.setHeader("Content-Type", "text/html; charset=UTF-8");
      res2.setHeader("Content-Length", Buffer.byteLength(doc));
      res2.setHeader("Content-Security-Policy", "default-src 'none'");
      res2.setHeader("X-Content-Type-Options", "nosniff");
      res2.setHeader("Location", loc);
      res2.end(doc);
    };
  }
  return serveStatic.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module, exports$1) {
  var bodyParser2 = bodyParserExports;
  var EventEmitter2 = require$$0$9.EventEmitter;
  var mixin2 = mergeDescriptors;
  var proto2 = applicationExports;
  var Route2 = route;
  var Router = routerExports;
  var req2 = request;
  var res2 = response;
  exports$1 = module.exports = createApplication;
  function createApplication() {
    var app2 = function(req3, res3, next) {
      app2.handle(req3, res3, next);
    };
    mixin2(app2, EventEmitter2.prototype, false);
    mixin2(app2, proto2, false);
    app2.request = Object.create(req2, {
      app: { configurable: true, enumerable: true, writable: true, value: app2 }
    });
    app2.response = Object.create(res2, {
      app: { configurable: true, enumerable: true, writable: true, value: app2 }
    });
    app2.init();
    return app2;
  }
  exports$1.application = proto2;
  exports$1.request = req2;
  exports$1.response = res2;
  exports$1.Route = Route2;
  exports$1.Router = Router;
  exports$1.json = bodyParser2.json;
  exports$1.query = requireQuery();
  exports$1.raw = bodyParser2.raw;
  exports$1.static = requireServeStatic();
  exports$1.text = bodyParser2.text;
  exports$1.urlencoded = bodyParser2.urlencoded;
  var removedMiddlewares = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache"
  ];
  removedMiddlewares.forEach(function(name) {
    Object.defineProperty(exports$1, name, {
      get: function() {
        throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
      },
      configurable: true
    });
  });
})(express$2, express$2.exports);
var expressExports = express$2.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var express = expressExports;
const express$1 = /* @__PURE__ */ getDefaultExportFromCjs(express);
var main = { exports: {} };
const version$2 = "16.6.1";
const require$$4 = {
  version: version$2
};
const fs$1 = require$$0$8;
const path2 = require$$1$2;
const os = require$$0$4;
const crypto$3 = require$$0$6;
const packageJson = require$$4;
const version$1 = packageJson.version;
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function parse(src2) {
  const obj = {};
  let lines = src2.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match2;
  while ((match2 = LINE.exec(lines)) != null) {
    const key = match2[1];
    let value = match2[2] || "";
    value = value.trim();
    const maybeQuote = value[0];
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, "\n");
      value = value.replace(/\\r/g, "\r");
    }
    obj[key] = value;
  }
  return obj;
}
function _parseVault(options2) {
  options2 = options2 || {};
  const vaultPath = _vaultPath(options2);
  options2.path = vaultPath;
  const result = DotenvModule.configDotenv(options2);
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err.code = "MISSING_DATA";
    throw err;
  }
  const keys = _dotenvKey(options2).split(",");
  const length = keys.length;
  let decrypted;
  for (let i = 0; i < length; i++) {
    try {
      const key = keys[i].trim();
      const attrs = _instructions(result, key);
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error2) {
      if (i + 1 >= length) {
        throw error2;
      }
    }
  }
  return DotenvModule.parse(decrypted);
}
function _warn(message) {
  console.log(`[dotenv@${version$1}][WARN] ${message}`);
}
function _debug(message) {
  console.log(`[dotenv@${version$1}][DEBUG] ${message}`);
}
function _log(message) {
  console.log(`[dotenv@${version$1}] ${message}`);
}
function _dotenvKey(options2) {
  if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
    return options2.DOTENV_KEY;
  }
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY;
  }
  return "";
}
function _instructions(result, dotenvKey) {
  let uri2;
  try {
    uri2 = new URL(dotenvKey);
  } catch (error2) {
    if (error2.code === "ERR_INVALID_URL") {
      const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    throw error2;
  }
  const key = uri2.password;
  if (!key) {
    const err = new Error("INVALID_DOTENV_KEY: Missing key part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environment = uri2.searchParams.get("environment");
  if (!environment) {
    const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey];
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
    throw err;
  }
  return { ciphertext, key };
}
function _vaultPath(options2) {
  let possibleVaultPath = null;
  if (options2 && options2.path && options2.path.length > 0) {
    if (Array.isArray(options2.path)) {
      for (const filepath of options2.path) {
        if (fs$1.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
    }
  } else {
    possibleVaultPath = path2.resolve(process.cwd(), ".env.vault");
  }
  if (fs$1.existsSync(possibleVaultPath)) {
    return possibleVaultPath;
  }
  return null;
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path2.join(os.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options2) {
  const debug2 = Boolean(options2 && options2.debug);
  const quiet = options2 && "quiet" in options2 ? options2.quiet : true;
  if (debug2 || !quiet) {
    _log("Loading env from encrypted .env.vault");
  }
  const parsed = DotenvModule._parseVault(options2);
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsed, options2);
  return { parsed };
}
function configDotenv(options2) {
  const dotenvPath = path2.resolve(process.cwd(), ".env");
  let encoding3 = "utf8";
  const debug2 = Boolean(options2 && options2.debug);
  const quiet = options2 && "quiet" in options2 ? options2.quiet : true;
  if (options2 && options2.encoding) {
    encoding3 = options2.encoding;
  } else {
    if (debug2) {
      _debug("No encoding is specified. UTF-8 is used by default");
    }
  }
  let optionPaths = [dotenvPath];
  if (options2 && options2.path) {
    if (!Array.isArray(options2.path)) {
      optionPaths = [_resolveHome(options2.path)];
    } else {
      optionPaths = [];
      for (const filepath of options2.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }
  let lastError;
  const parsedAll = {};
  for (const path22 of optionPaths) {
    try {
      const parsed = DotenvModule.parse(fs$1.readFileSync(path22, { encoding: encoding3 }));
      DotenvModule.populate(parsedAll, parsed, options2);
    } catch (e) {
      if (debug2) {
        _debug(`Failed to load ${path22} ${e.message}`);
      }
      lastError = e;
    }
  }
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsedAll, options2);
  if (debug2 || !quiet) {
    const keysCount = Object.keys(parsedAll).length;
    const shortPaths = [];
    for (const filePath of optionPaths) {
      try {
        const relative2 = path2.relative(process.cwd(), filePath);
        shortPaths.push(relative2);
      } catch (e) {
        if (debug2) {
          _debug(`Failed to load ${filePath} ${e.message}`);
        }
        lastError = e;
      }
    }
    _log(`injecting env (${keysCount}) from ${shortPaths.join(",")}`);
  }
  if (lastError) {
    return { parsed: parsedAll, error: lastError };
  } else {
    return { parsed: parsedAll };
  }
}
function config(options2) {
  if (_dotenvKey(options2).length === 0) {
    return DotenvModule.configDotenv(options2);
  }
  const vaultPath = _vaultPath(options2);
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
    return DotenvModule.configDotenv(options2);
  }
  return DotenvModule._configVault(options2);
}
function decrypt(encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), "hex");
  let ciphertext = Buffer.from(encrypted, "base64");
  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    const aesgcm = crypto$3.createDecipheriv("aes-256-gcm", key, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
  } catch (error2) {
    const isRange = error2 instanceof RangeError;
    const invalidKeyLength = error2.message === "Invalid key length";
    const decryptionFailed = error2.message === "Unsupported state or unable to authenticate data";
    if (isRange || invalidKeyLength) {
      const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    } else if (decryptionFailed) {
      const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      err.code = "DECRYPTION_FAILED";
      throw err;
    } else {
      throw error2;
    }
  }
}
function populate(processEnv, parsed, options2 = {}) {
  const debug2 = Boolean(options2 && options2.debug);
  const override = Boolean(options2 && options2.override);
  if (typeof parsed !== "object") {
    const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    err.code = "OBJECT_REQUIRED";
    throw err;
  }
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
      }
      if (debug2) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key] = parsed[key];
    }
  }
}
const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
};
main.exports.configDotenv = DotenvModule.configDotenv;
main.exports._configVault = DotenvModule._configVault;
main.exports._parseVault = DotenvModule._parseVault;
main.exports.config = DotenvModule.config;
main.exports.decrypt = DotenvModule.decrypt;
main.exports.parse = DotenvModule.parse;
main.exports.populate = DotenvModule.populate;
main.exports = DotenvModule;
var mainExports = main.exports;
const options = {};
if (process.env.DOTENV_CONFIG_ENCODING != null) {
  options.encoding = process.env.DOTENV_CONFIG_ENCODING;
}
if (process.env.DOTENV_CONFIG_PATH != null) {
  options.path = process.env.DOTENV_CONFIG_PATH;
}
if (process.env.DOTENV_CONFIG_QUIET != null) {
  options.quiet = process.env.DOTENV_CONFIG_QUIET;
}
if (process.env.DOTENV_CONFIG_DEBUG != null) {
  options.debug = process.env.DOTENV_CONFIG_DEBUG;
}
if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
  options.override = process.env.DOTENV_CONFIG_OVERRIDE;
}
if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
  options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
}
var envOptions = options;
const re = /^dotenv_config_(encoding|path|quiet|debug|override|DOTENV_KEY)=(.+)$/;
var cliOptions = function optionMatcher(args) {
  const options2 = args.reduce(function(acc, cur) {
    const matches = cur.match(re);
    if (matches) {
      acc[matches[1]] = matches[2];
    }
    return acc;
  }, {});
  if (!("quiet" in options2)) {
    options2.quiet = "true";
  }
  return options2;
};
(function() {
  mainExports.config(
    Object.assign(
      {},
      envOptions,
      cliOptions(process.argv)
    )
  );
})();
const defaultPort = PLAYGROUND_SERVER_PORT;
const __filename$1 = fileURLToPath(import.meta.url);
const __dirname$2 = dirname$1(__filename$1);
const STATIC_PATH = join$3(__dirname$2, "..", "..", "static");
const errorHandler = (err, req2, res2, next) => {
  console.error(err);
  const errorMessage = err instanceof Error ? err.message : "Internal server error";
  res2.status(500).json({
    error: errorMessage
  });
};
class PlaygroundServer {
  constructor(agent, staticPath = STATIC_PATH, id) {
    this._initialized = false;
    this.currentTaskId = null;
    this._app = express$1();
    this.tmpDir = getTmpDir();
    this.staticPath = staticPath;
    this.taskExecutionDumps = {};
    this.id = id || uuid();
    if (typeof agent === "function") {
      this.agentFactory = agent;
      this.agent = null;
    } else {
      this.agent = agent;
      this.agentFactory = null;
    }
  }
  /**
   * Get the Express app instance for custom configuration
   *
   * IMPORTANT: Add middleware (like CORS) BEFORE calling launch()
   * The routes are initialized when launch() is called, so middleware
   * added after launch() will not affect the API routes.
   *
   * @example
   * ```typescript
   * import cors from 'cors';
   *
   * const server = new PlaygroundServer(agent);
   *
   * // Add CORS middleware before launch
   * server.app.use(cors({
   *   origin: true,
   *   credentials: true,
   *   methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']
   * }));
   *
   * await server.launch();
   * ```
   */
  get app() {
    return this._app;
  }
  /**
   * Initialize Express app with all routes and middleware
   * Called automatically by launch() if not already initialized
   */
  initializeApp() {
    if (this._initialized) return;
    this._app.use(express$1.json({ limit: "50mb" }));
    this._app.use(
      (req2, _res, next) => {
        const { context: context2 } = req2.body || {};
        if (context2 && "updateContext" in this.agent.interface && typeof this.agent.interface.updateContext === "function") {
          this.agent.interface.updateContext(context2);
          console.log("Context updated by PlaygroundServer middleware");
        }
        next();
      }
    );
    this.setupRoutes();
    this.setupStaticRoutes();
    this._app.use(errorHandler);
    this._initialized = true;
  }
  filePathForUuid(uuid2) {
    if (!/^[a-zA-Z0-9-]+$/.test(uuid2)) {
      throw new Error("Invalid uuid format");
    }
    const filePath = join$3(this.tmpDir, `${uuid2}.json`);
    const resolvedPath = resolve$3(filePath);
    const resolvedTmpDir = resolve$3(this.tmpDir);
    if (!resolvedPath.startsWith(resolvedTmpDir)) {
      throw new Error("Invalid path");
    }
    return filePath;
  }
  saveContextFile(uuid2, context2) {
    const tmpFile = this.filePathForUuid(uuid2);
    console.log(`save context file: ${tmpFile}`);
    writeFileSync(tmpFile, context2);
    return tmpFile;
  }
  /**
   * Recreate agent instance (for cancellation)
   */
  async recreateAgent() {
    if (!this.agentFactory) {
      throw new Error(
        "Cannot recreate agent: factory function not provided. Attempting to destroy existing agent only."
      );
    }
    console.log("Recreating agent to cancel current task...");
    try {
      if (this.agent && typeof this.agent.destroy === "function") {
        await this.agent.destroy();
      }
    } catch (error2) {
      console.warn("Failed to destroy old agent:", error2);
    }
    try {
      this.agent = await this.agentFactory();
      console.log("Agent recreated successfully");
    } catch (error2) {
      console.error("Failed to recreate agent:", error2);
      throw error2;
    }
  }
  /**
   * Setup all API routes
   */
  setupRoutes() {
    this._app.get("/status", async (req2, res2) => {
      res2.send({
        status: "ok",
        id: this.id
      });
    });
    this._app.get("/context/:uuid", async (req2, res2) => {
      const { uuid: uuid2 } = req2.params;
      let contextFile;
      try {
        contextFile = this.filePathForUuid(uuid2);
      } catch {
        return res2.status(400).json({
          error: "Invalid uuid format"
        });
      }
      if (!existsSync(contextFile)) {
        return res2.status(404).json({
          error: "Context not found"
        });
      }
      const context2 = readFileSync(contextFile, "utf8");
      res2.json({
        context: context2
      });
    });
    this._app.get(
      "/task-progress/:requestId",
      async (req2, res2) => {
        const { requestId } = req2.params;
        const executionDump = this.taskExecutionDumps[requestId] || null;
        res2.json({
          executionDump
        });
      }
    );
    this._app.post("/action-space", async (req2, res2) => {
      try {
        let actionSpace = [];
        actionSpace = this.agent.interface.actionSpace();
        const processedActionSpace = actionSpace.map((action) => {
          if (action && typeof action === "object" && "paramSchema" in action) {
            const typedAction = action;
            if (typedAction.paramSchema && typeof typedAction.paramSchema === "object") {
              let processedSchema = null;
              try {
                if (typedAction.paramSchema.shape && typeof typedAction.paramSchema.shape === "object") {
                  processedSchema = {
                    type: "ZodObject",
                    shape: typedAction.paramSchema.shape
                  };
                }
              } catch (e) {
                const actionName = "name" in typedAction && typeof typedAction.name === "string" ? typedAction.name : "unknown";
                console.warn(
                  "Failed to process paramSchema for action:",
                  actionName,
                  e
                );
              }
              return {
                ...typedAction,
                paramSchema: processedSchema
              };
            }
          }
          return action;
        });
        res2.json(processedActionSpace);
      } catch (error2) {
        const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
        console.error("Failed to get action space:", error2);
        res2.status(500).json({
          error: errorMessage
        });
      }
    });
    this._app.post(
      "/playground-with-context",
      async (req2, res2) => {
        const context2 = req2.body.context;
        if (!context2) {
          return res2.status(400).json({
            error: "context is required"
          });
        }
        const requestId = uuid();
        this.saveContextFile(requestId, context2);
        return res2.json({
          location: `/playground/${requestId}`,
          uuid: requestId
        });
      }
    );
    this._app.post("/execute", async (req2, res2) => {
      var _a3;
      const {
        type: type3,
        prompt,
        params,
        requestId,
        deepThink,
        screenshotIncluded,
        domIncluded,
        deviceOptions
      } = req2.body;
      if (!type3) {
        return res2.status(400).json({
          error: "type is required"
        });
      }
      if (this.agentFactory) {
        console.log("Destroying old agent before execution...");
        try {
          if (this.agent && typeof this.agent.destroy === "function") {
            await this.agent.destroy();
          }
        } catch (error2) {
          console.warn("Failed to destroy old agent:", error2);
        }
        console.log("Creating new agent with latest config...");
        try {
          this.agent = await this.agentFactory();
          console.log("Agent created successfully");
        } catch (error2) {
          console.error("Failed to create agent:", error2);
          return res2.status(500).json({
            error: `Failed to create agent: ${error2 instanceof Error ? error2.message : "Unknown error"}`
          });
        }
      }
      if (deviceOptions && this.agent.interface && "options" in this.agent.interface) {
        this.agent.interface.options = {
          ...this.agent.interface.options || {},
          ...deviceOptions
        };
      }
      if (this.currentTaskId) {
        return res2.status(409).json({
          error: "Another task is already running",
          currentTaskId: this.currentTaskId
        });
      }
      if (requestId) {
        this.currentTaskId = requestId;
        this.taskExecutionDumps[requestId] = null;
        this.agent.onDumpUpdate = (_dump, executionDump) => {
          if (executionDump) {
            this.taskExecutionDumps[requestId] = executionDump;
          }
        };
      }
      const response2 = {
        result: null,
        dump: null,
        error: null,
        reportHTML: null,
        requestId
      };
      const startTime = Date.now();
      try {
        const actionSpace = this.agent.interface.actionSpace();
        const value = {
          type: type3,
          prompt,
          params
        };
        response2.result = await executeAction(
          this.agent,
          type3,
          actionSpace,
          value,
          {
            deepThink,
            screenshotIncluded,
            domIncluded,
            deviceOptions
          }
        );
      } catch (error2) {
        response2.error = formatErrorMessage(error2);
      }
      try {
        const dumpString = this.agent.dumpDataString({
          inlineScreenshots: true
        });
        if (dumpString) {
          const groupedDump = GroupedActionDump.fromSerializedString(dumpString);
          response2.dump = ((_a3 = groupedDump.executions) == null ? void 0 : _a3[0]) || null;
        } else {
          response2.dump = null;
        }
        response2.reportHTML = this.agent.reportHTMLString({ inlineScreenshots: true }) || null;
        this.agent.writeOutActionDumps();
        this.agent.resetDump();
      } catch (error2) {
        const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
        console.error(
          `write out dump failed: requestId: ${requestId}, ${errorMessage}`
        );
      }
      res2.send(response2);
      const timeCost = Date.now() - startTime;
      if (response2.error) {
        console.error(
          `handle request failed after ${timeCost}ms: requestId: ${requestId}, ${response2.error}`
        );
      } else {
        console.log(
          `handle request done after ${timeCost}ms: requestId: ${requestId}`
        );
      }
      if (requestId) {
        delete this.taskExecutionDumps[requestId];
        if (this.currentTaskId === requestId) {
          this.currentTaskId = null;
        }
      }
    });
    this._app.post(
      "/cancel/:requestId",
      async (req2, res2) => {
        var _a3, _b, _c, _d, _e;
        const { requestId } = req2.params;
        if (!requestId) {
          return res2.status(400).json({
            error: "requestId is required"
          });
        }
        try {
          if (this.currentTaskId !== requestId) {
            return res2.json({
              status: "not_found",
              message: "Task not found or already completed"
            });
          }
          console.log(`Cancelling task: ${requestId}`);
          let dump2 = null;
          let reportHTML = null;
          try {
            const dumpString = (_b = (_a3 = this.agent).dumpDataString) == null ? void 0 : _b.call(_a3, {
              inlineScreenshots: true
            });
            if (dumpString) {
              const groupedDump = GroupedActionDump.fromSerializedString(dumpString);
              dump2 = ((_c = groupedDump.executions) == null ? void 0 : _c[0]) || null;
            }
            reportHTML = ((_e = (_d = this.agent).reportHTMLString) == null ? void 0 : _e.call(_d, { inlineScreenshots: true })) || null;
          } catch (error2) {
            console.warn("Failed to get execution data before cancel:", error2);
          }
          await this.recreateAgent();
          delete this.taskExecutionDumps[requestId];
          this.currentTaskId = null;
          res2.json({
            status: "cancelled",
            message: "Task cancelled successfully",
            dump: dump2,
            reportHTML
          });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          console.error(`Failed to cancel: ${errorMessage}`);
          res2.status(500).json({
            error: `Failed to cancel: ${errorMessage}`
          });
        }
      }
    );
    this._app.get("/screenshot", async (_req, res2) => {
      try {
        if (typeof this.agent.interface.screenshotBase64 !== "function") {
          return res2.status(500).json({
            error: "Screenshot method not available on current interface"
          });
        }
        const base64Screenshot = await this.agent.interface.screenshotBase64();
        res2.json({
          screenshot: base64Screenshot,
          timestamp: Date.now()
        });
      } catch (error2) {
        const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
        console.error(`Failed to take screenshot: ${errorMessage}`);
        res2.status(500).json({
          error: `Failed to take screenshot: ${errorMessage}`
        });
      }
    });
    this._app.get("/interface-info", async (_req, res2) => {
      var _a3, _b;
      try {
        const type3 = this.agent.interface.interfaceType || "Unknown";
        const description = ((_b = (_a3 = this.agent.interface).describe) == null ? void 0 : _b.call(_a3)) || void 0;
        res2.json({
          type: type3,
          description
        });
      } catch (error2) {
        const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
        console.error(`Failed to get interface info: ${errorMessage}`);
        res2.status(500).json({
          error: `Failed to get interface info: ${errorMessage}`
        });
      }
    });
    this.app.post("/config", async (req2, res2) => {
      const { aiConfig } = req2.body;
      if (!aiConfig || typeof aiConfig !== "object") {
        return res2.status(400).json({
          error: "aiConfig is required and must be an object"
        });
      }
      if (Object.keys(aiConfig).length === 0) {
        return res2.json({
          status: "ok",
          message: "AI config not changed due to empty object"
        });
      }
      try {
        overrideAIConfig(aiConfig);
      } catch (error2) {
        const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
        console.error(`Failed to update AI config: ${errorMessage}`);
        return res2.status(500).json({
          error: `Failed to update AI config: ${errorMessage}`
        });
      }
      try {
        globalModelConfigManager.getModelConfig("default");
      } catch (error2) {
        const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
        console.error(`AI config validation failed: ${errorMessage}`);
        return res2.status(400).json({
          error: errorMessage
        });
      }
      return res2.json({
        status: "ok",
        message: "AI config updated. Agent will be recreated on next execution."
      });
    });
  }
  /**
   * Setup static file serving routes
   */
  setupStaticRoutes() {
    this._app.get("/", (_req, res2) => {
      this.serveHtmlWithPorts(res2);
    });
    this._app.get("/index.html", (_req, res2) => {
      this.serveHtmlWithPorts(res2);
    });
    this._app.use(express$1.static(this.staticPath));
    this._app.get("*", (_req, res2) => {
      this.serveHtmlWithPorts(res2);
    });
  }
  /**
   * Serve HTML with injected port configuration
   */
  serveHtmlWithPorts(res2) {
    try {
      const htmlPath = join$3(this.staticPath, "index.html");
      let html = readFileSync(htmlPath, "utf8");
      const scrcpyPort = global.scrcpyServerPort || this.port + 1;
      const configScript = `
        <script>
          window.SCRCPY_PORT = ${scrcpyPort};
        <\/script>
      `;
      html = html.replace("</head>", `${configScript}</head>`);
      res2.setHeader("Content-Type", "text/html");
      res2.send(html);
    } catch (error2) {
      console.error("Error serving HTML with ports:", error2);
      res2.status(500).send("Internal Server Error");
    }
  }
  /**
   * Launch the server on specified port
   */
  async launch(port) {
    if (this.agentFactory) {
      console.log("Initializing agent from factory function...");
      this.agent = await this.agentFactory();
      console.log("Agent initialized successfully");
    }
    this.initializeApp();
    this.port = port || defaultPort;
    return new Promise((resolve22) => {
      const serverPort = this.port;
      this.server = this._app.listen(serverPort, () => {
        resolve22(this);
      });
    });
  }
  /**
   * Close the server and clean up resources
   */
  async close() {
    return new Promise((resolve22, reject) => {
      if (this.server) {
        try {
          this.agent.destroy();
        } catch (error2) {
          console.warn("Failed to destroy agent:", error2);
        }
        this.taskExecutionDumps = {};
        this.server.close((error2) => {
          if (error2) {
            reject(error2);
          } else {
            this.server = void 0;
            resolve22();
          }
        });
      } else {
        resolve22();
      }
    });
  }
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
const IPC_DEVICE_LIST = "device:list";
const IPC_TASK_LOG = "task:log";
const IPC_START_TASK = "task:start";
const IPC_STOP_TASK = "task:stop";
const IPC_DEVICE_FRAME = "device:frame";
const IPC_TASK_STATE = "task:state";
const IPC_DEVICE_SELECT = "device:select";
const IPC_DEVICE_REFRESH = "device:refresh";
const IPC_DEVICE_DISCONNECT = "device:disconnect";
const IPC_REPORT_UPDATE = "report:update";
const IPC_REPORT_LIST = "report:list";
const IPC_REPORT_SELECT = "report:select";
const IPC_REPORT_DELETE = "report:delete";
const IPC_WINDOW_MINIMIZE = "window:minimize";
const IPC_WINDOW_TOGGLE_MAXIMIZE = "window:toggle-maximize";
const IPC_WINDOW_CLOSE = "window:close";
const IPC_WINDOW_STATE = "window:state";
var dist = {};
var adb = {};
var client$1 = {};
var connection$1 = {};
var parser$1 = {};
var promise = { exports: {} };
var es5 = { exports: {} };
var hasRequiredEs5;
function requireEs5() {
  if (hasRequiredEs5) return es5.exports;
  hasRequiredEs5 = 1;
  var isES5 = /* @__PURE__ */ function() {
    return this === void 0;
  }();
  if (isES5) {
    es5.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    var has2 = {}.hasOwnProperty;
    var str2 = {}.toString;
    var proto2 = {}.constructor.prototype;
    var ObjectKeys = function(o) {
      var ret = [];
      for (var key in o) {
        if (has2.call(o, key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    var ObjectGetDescriptor = function(o, key) {
      return { value: o[key] };
    };
    var ObjectDefineProperty = function(o, key, desc) {
      o[key] = desc.value;
      return o;
    };
    var ObjectFreeze = function(obj) {
      return obj;
    };
    var ObjectGetPrototypeOf = function(obj) {
      try {
        return Object(obj).constructor.prototype;
      } catch (e) {
        return proto2;
      }
    };
    var ArrayIsArray = function(obj) {
      try {
        return str2.call(obj) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    es5.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  return es5.exports;
}
var util$3;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$3;
  hasRequiredUtil = 1;
  var es52 = requireEs5();
  var canEvaluate = typeof navigator == "undefined";
  var errorObj = { e: {} };
  var tryCatchTarget;
  var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : commonjsGlobal !== void 0 ? commonjsGlobal : null;
  function tryCatcher() {
    try {
      var target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  var inherits2 = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
  };
  function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  }
  function isObject2(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
  }
  function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;
    return new Error(safeToString(maybeError));
  }
  function withAppended(target, appendee) {
    var len = target.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
      ret2[i] = target[i];
    }
    ret2[i] = appendee;
    return ret2;
  }
  function getDataPropertyOrDefault(obj2, key, defaultValue) {
    if (es52.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj2, key);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
    }
  }
  function notEnumerableProp(obj2, name, value) {
    if (isPrimitive(obj2)) return obj2;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es52.defineProperty(obj2, name, descriptor);
    return obj2;
  }
  function thrower(r) {
    throw r;
  }
  var inheritedDataKeys = function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0; i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es52.isES5) {
      var getKeys = Object.getOwnPropertyNames;
      return function(obj2) {
        var ret2 = [];
        var visitedKeys = /* @__PURE__ */ Object.create(null);
        while (obj2 != null && !isExcludedProto(obj2)) {
          var keys;
          try {
            keys = getKeys(obj2);
          } catch (e) {
            return ret2;
          }
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (visitedKeys[key]) continue;
            visitedKeys[key] = true;
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key);
            }
          }
          obj2 = es52.getPrototypeOf(obj2);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj2) {
        if (isExcludedProto(obj2)) return [];
        var ret2 = [];
        enumeration: for (var key in obj2) {
          if (hasProp.call(obj2, key)) {
            ret2.push(key);
          } else {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (hasProp.call(excludedPrototypes[i], key)) {
                continue enumeration;
              }
            }
            ret2.push(key);
          }
        }
        return ret2;
      };
    }
  }();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  function isClass(fn) {
    try {
      if (typeof fn === "function") {
        var keys = es52.names(fn.prototype);
        var hasMethods = es52.isES5 && keys.length > 1;
        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es52.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function toFastProperties(obj) {
    function FakeConstructor() {
    }
    FakeConstructor.prototype = obj;
    var receiver = new FakeConstructor();
    function ic() {
      return typeof receiver.foo;
    }
    ic();
    ic();
    return obj;
  }
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  function isIdentifier(str2) {
    return rident.test(str2);
  }
  function filledRange(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0; i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  }
  function safeToString(obj2) {
    try {
      return obj2 + "";
    } catch (e) {
      return "[no string representation]";
    }
  }
  function isError(obj2) {
    return obj2 instanceof Error || obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
  }
  function markAsOriginatingFromRejection(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {
    }
  }
  function originatesFromRejection(e) {
    if (e == null) return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  }
  function canAttachTrace(obj2) {
    return isError(obj2) && es52.propertyIsWritable(obj2, "stack");
  }
  var ensureErrorObject = function() {
    if (!("stack" in new Error())) {
      return function(value) {
        if (canAttachTrace(value)) return value;
        try {
          throw new Error(safeToString(value));
        } catch (err) {
          return err;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value)) return value;
        return new Error(safeToString(value));
      };
    }
  }();
  function classString(obj2) {
    return {}.toString.call(obj2);
  }
  function copyDescriptors(from, to, filter2) {
    var keys = es52.names(from);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (filter2(key)) {
        try {
          es52.defineProperty(to, key, es52.getDescriptor(from, key));
        } catch (ignore) {
        }
      }
    }
  }
  var asArray = function(v) {
    if (es52.isArray(v)) {
      return v;
    }
    return null;
  };
  if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
      return Array.from(v);
    } : function(v) {
      var ret2 = [];
      var it = v[Symbol.iterator]();
      var itResult;
      while (!(itResult = it.next()).done) {
        ret2.push(itResult.value);
      }
      return ret2;
    };
    asArray = function(v) {
      if (es52.isArray(v)) {
        return v;
      } else if (v != null && typeof v[Symbol.iterator] === "function") {
        return ArrayFrom(v);
      }
      return null;
    };
  }
  var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
  var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
  function env(key) {
    return hasEnvVariables ? process.env[key] : void 0;
  }
  function getNativePromise() {
    if (typeof Promise === "function") {
      try {
        var promise2 = new Promise(function() {
        });
        if (classString(promise2) === "[object Promise]") {
          return Promise;
        }
      } catch (e) {
      }
    }
  }
  var reflectHandler;
  function contextBind(ctx, cb) {
    if (ctx === null || typeof cb !== "function" || cb === reflectHandler) {
      return cb;
    }
    if (ctx.domain !== null) {
      cb = ctx.domain.bind(cb);
    }
    var async2 = ctx.async;
    if (async2 !== null) {
      var old2 = cb;
      cb = function() {
        var $_len = arguments.length + 2;
        var args = new Array($_len);
        for (var $_i = 2; $_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i - 2];
        }
        args[0] = old2;
        args[1] = this;
        return async2.runInAsyncScope.apply(async2, args);
      };
    }
    return cb;
  }
  var ret = {
    setReflectHandler: function(fn) {
      reflectHandler = fn;
    },
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es52.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject: isObject2,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits: inherits2,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    contextBind
  };
  ret.isRecentNode = ret.isNode && function() {
    var version2;
    if (process.versions && process.versions.node) {
      version2 = process.versions.node.split(".").map(Number);
    } else if (process.version) {
      version2 = process.version.split(".").map(Number);
    }
    return version2[0] === 0 && version2[1] > 10 || version2[0] > 0;
  }();
  ret.nodeSupportsAsyncResource = ret.isNode && function() {
    var supportsAsync = false;
    try {
      var res2 = require("async_hooks").AsyncResource;
      supportsAsync = typeof res2.prototype.runInAsyncScope === "function";
    } catch (e) {
      supportsAsync = false;
    }
    return supportsAsync;
  }();
  if (ret.isNode) ret.toFastProperties(process);
  try {
    throw new Error();
  } catch (e) {
    ret.lastLineError = e;
  }
  util$3 = ret;
  return util$3;
}
var async = { exports: {} };
var schedule_1;
var hasRequiredSchedule;
function requireSchedule() {
  if (hasRequiredSchedule) return schedule_1;
  hasRequiredSchedule = 1;
  var util2 = requireUtil();
  var schedule;
  var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
  };
  var NativePromise = util2.getNativePromise();
  if (util2.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = commonjsGlobal.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util2.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(commonjsGlobal, fn);
    } : function(fn) {
      ProcessNextTick.call(process, fn);
    };
  } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
      nativePromise.then(fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova)) && "classList" in document.documentElement) {
    schedule = function() {
      var div = document.createElement("div");
      var opts = { attributes: true };
      var toggleScheduled = false;
      var div2 = document.createElement("div");
      var o2 = new MutationObserver(function() {
        div.classList.toggle("foo");
        toggleScheduled = false;
      });
      o2.observe(div2, opts);
      var scheduleToggle = function() {
        if (toggleScheduled) return;
        toggleScheduled = true;
        div2.classList.toggle("foo");
      };
      return function schedule2(fn) {
        var o = new MutationObserver(function() {
          o.disconnect();
          fn();
        });
        o.observe(div, opts);
        scheduleToggle();
      };
    }();
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  schedule_1 = schedule;
  return schedule_1;
}
var queue$1;
var hasRequiredQueue$1;
function requireQueue$1() {
  if (hasRequiredQueue$1) return queue$1;
  hasRequiredQueue$1 = 1;
  function arrayMove(src2, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
      dst[j + dstIndex] = src2[j + srcIndex];
      src2[j + srcIndex] = void 0;
    }
  }
  function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  }
  Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
  };
  Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = void 0;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
  };
  Queue.prototype.length = function() {
    return this._length;
  };
  Queue.prototype._checkCapacity = function(size) {
    if (this._capacity < size) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  queue$1 = Queue;
  return queue$1;
}
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async.exports;
  hasRequiredAsync = 1;
  var firstLineError;
  try {
    throw new Error();
  } catch (e) {
    firstLineError = e;
  }
  var schedule = requireSchedule();
  var Queue = requireQueue$1();
  function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule;
  }
  Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
  };
  Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  };
  Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  };
  Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
      process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
      process.exit(2);
    } else {
      this.throwLater(e);
    }
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else try {
      this._schedule(function() {
        fn(arg);
      });
    } catch (e) {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    }
  };
  function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncSettlePromises(promise2) {
    this._normalQueue._pushOne(promise2);
    this._queueTick();
  }
  Async.prototype.invokeLater = AsyncInvokeLater;
  Async.prototype.invoke = AsyncInvoke;
  Async.prototype.settlePromises = AsyncSettlePromises;
  function _drainQueue(queue2) {
    while (queue2.length() > 0) {
      _drainQueueStep(queue2);
    }
  }
  function _drainQueueStep(queue2) {
    var fn = queue2.shift();
    if (typeof fn !== "function") {
      fn._settlePromises();
    } else {
      var receiver = queue2.shift();
      var arg = queue2.shift();
      fn.call(receiver, arg);
    }
  }
  Async.prototype._drainQueues = function() {
    _drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    _drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  async.exports = Async;
  async.exports.firstLineError = firstLineError;
  return async.exports;
}
var errors;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  var es52 = requireEs5();
  var Objectfreeze = es52.freeze;
  var util2 = requireUtil();
  var inherits2 = util2.inherits;
  var notEnumerableProp = util2.notEnumerableProp;
  function subError(nameProperty, defaultMessage2) {
    function SubError(message) {
      if (!(this instanceof SubError)) return new SubError(message);
      notEnumerableProp(
        this,
        "message",
        typeof message === "string" ? message : defaultMessage2
      );
      notEnumerableProp(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits2(SubError, Error);
    return SubError;
  }
  var _TypeError, _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError2 = subError("TimeoutError", "timeout error");
  var AggregateError2 = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods2 = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
  for (var i = 0; i < methods2.length; ++i) {
    if (typeof Array.prototype[methods2[i]] === "function") {
      AggregateError2.prototype[methods2[i]] = Array.prototype[methods2[i]];
    }
  }
  es52.defineProperty(AggregateError2.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError2.prototype["isOperational"] = true;
  var level = 0;
  AggregateError2.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0; i2 < this.length; ++i2) {
      var str2 = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str2.split("\n");
      for (var j = 0; j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str2 = lines.join("\n");
      ret += str2 + "\n";
    }
    level--;
    return ret;
  };
  function OperationalError(message) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
      notEnumerableProp(this, "message", message.message);
      notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  inherits2(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError: TimeoutError2,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError: AggregateError2
    });
    es52.defineProperty(Error, "__BluebirdErrorTypes__", {
      value: errorTypes,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  errors = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
  return errors;
}
var thenables;
var hasRequiredThenables;
function requireThenables() {
  if (hasRequiredThenables) return thenables;
  hasRequiredThenables = 1;
  thenables = function(Promise2, INTERNAL) {
    var util2 = requireUtil();
    var errorObj = util2.errorObj;
    var isObject2 = util2.isObject;
    function tryConvertToPromise(obj, context2) {
      if (isObject2(obj)) {
        if (obj instanceof Promise2) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
          if (context2) context2._pushContext();
          var ret = Promise2.reject(then.e);
          if (context2) context2._popContext();
          return ret;
        } else if (typeof then === "function") {
          if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise2(INTERNAL);
            obj._then(
              ret._fulfill,
              ret._reject,
              void 0,
              ret,
              null
            );
            return ret;
          }
          return doThenable(obj, then, context2);
        }
      }
      return obj;
    }
    function doGetThen(obj) {
      return obj.then;
    }
    function getThen(obj) {
      try {
        return doGetThen(obj);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
      try {
        return hasProp.call(obj, "_promise0");
      } catch (e) {
        return false;
      }
    }
    function doThenable(x, then, context2) {
      var promise2 = new Promise2(INTERNAL);
      var ret = promise2;
      if (context2) context2._pushContext();
      promise2._captureStackTrace();
      if (context2) context2._popContext();
      var synchronous = true;
      var result = util2.tryCatch(then).call(x, resolve3, reject);
      synchronous = false;
      if (promise2 && result === errorObj) {
        promise2._rejectCallback(result.e, true, true);
        promise2 = null;
      }
      function resolve3(value) {
        if (!promise2) return;
        promise2._resolveCallback(value);
        promise2 = null;
      }
      function reject(reason) {
        if (!promise2) return;
        promise2._rejectCallback(reason, synchronous, true);
        promise2 = null;
      }
      return ret;
    }
    return tryConvertToPromise;
  };
  return thenables;
}
var promise_array;
var hasRequiredPromise_array;
function requirePromise_array() {
  if (hasRequiredPromise_array) return promise_array;
  hasRequiredPromise_array = 1;
  promise_array = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util2 = requireUtil();
    util2.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
        case -6:
          return /* @__PURE__ */ new Map();
      }
    }
    function PromiseArray(values) {
      var promise2 = this._promise = new Promise2(INTERNAL);
      if (values instanceof Promise2) {
        promise2._propagateFrom(values, 3);
        values.suppressUnhandledRejections();
      }
      promise2._setOnCancel(this);
      this._values = values;
      this._length = 0;
      this._totalResolved = 0;
      this._init(void 0, -2);
    }
    util2.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init2(_, resolveValueIfEmpty) {
      var values = tryConvertToPromise(this._values, this._promise);
      if (values instanceof Promise2) {
        values = values._target();
        var bitField = values._bitField;
        this._values = values;
        if ((bitField & 50397184) === 0) {
          this._promise._setAsyncGuaranteed();
          return values._then(
            init2,
            this._reject,
            void 0,
            this,
            resolveValueIfEmpty
          );
        } else if ((bitField & 33554432) !== 0) {
          values = values._value();
        } else if ((bitField & 16777216) !== 0) {
          return this._reject(values._reason());
        } else {
          return this._cancel();
        }
      }
      values = util2.asArray(values);
      if (values === null) {
        var err = apiRejection(
          "expecting an array or an iterable object but got " + util2.classString(values)
        ).reason();
        this._promise._rejectCallback(err, false);
        return;
      }
      if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      this._iterate(values);
    };
    PromiseArray.prototype._iterate = function(values) {
      var len = this.getActualLength(values.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var result = this._promise;
      var isResolved = false;
      var bitField = null;
      for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          bitField = maybePromise._bitField;
        } else {
          bitField = null;
        }
        if (isResolved) {
          if (bitField !== null) {
            maybePromise.suppressUnhandledRejections();
          }
        } else if (bitField !== null) {
          if ((bitField & 50397184) === 0) {
            maybePromise._proxy(this, i);
            this._values[i] = maybePromise;
          } else if ((bitField & 33554432) !== 0) {
            isResolved = this._promiseFulfilled(maybePromise._value(), i);
          } else if ((bitField & 16777216) !== 0) {
            isResolved = this._promiseRejected(maybePromise._reason(), i);
          } else {
            isResolved = this._promiseCancelled(i);
          }
        } else {
          isResolved = this._promiseFulfilled(maybePromise, i);
        }
      }
      if (!isResolved) result._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
      if (this._isResolved() || !this._promise._isCancellable()) return;
      this._values = null;
      this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index2) {
      this._values[index2] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
      this._cancel();
      return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
      this._totalResolved++;
      this._reject(reason);
      return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
      if (this._isResolved()) return;
      var values = this._values;
      this._cancel();
      if (values instanceof Promise2) {
        values.cancel();
      } else {
        for (var i = 0; i < values.length; ++i) {
          if (values[i] instanceof Promise2) {
            values[i].cancel();
          }
        }
      }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
  return promise_array;
}
var context;
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context;
  hasRequiredContext = 1;
  context = function(Promise2) {
    var longStackTraces = false;
    var contextStack = [];
    Promise2.prototype._promiseCreated = function() {
    };
    Promise2.prototype._pushContext = function() {
    };
    Promise2.prototype._popContext = function() {
      return null;
    };
    Promise2._peekContext = Promise2.prototype._peekContext = function() {
    };
    function Context() {
      this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function() {
      if (this._trace !== void 0) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
      }
    };
    Context.prototype._popContext = function() {
      if (this._trace !== void 0) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
      }
      return null;
    };
    function createContext() {
      if (longStackTraces) return new Context();
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return void 0;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function() {
    };
    Context.activateLongStackTraces = function() {
      var Promise_pushContext = Promise2.prototype._pushContext;
      var Promise_popContext = Promise2.prototype._popContext;
      var Promise_PeekContext = Promise2._peekContext;
      var Promise_peekContext = Promise2.prototype._peekContext;
      var Promise_promiseCreated = Promise2.prototype._promiseCreated;
      Context.deactivateLongStackTraces = function() {
        Promise2.prototype._pushContext = Promise_pushContext;
        Promise2.prototype._popContext = Promise_popContext;
        Promise2._peekContext = Promise_PeekContext;
        Promise2.prototype._peekContext = Promise_peekContext;
        Promise2.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
      };
      longStackTraces = true;
      Promise2.prototype._pushContext = Context.prototype._pushContext;
      Promise2.prototype._popContext = Context.prototype._popContext;
      Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
      Promise2.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
      };
    };
    return Context;
  };
  return context;
}
var debuggability;
var hasRequiredDebuggability;
function requireDebuggability() {
  if (hasRequiredDebuggability) return debuggability;
  hasRequiredDebuggability = 1;
  debuggability = function(Promise2, Context, enableAsyncHooks, disableAsyncHooks) {
    var async2 = Promise2._async;
    var Warning = requireErrors().Warning;
    var util2 = requireUtil();
    var es52 = requireEs5();
    var canAttachTrace = util2.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util2.env("BLUEBIRD_DEBUG") != 0 && (util2.env("BLUEBIRD_DEBUG") || util2.env("NODE_ENV") === "development"));
    var warnings = !!(util2.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util2.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util2.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util2.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util2.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util2.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    var deferUnhandledRejectionCheck;
    (function() {
      var promises = [];
      function unhandledRejectionCheck() {
        for (var i = 0; i < promises.length; ++i) {
          promises[i]._notifyUnhandledRejection();
        }
        unhandledRejectionClear();
      }
      function unhandledRejectionClear() {
        promises.length = 0;
      }
      deferUnhandledRejectionCheck = function(promise2) {
        promises.push(promise2);
        setTimeout(unhandledRejectionCheck, 1);
      };
      es52.defineProperty(Promise2, "_unhandledRejectionCheck", {
        value: unhandledRejectionCheck
      });
      es52.defineProperty(Promise2, "_unhandledRejectionClear", {
        value: unhandledRejectionClear
      });
    })();
    Promise2.prototype.suppressUnhandledRejections = function() {
      var target = this._target();
      target._bitField = target._bitField & -1048577 | 524288;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 524288) !== 0) return;
      this._setRejectionIsUnhandled();
      deferUnhandledRejectionCheck(this);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      fireRejectionEvent(
        "rejectionHandled",
        unhandledRejectionHandled,
        void 0,
        this
      );
    };
    Promise2.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent(
          "unhandledRejection",
          possiblyUnhandledRejection,
          reason,
          this
        );
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & -262145;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & -1048577;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise2) {
      return warn(message, shouldUseOwnTrace, promise2 || this);
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var context2 = Promise2._getContext();
      possiblyUnhandledRejection = util2.contextBind(context2, fn);
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var context2 = Promise2._getContext();
      unhandledRejectionHandled = util2.contextBind(context2, fn);
    };
    var disableLongStackTraces = function() {
    };
    Promise2.longStackTraces = function() {
      if (async2.haveItemsQueued() && !config2.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
      }
      if (!config2.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
        var Promise_dereferenceTrace = Promise2.prototype._dereferenceTrace;
        config2.longStackTraces = true;
        disableLongStackTraces = function() {
          if (async2.haveItemsQueued() && !config2.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
          }
          Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
          Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
          Promise2.prototype._dereferenceTrace = Promise_dereferenceTrace;
          Context.deactivateLongStackTraces();
          config2.longStackTraces = false;
        };
        Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Promise2.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
        Context.activateLongStackTraces();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return config2.longStackTraces && longStackTracesIsSupported();
    };
    var legacyHandlers = {
      unhandledrejection: {
        before: function() {
          var ret = util2.global.onunhandledrejection;
          util2.global.onunhandledrejection = null;
          return ret;
        },
        after: function(fn) {
          util2.global.onunhandledrejection = fn;
        }
      },
      rejectionhandled: {
        before: function() {
          var ret = util2.global.onrejectionhandled;
          util2.global.onrejectionhandled = null;
          return ret;
        },
        after: function(fn) {
          util2.global.onrejectionhandled = fn;
        }
      }
    };
    var fireDomEvent = function() {
      var dispatch2 = function(legacy, e) {
        if (legacy) {
          var fn;
          try {
            fn = legacy.before();
            return !util2.global.dispatchEvent(e);
          } finally {
            legacy.after(fn);
          }
        } else {
          return !util2.global.dispatchEvent(e);
        }
      };
      try {
        if (typeof CustomEvent === "function") {
          var event = new CustomEvent("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            name = name.toLowerCase();
            var eventData = {
              detail: event2,
              cancelable: true
            };
            var domEvent = new CustomEvent(name, eventData);
            es52.defineProperty(
              domEvent,
              "promise",
              { value: event2.promise }
            );
            es52.defineProperty(
              domEvent,
              "reason",
              { value: event2.reason }
            );
            return dispatch2(legacyHandlers[name], domEvent);
          };
        } else if (typeof Event === "function") {
          var event = new Event("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            name = name.toLowerCase();
            var domEvent = new Event(name, {
              cancelable: true
            });
            domEvent.detail = event2;
            es52.defineProperty(domEvent, "promise", { value: event2.promise });
            es52.defineProperty(domEvent, "reason", { value: event2.reason });
            return dispatch2(legacyHandlers[name], domEvent);
          };
        } else {
          var event = document.createEvent("CustomEvent");
          event.initCustomEvent("testingtheevent", false, true, {});
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            name = name.toLowerCase();
            var domEvent = document.createEvent("CustomEvent");
            domEvent.initCustomEvent(
              name,
              false,
              true,
              event2
            );
            return dispatch2(legacyHandlers[name], domEvent);
          };
        }
      } catch (e) {
      }
      return function() {
        return false;
      };
    }();
    var fireGlobalEvent = function() {
      if (util2.isNode) {
        return function() {
          return process.emit.apply(process, arguments);
        };
      } else {
        if (!util2.global) {
          return function() {
            return false;
          };
        }
        return function(name) {
          var methodName = "on" + name.toLowerCase();
          var method2 = util2.global[methodName];
          if (!method2) return false;
          method2.apply(util2.global, [].slice.call(arguments, 1));
          return true;
        };
      }
    }();
    function generatePromiseLifecycleEventObject(name, promise2) {
      return { promise: promise2 };
    }
    var eventToObjectGenerator = {
      promiseCreated: generatePromiseLifecycleEventObject,
      promiseFulfilled: generatePromiseLifecycleEventObject,
      promiseRejected: generatePromiseLifecycleEventObject,
      promiseResolved: generatePromiseLifecycleEventObject,
      promiseCancelled: generatePromiseLifecycleEventObject,
      promiseChained: function(name, promise2, child) {
        return { promise: promise2, child };
      },
      warning: function(name, warning) {
        return { warning };
      },
      unhandledRejection: function(name, reason, promise2) {
        return { reason, promise: promise2 };
      },
      rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name) {
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
      } catch (e) {
        async2.throwLater(e);
        globalEventFired = true;
      }
      var domEventFired = false;
      try {
        domEventFired = fireDomEvent(
          name,
          eventToObjectGenerator[name].apply(null, arguments)
        );
      } catch (e) {
        async2.throwLater(e);
        domEventFired = true;
      }
      return domEventFired || globalEventFired;
    };
    Promise2.config = function(opts) {
      opts = Object(opts);
      if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
          Promise2.longStackTraces();
        } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
          disableLongStackTraces();
        }
      }
      if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config2.warnings = !!warningsOption;
        wForgottenReturn = config2.warnings;
        if (util2.isObject(warningsOption)) {
          if ("wForgottenReturn" in warningsOption) {
            wForgottenReturn = !!warningsOption.wForgottenReturn;
          }
        }
      }
      if ("cancellation" in opts && opts.cancellation && !config2.cancellation) {
        if (async2.haveItemsQueued()) {
          throw new Error(
            "cannot enable cancellation after promises are in use"
          );
        }
        Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
        Promise2.prototype._propagateFrom = cancellationPropagateFrom;
        Promise2.prototype._onCancel = cancellationOnCancel;
        Promise2.prototype._setOnCancel = cancellationSetOnCancel;
        Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
        Promise2.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config2.cancellation = true;
      }
      if ("monitoring" in opts) {
        if (opts.monitoring && !config2.monitoring) {
          config2.monitoring = true;
          Promise2.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config2.monitoring) {
          config2.monitoring = false;
          Promise2.prototype._fireEvent = defaultFireEvent;
        }
      }
      if ("asyncHooks" in opts && util2.nodeSupportsAsyncResource) {
        var prev = config2.asyncHooks;
        var cur = !!opts.asyncHooks;
        if (prev !== cur) {
          config2.asyncHooks = cur;
          if (cur) {
            enableAsyncHooks();
          } else {
            disableAsyncHooks();
          }
        }
      }
      return Promise2;
    };
    function defaultFireEvent() {
      return false;
    }
    Promise2.prototype._fireEvent = defaultFireEvent;
    Promise2.prototype._execute = function(executor, resolve3, reject) {
      try {
        executor(resolve3, reject);
      } catch (e) {
        return e;
      }
    };
    Promise2.prototype._onCancel = function() {
    };
    Promise2.prototype._setOnCancel = function(handler) {
    };
    Promise2.prototype._attachCancellationCallback = function(onCancel) {
    };
    Promise2.prototype._captureStackTrace = function() {
    };
    Promise2.prototype._attachExtraTrace = function() {
    };
    Promise2.prototype._dereferenceTrace = function() {
    };
    Promise2.prototype._clearCancellationData = function() {
    };
    Promise2.prototype._propagateFrom = function(parent, flags) {
    };
    function cancellationExecute(executor, resolve3, reject) {
      var promise2 = this;
      try {
        executor(resolve3, reject, function(onCancel) {
          if (typeof onCancel !== "function") {
            throw new TypeError("onCancel must be a function, got: " + util2.toString(onCancel));
          }
          promise2._attachCancellationCallback(onCancel);
        });
      } catch (e) {
        return e;
      }
    }
    function cancellationAttachCancellationCallback(onCancel) {
      if (!this._isCancellable()) return this;
      var previousOnCancel = this._onCancel();
      if (previousOnCancel !== void 0) {
        if (util2.isArray(previousOnCancel)) {
          previousOnCancel.push(onCancel);
        } else {
          this._setOnCancel([previousOnCancel, onCancel]);
        }
      } else {
        this._setOnCancel(onCancel);
      }
    }
    function cancellationOnCancel() {
      return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
      this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
      this._cancellationParent = void 0;
      this._onCancelField = void 0;
    }
    function cancellationPropagateFrom(parent, flags) {
      if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === void 0) {
          branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
      }
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    function bindingPropagateFrom(parent, flags) {
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
      var ret = this._boundTo;
      if (ret !== void 0) {
        if (ret instanceof Promise2) {
          if (ret.isFulfilled()) {
            return ret.value();
          } else {
            return void 0;
          }
        }
      }
      return ret;
    }
    function longStackTracesCaptureStackTrace() {
      this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error2, ignoreSelf) {
      if (canAttachTrace(error2)) {
        var trace = this._trace;
        if (trace !== void 0) {
          if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== void 0) {
          trace.attachExtraTrace(error2);
        } else if (!error2.__stackCleaned__) {
          var parsed = parseStackAndMessage(error2);
          util2.notEnumerableProp(
            error2,
            "stack",
            parsed.message + "\n" + parsed.stack.join("\n")
          );
          util2.notEnumerableProp(error2, "__stackCleaned__", true);
        }
      }
    }
    function longStackTracesDereferenceTrace() {
      this._trace = void 0;
    }
    function checkForgottenReturns(returnValue, promiseCreated, name, promise2, parent) {
      if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
        if (parent !== void 0 && parent._returnedNonUndefined()) return;
        if ((promise2._bitField & 65535) === 0) return;
        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
          var traceLines = promiseCreated._trace.stack.split("\n");
          var stack = cleanStack(traceLines);
          for (var i = stack.length - 1; i >= 0; --i) {
            var line = stack[i];
            if (!nodeFramePattern.test(line)) {
              var lineMatches = line.match(parseLinePattern);
              if (lineMatches) {
                handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
              }
              break;
            }
          }
          if (stack.length > 0) {
            var firstUserLine = stack[0];
            for (var i = 0; i < traceLines.length; ++i) {
              if (traceLines[i] === firstUserLine) {
                if (i > 0) {
                  creatorLine = "\n" + traceLines[i - 1];
                }
                break;
              }
            }
          }
        }
        var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
        promise2._warn(msg, true, promiseCreated);
      }
    }
    function deprecated(name, replacement) {
      var message = name + " is deprecated and will be removed in a future version.";
      if (replacement) message += " Use " + replacement + " instead.";
      return warn(message);
    }
    function warn(message, shouldUseOwnTrace, promise2) {
      if (!config2.warnings) return;
      var warning = new Warning(message);
      var ctx;
      if (shouldUseOwnTrace) {
        promise2._attachExtraTrace(warning);
      } else if (config2.longStackTraces && (ctx = Promise2._peekContext())) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
      }
      if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
      }
    }
    function reconstructStack(message, stacks) {
      for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
      }
      return message + "\n" + stacks.join("\n");
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1; j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint; j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret = [];
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret.push(line);
        }
      }
      return ret;
    }
    function stackFramesAsArray(error2) {
      var stack = error2.stack.replace(/\s+$/g, "").split("\n");
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0 && error2.name != "SyntaxError") {
        stack = stack.slice(i);
      }
      return stack;
    }
    function parseStackAndMessage(error2) {
      var stack = error2.stack;
      var message = error2.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error2) : ["    (No stack trace)"];
      return {
        message,
        stack: error2.name == "SyntaxError" ? stack : cleanStack(stack)
      };
    }
    function formatAndLogError(error2, title, isSoft) {
      if (typeof console !== "undefined") {
        var message;
        if (util2.isObject(error2)) {
          var stack = error2.stack;
          message = title + formatStack(stack, error2);
        } else {
          message = title + String(error2);
        }
        if (typeof printWarning === "function") {
          printWarning(message, isSoft);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message);
        }
      }
    }
    function fireRejectionEvent(name, localHandler, reason, promise2) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name === "rejectionHandled") {
            localHandler(promise2);
          } else {
            localHandler(reason, promise2);
          }
        }
      } catch (e) {
        async2.throwLater(e);
      }
      if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise2) && !localEventFired) {
          formatAndLogError(reason, "Unhandled rejection ");
        }
      } else {
        activeFireEvent(name, promise2);
      }
    }
    function formatNonError(obj) {
      var str2;
      if (typeof obj === "function") {
        str2 = "[function " + (obj.name || "anonymous") + "]";
      } else {
        str2 = obj && typeof obj.toString === "function" ? obj.toString() : util2.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str2)) {
          try {
            var newStr = JSON.stringify(obj);
            str2 = newStr;
          } catch (e) {
          }
        }
        if (str2.length === 0) {
          str2 = "(empty array)";
        }
      }
      return "(<" + snip(str2) + ">, no stack trace)";
    }
    function snip(str2) {
      var maxChars = 41;
      if (str2.length < maxChars) {
        return str2;
      }
      return str2.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
      return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches = line.match(parseLineInfoRegex);
      if (matches) {
        return {
          fileName: matches[1],
          line: parseInt(matches[2], 10)
        };
      }
    }
    function setBounds(firstLineError, lastLineError) {
      if (!longStackTracesIsSupported()) return;
      var firstStackLines = (firstLineError.stack || "").split("\n");
      var lastStackLines = (lastLineError.stack || "").split("\n");
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
          firstFileName = result.fileName;
          firstIndex = result.line;
          break;
        }
      }
      for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
          lastFileName = result.fileName;
          lastIndex = result.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    }
    function CapturedTrace(parent) {
      this._parent = parent;
      this._promisesCreated = 0;
      var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32) this.uncycle();
    }
    util2.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2) return;
      var nodes = [];
      var stackToIndex = {};
      for (var i = 0, node2 = this; node2 !== void 0; ++i) {
        nodes.push(node2);
        node2 = node2._parent;
      }
      length = this._length = i;
      for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === void 0) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index2 = stackToIndex[currentStack];
        if (index2 !== void 0 && index2 !== i) {
          if (index2 > 0) {
            nodes[index2 - 1]._parent = void 0;
            nodes[index2 - 1]._length = 1;
          }
          nodes[i]._parent = void 0;
          nodes[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
          if (index2 < length - 1) {
            cycleEdgeNode._parent = nodes[index2 + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = void 0;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2; j >= 0; --j) {
            nodes[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error2) {
      if (error2.__stackCleaned__) return;
      this.uncycle();
      var parsed = parseStackAndMessage(error2);
      var message = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== void 0) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util2.notEnumerableProp(error2, "stack", reconstructStack(message, stacks));
      util2.notEnumerableProp(error2, "__stackCleaned__", true);
    };
    var captureStackTrace = function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error2) {
        if (typeof stack === "string") return stack;
        if (error2.name !== void 0 && error2.message !== void 0) {
          return error2.toString();
        }
        return formatNonError(error2);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
          Error.stackTraceLimit += 6;
          captureStackTrace2(receiver, ignoreUntil);
          Error.stackTraceLimit -= 6;
        };
      }
      var err = new Error();
      if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace3(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error();
      } catch (e) {
        hasStackAfterThrow = "stack" in e;
      }
      if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace3(o) {
          Error.stackTraceLimit += 6;
          try {
            throw new Error();
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit -= 6;
        };
      }
      formatStack = function(stack, error2) {
        if (typeof stack === "string") return stack;
        if ((typeof error2 === "object" || typeof error2 === "function") && error2.name !== void 0 && error2.message !== void 0) {
          return error2.toString();
        }
        return formatNonError(error2);
      };
      return null;
    }();
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      printWarning = function(message) {
        console.warn(message);
      };
      if (util2.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
          var color = isSoft ? "\x1B[33m" : "\x1B[31m";
          console.warn(color + message + "\x1B[0m\n");
        };
      } else if (!util2.isNode && typeof new Error().stack === "string") {
        printWarning = function(message, isSoft) {
          console.warn(
            "%c" + message,
            isSoft ? "color: darkorange" : "color: red"
          );
        };
      }
    }
    var config2 = {
      warnings,
      longStackTraces: false,
      cancellation: false,
      monitoring: false,
      asyncHooks: false
    };
    if (longStackTraces) Promise2.longStackTraces();
    return {
      asyncHooks: function() {
        return config2.asyncHooks;
      },
      longStackTraces: function() {
        return config2.longStackTraces;
      },
      warnings: function() {
        return config2.warnings;
      },
      cancellation: function() {
        return config2.cancellation;
      },
      monitoring: function() {
        return config2.monitoring;
      },
      propagateFromFunction: function() {
        return propagateFromFunction;
      },
      boundValueFunction: function() {
        return boundValueFunction;
      },
      checkForgottenReturns,
      setBounds,
      warn,
      deprecated,
      CapturedTrace,
      fireDomEvent,
      fireGlobalEvent
    };
  };
  return debuggability;
}
var catch_filter;
var hasRequiredCatch_filter;
function requireCatch_filter() {
  if (hasRequiredCatch_filter) return catch_filter;
  hasRequiredCatch_filter = 1;
  catch_filter = function(NEXT_FILTER) {
    var util2 = requireUtil();
    var getKeys = requireEs5().keys;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function catchFilter(instances, cb, promise2) {
      return function(e) {
        var boundTo = promise2._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
          var item = instances[i];
          if (item === Error || item != null && item.prototype instanceof Error) {
            if (e instanceof item) {
              return tryCatch(cb).call(boundTo, e);
            }
          } else if (typeof item === "function") {
            var matchesPredicate = tryCatch(item).call(boundTo, e);
            if (matchesPredicate === errorObj) {
              return matchesPredicate;
            } else if (matchesPredicate) {
              return tryCatch(cb).call(boundTo, e);
            }
          } else if (util2.isObject(e)) {
            var keys = getKeys(item);
            for (var j = 0; j < keys.length; ++j) {
              var key = keys[j];
              if (item[key] != e[key]) {
                continue predicateLoop;
              }
            }
            return tryCatch(cb).call(boundTo, e);
          }
        }
        return NEXT_FILTER;
      };
    }
    return catchFilter;
  };
  return catch_filter;
}
var _finally;
var hasRequired_finally;
function require_finally() {
  if (hasRequired_finally) return _finally;
  hasRequired_finally = 1;
  _finally = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
    var util2 = requireUtil();
    var CancellationError = Promise2.CancellationError;
    var errorObj = util2.errorObj;
    var catchFilter = requireCatch_filter()(NEXT_FILTER);
    function PassThroughHandlerContext(promise2, type3, handler) {
      this.promise = promise2;
      this.type = type3;
      this.handler = handler;
      this.called = false;
      this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler2) {
      this.finallyHandler = finallyHandler2;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
      checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
      if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
          ctx.cancelPromise._reject(reason);
        } else {
          ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
      }
      return false;
    }
    function succeed() {
      return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
      if (checkCancel(this, reason)) return;
      errorObj.e = reason;
      return errorObj;
    }
    function finallyHandler(reasonOrValue) {
      var promise2 = this.promise;
      var handler = this.handler;
      if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler() ? handler.call(promise2._boundValue()) : handler.call(promise2._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) {
          return ret;
        } else if (ret !== void 0) {
          promise2._setReturnedNonUndefined();
          var maybePromise = tryConvertToPromise(ret, promise2);
          if (maybePromise instanceof Promise2) {
            if (this.cancelPromise != null) {
              if (maybePromise._isCancelled()) {
                var reason = new CancellationError("late cancellation observer");
                promise2._attachExtraTrace(reason);
                errorObj.e = reason;
                return errorObj;
              } else if (maybePromise.isPending()) {
                maybePromise._attachCancellationCallback(
                  new FinallyHandlerCancelReaction(this)
                );
              }
            }
            return maybePromise._then(
              succeed,
              fail,
              void 0,
              this,
              void 0
            );
          }
        }
      }
      if (promise2.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
      } else {
        checkCancel(this);
        return reasonOrValue;
      }
    }
    Promise2.prototype._passThrough = function(handler, type3, success, fail2) {
      if (typeof handler !== "function") return this.then();
      return this._then(
        success,
        fail2,
        void 0,
        new PassThroughHandlerContext(this, type3, handler),
        void 0
      );
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
      return this._passThrough(
        handler,
        0,
        finallyHandler,
        finallyHandler
      );
    };
    Promise2.prototype.tap = function(handler) {
      return this._passThrough(handler, 1, finallyHandler);
    };
    Promise2.prototype.tapCatch = function(handlerOrPredicate) {
      var len = arguments.length;
      if (len === 1) {
        return this._passThrough(
          handlerOrPredicate,
          1,
          void 0,
          finallyHandler
        );
      } else {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0; i < len - 1; ++i) {
          var item = arguments[i];
          if (util2.isObject(item)) {
            catchInstances[j++] = item;
          } else {
            return Promise2.reject(new TypeError(
              "tapCatch statement predicate: expecting an object but got " + util2.classString(item)
            ));
          }
        }
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(
          catchFilter(catchInstances, handler, this),
          1,
          void 0,
          finallyHandler
        );
      }
    };
    return PassThroughHandlerContext;
  };
  return _finally;
}
var nodeback;
var hasRequiredNodeback;
function requireNodeback() {
  if (hasRequiredNodeback) return nodeback;
  hasRequiredNodeback = 1;
  var util2 = requireUtil();
  var maybeWrapAsError = util2.maybeWrapAsError;
  var errors2 = requireErrors();
  var OperationalError = errors2.OperationalError;
  var es52 = requireEs5();
  function isUntypedError(obj) {
    return obj instanceof Error && es52.getPrototypeOf(obj) === Error.prototype;
  }
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
      ret = new OperationalError(obj);
      ret.name = obj.name;
      ret.message = obj.message;
      ret.stack = obj.stack;
      var keys = es52.keys(obj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!rErrorKey.test(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    util2.markAsOriginatingFromRejection(obj);
    return obj;
  }
  function nodebackForPromise(promise2, multiArgs) {
    return function(err, value) {
      if (promise2 === null) return;
      if (err) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
        promise2._attachExtraTrace(wrapped);
        promise2._reject(wrapped);
      } else if (!multiArgs) {
        promise2._fulfill(value);
      } else {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        promise2._fulfill(args);
      }
      promise2 = null;
    };
  }
  nodeback = nodebackForPromise;
  return nodeback;
}
var method;
var hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod) return method;
  hasRequiredMethod = 1;
  method = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug2) {
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError("expecting a function but got " + util2.classString(fn));
      }
      return function() {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug2.checkForgottenReturns(
          value,
          promiseCreated,
          "Promise.method",
          ret
        );
        ret._resolveFromSyncValue(value);
        return ret;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._pushContext();
      var value;
      if (arguments.length > 1) {
        debug2.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util2.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
      } else {
        value = tryCatch(fn)();
      }
      var promiseCreated = ret._popContext();
      debug2.checkForgottenReturns(
        value,
        promiseCreated,
        "Promise.try",
        ret
      );
      ret._resolveFromSyncValue(value);
      return ret;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util2.errorObj) {
        this._rejectCallback(value.e, false);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
  return method;
}
var bind;
var hasRequiredBind;
function requireBind() {
  if (hasRequiredBind) return bind;
  hasRequiredBind = 1;
  bind = function(Promise2, INTERNAL, tryConvertToPromise, debug2) {
    var calledBind = false;
    var rejectThis = function(_, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context2) {
      context2.promiseRejectionQueued = true;
      context2.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context2) {
      if ((this._bitField & 50397184) === 0) {
        this._resolveCallback(context2.target);
      }
    };
    var bindingRejected = function(e, context2) {
      if (!context2.promiseRejectionQueued) this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      if (!calledBind) {
        calledBind = true;
        Promise2.prototype._propagateFrom = debug2.propagateFromFunction();
        Promise2.prototype._boundValue = debug2.boundValueFunction();
      }
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL);
      ret._propagateFrom(this, 1);
      var target = this._target();
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context2 = {
          promiseRejectionQueued: false,
          promise: ret,
          target,
          bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, void 0, ret, context2);
        maybePromise._then(
          bindingResolved,
          bindingRejected,
          void 0,
          ret,
          context2
        );
        ret._setOnCancel(maybePromise);
      } else {
        ret._resolveCallback(target);
      }
      return ret;
    };
    Promise2.prototype._setBoundTo = function(obj) {
      if (obj !== void 0) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
      } else {
        this._bitField = this._bitField & -2097153;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    };
    Promise2.bind = function(thisArg, value) {
      return Promise2.resolve(value).bind(thisArg);
    };
  };
  return bind;
}
var cancel;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel) return cancel;
  hasRequiredCancel = 1;
  cancel = function(Promise2, PromiseArray, apiRejection, debug2) {
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
      if (!debug2.cancellation()) return this._warn("cancellation is disabled");
      var promise2 = this;
      var child = promise2;
      while (promise2._isCancellable()) {
        if (!promise2._cancelBy(child)) {
          if (child._isFollowing()) {
            child._followee().cancel();
          } else {
            child._cancelBranched();
          }
          break;
        }
        var parent = promise2._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
          if (promise2._isFollowing()) {
            promise2._followee().cancel();
          } else {
            promise2._cancelBranched();
          }
          break;
        } else {
          if (promise2._isFollowing()) promise2._followee().cancel();
          promise2._setWillBeCancelled();
          child = promise2;
          promise2 = parent;
        }
      }
    };
    Promise2.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    };
    Promise2.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
    };
    Promise2.prototype._cancelBy = function(canceller) {
      if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
      } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
          this._invokeOnCancel();
          return true;
        }
      }
      return false;
    };
    Promise2.prototype._cancelBranched = function() {
      if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
      }
    };
    Promise2.prototype._cancel = function() {
      if (!this._isCancellable()) return;
      this._setCancelled();
      async2.invoke(this._cancelPromises, this, void 0);
    };
    Promise2.prototype._cancelPromises = function() {
      if (this._length() > 0) this._settlePromises();
    };
    Promise2.prototype._unsetOnCancel = function() {
      this._onCancelField = void 0;
    };
    Promise2.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    };
    Promise2.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    };
    Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
      if (util2.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
          this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
      } else if (onCancelCallback !== void 0) {
        if (typeof onCancelCallback === "function") {
          if (!internalOnly) {
            var e = tryCatch(onCancelCallback).call(this._boundValue());
            if (e === errorObj) {
              this._attachExtraTrace(e.e);
              async2.throwLater(e.e);
            }
          }
        } else {
          onCancelCallback._resultCancelled(this);
        }
      }
    };
    Promise2.prototype._invokeOnCancel = function() {
      var onCancelCallback = this._onCancel();
      this._unsetOnCancel();
      async2.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise2.prototype._invokeInternalOnCancel = function() {
      if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
      }
    };
    Promise2.prototype._resultCancelled = function() {
      this.cancel();
    };
  };
  return cancel;
}
var direct_resolve;
var hasRequiredDirect_resolve;
function requireDirect_resolve() {
  if (hasRequiredDirect_resolve) return direct_resolve;
  hasRequiredDirect_resolve = 1;
  direct_resolve = function(Promise2) {
    function returner() {
      return this.value;
    }
    function thrower() {
      throw this.reason;
    }
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value instanceof Promise2) value.suppressUnhandledRejections();
      return this._then(
        returner,
        void 0,
        void 0,
        { value },
        void 0
      );
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      return this._then(
        thrower,
        void 0,
        void 0,
        { reason },
        void 0
      );
    };
    Promise2.prototype.catchThrow = function(reason) {
      if (arguments.length <= 1) {
        return this._then(
          void 0,
          thrower,
          void 0,
          { reason },
          void 0
        );
      } else {
        var _reason = arguments[1];
        var handler = function() {
          throw _reason;
        };
        return this.caught(reason, handler);
      }
    };
    Promise2.prototype.catchReturn = function(value) {
      if (arguments.length <= 1) {
        if (value instanceof Promise2) value.suppressUnhandledRejections();
        return this._then(
          void 0,
          returner,
          void 0,
          { value },
          void 0
        );
      } else {
        var _value = arguments[1];
        if (_value instanceof Promise2) _value.suppressUnhandledRejections();
        var handler = function() {
          return _value;
        };
        return this.caught(value, handler);
      }
    };
  };
  return direct_resolve;
}
var synchronous_inspection;
var hasRequiredSynchronous_inspection;
function requireSynchronous_inspection() {
  if (hasRequiredSynchronous_inspection) return synchronous_inspection;
  hasRequiredSynchronous_inspection = 1;
  synchronous_inspection = function(Promise2) {
    function PromiseInspection(promise2) {
      if (promise2 !== void 0) {
        promise2 = promise2._target();
        this._bitField = promise2._bitField;
        this._settledValueField = promise2._isFateSealed() ? promise2._settledValue() : void 0;
      } else {
        this._bitField = 0;
        this._settledValueField = void 0;
      }
    }
    PromiseInspection.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    };
    Promise2.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    };
    Promise2.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    };
    Promise2.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    };
    Promise2.prototype.isPending = function() {
      return isPending.call(this._target());
    };
    Promise2.prototype.isRejected = function() {
      return isRejected.call(this._target());
    };
    Promise2.prototype.isFulfilled = function() {
      return isFulfilled.call(this._target());
    };
    Promise2.prototype.isResolved = function() {
      return isResolved.call(this._target());
    };
    Promise2.prototype.value = function() {
      return value.call(this._target());
    };
    Promise2.prototype.reason = function() {
      var target = this._target();
      target._unsetRejectionIsUnhandled();
      return reason.call(target);
    };
    Promise2.prototype._value = function() {
      return this._settledValue();
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue();
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
  return synchronous_inspection;
}
var join;
var hasRequiredJoin;
function requireJoin() {
  if (hasRequiredJoin) return join;
  hasRequiredJoin = 1;
  join = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async2) {
    var util2 = requireUtil();
    var canEvaluate = util2.canEvaluate;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var reject;
    {
      if (canEvaluate) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", "                             \n	            'use strict';                                                    \n	            holder.pIndex = value;                                           \n	            holder.checkFulfillment(this);                                   \n	            ".replace(/Index/g, i2));
        };
        var promiseSetter = function(i2) {
          return new Function("promise", "holder", "                           \n	            'use strict';                                                    \n	            holder.pIndex = promise;                                         \n	            ".replace(/Index/g, i2));
        };
        var generateHolderClass = function(total) {
          var props2 = new Array(total);
          for (var i2 = 0; i2 < props2.length; ++i2) {
            props2[i2] = "this.p" + (i2 + 1);
          }
          var assignment = props2.join(" = ") + " = null;";
          var cancellationCode = "var promise;\n" + props2.map(function(prop) {
            return "                                                         \n	                promise = " + prop + ";                                      \n	                if (promise instanceof Promise) {                            \n	                    promise.cancel();                                        \n	                }                                                            \n	            ";
          }).join("\n");
          var passedArguments = props2.join(", ");
          var name = "Holder$" + total;
          var code = "return function(tryCatch, errorObj, Promise, async) {    \n	            'use strict';                                                    \n	            function [TheName](fn) {                                         \n	                [TheProperties]                                              \n	                this.fn = fn;                                                \n	                this.asyncNeeded = true;                                     \n	                this.now = 0;                                                \n	            }                                                                \n	                                                                             \n	            [TheName].prototype._callFunction = function(promise) {          \n	                promise._pushContext();                                      \n	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n	                promise._popContext();                                       \n	                if (ret === errorObj) {                                      \n	                    promise._rejectCallback(ret.e, false);                   \n	                } else {                                                     \n	                    promise._resolveCallback(ret);                           \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype.checkFulfillment = function(promise) {       \n	                var now = ++this.now;                                        \n	                if (now === [TheTotal]) {                                    \n	                    if (this.asyncNeeded) {                                  \n	                        async.invoke(this._callFunction, this, promise);     \n	                    } else {                                                 \n	                        this._callFunction(promise);                         \n	                    }                                                        \n	                                                                             \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype._resultCancelled = function() {              \n	                [CancellationCode]                                           \n	            };                                                               \n	                                                                             \n	            return [TheName];                                                \n	        }(tryCatch, errorObj, Promise, async);                               \n	        ";
          code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
          return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise2, async2);
        };
        var holderClasses = [];
        var thenCallbacks = [];
        var promiseSetters = [];
        for (var i = 0; i < 8; ++i) {
          holderClasses.push(generateHolderClass(i + 1));
          thenCallbacks.push(thenCallback(i + 1));
          promiseSetters.push(promiseSetter(i + 1));
        }
        reject = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last = arguments.length - 1;
      var fn;
      if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        {
          if (last <= 8 && canEvaluate) {
            var ret = new Promise2(INTERNAL);
            ret._captureStackTrace();
            var HolderClass = holderClasses[last - 1];
            var holder = new HolderClass(fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0; i2 < last; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                if ((bitField & 50397184) === 0) {
                  maybePromise._then(
                    callbacks[i2],
                    reject,
                    void 0,
                    ret,
                    holder
                  );
                  promiseSetters[i2](maybePromise, holder);
                  holder.asyncNeeded = false;
                } else if ((bitField & 33554432) !== 0) {
                  callbacks[i2].call(
                    ret,
                    maybePromise._value(),
                    holder
                  );
                } else if ((bitField & 16777216) !== 0) {
                  ret._reject(maybePromise._reason());
                } else {
                  ret._cancel();
                }
              } else {
                callbacks[i2].call(ret, maybePromise, holder);
              }
            }
            if (!ret._isFateSealed()) {
              if (holder.asyncNeeded) {
                var context2 = Promise2._getContext();
                holder.fn = util2.contextBind(context2, holder.fn);
              }
              ret._setAsyncGuaranteed();
              ret._setOnCancel(holder);
            }
            return ret;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0; $_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      if (fn) args.pop();
      var ret = new PromiseArray(args).promise();
      return fn !== void 0 ? ret.spread(fn) : ret;
    };
  };
  return join;
}
var call_get;
var hasRequiredCall_get;
function requireCall_get() {
  if (hasRequiredCall_get) return call_get;
  hasRequiredCall_get = 1;
  var cr = Object.create;
  if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  call_get = function(Promise2) {
    var util2 = requireUtil();
    var canEvaluate = util2.canEvaluate;
    var isIdentifier = util2.isIdentifier;
    var getMethodCaller;
    var getGetter;
    {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", "                                    \n	        return function(obj) {                                               \n	            'use strict'                                                     \n	            var len = this.length;                                           \n	            ensureMethod(obj, 'methodName');                                 \n	            switch(len) {                                                    \n	                case 1: return obj.methodName(this[0]);                      \n	                case 2: return obj.methodName(this[0], this[1]);             \n	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n	                case 0: return obj.methodName();                             \n	                default:                                                     \n	                    return obj.methodName.apply(obj, this);                  \n	            }                                                                \n	        };                                                                   \n	        ".replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter = function(propertyName) {
        return new Function("obj", "                                             \n	        'use strict';                                                        \n	        return obj.propertyName;                                             \n	        ".replace("propertyName", propertyName));
      };
      var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
          if (!isIdentifier(name)) {
            return null;
          }
          ret = compiler(name);
          cache[name] = ret;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
          }
        }
        return ret;
      };
      getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
      };
      getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
      };
    }
    function ensureMethod(obj, methodName) {
      var fn;
      if (obj != null) fn = obj[methodName];
      if (typeof fn !== "function") {
        var message = "Object " + util2.classString(obj) + " has no method '" + util2.toString(methodName) + "'";
        throw new Promise2.TypeError(message);
      }
      return fn;
    }
    function caller(obj) {
      var methodName = this.pop();
      var fn = ensureMethod(obj, methodName);
      return fn.apply(obj, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array(Math.max($_len - 1, 0));
      for (var $_i = 1; $_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      {
        if (canEvaluate) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(
              maybeCaller,
              void 0,
              void 0,
              args,
              void 0
            );
          }
        }
      }
      args.push(methodName);
      return this._then(caller, void 0, void 0, args, void 0);
    };
    function namedGetter(obj) {
      return obj[this];
    }
    function indexedGetter(obj) {
      var index2 = +this;
      if (index2 < 0) index2 = Math.max(0, index2 + obj.length);
      return obj[index2];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex = typeof propertyName === "number";
      var getter;
      if (!isIndex) {
        if (canEvaluate) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, void 0, void 0, propertyName, void 0);
    };
  };
  return call_get;
}
var generators;
var hasRequiredGenerators;
function requireGenerators() {
  if (hasRequiredGenerators) return generators;
  hasRequiredGenerators = 1;
  generators = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug2) {
    var errors2 = requireErrors();
    var TypeError2 = errors2.TypeError;
    var util2 = requireUtil();
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0; i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
          traceParent._pushContext();
          var ret = Promise2.reject(errorObj.e);
          traceParent._popContext();
          return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise2) return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
      if (debug2.cancellation()) {
        var internal2 = new Promise2(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
        this._promise = internal2.lastly(function() {
          return _finallyPromise;
        });
        internal2._captureStackTrace();
        internal2._setOnCancel(this);
      } else {
        var promise2 = this._promise = new Promise2(INTERNAL);
        promise2._captureStackTrace();
      }
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver;
      this._generator = void 0;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
      this._yieldedPromise = null;
      this._cancellationPhase = false;
    }
    util2.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
      return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
      this._promise = this._generator = null;
      if (debug2.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
      }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
      if (this._isResolved()) return;
      var implementsReturn = typeof this._generator["return"] !== "undefined";
      var result;
      if (!implementsReturn) {
        var reason = new Promise2.CancellationError(
          "generator .return() sentinel"
        );
        Promise2.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(
          this._generator,
          reason
        );
        this._promise._popContext();
      } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(
          this._generator,
          void 0
        );
        this._promise._popContext();
      }
      this._cancellationPhase = true;
      this._yieldedPromise = null;
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
      this._yieldedPromise = null;
      this._promise._pushContext();
      var result = tryCatch(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
      this._yieldedPromise = null;
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof Promise2) {
        var promise2 = this._yieldedPromise;
        this._yieldedPromise = null;
        promise2.cancel();
      }
    };
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = void 0;
      this._promiseFulfilled(void 0);
    };
    PromiseSpawn.prototype._continue = function(result) {
      var promise2 = this._promise;
      if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._rejectCallback(result.e, false);
        }
      }
      var value = result.value;
      if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._resolveCallback(value);
        }
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(
            maybePromise,
            this._yieldHandlers,
            this._promise
          );
          if (maybePromise === null) {
            this._promiseRejected(
              new TypeError2(
                "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
              )
            );
            return;
          }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        if ((bitField & 50397184) === 0) {
          this._yieldedPromise = maybePromise;
          maybePromise._proxy(this, null);
        } else if ((bitField & 33554432) !== 0) {
          Promise2._async.invoke(
            this._promiseFulfilled,
            this,
            maybePromise._value()
          );
        } else if ((bitField & 16777216) !== 0) {
          Promise2._async.invoke(
            this._promiseRejected,
            this,
            maybePromise._reason()
          );
        } else {
          this._promiseCancelled();
        }
      }
    };
    Promise2.coroutine = function(generatorFunction, options2) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var yieldHandler = Object(options2).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(
          void 0,
          void 0,
          yieldHandler,
          stack
        );
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(void 0);
        return ret;
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      debug2.deprecated("Promise.spawn()", "Promise.coroutine()");
      if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var spawn = new PromiseSpawn(generatorFunction, this);
      var ret = spawn.promise();
      spawn._run(Promise2.spawn);
      return ret;
    };
  };
  return generators;
}
var map;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map;
  hasRequiredMap = 1;
  map = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2) {
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    function MappingPromiseArray(promises, fn, limit2, _filter) {
      this.constructor$(promises);
      this._promise._captureStackTrace();
      var context2 = Promise2._getContext();
      this._callback = util2.contextBind(context2, fn);
      this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
      this._limit = limit2;
      this._inFlight = 0;
      this._queue = [];
      async2.invoke(this._asyncInit, this, void 0);
      if (util2.isArray(promises)) {
        for (var i = 0; i < promises.length; ++i) {
          var maybePromise = promises[i];
          if (maybePromise instanceof Promise2) {
            maybePromise.suppressUnhandledRejections();
          }
        }
      }
    }
    util2.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
      this._init$(void 0, -2);
    };
    MappingPromiseArray.prototype._init = function() {
    };
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index2) {
      var values = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit2 = this._limit;
      if (index2 < 0) {
        index2 = index2 * -1 - 1;
        values[index2] = value;
        if (limit2 >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved()) return true;
        }
      } else {
        if (limit2 >= 1 && this._inFlight >= limit2) {
          values[index2] = value;
          this._queue.push(index2);
          return false;
        }
        if (preservedValues !== null) preservedValues[index2] = value;
        var promise2 = this._promise;
        var callback = this._callback;
        var receiver = promise2._boundValue();
        promise2._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index2, length);
        var promiseCreated = promise2._popContext();
        debug2.checkForgottenReturns(
          ret,
          promiseCreated,
          preservedValues !== null ? "Promise.filter" : "Promise.map",
          promise2
        );
        if (ret === errorObj) {
          this._reject(ret.e);
          return true;
        }
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          if ((bitField & 50397184) === 0) {
            if (limit2 >= 1) this._inFlight++;
            values[index2] = maybePromise;
            maybePromise._proxy(this, (index2 + 1) * -1);
            return false;
          } else if ((bitField & 33554432) !== 0) {
            ret = maybePromise._value();
          } else if ((bitField & 16777216) !== 0) {
            this._reject(maybePromise._reason());
            return true;
          } else {
            this._cancel();
            return true;
          }
        }
        values[index2] = ret;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values, preservedValues);
        } else {
          this._resolve(values);
        }
        return true;
      }
      return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue2 = this._queue;
      var limit2 = this._limit;
      var values = this._values;
      while (queue2.length > 0 && this._inFlight < limit2) {
        if (this._isResolved()) return;
        var index2 = queue2.pop();
        this._promiseFulfilled(values[index2], index2);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values) {
      var len = values.length;
      var ret = new Array(len);
      var j = 0;
      for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
      }
      ret.length = j;
      this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map2(promises, fn, options2, _filter) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var limit2 = 0;
      if (options2 !== void 0) {
        if (typeof options2 === "object" && options2 !== null) {
          if (typeof options2.concurrency !== "number") {
            return Promise2.reject(
              new TypeError("'concurrency' must be a number but it is " + util2.classString(options2.concurrency))
            );
          }
          limit2 = options2.concurrency;
        } else {
          return Promise2.reject(new TypeError(
            "options argument must be an object but it is " + util2.classString(options2)
          ));
        }
      }
      limit2 = typeof limit2 === "number" && isFinite(limit2) && limit2 >= 1 ? limit2 : 0;
      return new MappingPromiseArray(promises, fn, limit2, _filter).promise();
    }
    Promise2.prototype.map = function(fn, options2) {
      return map2(this, fn, options2, null);
    };
    Promise2.map = function(promises, fn, options2, _filter) {
      return map2(promises, fn, options2, _filter);
    };
  };
  return map;
}
var nodeify;
var hasRequiredNodeify;
function requireNodeify() {
  if (hasRequiredNodeify) return nodeify;
  hasRequiredNodeify = 1;
  nodeify = function(Promise2) {
    var util2 = requireUtil();
    var async2 = Promise2._async;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function spreadAdapter(val, nodeback2) {
      var promise2 = this;
      if (!util2.isArray(val)) return successAdapter.call(promise2, val, nodeback2);
      var ret = tryCatch(nodeback2).apply(promise2._boundValue(), [null].concat(val));
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function successAdapter(val, nodeback2) {
      var promise2 = this;
      var receiver = promise2._boundValue();
      var ret = val === void 0 ? tryCatch(nodeback2).call(receiver, null) : tryCatch(nodeback2).call(receiver, null, val);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function errorAdapter(reason, nodeback2) {
      var promise2 = this;
      if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
      }
      var ret = tryCatch(nodeback2).call(promise2._boundValue(), reason);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback2, options2) {
      if (typeof nodeback2 == "function") {
        var adapter = successAdapter;
        if (options2 !== void 0 && Object(options2).spread) {
          adapter = spreadAdapter;
        }
        this._then(
          adapter,
          errorAdapter,
          void 0,
          this,
          nodeback2
        );
      }
      return this;
    };
  };
  return nodeify;
}
var promisify;
var hasRequiredPromisify;
function requirePromisify() {
  if (hasRequiredPromisify) return promisify;
  hasRequiredPromisify = 1;
  promisify = function(Promise2, INTERNAL) {
    var THIS = {};
    var util2 = requireUtil();
    var nodebackForPromise = requireNodeback();
    var withAppended = util2.withAppended;
    var maybeWrapAsError = util2.maybeWrapAsError;
    var canEvaluate = util2.canEvaluate;
    var TypeError2 = requireErrors().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
      return util2.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key) {
      return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj, key, suffix) {
      var val = util2.getDataPropertyOrDefault(
        obj,
        key + suffix,
        defaultPromisified
      );
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
      for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
          var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
          for (var j = 0; j < ret.length; j += 2) {
            if (ret[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter2) {
      var keys = util2.inheritedDataKeys(obj);
      var ret = [];
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter2 === defaultFilter ? true : defaultFilter(key);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter2(key, value, obj, passesDefaultFilter)) {
          ret.push(key, value);
        }
      }
      checkValid(ret, suffix, suffixRegexp);
      return ret;
    }
    var escapeIdentRegex = function(str2) {
      return str2.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min2 = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1; i >= min2; --i) {
          ret.push(i);
        }
        for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
          ret.push(i);
        }
        return ret;
      };
      var argumentSequence = function(argumentCount) {
        return util2.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util2.filledRange(
          Math.max(parameterCount2, 3),
          "_arg",
          ""
        );
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma = count > 0 ? ", " : "";
          var ret;
          if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
          } else {
            ret = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
          }
          return ret.replace("{{args}}", args).replace(", ", comma);
        }
        function generateArgumentSwitchCase() {
          var ret = "";
          for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret += "                                                             \n	        default:                                                             \n	            var args = new Array(len + 1);                                   \n	            var i = 0;                                                       \n	            for (var i = 0; i < len; ++i) {                                  \n	               args[i] = arguments[i];                                       \n	            }                                                                \n	            args[i] = nodeback;                                              \n	            [CodeForCall]                                                    \n	            break;                                                           \n	        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
          return ret;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        var body = "'use strict';                                                \n	        var ret = function (Parameters) {                                    \n	            'use strict';                                                    \n	            var len = arguments.length;                                      \n	            var promise = new Promise(INTERNAL);                             \n	            promise._captureStackTrace();                                    \n	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n	            var ret;                                                         \n	            var callback = tryCatch([GetFunctionCode]);                      \n	            switch(len) {                                                    \n	                [CodeForSwitchCase]                                          \n	            }                                                                \n	            if (ret === errorObj) {                                          \n	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n	            }                                                                \n	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n	            return promise;                                                  \n	        };                                                                   \n	        notEnumerableProp(ret, '__isPromisified__', true);                   \n	        return ret;                                                          \n	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
        body = body.replace("Parameters", parameterDeclaration(newParameterCount));
        return new Function(
          "Promise",
          "fn",
          "receiver",
          "withAppended",
          "maybeWrapAsError",
          "nodebackForPromise",
          "tryCatch",
          "errorObj",
          "notEnumerableProp",
          "INTERNAL",
          body
        )(
          Promise2,
          fn,
          receiver,
          withAppended,
          maybeWrapAsError,
          nodebackForPromise,
          util2.tryCatch,
          util2.errorObj,
          util2.notEnumerableProp,
          INTERNAL
        );
      };
    }
    function makeNodePromisifiedClosure(callback, receiver, _, fn, __2, multiArgs) {
      var defaultThis = /* @__PURE__ */ function() {
        return this;
      }();
      var method2 = callback;
      if (typeof method2 === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise2 = new Promise2(INTERNAL);
        promise2._captureStackTrace();
        var cb = typeof method2 === "string" && this !== defaultThis ? this[method2] : callback;
        var fn2 = nodebackForPromise(promise2, multiArgs);
        try {
          cb.apply(_receiver, withAppended(arguments, fn2));
        } catch (e) {
          promise2._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise2._isFateSealed()) promise2._setAsyncGuaranteed();
        return promise2;
      }
      util2.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj, suffix, filter2, promisifier, multiArgs) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods2 = promisifiableMethods(obj, suffix, suffixRegexp, filter2);
      for (var i = 0, len = methods2.length; i < len; i += 2) {
        var key = methods2[i];
        var fn = methods2[i + 1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
          obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(
              key,
              THIS,
              key,
              fn,
              suffix,
              multiArgs
            );
          });
          util2.notEnumerableProp(promisified, "__isPromisified__", true);
          obj[promisifiedKey] = promisified;
        }
      }
      util2.toFastProperties(obj);
      return obj;
    }
    function promisify2(callback, receiver, multiArgs) {
      return makeNodePromisified(
        callback,
        receiver,
        void 0,
        callback,
        null,
        multiArgs
      );
    }
    Promise2.promisify = function(fn, options2) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      if (isPromisified(fn)) {
        return fn;
      }
      options2 = Object(options2);
      var receiver = options2.context === void 0 ? THIS : options2.context;
      var multiArgs = !!options2.multiArgs;
      var ret = promisify2(fn, receiver, multiArgs);
      util2.copyDescriptors(fn, ret, propsFilter);
      return ret;
    };
    Promise2.promisifyAll = function(target, options2) {
      if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      options2 = Object(options2);
      var multiArgs = !!options2.multiArgs;
      var suffix = options2.suffix;
      if (typeof suffix !== "string") suffix = defaultSuffix;
      var filter2 = options2.filter;
      if (typeof filter2 !== "function") filter2 = defaultFilter;
      var promisifier = options2.promisifier;
      if (typeof promisifier !== "function") promisifier = makeNodePromisified;
      if (!util2.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
      }
      var keys = util2.inheritedDataKeys(target);
      for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" && util2.isClass(value)) {
          promisifyAll(
            value.prototype,
            suffix,
            filter2,
            promisifier,
            multiArgs
          );
          promisifyAll(value, suffix, filter2, promisifier, multiArgs);
        }
      }
      return promisifyAll(target, suffix, filter2, promisifier, multiArgs);
    };
  };
  return promisify;
}
var props;
var hasRequiredProps;
function requireProps() {
  if (hasRequiredProps) return props;
  hasRequiredProps = 1;
  props = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil();
    var isObject2 = util2.isObject;
    var es52 = requireEs5();
    var Es6Map;
    if (typeof Map === "function") Es6Map = Map;
    var mapToEntries = /* @__PURE__ */ function() {
      var index2 = 0;
      var size = 0;
      function extractEntry(value, key) {
        this[index2] = value;
        this[index2 + size] = key;
        index2++;
      }
      return function mapToEntries2(map2) {
        size = map2.size;
        index2 = 0;
        var ret = new Array(map2.size * 2);
        map2.forEach(extractEntry, ret);
        return ret;
      };
    }();
    var entriesToMap = function(entries) {
      var ret = new Es6Map();
      var length = entries.length / 2 | 0;
      for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
      }
      return ret;
    };
    function PropertiesPromiseArray(obj) {
      var isMap = false;
      var entries;
      if (Es6Map !== void 0 && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
      } else {
        var keys = es52.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
          var key = keys[i];
          entries[i] = obj[key];
          entries[i + len] = key;
        }
      }
      this.constructor$(entries);
      this._isMap = isMap;
      this._init$(void 0, isMap ? -6 : -3);
    }
    util2.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {
    };
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index2) {
      this._values[index2] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
          val = entriesToMap(this._values);
        } else {
          val = {};
          var keyOffset = this.length();
          for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
          }
        }
        this._resolve(val);
        return true;
      }
      return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props2(promises) {
      var ret;
      var castValue = tryConvertToPromise(promises);
      if (!isObject2(castValue)) {
        return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
      } else if (castValue instanceof Promise2) {
        ret = castValue._then(
          Promise2.props,
          void 0,
          void 0,
          void 0,
          void 0
        );
      } else {
        ret = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret._propagateFrom(castValue, 2);
      }
      return ret;
    }
    Promise2.prototype.props = function() {
      return props2(this);
    };
    Promise2.props = function(promises) {
      return props2(promises);
    };
  };
  return props;
}
var race;
var hasRequiredRace;
function requireRace() {
  if (hasRequiredRace) return race;
  hasRequiredRace = 1;
  race = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil();
    var raceLater = function(promise2) {
      return promise2.then(function(array) {
        return race2(array, promise2);
      });
    };
    function race2(promises, parent) {
      var maybePromise = tryConvertToPromise(promises);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else {
        promises = util2.asArray(promises);
        if (promises === null)
          return apiRejection("expecting an array or an iterable object but got " + util2.classString(promises));
      }
      var ret = new Promise2(INTERNAL);
      if (parent !== void 0) {
        ret._propagateFrom(parent, 3);
      }
      var fulfill = ret._fulfill;
      var reject = ret._reject;
      for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];
        if (val === void 0 && !(i in promises)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject, void 0, ret, null);
      }
      return ret;
    }
    Promise2.race = function(promises) {
      return race2(promises, void 0);
    };
    Promise2.prototype.race = function() {
      return race2(this, void 0);
    };
  };
  return race;
}
var reduce$1;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce) return reduce$1;
  hasRequiredReduce = 1;
  reduce$1 = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2) {
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
      this.constructor$(promises);
      var context2 = Promise2._getContext();
      this._fn = util2.contextBind(context2, fn);
      if (initialValue !== void 0) {
        initialValue = Promise2.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
      }
      this._initialValue = initialValue;
      this._currentCancellable = null;
      if (_each === INTERNAL) {
        this._eachValues = Array(this._length);
      } else if (_each === 0) {
        this._eachValues = null;
      } else {
        this._eachValues = void 0;
      }
      this._promise._captureStackTrace();
      this._init$(void 0, -5);
    }
    util2.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
      if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
        this._eachValues.push(accum);
      }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
      if (this._eachValues !== null) {
        this._eachValues.push(value);
      }
      return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {
    };
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
      this._promise._resolveCallback(value);
      this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
      if (sender === this._initialValue) return this._cancel();
      if (this._isResolved()) return;
      this._resultCancelled$();
      if (this._currentCancellable instanceof Promise2) {
        this._currentCancellable.cancel();
      }
      if (this._initialValue instanceof Promise2) {
        this._initialValue.cancel();
      }
    };
    ReductionPromiseArray.prototype._iterate = function(values) {
      this._values = values;
      var value;
      var i;
      var length = values.length;
      if (this._initialValue !== void 0) {
        value = this._initialValue;
        i = 0;
      } else {
        value = Promise2.resolve(values[0]);
        i = 1;
      }
      this._currentCancellable = value;
      for (var j = i; j < length; ++j) {
        var maybePromise = values[j];
        if (maybePromise instanceof Promise2) {
          maybePromise.suppressUnhandledRejections();
        }
      }
      if (!value.isRejected()) {
        for (; i < length; ++i) {
          var ctx = {
            accum: null,
            value: values[i],
            index: i,
            length,
            array: this
          };
          value = value._then(gotAccum, void 0, void 0, ctx, void 0);
          if ((i & 127) === 0) {
            value._setNoAsyncGuarantee();
          }
        }
      }
      if (this._eachValues !== void 0) {
        value = value._then(this._eachComplete, void 0, void 0, this, void 0);
      }
      value._then(completed, completed, void 0, value, this);
    };
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce2(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises, fn, initialValue, _each) {
      return reduce2(promises, fn, initialValue, _each);
    };
    function completed(valueOrReason, array) {
      if (this.isFulfilled()) {
        array._resolve(valueOrReason);
      } else {
        array._reject(valueOrReason);
      }
    }
    function reduce2(promises, fn, initialValue, _each) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
      return array.promise();
    }
    function gotAccum(accum) {
      this.accum = accum;
      this.array._gotAccum(accum);
      var value = tryConvertToPromise(this.value, this.array._promise);
      if (value instanceof Promise2) {
        this.array._currentCancellable = value;
        return value._then(gotValue, void 0, void 0, this, void 0);
      } else {
        return gotValue.call(this, value);
      }
    }
    function gotValue(value) {
      var array = this.array;
      var promise2 = array._promise;
      var fn = tryCatch(array._fn);
      promise2._pushContext();
      var ret;
      if (array._eachValues !== void 0) {
        ret = fn.call(promise2._boundValue(), value, this.index, this.length);
      } else {
        ret = fn.call(
          promise2._boundValue(),
          this.accum,
          value,
          this.index,
          this.length
        );
      }
      if (ret instanceof Promise2) {
        array._currentCancellable = ret;
      }
      var promiseCreated = promise2._popContext();
      debug2.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
        promise2
      );
      return ret;
    }
  };
  return reduce$1;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle) return settle;
  hasRequiredSettle = 1;
  settle = function(Promise2, PromiseArray, debug2) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util2 = requireUtil();
    function SettledPromiseArray(values) {
      this.constructor$(values);
    }
    util2.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index2, inspection) {
      this._values[index2] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index2) {
      var ret = new PromiseInspection();
      ret._bitField = 33554432;
      ret._settledValueField = value;
      return this._promiseResolved(index2, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index2) {
      var ret = new PromiseInspection();
      ret._bitField = 16777216;
      ret._settledValueField = reason;
      return this._promiseResolved(index2, ret);
    };
    Promise2.settle = function(promises) {
      debug2.deprecated(".settle()", ".reflect()");
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.allSettled = function(promises) {
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.prototype.settle = function() {
      return Promise2.settle(this);
    };
  };
  return settle;
}
var some;
var hasRequiredSome;
function requireSome() {
  if (hasRequiredSome) return some;
  hasRequiredSome = 1;
  some = function(Promise2, PromiseArray, apiRejection) {
    var util2 = requireUtil();
    var RangeError2 = requireErrors().RangeError;
    var AggregateError2 = requireErrors().AggregateError;
    var isArray2 = util2.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values) {
      this.constructor$(values);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util2.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(void 0, -5);
      var isArrayResolved = isArray2(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
      if (this._values instanceof Promise2 || this._values == null) {
        return this._cancel();
      }
      this._addRejected(CANCELLATION);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError2();
        for (var i = this.length(); i < this._values.length; ++i) {
          if (this._values[i] !== CANCELLATION) {
            e.push(this._values[i]);
          }
        }
        if (e.length > 0) {
          this._reject(e);
        } else {
          this._cancel();
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some2(promises, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
      }
      var ret = new SomePromiseArray(promises);
      var promise2 = ret.promise();
      ret.setHowMany(howMany);
      ret.init();
      return promise2;
    }
    Promise2.some = function(promises, howMany) {
      return some2(promises, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some2(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
  return some;
}
var timers;
var hasRequiredTimers;
function requireTimers() {
  if (hasRequiredTimers) return timers;
  hasRequiredTimers = 1;
  timers = function(Promise2, INTERNAL, debug2) {
    var util2 = requireUtil();
    var TimeoutError2 = Promise2.TimeoutError;
    function HandleWrapper(handle3) {
      this.handle = handle3;
    }
    HandleWrapper.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var afterValue = function(value) {
      return delay2(+this).thenReturn(value);
    };
    var delay2 = Promise2.delay = function(ms2, value) {
      var ret;
      var handle3;
      if (value !== void 0) {
        ret = Promise2.resolve(value)._then(afterValue, null, null, ms2, void 0);
        if (debug2.cancellation() && value instanceof Promise2) {
          ret._setOnCancel(value);
        }
      } else {
        ret = new Promise2(INTERNAL);
        handle3 = setTimeout(function() {
          ret._fulfill();
        }, +ms2);
        if (debug2.cancellation()) {
          ret._setOnCancel(new HandleWrapper(handle3));
        }
        ret._captureStackTrace();
      }
      ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.prototype.delay = function(ms2) {
      return delay2(ms2, this);
    };
    var afterTimeout = function(promise2, message, parent) {
      var err;
      if (typeof message !== "string") {
        if (message instanceof Error) {
          err = message;
        } else {
          err = new TimeoutError2("operation timed out");
        }
      } else {
        err = new TimeoutError2(message);
      }
      util2.markAsOriginatingFromRejection(err);
      promise2._attachExtraTrace(err);
      promise2._reject(err);
      if (parent != null) {
        parent.cancel();
      }
    };
    function successClear(value) {
      clearTimeout(this.handle);
      return value;
    }
    function failureClear(reason) {
      clearTimeout(this.handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms2, message) {
      ms2 = +ms2;
      var ret, parent;
      var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
          afterTimeout(ret, message, parent);
        }
      }, ms2));
      if (debug2.cancellation()) {
        parent = this.then();
        ret = parent._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
        ret._setOnCancel(handleWrapper);
      } else {
        ret = this._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
      }
      return ret;
    };
  };
  return timers;
}
var using;
var hasRequiredUsing;
function requireUsing() {
  if (hasRequiredUsing) return using;
  hasRequiredUsing = 1;
  using = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug2) {
    var util2 = requireUtil();
    var TypeError2 = requireErrors().TypeError;
    var inherits2 = requireUtil().inherits;
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var NULL2 = {};
    function thrower(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret = new Promise2(INTERNAL);
      function iterator2() {
        if (i >= len) return ret._fulfill();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(
              maybePromise._getDisposer().tryDispose(inspection),
              resources.promise
            );
          } catch (e) {
            return thrower(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(
              iterator2,
              thrower,
              null,
              null,
              null
            );
          }
        }
        iterator2();
      }
      iterator2();
      return ret;
    }
    function Disposer(data, promise2, context2) {
      this._data = data;
      this._promise = promise2;
      this._context = context2;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return NULL2;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context2 = this._context;
      if (context2 !== void 0) context2._pushContext();
      var ret = resource !== NULL2 ? this.doDispose(resource, inspection) : null;
      if (context2 !== void 0) context2._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret;
    };
    Disposer.isDisposer = function(d2) {
      return d2 != null && typeof d2.resource === "function" && typeof d2.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise2, context2) {
      this.constructor$(fn, promise2, context2);
    }
    inherits2(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    function ResourceList(length) {
      this.length = length;
      this.promise = null;
      this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
      var len = this.length;
      for (var i = 0; i < len; ++i) {
        var item = this[i];
        if (item instanceof Promise2) {
          item.cancel();
        }
      }
    };
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2) return apiRejection(
        "you must pass at least 2 arguments to Promise.using"
      );
      var fn = arguments[len - 1];
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new ResourceList(len);
      for (var i = 0; i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, void 0);
          }
        }
        resources[i] = resource;
      }
      var reflectedResources = new Array(resources.length);
      for (var i = 0; i < reflectedResources.length; ++i) {
        reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
      }
      var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
        for (var i2 = 0; i2 < inspections.length; ++i2) {
          var inspection = inspections[i2];
          if (inspection.isRejected()) {
            errorObj.e = inspection.error();
            return errorObj;
          } else if (!inspection.isFulfilled()) {
            resultPromise.cancel();
            return;
          }
          inspections[i2] = inspection.value();
        }
        promise2._pushContext();
        fn = tryCatch(fn);
        var ret = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
        var promiseCreated = promise2._popContext();
        debug2.checkForgottenReturns(
          ret,
          promiseCreated,
          "Promise.using",
          promise2
        );
        return ret;
      });
      var promise2 = resultPromise.lastly(function() {
        var inspection = new Promise2.PromiseInspection(resultPromise);
        return dispose(resources, inspection);
      });
      resources.promise = promise2;
      promise2._setOnCancel(resources);
      return promise2;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 131072;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & -131073;
      this._disposer = void 0;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext());
      }
      throw new TypeError2();
    };
  };
  return using;
}
var any;
var hasRequiredAny;
function requireAny() {
  if (hasRequiredAny) return any;
  hasRequiredAny = 1;
  any = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any2(promises) {
      var ret = new SomePromiseArray(promises);
      var promise2 = ret.promise();
      ret.setHowMany(1);
      ret.setUnwrap();
      ret.init();
      return promise2;
    }
    Promise2.any = function(promises) {
      return any2(promises);
    };
    Promise2.prototype.any = function() {
      return any2(this);
    };
  };
  return any;
}
var each;
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach) return each;
  hasRequiredEach = 1;
  each = function(Promise2, INTERNAL) {
    var PromiseReduce = Promise2.reduce;
    var PromiseAll = Promise2.all;
    function promiseAllThis() {
      return PromiseAll(this);
    }
    function PromiseMapSeries(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
    };
    Promise2.prototype.mapSeries = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };
    Promise2.each = function(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
    };
    Promise2.mapSeries = PromiseMapSeries;
  };
  return each;
}
var filter;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter) return filter;
  hasRequiredFilter = 1;
  filter = function(Promise2, INTERNAL) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options2) {
      return PromiseMap(this, fn, options2, INTERNAL);
    };
    Promise2.filter = function(promises, fn, options2) {
      return PromiseMap(promises, fn, options2, INTERNAL);
    };
  };
  return filter;
}
(function(module) {
  module.exports = function() {
    var makeSelfResolutionError = function() {
      return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
    };
    var reflectHandler = function() {
      return new Promise2.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
      return Promise2.reject(new TypeError2(msg));
    };
    function Proxyable() {
    }
    var UNDEFINED_BINDING = {};
    var util2 = requireUtil();
    util2.setReflectHandler(reflectHandler);
    var getDomain = function() {
      var domain = process.domain;
      if (domain === void 0) {
        return null;
      }
      return domain;
    };
    var getContextDefault = function() {
      return null;
    };
    var getContextDomain = function() {
      return {
        domain: getDomain(),
        async: null
      };
    };
    var AsyncResource = util2.isNode && util2.nodeSupportsAsyncResource ? require$$1$5.AsyncResource : null;
    var getContextAsyncHooks = function() {
      return {
        domain: getDomain(),
        async: new AsyncResource("Bluebird::Promise")
      };
    };
    var getContext = util2.isNode ? getContextDomain : getContextDefault;
    util2.notEnumerableProp(Promise2, "_getContext", getContext);
    var enableAsyncHooks = function() {
      getContext = getContextAsyncHooks;
      util2.notEnumerableProp(Promise2, "_getContext", getContextAsyncHooks);
    };
    var disableAsyncHooks = function() {
      getContext = getContextDomain;
      util2.notEnumerableProp(Promise2, "_getContext", getContextDomain);
    };
    var es52 = requireEs5();
    var Async = requireAsync();
    var async2 = new Async();
    es52.defineProperty(Promise2, "_async", { value: async2 });
    var errors2 = requireErrors();
    var TypeError2 = Promise2.TypeError = errors2.TypeError;
    Promise2.RangeError = errors2.RangeError;
    var CancellationError = Promise2.CancellationError = errors2.CancellationError;
    Promise2.TimeoutError = errors2.TimeoutError;
    Promise2.OperationalError = errors2.OperationalError;
    Promise2.RejectionError = errors2.OperationalError;
    Promise2.AggregateError = errors2.AggregateError;
    var INTERNAL = function() {
    };
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = requireThenables()(Promise2, INTERNAL);
    var PromiseArray = requirePromise_array()(
      Promise2,
      INTERNAL,
      tryConvertToPromise,
      apiRejection,
      Proxyable
    );
    var Context = requireContext()(Promise2);
    var createContext = Context.create;
    var debug2 = requireDebuggability()(
      Promise2,
      Context,
      enableAsyncHooks,
      disableAsyncHooks
    );
    debug2.CapturedTrace;
    var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise, NEXT_FILTER);
    var catchFilter = requireCatch_filter()(NEXT_FILTER);
    var nodebackForPromise = requireNodeback();
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    function check(self2, executor) {
      if (self2 == null || self2.constructor !== Promise2) {
        throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
      }
      if (typeof executor !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(executor));
      }
    }
    function Promise2(executor) {
      if (executor !== INTERNAL) {
        check(this, executor);
      }
      this._bitField = 0;
      this._fulfillmentHandler0 = void 0;
      this._rejectionHandler0 = void 0;
      this._promise0 = void 0;
      this._receiver0 = void 0;
      this._resolveFromExecutor(executor);
      this._promiseCreated();
      this._fireEvent("promiseCreated", this);
    }
    Promise2.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
      var len = arguments.length;
      if (len > 1) {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0; i < len - 1; ++i) {
          var item = arguments[i];
          if (util2.isObject(item)) {
            catchInstances[j++] = item;
          } else {
            return apiRejection("Catch statement predicate: expecting an object but got " + util2.classString(item));
          }
        }
        catchInstances.length = j;
        fn = arguments[i];
        if (typeof fn !== "function") {
          throw new TypeError2("The last argument to .catch() must be a function, got " + util2.toString(fn));
        }
        return this.then(void 0, catchFilter(catchInstances, fn, this));
      }
      return this.then(void 0, fn);
    };
    Promise2.prototype.reflect = function() {
      return this._then(
        reflectHandler,
        reflectHandler,
        void 0,
        this,
        void 0
      );
    };
    Promise2.prototype.then = function(didFulfill, didReject) {
      if (debug2.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " + util2.classString(didFulfill);
        if (arguments.length > 1) {
          msg += ", " + util2.classString(didReject);
        }
        this._warn(msg);
      }
      return this._then(didFulfill, didReject, void 0, void 0, void 0);
    };
    Promise2.prototype.done = function(didFulfill, didReject) {
      var promise2 = this._then(didFulfill, didReject, void 0, void 0, void 0);
      promise2._setIsFinal();
    };
    Promise2.prototype.spread = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      return this.all()._then(fn, void 0, void 0, APPLY, void 0);
    };
    Promise2.prototype.toJSON = function() {
      var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: void 0,
        rejectionReason: void 0
      };
      if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
      } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
      }
      return ret;
    };
    Promise2.prototype.all = function() {
      if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
      }
      return new PromiseArray(this).promise();
    };
    Promise2.prototype.error = function(fn) {
      return this.caught(util2.originatesFromRejection, fn);
    };
    Promise2.getNewLibraryCopy = module.exports;
    Promise2.is = function(val) {
      return val instanceof Promise2;
    };
    Promise2.fromNode = Promise2.fromCallback = function(fn) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
      var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
      if (result === errorObj) {
        ret._rejectCallback(result.e, true);
      }
      if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.all = function(promises) {
      return new PromiseArray(promises).promise();
    };
    Promise2.cast = function(obj) {
      var ret = tryConvertToPromise(obj);
      if (!(ret instanceof Promise2)) {
        ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
      }
      return ret;
    };
    Promise2.resolve = Promise2.fulfilled = Promise2.cast;
    Promise2.reject = Promise2.rejected = function(reason) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._rejectCallback(reason, true);
      return ret;
    };
    Promise2.setScheduler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      return async2.setScheduler(fn);
    };
    Promise2.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
      var haveInternalData = internalData !== void 0;
      var promise2 = haveInternalData ? internalData : new Promise2(INTERNAL);
      var target = this._target();
      var bitField = target._bitField;
      if (!haveInternalData) {
        promise2._propagateFrom(this, 3);
        promise2._captureStackTrace();
        if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
          if (!((bitField & 50397184) === 0)) {
            receiver = this._boundValue();
          } else {
            receiver = target === this ? void 0 : this._boundTo;
          }
        }
        this._fireEvent("promiseChained", this, promise2);
      }
      var context2 = getContext();
      if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if ((bitField & 33554432) !== 0) {
          value = target._rejectionHandler0;
          handler = didFulfill;
        } else if ((bitField & 16777216) !== 0) {
          value = target._fulfillmentHandler0;
          handler = didReject;
          target._unsetRejectionIsUnhandled();
        } else {
          settler = target._settlePromiseLateCancellationObserver;
          value = new CancellationError("late cancellation observer");
          target._attachExtraTrace(value);
          handler = didReject;
        }
        async2.invoke(settler, target, {
          handler: util2.contextBind(context2, handler),
          promise: promise2,
          receiver,
          value
        });
      } else {
        target._addCallbacks(
          didFulfill,
          didReject,
          promise2,
          receiver,
          context2
        );
      }
      return promise2;
    };
    Promise2.prototype._length = function() {
      return this._bitField & 65535;
    };
    Promise2.prototype._isFateSealed = function() {
      return (this._bitField & 117506048) !== 0;
    };
    Promise2.prototype._isFollowing = function() {
      return (this._bitField & 67108864) === 67108864;
    };
    Promise2.prototype._setLength = function(len) {
      this._bitField = this._bitField & -65536 | len & 65535;
    };
    Promise2.prototype._setFulfilled = function() {
      this._bitField = this._bitField | 33554432;
      this._fireEvent("promiseFulfilled", this);
    };
    Promise2.prototype._setRejected = function() {
      this._bitField = this._bitField | 16777216;
      this._fireEvent("promiseRejected", this);
    };
    Promise2.prototype._setFollowing = function() {
      this._bitField = this._bitField | 67108864;
      this._fireEvent("promiseResolved", this);
    };
    Promise2.prototype._setIsFinal = function() {
      this._bitField = this._bitField | 4194304;
    };
    Promise2.prototype._isFinal = function() {
      return (this._bitField & 4194304) > 0;
    };
    Promise2.prototype._unsetCancelled = function() {
      this._bitField = this._bitField & -65537;
    };
    Promise2.prototype._setCancelled = function() {
      this._bitField = this._bitField | 65536;
      this._fireEvent("promiseCancelled", this);
    };
    Promise2.prototype._setWillBeCancelled = function() {
      this._bitField = this._bitField | 8388608;
    };
    Promise2.prototype._setAsyncGuaranteed = function() {
      if (async2.hasCustomScheduler()) return;
      var bitField = this._bitField;
      this._bitField = bitField | (bitField & 536870912) >> 2 ^ 134217728;
    };
    Promise2.prototype._setNoAsyncGuarantee = function() {
      this._bitField = (this._bitField | 536870912) & -134217729;
    };
    Promise2.prototype._receiverAt = function(index2) {
      var ret = index2 === 0 ? this._receiver0 : this[index2 * 4 - 4 + 3];
      if (ret === UNDEFINED_BINDING) {
        return void 0;
      } else if (ret === void 0 && this._isBound()) {
        return this._boundValue();
      }
      return ret;
    };
    Promise2.prototype._promiseAt = function(index2) {
      return this[index2 * 4 - 4 + 2];
    };
    Promise2.prototype._fulfillmentHandlerAt = function(index2) {
      return this[index2 * 4 - 4 + 0];
    };
    Promise2.prototype._rejectionHandlerAt = function(index2) {
      return this[index2 * 4 - 4 + 1];
    };
    Promise2.prototype._boundValue = function() {
    };
    Promise2.prototype._migrateCallback0 = function(follower) {
      follower._bitField;
      var fulfill = follower._fulfillmentHandler0;
      var reject = follower._rejectionHandler0;
      var promise2 = follower._promise0;
      var receiver = follower._receiverAt(0);
      if (receiver === void 0) receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise2, receiver, null);
    };
    Promise2.prototype._migrateCallbackAt = function(follower, index2) {
      var fulfill = follower._fulfillmentHandlerAt(index2);
      var reject = follower._rejectionHandlerAt(index2);
      var promise2 = follower._promiseAt(index2);
      var receiver = follower._receiverAt(index2);
      if (receiver === void 0) receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise2, receiver, null);
    };
    Promise2.prototype._addCallbacks = function(fulfill, reject, promise2, receiver, context2) {
      var index2 = this._length();
      if (index2 >= 65535 - 4) {
        index2 = 0;
        this._setLength(0);
      }
      if (index2 === 0) {
        this._promise0 = promise2;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
          this._fulfillmentHandler0 = util2.contextBind(context2, fulfill);
        }
        if (typeof reject === "function") {
          this._rejectionHandler0 = util2.contextBind(context2, reject);
        }
      } else {
        var base = index2 * 4 - 4;
        this[base + 2] = promise2;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
          this[base + 0] = util2.contextBind(context2, fulfill);
        }
        if (typeof reject === "function") {
          this[base + 1] = util2.contextBind(context2, reject);
        }
      }
      this._setLength(index2 + 1);
      return index2;
    };
    Promise2.prototype._proxy = function(proxyable, arg) {
      this._addCallbacks(void 0, void 0, arg, proxyable, null);
    };
    Promise2.prototype._resolveCallback = function(value, shouldBind) {
      if ((this._bitField & 117506048) !== 0) return;
      if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
      var maybePromise = tryConvertToPromise(value, this);
      if (!(maybePromise instanceof Promise2)) return this._fulfill(value);
      if (shouldBind) this._propagateFrom(maybePromise, 2);
      var promise2 = maybePromise._target();
      if (promise2 === this) {
        this._reject(makeSelfResolutionError());
        return;
      }
      var bitField = promise2._bitField;
      if ((bitField & 50397184) === 0) {
        var len = this._length();
        if (len > 0) promise2._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
          promise2._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(maybePromise);
      } else if ((bitField & 33554432) !== 0) {
        this._fulfill(promise2._value());
      } else if ((bitField & 16777216) !== 0) {
        this._reject(promise2._reason());
      } else {
        var reason = new CancellationError("late cancellation observer");
        promise2._attachExtraTrace(reason);
        this._reject(reason);
      }
    };
    Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
      var trace = util2.ensureErrorObject(reason);
      var hasStack = trace === reason;
      if (!hasStack && !ignoreNonErrorWarnings && debug2.warnings()) {
        var message = "a promise was rejected with a non-error: " + util2.classString(reason);
        this._warn(message, true);
      }
      this._attachExtraTrace(trace, synchronous ? hasStack : false);
      this._reject(reason);
    };
    Promise2.prototype._resolveFromExecutor = function(executor) {
      if (executor === INTERNAL) return;
      var promise2 = this;
      this._captureStackTrace();
      this._pushContext();
      var synchronous = true;
      var r = this._execute(executor, function(value) {
        promise2._resolveCallback(value);
      }, function(reason) {
        promise2._rejectCallback(reason, synchronous);
      });
      synchronous = false;
      this._popContext();
      if (r !== void 0) {
        promise2._rejectCallback(r, true);
      }
    };
    Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise2) {
      var bitField = promise2._bitField;
      if ((bitField & 65536) !== 0) return;
      promise2._pushContext();
      var x;
      if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
          x = errorObj;
          x.e = new TypeError2("cannot .spread() a non-array: " + util2.classString(value));
        } else {
          x = tryCatch(handler).apply(this._boundValue(), value);
        }
      } else {
        x = tryCatch(handler).call(receiver, value);
      }
      var promiseCreated = promise2._popContext();
      bitField = promise2._bitField;
      if ((bitField & 65536) !== 0) return;
      if (x === NEXT_FILTER) {
        promise2._reject(value);
      } else if (x === errorObj) {
        promise2._rejectCallback(x.e, false);
      } else {
        debug2.checkForgottenReturns(x, promiseCreated, "", promise2, this);
        promise2._resolveCallback(x);
      }
    };
    Promise2.prototype._target = function() {
      var ret = this;
      while (ret._isFollowing()) ret = ret._followee();
      return ret;
    };
    Promise2.prototype._followee = function() {
      return this._rejectionHandler0;
    };
    Promise2.prototype._setFollowee = function(promise2) {
      this._rejectionHandler0 = promise2;
    };
    Promise2.prototype._settlePromise = function(promise2, handler, receiver, value) {
      var isPromise = promise2 instanceof Promise2;
      var bitField = this._bitField;
      var asyncGuaranteed = (bitField & 134217728) !== 0;
      if ((bitField & 65536) !== 0) {
        if (isPromise) promise2._invokeInternalOnCancel();
        if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
          receiver.cancelPromise = promise2;
          if (tryCatch(handler).call(receiver, value) === errorObj) {
            promise2._reject(errorObj.e);
          }
        } else if (handler === reflectHandler) {
          promise2._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
          receiver._promiseCancelled(promise2);
        } else if (isPromise || promise2 instanceof PromiseArray) {
          promise2._cancel();
        } else {
          receiver.cancel();
        }
      } else if (typeof handler === "function") {
        if (!isPromise) {
          handler.call(receiver, value, promise2);
        } else {
          if (asyncGuaranteed) promise2._setAsyncGuaranteed();
          this._settlePromiseFromHandler(handler, receiver, value, promise2);
        }
      } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
          if ((bitField & 33554432) !== 0) {
            receiver._promiseFulfilled(value, promise2);
          } else {
            receiver._promiseRejected(value, promise2);
          }
        }
      } else if (isPromise) {
        if (asyncGuaranteed) promise2._setAsyncGuaranteed();
        if ((bitField & 33554432) !== 0) {
          promise2._fulfill(value);
        } else {
          promise2._reject(value);
        }
      }
    };
    Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
      var handler = ctx.handler;
      var promise2 = ctx.promise;
      var receiver = ctx.receiver;
      var value = ctx.value;
      if (typeof handler === "function") {
        if (!(promise2 instanceof Promise2)) {
          handler.call(receiver, value, promise2);
        } else {
          this._settlePromiseFromHandler(handler, receiver, value, promise2);
        }
      } else if (promise2 instanceof Promise2) {
        promise2._reject(value);
      }
    };
    Promise2.prototype._settlePromiseCtx = function(ctx) {
      this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };
    Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
      var promise2 = this._promise0;
      var receiver = this._receiverAt(0);
      this._promise0 = void 0;
      this._receiver0 = void 0;
      this._settlePromise(promise2, handler, receiver, value);
    };
    Promise2.prototype._clearCallbackDataAtIndex = function(index2) {
      var base = index2 * 4 - 4;
      this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
    };
    Promise2.prototype._fulfill = function(value) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16) return;
      if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
      }
      this._setFulfilled();
      this._rejectionHandler0 = value;
      if ((bitField & 65535) > 0) {
        if ((bitField & 134217728) !== 0) {
          this._settlePromises();
        } else {
          async2.settlePromises(this);
        }
        this._dereferenceTrace();
      }
    };
    Promise2.prototype._reject = function(reason) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16) return;
      this._setRejected();
      this._fulfillmentHandler0 = reason;
      if (this._isFinal()) {
        return async2.fatalError(reason, util2.isNode);
      }
      if ((bitField & 65535) > 0) {
        async2.settlePromises(this);
      } else {
        this._ensurePossibleRejectionHandled();
      }
    };
    Promise2.prototype._fulfillPromises = function(len, value) {
      for (var i = 1; i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise2 = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise2, handler, receiver, value);
      }
    };
    Promise2.prototype._rejectPromises = function(len, reason) {
      for (var i = 1; i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise2 = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise2, handler, receiver, reason);
      }
    };
    Promise2.prototype._settlePromises = function() {
      var bitField = this._bitField;
      var len = bitField & 65535;
      if (len > 0) {
        if ((bitField & 16842752) !== 0) {
          var reason = this._fulfillmentHandler0;
          this._settlePromise0(this._rejectionHandler0, reason, bitField);
          this._rejectPromises(len, reason);
        } else {
          var value = this._rejectionHandler0;
          this._settlePromise0(this._fulfillmentHandler0, value, bitField);
          this._fulfillPromises(len, value);
        }
        this._setLength(0);
      }
      this._clearCancellationData();
    };
    Promise2.prototype._settledValue = function() {
      var bitField = this._bitField;
      if ((bitField & 33554432) !== 0) {
        return this._rejectionHandler0;
      } else if ((bitField & 16777216) !== 0) {
        return this._fulfillmentHandler0;
      }
    };
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      es52.defineProperty(Promise2.prototype, Symbol.toStringTag, {
        get: function() {
          return "Object";
        }
      });
    }
    function deferResolve(v) {
      this.promise._resolveCallback(v);
    }
    function deferReject(v) {
      this.promise._rejectCallback(v, false);
    }
    Promise2.defer = Promise2.pending = function() {
      debug2.deprecated("Promise.defer", "new Promise");
      var promise2 = new Promise2(INTERNAL);
      return {
        promise: promise2,
        resolve: deferResolve,
        reject: deferReject
      };
    };
    util2.notEnumerableProp(
      Promise2,
      "_makeSelfResolutionError",
      makeSelfResolutionError
    );
    requireMethod()(
      Promise2,
      INTERNAL,
      tryConvertToPromise,
      apiRejection,
      debug2
    );
    requireBind()(Promise2, INTERNAL, tryConvertToPromise, debug2);
    requireCancel()(Promise2, PromiseArray, apiRejection, debug2);
    requireDirect_resolve()(Promise2);
    requireSynchronous_inspection()(Promise2);
    requireJoin()(
      Promise2,
      PromiseArray,
      tryConvertToPromise,
      INTERNAL,
      async2
    );
    Promise2.Promise = Promise2;
    Promise2.version = "3.7.2";
    requireCall_get()(Promise2);
    requireGenerators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug2);
    requireMap()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2);
    requireNodeify()(Promise2);
    requirePromisify()(Promise2, INTERNAL);
    requireProps()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
    requireRace()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
    requireReduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2);
    requireSettle()(Promise2, PromiseArray, debug2);
    requireSome()(Promise2, PromiseArray, apiRejection);
    requireTimers()(Promise2, INTERNAL, debug2);
    requireUsing()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug2);
    requireAny()(Promise2);
    requireEach()(Promise2, INTERNAL);
    requireFilter()(Promise2, INTERNAL);
    util2.toFastProperties(Promise2);
    util2.toFastProperties(Promise2.prototype);
    function fillTypes(value) {
      var p = new Promise2(INTERNAL);
      p._fulfillmentHandler0 = value;
      p._rejectionHandler0 = value;
      p._promise0 = value;
      p._receiver0 = value;
    }
    fillTypes({ a: 1 });
    fillTypes({ b: 2 });
    fillTypes({ c: 3 });
    fillTypes(1);
    fillTypes(function() {
    });
    fillTypes(void 0);
    fillTypes(false);
    fillTypes(new Promise2(INTERNAL));
    debug2.setBounds(Async.firstLineError, util2.lastLineError);
    return Promise2;
  };
})(promise);
var promiseExports = promise.exports;
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
  try {
    if (Promise === bluebird) Promise = old;
  } catch (e) {
  }
  return bluebird;
}
var bluebird = promiseExports();
bluebird.noConflict = noConflict;
var bluebird_1$b = bluebird;
var protocol2 = {};
Object.defineProperty(protocol2, "__esModule", { value: true });
class Protocol {
  static decodeLength(length) {
    return parseInt(length, 16);
  }
  static encodeLength(length) {
    return length.toString(16).padStart(4, "0").toUpperCase();
  }
  static encodeData(data) {
    if (!Buffer.isBuffer(data)) {
      data = Buffer.from(data);
    }
    const len = Protocol.encodeLength(data.length);
    return Buffer.concat([Buffer.from(len), data]);
  }
}
Protocol.OKAY = "OKAY";
Protocol.FAIL = "FAIL";
Protocol.STAT = "STAT";
Protocol.STA2 = "STA2";
Protocol.LIST = "LIST";
Protocol.DENT = "DENT";
Protocol.RECV = "RECV";
Protocol.DATA = "DATA";
Protocol.DONE = "DONE";
Protocol.SEND = "SEND";
Protocol.QUIT = "QUIT";
protocol2.default = Protocol;
var __importDefault$10 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(parser$1, "__esModule", { value: true });
const bluebird_1$a = __importDefault$10(bluebird_1$b);
const protocol_1$I = __importDefault$10(protocol2);
class FailError extends Error {
  constructor(message) {
    super(`Failure: '${message}'`);
    Object.setPrototypeOf(this, FailError.prototype);
    this.name = "FailError";
    Error.captureStackTrace(this, FailError);
  }
}
class PrematureEOFError extends Error {
  constructor(howManyMissing) {
    super(`Premature end of stream, needed ${howManyMissing} more bytes`);
    Object.setPrototypeOf(this, PrematureEOFError.prototype);
    this.name = "PrematureEOFError";
    this.missingBytes = howManyMissing;
    Error.captureStackTrace(this, PrematureEOFError);
  }
}
class UnexpectedDataError extends Error {
  constructor(unexpected, expected) {
    super(`Unexpected '${unexpected}', was expecting ${expected}`);
    this.unexpected = unexpected;
    this.expected = expected;
    Object.setPrototypeOf(this, UnexpectedDataError.prototype);
    this.name = "UnexpectedDataError";
    Error.captureStackTrace(this, UnexpectedDataError);
  }
}
class TimeoutError extends Error {
  constructor() {
    super(`Socket timeout reached.`);
    Object.setPrototypeOf(this, TimeoutError.prototype);
    this.name = "TimeoutError";
    Error.captureStackTrace(this, TimeoutError);
  }
}
bluebird_1$a.default.config({
  // Enable warnings
  // warnings: true,
  // Enable long stack traces
  // longStackTraces: true,
  // Enable cancellation
  cancellation: true
  // Enable monitoring
  // monitoring: true,
});
class Parser {
  constructor(stream2) {
    this.stream = stream2;
    this.ended = false;
  }
  end() {
    if (this.ended) {
      return bluebird_1$a.default.resolve(true);
    }
    let tryRead;
    let errorListener;
    let endListener;
    let timeoutListener;
    return new bluebird_1$a.default((resolve3, reject, onCancel) => {
      tryRead = () => {
        while (this.stream.read()) {
        }
      };
      errorListener = function(err) {
        return reject(err);
      };
      endListener = () => {
        this.ended = true;
        return resolve3(true);
      };
      timeoutListener = () => {
        this.stream.end();
        return reject(new Parser.TimeoutError());
      };
      this.stream.on("readable", tryRead);
      this.stream.on("error", errorListener);
      this.stream.on("end", endListener);
      this.stream.on("timeout", timeoutListener);
      this.stream.read(0);
      this.stream.end();
      onCancel(() => {
      });
    }).finally(() => {
      this.stream.removeListener("readable", tryRead);
      this.stream.removeListener("error", errorListener);
      this.stream.removeListener("end", endListener);
      this.stream.removeListener("timeout", timeoutListener);
    });
  }
  raw() {
    return this.stream;
  }
  readAll() {
    let all2 = Buffer.alloc(0);
    let tryRead;
    let errorListener;
    let endListener;
    let timeoutListener;
    return new bluebird_1$a.default((resolve3, reject, onCancel) => {
      tryRead = () => {
        let chunk;
        while (chunk = this.stream.read()) {
          all2 = Buffer.concat([all2, chunk]);
        }
        if (this.ended) {
          return resolve3(all2);
        }
      };
      errorListener = function(err) {
        return reject(err);
      };
      endListener = () => {
        this.ended = true;
        return resolve3(all2);
      };
      timeoutListener = () => {
        this.stream.end();
        return reject(new Parser.TimeoutError());
      };
      this.stream.on("readable", tryRead);
      this.stream.on("error", errorListener);
      this.stream.on("end", endListener);
      this.stream.on("timeout", timeoutListener);
      tryRead();
      onCancel(() => {
      });
    }).finally(() => {
      this.stream.removeListener("readable", tryRead);
      this.stream.removeListener("error", errorListener);
      this.stream.removeListener("end", endListener);
      this.stream.removeListener("timeout", timeoutListener);
    });
  }
  readAscii(howMany) {
    return this.readBytes(howMany).then((chunk) => chunk.toString("ascii"));
  }
  readBytes(howMany) {
    let tryRead;
    let errorListener;
    let endListener;
    let timeoutListener;
    return new bluebird_1$a.default((resolve3, reject) => {
      tryRead = () => {
        if (howMany) {
          const chunk = this.stream.read(howMany);
          if (chunk) {
            howMany -= chunk.length;
            if (howMany === 0) {
              return resolve3(chunk);
            }
          }
          if (this.ended) {
            return reject(new Parser.PrematureEOFError(howMany));
          }
        } else {
          return resolve3(Buffer.alloc(0));
        }
      };
      endListener = () => {
        this.ended = true;
        return reject(new Parser.PrematureEOFError(howMany));
      };
      timeoutListener = () => {
        this.stream.end();
        return reject(new Parser.TimeoutError());
      };
      errorListener = (err) => reject(err);
      this.stream.on("readable", tryRead);
      this.stream.on("error", errorListener);
      this.stream.on("end", endListener);
      this.stream.on("timeout", timeoutListener);
      tryRead();
    }).finally(() => {
      this.stream.removeListener("readable", tryRead);
      this.stream.removeListener("error", errorListener);
      this.stream.removeListener("end", endListener);
      this.stream.removeListener("timeout", timeoutListener);
    });
  }
  readByteFlow(howMany, targetStream) {
    let tryRead;
    let errorListener;
    let endListener;
    let timeoutListener;
    return new bluebird_1$a.default((resolve3, reject) => {
      tryRead = () => {
        if (howMany) {
          let chunk;
          while (chunk = this.stream.read(howMany) || this.stream.read()) {
            howMany -= chunk.length;
            targetStream.write(chunk);
            if (howMany === 0) {
              return resolve3();
            }
          }
          if (this.ended) {
            return reject(new Parser.PrematureEOFError(howMany));
          }
        } else {
          return resolve3();
        }
      };
      endListener = () => {
        this.ended = true;
        return reject(new Parser.PrematureEOFError(howMany));
      };
      errorListener = function(err) {
        return reject(err);
      };
      timeoutListener = () => {
        this.stream.end();
        return reject(new Parser.TimeoutError());
      };
      this.stream.on("readable", tryRead);
      this.stream.on("error", errorListener);
      this.stream.on("end", endListener);
      this.stream.on("timeout", timeoutListener);
      tryRead();
    }).finally(() => {
      this.stream.removeListener("readable", tryRead);
      this.stream.removeListener("error", errorListener);
      this.stream.removeListener("end", endListener);
      this.stream.removeListener("timeout", timeoutListener);
    });
  }
  readError() {
    return this.readValue().then(function(value) {
      throw new Parser.FailError(value.toString());
    });
  }
  readValue() {
    return this.readAscii(4).then((value) => {
      const length = protocol_1$I.default.decodeLength(value);
      return this.readBytes(length);
    });
  }
  readUntil(code) {
    let skipped = Buffer.alloc(0);
    const read = () => {
      return this.readBytes(1).then(function(chunk) {
        if (chunk[0] === code) {
          return skipped;
        } else {
          skipped = Buffer.concat([skipped, chunk]);
          return read();
        }
      });
    };
    return read();
  }
  searchLine(re2) {
    return this.readLine().then((line) => {
      const match2 = re2.exec(line.toString());
      if (match2) {
        return match2;
      } else {
        return this.searchLine(re2);
      }
    });
  }
  readLine() {
    return this.readUntil(10).then(function(line) {
      if (line[line.length - 1] === 13) {
        return line.slice(0, -1);
      } else {
        return line;
      }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  unexpected(data, expected) {
    return bluebird_1$a.default.reject(new Parser.UnexpectedDataError(data, expected));
  }
}
Parser.FailError = FailError;
Parser.PrematureEOFError = PrematureEOFError;
Parser.UnexpectedDataError = UnexpectedDataError;
Parser.TimeoutError = TimeoutError;
parser$1.default = Parser;
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$5(result, mod, k);
  }
  __setModuleDefault$5(result, mod);
  return result;
};
const fs = __importStar$5(require$$0$8);
let func;
if (process.env.ADBKIT_DUMP) {
  const out = fs.createWriteStream("adbkit.dump");
  func = function(chunk) {
    out.write(chunk);
    return chunk;
  };
} else {
  func = (chunk) => chunk;
}
var dump = func;
var src = { exports: {} };
var browser = { exports: {} };
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms$2;
    createDebug.destroy = destroy2;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
          if (match2 === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend3;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend3(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports$1) {
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load2;
    exports$1.useColors = useColors;
    exports$1.storage = localstorage();
    exports$1.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports$1.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports$1.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports$1.storage.setItem("debug", namespaces);
        } else {
          exports$1.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports$1.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = requireCommon()(exports$1);
    const { formatters: formatters2 } = module.exports;
    formatters2.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function(module, exports$1) {
    const tty = require$$0$3;
    const util2 = require$$1$1;
    exports$1.init = init2;
    exports$1.log = log2;
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load2;
    exports$1.useColors = useColors;
    exports$1.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports$1.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports$1.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports$1.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports$1.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util2.formatWithOptions(exports$1.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports$1.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports$1);
    const { formatters: formatters2 } = module.exports;
    formatters2.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters2.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode();
}
var srcExports = src.exports;
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$4(result, mod, k);
  }
  __setModuleDefault$4(result, mod);
  return result;
};
var __importDefault$$ = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(connection$1, "__esModule", { value: true });
const Net$1 = __importStar$4(require$$0$7);
const events_1$c = require$$0$9;
const child_process_1$1 = require$$0$c;
const parser_1$9 = __importDefault$$(parser$1);
const dump_1 = __importDefault$$(dump);
const debug_1$6 = __importDefault$$(srcExports);
const bluebird_1$9 = __importDefault$$(bluebird_1$b);
const debug$6 = (0, debug_1$6.default)("adb:connection");
class Connection extends events_1$c.EventEmitter {
  constructor(options2) {
    super();
    this.options = options2 || { port: 0 };
    this.triedStarting = false;
  }
  connect() {
    this.socket = Net$1.connect(this.options);
    this.socket.setNoDelay(true);
    this.parser = new parser_1$9.default(this.socket);
    this.socket.on("connect", () => this.emit("connect"));
    this.socket.on("end", () => this.emit("end"));
    this.socket.on("drain", () => this.emit("drain"));
    this.socket.on("timeout", () => this.emit("timeout"));
    this.socket.on("close", (hadError) => this.emit("close", hadError));
    return new bluebird_1$9.default((resolve3, reject) => {
      this.socket.once("connect", resolve3);
      this.socket.once("error", reject);
    }).catch((err) => {
      if (err.code === "ECONNREFUSED" && !this.triedStarting) {
        debug$6("Connection was refused, let's try starting the server once");
        this.triedStarting = true;
        return this.startServer().then(() => {
          return this.connect();
        });
      } else {
        this.end();
        throw err;
      }
    }).then(() => {
      if (this.socket) {
        this.socket.on("error", (err) => {
          if (this.socket && this.socket.listenerCount("error") === 1) {
            this.emit("error", err);
          }
        });
      }
      return this;
    });
  }
  /**
   * added for Mock testing
   */
  getSocket() {
    return this.socket;
  }
  end() {
    if (this.socket) {
      this.socket.end();
    }
    return this;
  }
  write(data, callback) {
    this.socket.write((0, dump_1.default)(data), callback);
    return this;
  }
  startServer() {
    let port = 0;
    if ("port" in this.options) {
      port = this.options.port;
    }
    const args = port ? ["-P", String(port), "start-server"] : ["start-server"];
    debug$6(`Starting ADB server via '${this.options.bin} ${args.join(" ")}'`);
    return this._exec(args, {});
  }
  _exec(args, options2) {
    debug$6(`CLI: ${this.options.bin} ${args.join(" ")}`);
    return bluebird_1$9.default.promisify(child_process_1$1.execFile)(this.options.bin, args, options2);
  }
}
connection$1.default = Connection;
var host2 = {};
var connect = {};
var command$1 = {};
var __importDefault$_ = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(command$1, "__esModule", { value: true });
const protocol_1$H = __importDefault$_(protocol2);
const debug_1$5 = __importDefault$_(srcExports);
const debug$5 = (0, debug_1$5.default)("adb:command");
const RE_SQUOT = /'/g;
const RE_ESCAPE = /([$`\\!"])/g;
class Command {
  constructor(connection2) {
    this.connection = connection2;
    this.parser = this.connection.parser;
    this.protocol = protocol_1$H.default;
  }
  _send(data) {
    const encoded = protocol_1$H.default.encodeData(data);
    if (debug$5.enabled) {
      debug$5(`Send '${encoded}'`);
    }
    this.connection.write(encoded);
    return this;
  }
  _escape(arg) {
    switch (typeof arg) {
      case "number":
        return arg;
      default:
        return "'" + arg.toString().replace(RE_SQUOT, `'"'"'`) + "'";
    }
  }
  _escapeCompat(arg) {
    switch (typeof arg) {
      case "number":
        return arg;
      default:
        return '"' + arg.toString().replace(RE_ESCAPE, "\\$1") + '"';
    }
  }
}
command$1.default = Command;
var __importDefault$Z = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(connect, "__esModule", { value: true });
const command_1$D = __importDefault$Z(command$1);
const protocol_1$G = __importDefault$Z(protocol2);
const RE_OK$4 = /connected to|already connected/;
class HostConnectCommand extends command_1$D.default {
  execute(host3, port) {
    this._send(`host:connect:${host3}:${port}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$G.default.OKAY:
          return this.parser.readValue().then(function(value) {
            if (RE_OK$4.test(value.toString())) {
              return `${host3}:${port}`;
            } else {
              throw new Error(value.toString());
            }
          });
        case protocol_1$G.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
connect.default = HostConnectCommand;
var devices = {};
var __importDefault$Y = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(devices, "__esModule", { value: true });
const command_1$C = __importDefault$Y(command$1);
const protocol_1$F = __importDefault$Y(protocol2);
class HostDevicesCommand extends command_1$C.default {
  execute() {
    this._send("host:devices");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$F.default.OKAY:
          return this._readDevices();
        case protocol_1$F.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
  _readDevices() {
    return this.parser.readValue().then(this._parseDevices);
  }
  _parseDevices(value) {
    return value.toString("ascii").split("\n").filter((e) => e).map((line) => {
      const [id, type3] = line.split("	");
      return {
        id,
        type: type3
      };
    });
  }
}
devices.default = HostDevicesCommand;
var deviceswithpaths = {};
var __importDefault$X = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(deviceswithpaths, "__esModule", { value: true });
const command_1$B = __importDefault$X(command$1);
const protocol_1$E = __importDefault$X(protocol2);
class HostDevicesWithPathsCommand extends command_1$B.default {
  execute() {
    this._send("host:devices-l");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$E.default.OKAY:
          return this._readDevices();
        case protocol_1$E.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
  _readDevices() {
    return this.parser.readValue().then(this._parseDevices);
  }
  _parseDevices(value) {
    return value.toString("ascii").split("\n").filter((e) => e).map((line) => {
      const [id, type3, path3, product, model, device, transportId] = line.split(/\s+/);
      return {
        id,
        type: type3,
        path: path3,
        product,
        model,
        device,
        transportId
      };
    });
  }
}
deviceswithpaths.default = HostDevicesWithPathsCommand;
var disconnect = {};
var __importDefault$W = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(disconnect, "__esModule", { value: true });
const command_1$A = __importDefault$W(command$1);
const protocol_1$D = __importDefault$W(protocol2);
const RE_OK$3 = /^$/;
const RE_DISC = /^disconnected.*$/;
class HostDisconnectCommand extends command_1$A.default {
  execute(host3, port) {
    this._send(`host:disconnect:${host3}:${port}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$D.default.OKAY:
          return this.parser.readValue().then(function(value) {
            if (RE_OK$3.test(value.toString()) || RE_DISC.test(value.toString())) {
              return `${host3}:${port}`;
            } else {
              throw new Error(value.toString());
            }
          });
        case protocol_1$D.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
disconnect.default = HostDisconnectCommand;
var kill = {};
var __importDefault$V = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(kill, "__esModule", { value: true });
const command_1$z = __importDefault$V(command$1);
const protocol_1$C = __importDefault$V(protocol2);
class HostKillCommand extends command_1$z.default {
  execute() {
    this._send("host:kill");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$C.default.OKAY:
          return true;
        case protocol_1$C.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
kill.default = HostKillCommand;
var trackdevices = {};
var tracker = {};
var __importDefault$U = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(tracker, "__esModule", { value: true });
const bluebird_1$8 = __importDefault$U(bluebird_1$b);
const parser_1$8 = __importDefault$U(parser$1);
const events_1$b = require$$0$9;
class Tracker extends events_1$b.EventEmitter {
  constructor(command2) {
    super();
    this.command = command2;
    this.deviceList = [];
    this.deviceMap = {};
    this.reader = this.read().catch(bluebird_1$8.default.CancellationError, () => true).catch(parser_1$8.default.PrematureEOFError, () => {
      throw new Error("Connection closed");
    }).catch((err) => this.emit("error", err)).finally(() => {
      this.command.parser.end().then(() => this.emit("end"));
    });
  }
  read() {
    return this.command._readDevices().then((list) => {
      this.update(list);
      return this.read();
    });
  }
  update(newList) {
    const changeSet = {
      removed: [],
      changed: [],
      added: []
    };
    const newMap = {};
    for (let i = 0, len = newList.length; i < len; i++) {
      const device = newList[i];
      const oldDevice = this.deviceMap[device.id];
      if (oldDevice) {
        if (oldDevice.type !== device.type) {
          changeSet.changed.push(device);
          this.emit("change", device, oldDevice);
        }
      } else {
        changeSet.added.push(device);
        this.emit("add", device);
      }
      newMap[device.id] = device;
    }
    const ref2 = this.deviceList;
    for (let i = 0, len = ref2.length; i < len; i++) {
      const device = ref2[i];
      if (!newMap[device.id]) {
        changeSet.removed.push(device);
        this.emit("remove", device);
      }
    }
    this.emit("changeSet", changeSet);
    this.deviceList = newList;
    this.deviceMap = newMap;
    return this;
  }
  end() {
    this.reader.cancel();
    return this;
  }
}
tracker.default = Tracker;
var __importDefault$T = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(trackdevices, "__esModule", { value: true });
const protocol_1$B = __importDefault$T(protocol2);
const tracker_1 = __importDefault$T(tracker);
const devices_1 = __importDefault$T(devices);
class HostTrackDevicesCommand extends devices_1.default {
  // FIXME(intentional any): correct return value: `Bluebird<Tracker>`
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  execute() {
    this._send("host:track-devices");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$B.default.OKAY:
          return new tracker_1.default(this);
        case protocol_1$B.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
trackdevices.default = HostTrackDevicesCommand;
var transport = {};
var __importDefault$S = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(transport, "__esModule", { value: true });
const command_1$y = __importDefault$S(command$1);
const protocol_1$A = __importDefault$S(protocol2);
class HostTransportCommand extends command_1$y.default {
  execute(serial) {
    this._send(`host:transport:${serial}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$A.default.OKAY:
          return true;
        case protocol_1$A.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
transport.default = HostTransportCommand;
var version = {};
var __importDefault$R = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(version, "__esModule", { value: true });
const command_1$x = __importDefault$R(command$1);
const protocol_1$z = __importDefault$R(protocol2);
class HostVersionCommand extends command_1$x.default {
  execute() {
    this._send("host:version");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$z.default.OKAY:
          return this.parser.readValue().then((value) => {
            return this._parseVersion(value.toString());
          });
        case protocol_1$z.default.FAIL:
          return this.parser.readError();
        default:
          return this._parseVersion(reply2);
      }
    });
  }
  _parseVersion(version2) {
    return parseInt(version2, 16);
  }
}
version.default = HostVersionCommand;
(function(exports$1) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.HostVersionCommand = exports$1.HostTransportCommand = exports$1.HostTrackDevicesCommand = exports$1.HostKillCommand = exports$1.HostDisconnectCommand = exports$1.HostDevicesWithPathsCommand = exports$1.HostDevicesCommand = exports$1.HostConnectCommand = void 0;
  var connect_1 = connect;
  Object.defineProperty(exports$1, "HostConnectCommand", { enumerable: true, get: function() {
    return __importDefault2(connect_1).default;
  } });
  var devices_12 = devices;
  Object.defineProperty(exports$1, "HostDevicesCommand", { enumerable: true, get: function() {
    return __importDefault2(devices_12).default;
  } });
  var deviceswithpaths_1 = deviceswithpaths;
  Object.defineProperty(exports$1, "HostDevicesWithPathsCommand", { enumerable: true, get: function() {
    return __importDefault2(deviceswithpaths_1).default;
  } });
  var disconnect_1 = disconnect;
  Object.defineProperty(exports$1, "HostDisconnectCommand", { enumerable: true, get: function() {
    return __importDefault2(disconnect_1).default;
  } });
  var kill_1 = kill;
  Object.defineProperty(exports$1, "HostKillCommand", { enumerable: true, get: function() {
    return __importDefault2(kill_1).default;
  } });
  var trackdevices_1 = trackdevices;
  Object.defineProperty(exports$1, "HostTrackDevicesCommand", { enumerable: true, get: function() {
    return __importDefault2(trackdevices_1).default;
  } });
  var transport_1 = transport;
  Object.defineProperty(exports$1, "HostTransportCommand", { enumerable: true, get: function() {
    return __importDefault2(transport_1).default;
  } });
  var version_1 = version;
  Object.defineProperty(exports$1, "HostVersionCommand", { enumerable: true, get: function() {
    return __importDefault2(version_1).default;
  } });
})(host2);
var server = {};
var socket = {};
var packetreader = {};
var packet = {};
Object.defineProperty(packet, "__esModule", { value: true });
class Packet {
  static checksum(data) {
    let sum = 0;
    if (data) {
      for (let i = 0, len = data.length; i < len; i++) {
        const char = data[i];
        sum += char;
      }
    }
    return sum;
  }
  static magic(command2) {
    return (command2 ^ 4294967295) >>> 0;
  }
  static assemble(command2, arg0, arg1, data) {
    if (data) {
      const chunk = Buffer.alloc(24 + data.length);
      chunk.writeUInt32LE(command2, 0);
      chunk.writeUInt32LE(arg0, 4);
      chunk.writeUInt32LE(arg1, 8);
      chunk.writeUInt32LE(data.length, 12);
      chunk.writeUInt32LE(Packet.checksum(data), 16);
      chunk.writeUInt32LE(Packet.magic(command2), 20);
      data.copy(chunk, 24);
      return chunk;
    } else {
      const chunk = Buffer.alloc(24);
      chunk.writeUInt32LE(command2, 0);
      chunk.writeUInt32LE(arg0, 4);
      chunk.writeUInt32LE(arg1, 8);
      chunk.writeUInt32LE(0, 12);
      chunk.writeUInt32LE(0, 16);
      chunk.writeUInt32LE(Packet.magic(command2), 20);
      return chunk;
    }
  }
  static swap32(n) {
    const buffer2 = Buffer.alloc(4);
    buffer2.writeUInt32LE(n, 0);
    return buffer2.readUInt32BE(0);
  }
  constructor(command2, arg0, arg1, length, check, magic, data) {
    this.command = command2;
    this.arg0 = arg0;
    this.arg1 = arg1;
    this.length = length;
    this.check = check;
    this.magic = magic;
    this.data = data;
  }
  verifyChecksum() {
    return this.check === 0 ? true : this.check === Packet.checksum(this.data);
  }
  verifyMagic() {
    return this.magic === Packet.magic(this.command);
  }
  getType() {
    switch (this.command) {
      case Packet.A_SYNC:
        return "SYNC";
      case Packet.A_CNXN:
        return "CNXN";
      case Packet.A_OPEN:
        return "OPEN";
      case Packet.A_OKAY:
        return "OKAY";
      case Packet.A_CLSE:
        return "CLSE";
      case Packet.A_WRTE:
        return "WRTE";
      case Packet.A_AUTH:
        return "AUTH";
      default:
        throw new Error("Unknown command {@command}");
    }
  }
  toString() {
    const type3 = this.getType();
    return `${type3} arg0=${this.arg0} arg1=${this.arg1} length=${this.length}`;
  }
}
Packet.A_SYNC = 1129208147;
Packet.A_CNXN = 1314410051;
Packet.A_OPEN = 1313165391;
Packet.A_OKAY = 1497451343;
Packet.A_CLSE = 1163086915;
Packet.A_WRTE = 1163154007;
Packet.A_AUTH = 1213486401;
packet.default = Packet;
var __importDefault$Q = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(packetreader, "__esModule", { value: true });
const events_1$a = require$$0$9;
const packet_1$2 = __importDefault$Q(packet);
class ChecksumError extends Error {
  constructor(packet2) {
    super();
    this.packet = packet2;
    Object.setPrototypeOf(this, ChecksumError.prototype);
    this.name = "ChecksumError";
    this.message = "Checksum mismatch";
    Error.captureStackTrace(this, PacketReader.ChecksumError);
  }
}
class MagicError extends Error {
  constructor(packet2) {
    super();
    this.packet = packet2;
    Object.setPrototypeOf(this, MagicError.prototype);
    this.name = "MagicError";
    this.message = "Magic value mismatch";
    Error.captureStackTrace(this, PacketReader.MagicError);
  }
}
class PacketReader extends events_1$a.EventEmitter {
  constructor(stream2) {
    super();
    this.stream = stream2;
    this.inBody = false;
    this.stream.on("readable", this._tryRead.bind(this));
    this.stream.on("error", (err) => {
      return this.emit("error", err);
    });
    this.stream.on("end", () => {
      return this.emit("end");
    });
    setImmediate(this._tryRead.bind(this));
  }
  _tryRead() {
    while (this._appendChunk()) {
      while (this.buffer) {
        if (this.inBody) {
          if (!(this.buffer.length >= this.packet.length)) {
            break;
          }
          this.packet.data = this._consume(this.packet.length);
          if (!this.packet.verifyChecksum()) {
            this.emit("error", new PacketReader.ChecksumError(this.packet));
            return;
          }
          this.emit("packet", this.packet);
          this.inBody = false;
        } else {
          if (!(this.buffer.length >= 24)) {
            break;
          }
          const header3 = this._consume(24);
          this.packet = new packet_1$2.default(header3.readUInt32LE(0), header3.readUInt32LE(4), header3.readUInt32LE(8), header3.readUInt32LE(12), header3.readUInt32LE(16), header3.readUInt32LE(20), Buffer.alloc(0));
          if (!this.packet.verifyMagic()) {
            this.emit("error", new PacketReader.MagicError(this.packet));
            return;
          }
          if (this.packet.length === 0) {
            this.emit("packet", this.packet);
          } else {
            this.inBody = true;
          }
        }
      }
    }
  }
  _appendChunk() {
    const chunk = this.stream.read();
    if (chunk) {
      if (this.buffer) {
        return this.buffer = Buffer.concat([this.buffer, chunk], this.buffer.length + chunk.length);
      } else {
        return this.buffer = chunk;
      }
    } else {
      return null;
    }
  }
  _consume(length) {
    const chunk = this.buffer.slice(0, length);
    this.buffer = length === this.buffer.length ? null : this.buffer.slice(length);
    return chunk;
  }
}
PacketReader.ChecksumError = ChecksumError;
PacketReader.MagicError = MagicError;
packetreader.default = PacketReader;
var rollingcounter = {};
Object.defineProperty(rollingcounter, "__esModule", { value: true });
class RollingCounter {
  constructor(max2, min2 = 1) {
    this.max = max2;
    this.min = min2;
    this.now = this.min;
  }
  next() {
    if (!(this.now < this.max)) {
      this.now = this.min;
    }
    return ++this.now;
  }
}
rollingcounter.default = RollingCounter;
var auth = {};
var forge$C = {
  // default options
  options: {
    usePureJavaScript: false
  }
};
var api$1 = {};
var baseN$1 = api$1;
var _reverseAlphabets = {};
api$1.encode = function(input, alphabet, maxline) {
  if (typeof alphabet !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (maxline !== void 0 && typeof maxline !== "number") {
    throw new TypeError('"maxline" must be a number.');
  }
  var output = "";
  if (!(input instanceof Uint8Array)) {
    output = _encodeWithByteBuffer(input, alphabet);
  } else {
    var i = 0;
    var base = alphabet.length;
    var first2 = alphabet.charAt(0);
    var digits = [0];
    for (i = 0; i < input.length; ++i) {
      for (var j = 0, carry = input[i]; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base;
        carry = carry / base | 0;
      }
      while (carry > 0) {
        digits.push(carry % base);
        carry = carry / base | 0;
      }
    }
    for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
      output += first2;
    }
    for (i = digits.length - 1; i >= 0; --i) {
      output += alphabet[digits[i]];
    }
  }
  if (maxline) {
    var regex = new RegExp(".{1," + maxline + "}", "g");
    output = output.match(regex).join("\r\n");
  }
  return output;
};
api$1.decode = function(input, alphabet) {
  if (typeof input !== "string") {
    throw new TypeError('"input" must be a string.');
  }
  if (typeof alphabet !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  var table = _reverseAlphabets[alphabet];
  if (!table) {
    table = _reverseAlphabets[alphabet] = [];
    for (var i = 0; i < alphabet.length; ++i) {
      table[alphabet.charCodeAt(i)] = i;
    }
  }
  input = input.replace(/\s/g, "");
  var base = alphabet.length;
  var first2 = alphabet.charAt(0);
  var bytes2 = [0];
  for (var i = 0; i < input.length; i++) {
    var value = table[input.charCodeAt(i)];
    if (value === void 0) {
      return;
    }
    for (var j = 0, carry = value; j < bytes2.length; ++j) {
      carry += bytes2[j] * base;
      bytes2[j] = carry & 255;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes2.push(carry & 255);
      carry >>= 8;
    }
  }
  for (var k = 0; input[k] === first2 && k < input.length - 1; ++k) {
    bytes2.push(0);
  }
  if (typeof Buffer !== "undefined") {
    return Buffer.from(bytes2.reverse());
  }
  return new Uint8Array(bytes2.reverse());
};
function _encodeWithByteBuffer(input, alphabet) {
  var i = 0;
  var base = alphabet.length;
  var first2 = alphabet.charAt(0);
  var digits = [0];
  for (i = 0; i < input.length(); ++i) {
    for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
      carry += digits[j] << 8;
      digits[j] = carry % base;
      carry = carry / base | 0;
    }
    while (carry > 0) {
      digits.push(carry % base);
      carry = carry / base | 0;
    }
  }
  var output = "";
  for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
    output += first2;
  }
  for (i = digits.length - 1; i >= 0; --i) {
    output += alphabet[digits[i]];
  }
  return output;
}
var forge$B = forge$C;
var baseN = baseN$1;
var util$2 = forge$B.util = forge$B.util || {};
(function() {
  if (typeof process !== "undefined" && process.nextTick && !process.browser) {
    util$2.nextTick = process.nextTick;
    if (typeof setImmediate === "function") {
      util$2.setImmediate = setImmediate;
    } else {
      util$2.setImmediate = util$2.nextTick;
    }
    return;
  }
  if (typeof setImmediate === "function") {
    util$2.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    };
    util$2.nextTick = function(callback) {
      return setImmediate(callback);
    };
    return;
  }
  util$2.setImmediate = function(callback) {
    setTimeout(callback, 0);
  };
  if (typeof window !== "undefined" && typeof window.postMessage === "function") {
    let handler = function(event) {
      if (event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function(callback) {
          callback();
        });
      }
    };
    var msg = "forge.setImmediate";
    var callbacks = [];
    util$2.setImmediate = function(callback) {
      callbacks.push(callback);
      if (callbacks.length === 1) {
        window.postMessage(msg, "*");
      }
    };
    window.addEventListener("message", handler, true);
  }
  if (typeof MutationObserver !== "undefined") {
    var now = Date.now();
    var attr = true;
    var div = document.createElement("div");
    var callbacks = [];
    new MutationObserver(function() {
      var copy = callbacks.slice();
      callbacks.length = 0;
      copy.forEach(function(callback) {
        callback();
      });
    }).observe(div, { attributes: true });
    var oldSetImmediate = util$2.setImmediate;
    util$2.setImmediate = function(callback) {
      if (Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback);
        if (callbacks.length === 1) {
          div.setAttribute("a", attr = !attr);
        }
      }
    };
  }
  util$2.nextTick = util$2.setImmediate;
})();
util$2.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
util$2.globalScope = function() {
  if (util$2.isNodejs) {
    return commonjsGlobal;
  }
  return typeof self === "undefined" ? window : self;
}();
util$2.isArray = Array.isArray || function(x) {
  return Object.prototype.toString.call(x) === "[object Array]";
};
util$2.isArrayBuffer = function(x) {
  return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
};
util$2.isArrayBufferView = function(x) {
  return x && util$2.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
};
function _checkBitsParam(n) {
  if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
    throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
  }
}
util$2.ByteBuffer = ByteStringBuffer;
function ByteStringBuffer(b) {
  this.data = "";
  this.read = 0;
  if (typeof b === "string") {
    this.data = b;
  } else if (util$2.isArrayBuffer(b) || util$2.isArrayBufferView(b)) {
    if (typeof Buffer !== "undefined" && b instanceof Buffer) {
      this.data = b.toString("binary");
    } else {
      var arr = new Uint8Array(b);
      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch (e) {
        for (var i = 0; i < arr.length; ++i) {
          this.putByte(arr[i]);
        }
      }
    }
  } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
    this.data = b.data;
    this.read = b.read;
  }
  this._constructedStringLength = 0;
}
util$2.ByteStringBuffer = ByteStringBuffer;
var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
util$2.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
  this._constructedStringLength += x;
  if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};
util$2.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
util$2.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$2.ByteStringBuffer.prototype.putByte = function(b) {
  return this.putBytes(String.fromCharCode(b));
};
util$2.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
  b = String.fromCharCode(b);
  var d2 = this.data;
  while (n > 0) {
    if (n & 1) {
      d2 += b;
    }
    n >>>= 1;
    if (n > 0) {
      b += b;
    }
  }
  this.data = d2;
  this._optimizeConstructedString(n);
  return this;
};
util$2.ByteStringBuffer.prototype.putBytes = function(bytes2) {
  this.data += bytes2;
  this._optimizeConstructedString(bytes2.length);
  return this;
};
util$2.ByteStringBuffer.prototype.putString = function(str2) {
  return this.putBytes(util$2.encodeUtf8(str2));
};
util$2.ByteStringBuffer.prototype.putInt16 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
  );
};
util$2.ByteStringBuffer.prototype.putInt24 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
  );
};
util$2.ByteStringBuffer.prototype.putInt32 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
  );
};
util$2.ByteStringBuffer.prototype.putInt16Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)
  );
};
util$2.ByteStringBuffer.prototype.putInt24Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)
  );
};
util$2.ByteStringBuffer.prototype.putInt32Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)
  );
};
util$2.ByteStringBuffer.prototype.putInt = function(i, n) {
  _checkBitsParam(n);
  var bytes2 = "";
  do {
    n -= 8;
    bytes2 += String.fromCharCode(i >> n & 255);
  } while (n > 0);
  return this.putBytes(bytes2);
};
util$2.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
  if (i < 0) {
    i += 2 << n - 1;
  }
  return this.putInt(i, n);
};
util$2.ByteStringBuffer.prototype.putBuffer = function(buffer2) {
  return this.putBytes(buffer2.getBytes());
};
util$2.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
util$2.ByteStringBuffer.prototype.getInt16 = function() {
  var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  this.read += 2;
  return rval;
};
util$2.ByteStringBuffer.prototype.getInt24 = function() {
  var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  this.read += 3;
  return rval;
};
util$2.ByteStringBuffer.prototype.getInt32 = function() {
  var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  this.read += 4;
  return rval;
};
util$2.ByteStringBuffer.prototype.getInt16Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  this.read += 2;
  return rval;
};
util$2.ByteStringBuffer.prototype.getInt24Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  this.read += 3;
  return rval;
};
util$2.ByteStringBuffer.prototype.getInt32Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  this.read += 4;
  return rval;
};
util$2.ByteStringBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n -= 8;
  } while (n > 0);
  return rval;
};
util$2.ByteStringBuffer.prototype.getSignedInt = function(n) {
  var x = this.getInt(n);
  var max2 = 2 << n - 2;
  if (x >= max2) {
    x -= max2 << 1;
  }
  return x;
};
util$2.ByteStringBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$2.ByteStringBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$2.ByteStringBuffer.prototype.at = function(i) {
  return this.data.charCodeAt(this.read + i);
};
util$2.ByteStringBuffer.prototype.setAt = function(i, b) {
  this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
  return this;
};
util$2.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
util$2.ByteStringBuffer.prototype.copy = function() {
  var c = util$2.createBuffer(this.data);
  c.read = this.read;
  return c;
};
util$2.ByteStringBuffer.prototype.compact = function() {
  if (this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }
  return this;
};
util$2.ByteStringBuffer.prototype.clear = function() {
  this.data = "";
  this.read = 0;
  return this;
};
util$2.ByteStringBuffer.prototype.truncate = function(count) {
  var len = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len);
  this.read = 0;
  return this;
};
util$2.ByteStringBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i = this.read; i < this.data.length; ++i) {
    var b = this.data.charCodeAt(i);
    if (b < 16) {
      rval += "0";
    }
    rval += b.toString(16);
  }
  return rval;
};
util$2.ByteStringBuffer.prototype.toString = function() {
  return util$2.decodeUtf8(this.bytes());
};
function DataBuffer(b, options2) {
  options2 = options2 || {};
  this.read = options2.readOffset || 0;
  this.growSize = options2.growSize || 1024;
  var isArrayBuffer = util$2.isArrayBuffer(b);
  var isArrayBufferView = util$2.isArrayBufferView(b);
  if (isArrayBuffer || isArrayBufferView) {
    if (isArrayBuffer) {
      this.data = new DataView(b);
    } else {
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }
    this.write = "writeOffset" in options2 ? options2.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;
  if (b !== null && b !== void 0) {
    this.putBytes(b);
  }
  if ("writeOffset" in options2) {
    this.write = options2.writeOffset;
  }
}
util$2.DataBuffer = DataBuffer;
util$2.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
util$2.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$2.DataBuffer.prototype.accommodate = function(amount, growSize) {
  if (this.length() >= amount) {
    return this;
  }
  growSize = Math.max(growSize || this.growSize, amount);
  var src2 = new Uint8Array(
    this.data.buffer,
    this.data.byteOffset,
    this.data.byteLength
  );
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src2);
  this.data = new DataView(dst.buffer);
  return this;
};
util$2.DataBuffer.prototype.putByte = function(b) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b);
  return this;
};
util$2.DataBuffer.prototype.fillWithByte = function(b, n) {
  this.accommodate(n);
  for (var i = 0; i < n; ++i) {
    this.data.setUint8(b);
  }
  return this;
};
util$2.DataBuffer.prototype.putBytes = function(bytes2, encoding3) {
  if (util$2.isArrayBufferView(bytes2)) {
    var src2 = new Uint8Array(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    var len = src2.byteLength - src2.byteOffset;
    this.accommodate(len);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src2);
    this.write += len;
    return this;
  }
  if (util$2.isArrayBuffer(bytes2)) {
    var src2 = new Uint8Array(bytes2);
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src2, this.write);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes2 instanceof util$2.DataBuffer || typeof bytes2 === "object" && typeof bytes2.read === "number" && typeof bytes2.write === "number" && util$2.isArrayBufferView(bytes2.data)) {
    var src2 = new Uint8Array(bytes2.data.byteLength, bytes2.read, bytes2.length());
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(bytes2.data.byteLength, this.write);
    dst.set(src2);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes2 instanceof util$2.ByteStringBuffer) {
    bytes2 = bytes2.data;
    encoding3 = "binary";
  }
  encoding3 = encoding3 || "binary";
  if (typeof bytes2 === "string") {
    var view2;
    if (encoding3 === "hex") {
      this.accommodate(Math.ceil(bytes2.length / 2));
      view2 = new Uint8Array(this.data.buffer, this.write);
      this.write += util$2.binary.hex.decode(bytes2, view2, this.write);
      return this;
    }
    if (encoding3 === "base64") {
      this.accommodate(Math.ceil(bytes2.length / 4) * 3);
      view2 = new Uint8Array(this.data.buffer, this.write);
      this.write += util$2.binary.base64.decode(bytes2, view2, this.write);
      return this;
    }
    if (encoding3 === "utf8") {
      bytes2 = util$2.encodeUtf8(bytes2);
      encoding3 = "binary";
    }
    if (encoding3 === "binary" || encoding3 === "raw") {
      this.accommodate(bytes2.length);
      view2 = new Uint8Array(this.data.buffer, this.write);
      this.write += util$2.binary.raw.decode(view2);
      return this;
    }
    if (encoding3 === "utf16") {
      this.accommodate(bytes2.length * 2);
      view2 = new Uint16Array(this.data.buffer, this.write);
      this.write += util$2.text.utf16.encode(view2);
      return this;
    }
    throw new Error("Invalid encoding: " + encoding3);
  }
  throw Error("Invalid parameter: " + bytes2);
};
util$2.DataBuffer.prototype.putBuffer = function(buffer2) {
  this.putBytes(buffer2);
  buffer2.clear();
  return this;
};
util$2.DataBuffer.prototype.putString = function(str2) {
  return this.putBytes(str2, "utf16");
};
util$2.DataBuffer.prototype.putInt16 = function(i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i);
  this.write += 2;
  return this;
};
util$2.DataBuffer.prototype.putInt24 = function(i) {
  this.accommodate(3);
  this.data.setInt16(this.write, i >> 8 & 65535);
  this.data.setInt8(this.write, i >> 16 & 255);
  this.write += 3;
  return this;
};
util$2.DataBuffer.prototype.putInt32 = function(i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i);
  this.write += 4;
  return this;
};
util$2.DataBuffer.prototype.putInt16Le = function(i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i, true);
  this.write += 2;
  return this;
};
util$2.DataBuffer.prototype.putInt24Le = function(i) {
  this.accommodate(3);
  this.data.setInt8(this.write, i >> 16 & 255);
  this.data.setInt16(this.write, i >> 8 & 65535, true);
  this.write += 3;
  return this;
};
util$2.DataBuffer.prototype.putInt32Le = function(i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i, true);
  this.write += 4;
  return this;
};
util$2.DataBuffer.prototype.putInt = function(i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  do {
    n -= 8;
    this.data.setInt8(this.write++, i >> n & 255);
  } while (n > 0);
  return this;
};
util$2.DataBuffer.prototype.putSignedInt = function(i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  if (i < 0) {
    i += 2 << n - 1;
  }
  return this.putInt(i, n);
};
util$2.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
util$2.DataBuffer.prototype.getInt16 = function() {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};
util$2.DataBuffer.prototype.getInt24 = function() {
  var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  this.read += 3;
  return rval;
};
util$2.DataBuffer.prototype.getInt32 = function() {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};
util$2.DataBuffer.prototype.getInt16Le = function() {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};
util$2.DataBuffer.prototype.getInt24Le = function() {
  var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
  this.read += 3;
  return rval;
};
util$2.DataBuffer.prototype.getInt32Le = function() {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};
util$2.DataBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n -= 8;
  } while (n > 0);
  return rval;
};
util$2.DataBuffer.prototype.getSignedInt = function(n) {
  var x = this.getInt(n);
  var max2 = 2 << n - 2;
  if (x >= max2) {
    x -= max2 << 1;
  }
  return x;
};
util$2.DataBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$2.DataBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$2.DataBuffer.prototype.at = function(i) {
  return this.data.getUint8(this.read + i);
};
util$2.DataBuffer.prototype.setAt = function(i, b) {
  this.data.setUint8(i, b);
  return this;
};
util$2.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
util$2.DataBuffer.prototype.copy = function() {
  return new util$2.DataBuffer(this);
};
util$2.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var src2 = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src2.byteLength);
    dst.set(src2);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }
  return this;
};
util$2.DataBuffer.prototype.clear = function() {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};
util$2.DataBuffer.prototype.truncate = function(count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};
util$2.DataBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i = this.read; i < this.data.byteLength; ++i) {
    var b = this.data.getUint8(i);
    if (b < 16) {
      rval += "0";
    }
    rval += b.toString(16);
  }
  return rval;
};
util$2.DataBuffer.prototype.toString = function(encoding3) {
  var view2 = new Uint8Array(this.data, this.read, this.length());
  encoding3 = encoding3 || "utf8";
  if (encoding3 === "binary" || encoding3 === "raw") {
    return util$2.binary.raw.encode(view2);
  }
  if (encoding3 === "hex") {
    return util$2.binary.hex.encode(view2);
  }
  if (encoding3 === "base64") {
    return util$2.binary.base64.encode(view2);
  }
  if (encoding3 === "utf8") {
    return util$2.text.utf8.decode(view2);
  }
  if (encoding3 === "utf16") {
    return util$2.text.utf16.decode(view2);
  }
  throw new Error("Invalid encoding: " + encoding3);
};
util$2.createBuffer = function(input, encoding3) {
  encoding3 = encoding3 || "raw";
  if (input !== void 0 && encoding3 === "utf8") {
    input = util$2.encodeUtf8(input);
  }
  return new util$2.ByteBuffer(input);
};
util$2.fillString = function(c, n) {
  var s2 = "";
  while (n > 0) {
    if (n & 1) {
      s2 += c;
    }
    n >>>= 1;
    if (n > 0) {
      c += c;
    }
  }
  return s2;
};
util$2.xorBytes = function(s1, s2, n) {
  var s3 = "";
  var b = "";
  var t2 = "";
  var i = 0;
  var c = 0;
  for (; n > 0; --n, ++i) {
    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
    if (c >= 10) {
      s3 += t2;
      t2 = "";
      c = 0;
    }
    t2 += String.fromCharCode(b);
    ++c;
  }
  s3 += t2;
  return s3;
};
util$2.hexToBytes = function(hex) {
  var rval = "";
  var i = 0;
  if (hex.length & true) {
    i = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  }
  for (; i < hex.length; i += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return rval;
};
util$2.bytesToHex = function(bytes2) {
  return util$2.createBuffer(bytes2).toHex();
};
util$2.int32ToBytes = function(i) {
  return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
};
var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var _base64Idx = [
  /*43 -43 = 0*/
  /*'+',  1,  2,  3,'/' */
  62,
  -1,
  -1,
  -1,
  63,
  /*'0','1','2','3','4','5','6','7','8','9' */
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  /*15, 16, 17,'=', 19, 20, 21 */
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  /*65 - 43 = 22*/
  /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  /*91 - 43 = 48 */
  /*48, 49, 50, 51, 52, 53 */
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  /*97 - 43 = 54*/
  /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
util$2.encode64 = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i = 0;
  while (i < input.length) {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$2.decode64 = function(input) {
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var output = "";
  var enc1, enc2, enc3, enc4;
  var i = 0;
  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
    if (enc3 !== 64) {
      output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
      if (enc4 !== 64) {
        output += String.fromCharCode((enc3 & 3) << 6 | enc4);
      }
    }
  }
  return output;
};
util$2.encodeUtf8 = function(str2) {
  return unescape(encodeURIComponent(str2));
};
util$2.decodeUtf8 = function(str2) {
  return decodeURIComponent(escape(str2));
};
util$2.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: baseN.encode,
    decode: baseN.decode
  }
};
util$2.binary.raw.encode = function(bytes2) {
  return String.fromCharCode.apply(null, bytes2);
};
util$2.binary.raw.decode = function(str2, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str2.length);
  }
  offset = offset || 0;
  var j = offset;
  for (var i = 0; i < str2.length; ++i) {
    out[j++] = str2.charCodeAt(i);
  }
  return output ? j - offset : out;
};
util$2.binary.hex.encode = util$2.bytesToHex;
util$2.binary.hex.decode = function(hex, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }
  offset = offset || 0;
  var i = 0, j = offset;
  if (hex.length & 1) {
    i = 1;
    out[j++] = parseInt(hex[0], 16);
  }
  for (; i < hex.length; i += 2) {
    out[j++] = parseInt(hex.substr(i, 2), 16);
  }
  return output ? j - offset : out;
};
util$2.binary.base64.encode = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i = 0;
  while (i < input.byteLength) {
    chr1 = input[i++];
    chr2 = input[i++];
    chr3 = input[i++];
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$2.binary.base64.decode = function(input, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i = 0, j = offset;
  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    out[j++] = enc1 << 2 | enc2 >> 4;
    if (enc3 !== 64) {
      out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
      if (enc4 !== 64) {
        out[j++] = (enc3 & 3) << 6 | enc4;
      }
    }
  }
  return output ? j - offset : out.subarray(0, j);
};
util$2.binary.base58.encode = function(input, maxline) {
  return util$2.binary.baseN.encode(input, _base58, maxline);
};
util$2.binary.base58.decode = function(input, maxline) {
  return util$2.binary.baseN.decode(input, _base58, maxline);
};
util$2.text = {
  utf8: {},
  utf16: {}
};
util$2.text.utf8.encode = function(str2, output, offset) {
  str2 = util$2.encodeUtf8(str2);
  var out = output;
  if (!out) {
    out = new Uint8Array(str2.length);
  }
  offset = offset || 0;
  var j = offset;
  for (var i = 0; i < str2.length; ++i) {
    out[j++] = str2.charCodeAt(i);
  }
  return output ? j - offset : out;
};
util$2.text.utf8.decode = function(bytes2) {
  return util$2.decodeUtf8(String.fromCharCode.apply(null, bytes2));
};
util$2.text.utf16.encode = function(str2, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str2.length * 2);
  }
  var view2 = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j = offset;
  var k = offset;
  for (var i = 0; i < str2.length; ++i) {
    view2[k++] = str2.charCodeAt(i);
    j += 2;
  }
  return output ? j - offset : out;
};
util$2.text.utf16.decode = function(bytes2) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes2.buffer));
};
util$2.deflate = function(api2, bytes2, raw) {
  bytes2 = util$2.decode64(api2.deflate(util$2.encode64(bytes2)).rval);
  if (raw) {
    var start = 2;
    var flg = bytes2.charCodeAt(1);
    if (flg & 32) {
      start = 6;
    }
    bytes2 = bytes2.substring(start, bytes2.length - 4);
  }
  return bytes2;
};
util$2.inflate = function(api2, bytes2, raw) {
  var rval = api2.inflate(util$2.encode64(bytes2)).rval;
  return rval === null ? null : util$2.decode64(rval);
};
var _setStorageObject = function(api2, id, obj) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval;
  if (obj === null) {
    rval = api2.removeItem(id);
  } else {
    obj = util$2.encode64(JSON.stringify(obj));
    rval = api2.setItem(id, obj);
  }
  if (typeof rval !== "undefined" && rval.rval !== true) {
    var error2 = new Error(rval.error.message);
    error2.id = rval.error.id;
    error2.name = rval.error.name;
    throw error2;
  }
};
var _getStorageObject = function(api2, id) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval = api2.getItem(id);
  if (api2.init) {
    if (rval.rval === null) {
      if (rval.error) {
        var error2 = new Error(rval.error.message);
        error2.id = rval.error.id;
        error2.name = rval.error.name;
        throw error2;
      }
      rval = null;
    } else {
      rval = rval.rval;
    }
  }
  if (rval !== null) {
    rval = JSON.parse(util$2.decode64(rval));
  }
  return rval;
};
var _setItem = function(api2, id, key, data) {
  var obj = _getStorageObject(api2, id);
  if (obj === null) {
    obj = {};
  }
  obj[key] = data;
  _setStorageObject(api2, id, obj);
};
var _getItem = function(api2, id, key) {
  var rval = _getStorageObject(api2, id);
  if (rval !== null) {
    rval = key in rval ? rval[key] : null;
  }
  return rval;
};
var _removeItem = function(api2, id, key) {
  var obj = _getStorageObject(api2, id);
  if (obj !== null && key in obj) {
    delete obj[key];
    var empty = true;
    for (var prop in obj) {
      empty = false;
      break;
    }
    if (empty) {
      obj = null;
    }
    _setStorageObject(api2, id, obj);
  }
};
var _clearItems = function(api2, id) {
  _setStorageObject(api2, id, null);
};
var _callStorageFunction = function(func2, args, location2) {
  var rval = null;
  if (typeof location2 === "undefined") {
    location2 = ["web", "flash"];
  }
  var type3;
  var done = false;
  var exception2 = null;
  for (var idx in location2) {
    type3 = location2[idx];
    try {
      if (type3 === "flash" || type3 === "both") {
        if (args[0] === null) {
          throw new Error("Flash local storage not available.");
        }
        rval = func2.apply(this, args);
        done = type3 === "flash";
      }
      if (type3 === "web" || type3 === "both") {
        args[0] = localStorage;
        rval = func2.apply(this, args);
        done = true;
      }
    } catch (ex) {
      exception2 = ex;
    }
    if (done) {
      break;
    }
  }
  if (!done) {
    throw exception2;
  }
  return rval;
};
util$2.setItem = function(api2, id, key, data, location2) {
  _callStorageFunction(_setItem, arguments, location2);
};
util$2.getItem = function(api2, id, key, location2) {
  return _callStorageFunction(_getItem, arguments, location2);
};
util$2.removeItem = function(api2, id, key, location2) {
  _callStorageFunction(_removeItem, arguments, location2);
};
util$2.clearItems = function(api2, id, location2) {
  _callStorageFunction(_clearItems, arguments, location2);
};
util$2.isEmpty = function(obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};
util$2.format = function(format2) {
  var re2 = /%./g;
  var match2;
  var part;
  var argi = 0;
  var parts = [];
  var last = 0;
  while (match2 = re2.exec(format2)) {
    part = format2.substring(last, re2.lastIndex - 2);
    if (part.length > 0) {
      parts.push(part);
    }
    last = re2.lastIndex;
    var code = match2[0][1];
    switch (code) {
      case "s":
      case "o":
        if (argi < arguments.length) {
          parts.push(arguments[argi++ + 1]);
        } else {
          parts.push("<?>");
        }
        break;
      case "%":
        parts.push("%");
        break;
      default:
        parts.push("<%" + code + "?>");
    }
  }
  parts.push(format2.substring(last));
  return parts.join("");
};
util$2.formatNumber = function(number2, decimals, dec_point, thousands_sep) {
  var n = number2, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d2 = dec_point === void 0 ? "," : dec_point;
  var t2 = thousands_sep === void 0 ? "." : thousands_sep, s2 = n < 0 ? "-" : "";
  var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
  var j = i.length > 3 ? i.length % 3 : 0;
  return s2 + (j ? i.substr(0, j) + t2 : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t2) + (c ? d2 + Math.abs(n - i).toFixed(c).slice(2) : "");
};
util$2.formatSize = function(size) {
  if (size >= 1073741824) {
    size = util$2.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
  } else if (size >= 1048576) {
    size = util$2.formatNumber(size / 1048576, 2, ".", "") + " MiB";
  } else if (size >= 1024) {
    size = util$2.formatNumber(size / 1024, 0) + " KiB";
  } else {
    size = util$2.formatNumber(size, 0) + " bytes";
  }
  return size;
};
util$2.bytesFromIP = function(ip2) {
  if (ip2.indexOf(".") !== -1) {
    return util$2.bytesFromIPv4(ip2);
  }
  if (ip2.indexOf(":") !== -1) {
    return util$2.bytesFromIPv6(ip2);
  }
  return null;
};
util$2.bytesFromIPv4 = function(ip2) {
  ip2 = ip2.split(".");
  if (ip2.length !== 4) {
    return null;
  }
  var b = util$2.createBuffer();
  for (var i = 0; i < ip2.length; ++i) {
    var num = parseInt(ip2[i], 10);
    if (isNaN(num)) {
      return null;
    }
    b.putByte(num);
  }
  return b.getBytes();
};
util$2.bytesFromIPv6 = function(ip2) {
  var blanks = 0;
  ip2 = ip2.split(":").filter(function(e) {
    if (e.length === 0) ++blanks;
    return true;
  });
  var zeros = (8 - ip2.length + blanks) * 2;
  var b = util$2.createBuffer();
  for (var i = 0; i < 8; ++i) {
    if (!ip2[i] || ip2[i].length === 0) {
      b.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }
    var bytes2 = util$2.hexToBytes(ip2[i]);
    if (bytes2.length < 2) {
      b.putByte(0);
    }
    b.putBytes(bytes2);
  }
  return b.getBytes();
};
util$2.bytesToIP = function(bytes2) {
  if (bytes2.length === 4) {
    return util$2.bytesToIPv4(bytes2);
  }
  if (bytes2.length === 16) {
    return util$2.bytesToIPv6(bytes2);
  }
  return null;
};
util$2.bytesToIPv4 = function(bytes2) {
  if (bytes2.length !== 4) {
    return null;
  }
  var ip2 = [];
  for (var i = 0; i < bytes2.length; ++i) {
    ip2.push(bytes2.charCodeAt(i));
  }
  return ip2.join(".");
};
util$2.bytesToIPv6 = function(bytes2) {
  if (bytes2.length !== 16) {
    return null;
  }
  var ip2 = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;
  for (var i = 0; i < bytes2.length; i += 2) {
    var hex = util$2.bytesToHex(bytes2[i] + bytes2[i + 1]);
    while (hex[0] === "0" && hex !== "0") {
      hex = hex.substr(1);
    }
    if (hex === "0") {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip2.length;
      if (!last || idx !== last.end + 1) {
        zeroGroups.push({ start: idx, end: idx });
      } else {
        last.end = idx;
        if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }
    ip2.push(hex);
  }
  if (zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup];
    if (group.end - group.start > 0) {
      ip2.splice(group.start, group.end - group.start + 1, "");
      if (group.start === 0) {
        ip2.unshift("");
      }
      if (group.end === 7) {
        ip2.push("");
      }
    }
  }
  return ip2.join(":");
};
util$2.estimateCores = function(options2, callback) {
  if (typeof options2 === "function") {
    callback = options2;
    options2 = {};
  }
  options2 = options2 || {};
  if ("cores" in util$2 && !options2.update) {
    return callback(null, util$2.cores);
  }
  if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
    util$2.cores = navigator.hardwareConcurrency;
    return callback(null, util$2.cores);
  }
  if (typeof Worker === "undefined") {
    util$2.cores = 1;
    return callback(null, util$2.cores);
  }
  if (typeof Blob === "undefined") {
    util$2.cores = 2;
    return callback(null, util$2.cores);
  }
  var blobUrl = URL.createObjectURL(new Blob([
    "(",
    (function() {
      self.addEventListener("message", function(e) {
        var st = Date.now();
        var et = st + 4;
        self.postMessage({ st, et });
      });
    }).toString(),
    ")()"
  ], { type: "application/javascript" }));
  sample([], 5, 16);
  function sample(max2, samples, numWorkers) {
    if (samples === 0) {
      var avg = Math.floor(max2.reduce(function(avg2, x) {
        return avg2 + x;
      }, 0) / max2.length);
      util$2.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util$2.cores);
    }
    map2(numWorkers, function(err, results) {
      max2.push(reduce2(numWorkers, results));
      sample(max2, samples - 1, numWorkers);
    });
  }
  function map2(numWorkers, callback2) {
    var workers = [];
    var results = [];
    for (var i = 0; i < numWorkers; ++i) {
      var worker = new Worker(blobUrl);
      worker.addEventListener("message", function(e) {
        results.push(e.data);
        if (results.length === numWorkers) {
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].terminate();
          }
          callback2(null, results);
        }
      });
      workers.push(worker);
    }
    for (var i = 0; i < numWorkers; ++i) {
      workers[i].postMessage(i);
    }
  }
  function reduce2(numWorkers, results) {
    var overlaps = [];
    for (var n = 0; n < numWorkers; ++n) {
      var r1 = results[n];
      var overlap = overlaps[n] = [];
      for (var i = 0; i < numWorkers; ++i) {
        if (n === i) {
          continue;
        }
        var r2 = results[i];
        if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
          overlap.push(i);
        }
      }
    }
    return overlaps.reduce(function(max2, overlap2) {
      return Math.max(max2, overlap2.length);
    }, 0);
  }
};
var forge$A = forge$C;
forge$A.cipher = forge$A.cipher || {};
forge$A.cipher.algorithms = forge$A.cipher.algorithms || {};
forge$A.cipher.createCipher = function(algorithm, key) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$A.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$A.cipher.BlockCipher({
    algorithm: api2,
    key,
    decrypt: false
  });
};
forge$A.cipher.createDecipher = function(algorithm, key) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$A.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$A.cipher.BlockCipher({
    algorithm: api2,
    key,
    decrypt: true
  });
};
forge$A.cipher.registerAlgorithm = function(name, algorithm) {
  name = name.toUpperCase();
  forge$A.cipher.algorithms[name] = algorithm;
};
forge$A.cipher.getAlgorithm = function(name) {
  name = name.toUpperCase();
  if (name in forge$A.cipher.algorithms) {
    return forge$A.cipher.algorithms[name];
  }
  return null;
};
var BlockCipher = forge$A.cipher.BlockCipher = function(options2) {
  this.algorithm = options2.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options2.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options2.decrypt;
  this.algorithm.initialize(options2);
};
BlockCipher.prototype.start = function(options2) {
  options2 = options2 || {};
  var opts = {};
  for (var key in options2) {
    opts[key] = options2[key];
  }
  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge$A.util.createBuffer();
  this.output = options2.output || forge$A.util.createBuffer();
  this.mode.start(opts);
};
BlockCipher.prototype.update = function(input) {
  if (input) {
    this._input.putBuffer(input);
  }
  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
  }
  this._input.compact();
};
BlockCipher.prototype.finish = function(pad) {
  if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
    this.mode.pad = function(input) {
      return pad(this.blockSize, input, false);
    };
    this.mode.unpad = function(output) {
      return pad(this.blockSize, output, true);
    };
  }
  var options2 = {};
  options2.decrypt = this._decrypt;
  options2.overflow = this._input.length() % this.blockSize;
  if (!this._decrypt && this.mode.pad) {
    if (!this.mode.pad(this._input, options2)) {
      return false;
    }
  }
  this._finish = true;
  this.update();
  if (this._decrypt && this.mode.unpad) {
    if (!this.mode.unpad(this.output, options2)) {
      return false;
    }
  }
  if (this.mode.afterFinish) {
    if (!this.mode.afterFinish(this.output, options2)) {
      return false;
    }
  }
  return true;
};
var forge$z = forge$C;
forge$z.cipher = forge$z.cipher || {};
var modes = forge$z.cipher.modes = forge$z.cipher.modes || {};
modes.ecb = function(options2) {
  options2 = options2 || {};
  this.name = "ECB";
  this.cipher = options2.cipher;
  this.blockSize = options2.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes.ecb.prototype.start = function(options2) {
};
modes.ecb.prototype.encrypt = function(input, output, finish) {
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }
  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};
modes.ecb.prototype.decrypt = function(input, output, finish) {
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }
  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};
modes.ecb.prototype.pad = function(input, options2) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes.ecb.prototype.unpad = function(output, options2) {
  if (options2.overflow > 0) {
    return false;
  }
  var len = output.length();
  var count = output.at(len - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes.cbc = function(options2) {
  options2 = options2 || {};
  this.name = "CBC";
  this.cipher = options2.cipher;
  this.blockSize = options2.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes.cbc.prototype.start = function(options2) {
  if (options2.iv === null) {
    if (!this._prev) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = this._prev.slice(0);
  } else if (!("iv" in options2)) {
    throw new Error("Invalid IV parameter.");
  } else {
    this._iv = transformIV(options2.iv, this.blockSize);
    this._prev = this._iv.slice(0);
  }
};
modes.cbc.prototype.encrypt = function(input, output, finish) {
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }
  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = this._prev[i] ^ input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
  this._prev = this._outBlock;
};
modes.cbc.prototype.decrypt = function(input, output, finish) {
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }
  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._prev[i] ^ this._outBlock[i]);
  }
  this._prev = this._inBlock.slice(0);
};
modes.cbc.prototype.pad = function(input, options2) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes.cbc.prototype.unpad = function(output, options2) {
  if (options2.overflow > 0) {
    return false;
  }
  var len = output.length();
  var count = output.at(len - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes.cfb = function(options2) {
  options2 = options2 || {};
  this.name = "CFB";
  this.cipher = options2.cipher;
  this.blockSize = options2.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialBlock = new Array(this._ints);
  this._partialOutput = forge$z.util.createBuffer();
  this._partialBytes = 0;
};
modes.cfb.prototype.start = function(options2) {
  if (!("iv" in options2)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options2.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.cfb.prototype.encrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
      output.putInt32(this._inBlock[i]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
    this._partialOutput.putInt32(this._partialBlock[i]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes
    ));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes
  ));
  this._partialBytes = 0;
};
modes.cfb.prototype.decrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32();
    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes
    ));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes
  ));
  this._partialBytes = 0;
};
modes.ofb = function(options2) {
  options2 = options2 || {};
  this.name = "OFB";
  this.cipher = options2.cipher;
  this.blockSize = options2.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$z.util.createBuffer();
  this._partialBytes = 0;
};
modes.ofb.prototype.start = function(options2) {
  if (!("iv" in options2)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options2.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.ofb.prototype.encrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (input.length() === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
      this._inBlock[i] = this._outBlock[i];
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i = 0; i < this._ints; ++i) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._outBlock[i];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes
    ));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes
  ));
  this._partialBytes = 0;
};
modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
modes.ctr = function(options2) {
  options2 = options2 || {};
  this.name = "CTR";
  this.cipher = options2.cipher;
  this.blockSize = options2.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$z.util.createBuffer();
  this._partialBytes = 0;
};
modes.ctr.prototype.start = function(options2) {
  if (!("iv" in options2)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options2.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.ctr.prototype.encrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes
      ));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes
    ));
    this._partialBytes = 0;
  }
  inc32(this._inBlock);
};
modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
modes.gcm = function(options2) {
  options2 = options2 || {};
  this.name = "GCM";
  this.cipher = options2.cipher;
  this.blockSize = options2.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$z.util.createBuffer();
  this._partialBytes = 0;
  this._R = 3774873600;
};
modes.gcm.prototype.start = function(options2) {
  if (!("iv" in options2)) {
    throw new Error("Invalid IV parameter.");
  }
  var iv = forge$z.util.createBuffer(options2.iv);
  this._cipherLength = 0;
  var additionalData;
  if ("additionalData" in options2) {
    additionalData = forge$z.util.createBuffer(options2.additionalData);
  } else {
    additionalData = forge$z.util.createBuffer();
  }
  if ("tagLength" in options2) {
    this._tagLength = options2.tagLength;
  } else {
    this._tagLength = 128;
  }
  this._tag = null;
  if (options2.decrypt) {
    this._tag = forge$z.util.createBuffer(options2.tag).getBytes();
    if (this._tag.length !== this._tagLength / 8) {
      throw new Error("Authentication tag does not match tag length.");
    }
  }
  this._hashBlock = new Array(this._ints);
  this.tag = null;
  this._hashSubkey = new Array(this._ints);
  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
  this.componentBits = 4;
  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var ivLength = iv.length();
  if (ivLength === 12) {
    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
  } else {
    this._j0 = [0, 0, 0, 0];
    while (iv.length() > 0) {
      this._j0 = this.ghash(
        this._hashSubkey,
        this._j0,
        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
      );
    }
    this._j0 = this.ghash(
      this._hashSubkey,
      this._j0,
      [0, 0].concat(from64To32(ivLength * 8))
    );
  }
  this._inBlock = this._j0.slice(0);
  inc32(this._inBlock);
  this._partialBytes = 0;
  additionalData = forge$z.util.createBuffer(additionalData);
  this._aDataLength = from64To32(additionalData.length() * 8);
  var overflow = additionalData.length() % this.blockSize;
  if (overflow) {
    additionalData.fillWithByte(0, this.blockSize - overflow);
  }
  this._s = [0, 0, 0, 0];
  while (additionalData.length() > 0) {
    this._s = this.ghash(this._hashSubkey, this._s, [
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32()
    ]);
  }
};
modes.gcm.prototype.encrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i] ^= input.getInt32());
    }
    this._cipherLength += this.blockSize;
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
    if (partialBytes <= 0 || finish) {
      if (finish) {
        var overflow = inputLength % this.blockSize;
        this._cipherLength += overflow;
        this._partialOutput.truncate(this.blockSize - overflow);
      } else {
        this._cipherLength += this.blockSize;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._outBlock[i] = this._partialOutput.getInt32();
      }
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      input.read -= this.blockSize;
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes
      ));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes
    ));
    this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
  inc32(this._inBlock);
};
modes.gcm.prototype.decrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  inc32(this._inBlock);
  this._hashBlock[0] = input.getInt32();
  this._hashBlock[1] = input.getInt32();
  this._hashBlock[2] = input.getInt32();
  this._hashBlock[3] = input.getInt32();
  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
  }
  if (inputLength < this.blockSize) {
    this._cipherLength += inputLength % this.blockSize;
  } else {
    this._cipherLength += this.blockSize;
  }
};
modes.gcm.prototype.afterFinish = function(output, options2) {
  var rval = true;
  if (options2.decrypt && options2.overflow) {
    output.truncate(this.blockSize - options2.overflow);
  }
  this.tag = forge$z.util.createBuffer();
  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, lengths);
  var tag = [];
  this.cipher.encrypt(this._j0, tag);
  for (var i = 0; i < this._ints; ++i) {
    this.tag.putInt32(this._s[i] ^ tag[i]);
  }
  this.tag.truncate(this.tag.length() % (this._tagLength / 8));
  if (options2.decrypt && this.tag.bytes() !== this._tag) {
    rval = false;
  }
  return rval;
};
modes.gcm.prototype.multiply = function(x, y2) {
  var z_i = [0, 0, 0, 0];
  var v_i = y2.slice(0);
  for (var i = 0; i < 128; ++i) {
    var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
    if (x_i) {
      z_i[0] ^= v_i[0];
      z_i[1] ^= v_i[1];
      z_i[2] ^= v_i[2];
      z_i[3] ^= v_i[3];
    }
    this.pow(v_i, v_i);
  }
  return z_i;
};
modes.gcm.prototype.pow = function(x, out) {
  var lsb = x[3] & 1;
  for (var i = 3; i > 0; --i) {
    out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
  }
  out[0] = x[0] >>> 1;
  if (lsb) {
    out[0] ^= this._R;
  }
};
modes.gcm.prototype.tableMultiply = function(x) {
  var z2 = [0, 0, 0, 0];
  for (var i = 0; i < 32; ++i) {
    var idx = i / 8 | 0;
    var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
    var ah = this._m[i][x_i];
    z2[0] ^= ah[0];
    z2[1] ^= ah[1];
    z2[2] ^= ah[2];
    z2[3] ^= ah[3];
  }
  return z2;
};
modes.gcm.prototype.ghash = function(h2, y2, x) {
  y2[0] ^= x[0];
  y2[1] ^= x[1];
  y2[2] ^= x[2];
  y2[3] ^= x[3];
  return this.tableMultiply(y2);
};
modes.gcm.prototype.generateHashTable = function(h2, bits) {
  var multiplier = 8 / bits;
  var perInt = 4 * multiplier;
  var size = 16 * multiplier;
  var m2 = new Array(size);
  for (var i = 0; i < size; ++i) {
    var tmp = [0, 0, 0, 0];
    var idx = i / perInt | 0;
    var shft = (perInt - 1 - i % perInt) * bits;
    tmp[idx] = 1 << bits - 1 << shft;
    m2[i] = this.generateSubHashTable(this.multiply(tmp, h2), bits);
  }
  return m2;
};
modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
  var size = 1 << bits;
  var half = size >>> 1;
  var m2 = new Array(size);
  m2[half] = mid.slice(0);
  var i = half >>> 1;
  while (i > 0) {
    this.pow(m2[2 * i], m2[i] = []);
    i >>= 1;
  }
  i = 2;
  while (i < half) {
    for (var j = 1; j < i; ++j) {
      var m_i = m2[i];
      var m_j = m2[j];
      m2[i + j] = [
        m_i[0] ^ m_j[0],
        m_i[1] ^ m_j[1],
        m_i[2] ^ m_j[2],
        m_i[3] ^ m_j[3]
      ];
    }
    i *= 2;
  }
  m2[0] = [0, 0, 0, 0];
  for (i = half + 1; i < size; ++i) {
    var c = m2[i ^ half];
    m2[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
  }
  return m2;
};
function transformIV(iv, blockSize) {
  if (typeof iv === "string") {
    iv = forge$z.util.createBuffer(iv);
  }
  if (forge$z.util.isArray(iv) && iv.length > 4) {
    var tmp = iv;
    iv = forge$z.util.createBuffer();
    for (var i = 0; i < tmp.length; ++i) {
      iv.putByte(tmp[i]);
    }
  }
  if (iv.length() < blockSize) {
    throw new Error(
      "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
    );
  }
  if (!forge$z.util.isArray(iv)) {
    var ints = [];
    var blocks = blockSize / 4;
    for (var i = 0; i < blocks; ++i) {
      ints.push(iv.getInt32());
    }
    iv = ints;
  }
  return iv;
}
function inc32(block) {
  block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
}
function from64To32(num) {
  return [num / 4294967296 | 0, num & 4294967295];
}
var forge$y = forge$C;
forge$y.aes = forge$y.aes || {};
forge$y.aes.startEncrypting = function(key, iv, output, mode) {
  var cipher = _createCipher$1({
    key,
    output,
    decrypt: false,
    mode
  });
  cipher.start(iv);
  return cipher;
};
forge$y.aes.createEncryptionCipher = function(key, mode) {
  return _createCipher$1({
    key,
    output: null,
    decrypt: false,
    mode
  });
};
forge$y.aes.startDecrypting = function(key, iv, output, mode) {
  var cipher = _createCipher$1({
    key,
    output,
    decrypt: true,
    mode
  });
  cipher.start(iv);
  return cipher;
};
forge$y.aes.createDecryptionCipher = function(key, mode) {
  return _createCipher$1({
    key,
    output: null,
    decrypt: true,
    mode
  });
};
forge$y.aes.Algorithm = function(name, mode) {
  if (!init) {
    initialize();
  }
  var self2 = this;
  self2.name = name;
  self2.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock$1(self2._w, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock$1(self2._w, inBlock, outBlock, true);
      }
    }
  });
  self2._init = false;
};
forge$y.aes.Algorithm.prototype.initialize = function(options2) {
  if (this._init) {
    return;
  }
  var key = options2.key;
  var tmp;
  if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
    key = forge$y.util.createBuffer(key);
  } else if (forge$y.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
    tmp = key;
    key = forge$y.util.createBuffer();
    for (var i = 0; i < tmp.length; ++i) {
      key.putByte(tmp[i]);
    }
  }
  if (!forge$y.util.isArray(key)) {
    tmp = key;
    key = [];
    var len = tmp.length();
    if (len === 16 || len === 24 || len === 32) {
      len = len >>> 2;
      for (var i = 0; i < len; ++i) {
        key.push(tmp.getInt32());
      }
    }
  }
  if (!forge$y.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
    throw new Error("Invalid key parameter.");
  }
  var mode = this.mode.name;
  var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
  this._w = _expandKey(key, options2.decrypt && !encryptOp);
  this._init = true;
};
forge$y.aes._expandKey = function(key, decrypt2) {
  if (!init) {
    initialize();
  }
  return _expandKey(key, decrypt2);
};
forge$y.aes._updateBlock = _updateBlock$1;
registerAlgorithm$1("AES-ECB", forge$y.cipher.modes.ecb);
registerAlgorithm$1("AES-CBC", forge$y.cipher.modes.cbc);
registerAlgorithm$1("AES-CFB", forge$y.cipher.modes.cfb);
registerAlgorithm$1("AES-OFB", forge$y.cipher.modes.ofb);
registerAlgorithm$1("AES-CTR", forge$y.cipher.modes.ctr);
registerAlgorithm$1("AES-GCM", forge$y.cipher.modes.gcm);
function registerAlgorithm$1(name, mode) {
  var factory = function() {
    return new forge$y.aes.Algorithm(name, mode);
  };
  forge$y.cipher.registerAlgorithm(name, factory);
}
var init = false;
var Nb = 4;
var sbox;
var isbox;
var rcon;
var mix;
var imix;
function initialize() {
  init = true;
  rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  var xtime = new Array(256);
  for (var i = 0; i < 128; ++i) {
    xtime[i] = i << 1;
    xtime[i + 128] = i + 128 << 1 ^ 283;
  }
  sbox = new Array(256);
  isbox = new Array(256);
  mix = new Array(4);
  imix = new Array(4);
  for (var i = 0; i < 4; ++i) {
    mix[i] = new Array(256);
    imix[i] = new Array(256);
  }
  var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
  for (var i = 0; i < 256; ++i) {
    sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
    sx = sx >> 8 ^ sx & 255 ^ 99;
    sbox[e] = sx;
    isbox[sx] = e;
    sx2 = xtime[sx];
    e2 = xtime[e];
    e4 = xtime[e2];
    e8 = xtime[e4];
    me = sx2 << 24 ^ // 2
    sx << 16 ^ // 1
    sx << 8 ^ // 1
    (sx ^ sx2);
    ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
    (e ^ e8) << 16 ^ // 9
    (e ^ e4 ^ e8) << 8 ^ // D (13)
    (e ^ e2 ^ e8);
    for (var n = 0; n < 4; ++n) {
      mix[n][e] = me;
      imix[n][sx] = ime;
      me = me << 24 | me >>> 8;
      ime = ime << 24 | ime >>> 8;
    }
    if (e === 0) {
      e = ei = 1;
    } else {
      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
      ei ^= xtime[xtime[ei]];
    }
  }
}
function _expandKey(key, decrypt2) {
  var w2 = key.slice(0);
  var temp, iNk = 1;
  var Nk = w2.length;
  var Nr1 = Nk + 6 + 1;
  var end = Nb * Nr1;
  for (var i = Nk; i < end; ++i) {
    temp = w2[i - 1];
    if (i % Nk === 0) {
      temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
      iNk++;
    } else if (Nk > 6 && i % Nk === 4) {
      temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
    }
    w2[i] = w2[i - Nk] ^ temp;
  }
  if (decrypt2) {
    var tmp;
    var m0 = imix[0];
    var m1 = imix[1];
    var m2 = imix[2];
    var m3 = imix[3];
    var wnew = w2.slice(0);
    end = w2.length;
    for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
      if (i === 0 || i === end - Nb) {
        wnew[i] = w2[wi];
        wnew[i + 1] = w2[wi + 3];
        wnew[i + 2] = w2[wi + 2];
        wnew[i + 3] = w2[wi + 1];
      } else {
        for (var n = 0; n < Nb; ++n) {
          tmp = w2[wi + n];
          wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
        }
      }
    }
    w2 = wnew;
  }
  return w2;
}
function _updateBlock$1(w2, input, output, decrypt2) {
  var Nr = w2.length / 4 - 1;
  var m0, m1, m2, m3, sub;
  if (decrypt2) {
    m0 = imix[0];
    m1 = imix[1];
    m2 = imix[2];
    m3 = imix[3];
    sub = isbox;
  } else {
    m0 = mix[0];
    m1 = mix[1];
    m2 = mix[2];
    m3 = mix[3];
    sub = sbox;
  }
  var a, b, c, d2, a2, b2, c2;
  a = input[0] ^ w2[0];
  b = input[decrypt2 ? 3 : 1] ^ w2[1];
  c = input[2] ^ w2[2];
  d2 = input[decrypt2 ? 1 : 3] ^ w2[3];
  var i = 3;
  for (var round2 = 1; round2 < Nr; ++round2) {
    a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d2 & 255] ^ w2[++i];
    b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d2 >>> 8 & 255] ^ m3[a & 255] ^ w2[++i];
    c2 = m0[c >>> 24] ^ m1[d2 >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w2[++i];
    d2 = m0[d2 >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w2[++i];
    a = a2;
    b = b2;
    c = c2;
  }
  output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d2 & 255] ^ w2[++i];
  output[decrypt2 ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d2 >>> 8 & 255] << 8 ^ sub[a & 255] ^ w2[++i];
  output[2] = sub[c >>> 24] << 24 ^ sub[d2 >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w2[++i];
  output[decrypt2 ? 1 : 3] = sub[d2 >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w2[++i];
}
function _createCipher$1(options2) {
  options2 = options2 || {};
  var mode = (options2.mode || "CBC").toUpperCase();
  var algorithm = "AES-" + mode;
  var cipher;
  if (options2.decrypt) {
    cipher = forge$y.cipher.createDecipher(algorithm, options2.key);
  } else {
    cipher = forge$y.cipher.createCipher(algorithm, options2.key);
  }
  var start = cipher.start;
  cipher.start = function(iv, options3) {
    var output = null;
    if (options3 instanceof forge$y.util.ByteBuffer) {
      output = options3;
      options3 = {};
    }
    options3 = options3 || {};
    options3.output = output;
    options3.iv = iv;
    start.call(cipher, options3);
  };
  return cipher;
}
var forge$x = forge$C;
forge$x.pki = forge$x.pki || {};
var oids$2 = forge$x.pki.oids = forge$x.oids = forge$x.oids || {};
function _IN(id, name) {
  oids$2[id] = name;
  oids$2[name] = id;
}
function _I_(id, name) {
  oids$2[id] = name;
}
_IN("1.2.840.113549.1.1.1", "rsaEncryption");
_IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
_IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
_IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
_IN("1.2.840.113549.1.1.8", "mgf1");
_IN("1.2.840.113549.1.1.9", "pSpecified");
_IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
_IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
_IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
_IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
_IN("1.3.101.112", "EdDSA25519");
_IN("1.2.840.10040.4.3", "dsa-with-sha1");
_IN("1.3.14.3.2.7", "desCBC");
_IN("1.3.14.3.2.26", "sha1");
_IN("1.3.14.3.2.29", "sha1WithRSASignature");
_IN("2.16.840.1.101.3.4.2.1", "sha256");
_IN("2.16.840.1.101.3.4.2.2", "sha384");
_IN("2.16.840.1.101.3.4.2.3", "sha512");
_IN("2.16.840.1.101.3.4.2.4", "sha224");
_IN("2.16.840.1.101.3.4.2.5", "sha512-224");
_IN("2.16.840.1.101.3.4.2.6", "sha512-256");
_IN("1.2.840.113549.2.2", "md2");
_IN("1.2.840.113549.2.5", "md5");
_IN("1.2.840.113549.1.7.1", "data");
_IN("1.2.840.113549.1.7.2", "signedData");
_IN("1.2.840.113549.1.7.3", "envelopedData");
_IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
_IN("1.2.840.113549.1.7.5", "digestedData");
_IN("1.2.840.113549.1.7.6", "encryptedData");
_IN("1.2.840.113549.1.9.1", "emailAddress");
_IN("1.2.840.113549.1.9.2", "unstructuredName");
_IN("1.2.840.113549.1.9.3", "contentType");
_IN("1.2.840.113549.1.9.4", "messageDigest");
_IN("1.2.840.113549.1.9.5", "signingTime");
_IN("1.2.840.113549.1.9.6", "counterSignature");
_IN("1.2.840.113549.1.9.7", "challengePassword");
_IN("1.2.840.113549.1.9.8", "unstructuredAddress");
_IN("1.2.840.113549.1.9.14", "extensionRequest");
_IN("1.2.840.113549.1.9.20", "friendlyName");
_IN("1.2.840.113549.1.9.21", "localKeyId");
_IN("1.2.840.113549.1.9.22.1", "x509Certificate");
_IN("1.2.840.113549.1.12.10.1.1", "keyBag");
_IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
_IN("1.2.840.113549.1.12.10.1.3", "certBag");
_IN("1.2.840.113549.1.12.10.1.4", "crlBag");
_IN("1.2.840.113549.1.12.10.1.5", "secretBag");
_IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
_IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
_IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
_IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
_IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
_IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
_IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
_IN("1.2.840.113549.2.7", "hmacWithSHA1");
_IN("1.2.840.113549.2.8", "hmacWithSHA224");
_IN("1.2.840.113549.2.9", "hmacWithSHA256");
_IN("1.2.840.113549.2.10", "hmacWithSHA384");
_IN("1.2.840.113549.2.11", "hmacWithSHA512");
_IN("1.2.840.113549.3.7", "des-EDE3-CBC");
_IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
_IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
_IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
_IN("2.5.4.3", "commonName");
_IN("2.5.4.4", "surname");
_IN("2.5.4.5", "serialNumber");
_IN("2.5.4.6", "countryName");
_IN("2.5.4.7", "localityName");
_IN("2.5.4.8", "stateOrProvinceName");
_IN("2.5.4.9", "streetAddress");
_IN("2.5.4.10", "organizationName");
_IN("2.5.4.11", "organizationalUnitName");
_IN("2.5.4.12", "title");
_IN("2.5.4.13", "description");
_IN("2.5.4.15", "businessCategory");
_IN("2.5.4.17", "postalCode");
_IN("2.5.4.42", "givenName");
_IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
_IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
_IN("2.16.840.1.113730.1.1", "nsCertType");
_IN("2.16.840.1.113730.1.13", "nsComment");
_I_("2.5.29.1", "authorityKeyIdentifier");
_I_("2.5.29.2", "keyAttributes");
_I_("2.5.29.3", "certificatePolicies");
_I_("2.5.29.4", "keyUsageRestriction");
_I_("2.5.29.5", "policyMapping");
_I_("2.5.29.6", "subtreesConstraint");
_I_("2.5.29.7", "subjectAltName");
_I_("2.5.29.8", "issuerAltName");
_I_("2.5.29.9", "subjectDirectoryAttributes");
_I_("2.5.29.10", "basicConstraints");
_I_("2.5.29.11", "nameConstraints");
_I_("2.5.29.12", "policyConstraints");
_I_("2.5.29.13", "basicConstraints");
_IN("2.5.29.14", "subjectKeyIdentifier");
_IN("2.5.29.15", "keyUsage");
_I_("2.5.29.16", "privateKeyUsagePeriod");
_IN("2.5.29.17", "subjectAltName");
_IN("2.5.29.18", "issuerAltName");
_IN("2.5.29.19", "basicConstraints");
_I_("2.5.29.20", "cRLNumber");
_I_("2.5.29.21", "cRLReason");
_I_("2.5.29.22", "expirationDate");
_I_("2.5.29.23", "instructionCode");
_I_("2.5.29.24", "invalidityDate");
_I_("2.5.29.25", "cRLDistributionPoints");
_I_("2.5.29.26", "issuingDistributionPoint");
_I_("2.5.29.27", "deltaCRLIndicator");
_I_("2.5.29.28", "issuingDistributionPoint");
_I_("2.5.29.29", "certificateIssuer");
_I_("2.5.29.30", "nameConstraints");
_IN("2.5.29.31", "cRLDistributionPoints");
_IN("2.5.29.32", "certificatePolicies");
_I_("2.5.29.33", "policyMappings");
_I_("2.5.29.34", "policyConstraints");
_IN("2.5.29.35", "authorityKeyIdentifier");
_I_("2.5.29.36", "policyConstraints");
_IN("2.5.29.37", "extKeyUsage");
_I_("2.5.29.46", "freshestCRL");
_I_("2.5.29.54", "inhibitAnyPolicy");
_IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
_IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
_IN("1.3.6.1.5.5.7.3.1", "serverAuth");
_IN("1.3.6.1.5.5.7.3.2", "clientAuth");
_IN("1.3.6.1.5.5.7.3.3", "codeSigning");
_IN("1.3.6.1.5.5.7.3.4", "emailProtection");
_IN("1.3.6.1.5.5.7.3.8", "timeStamping");
var forge$w = forge$C;
var asn1$8 = forge$w.asn1 = forge$w.asn1 || {};
asn1$8.Class = {
  UNIVERSAL: 0,
  APPLICATION: 64,
  CONTEXT_SPECIFIC: 128,
  PRIVATE: 192
};
asn1$8.Type = {
  NONE: 0,
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTETSTRING: 4,
  NULL: 5,
  OID: 6,
  ODESC: 7,
  EXTERNAL: 8,
  REAL: 9,
  ENUMERATED: 10,
  EMBEDDED: 11,
  UTF8: 12,
  ROID: 13,
  SEQUENCE: 16,
  SET: 17,
  PRINTABLESTRING: 19,
  IA5STRING: 22,
  UTCTIME: 23,
  GENERALIZEDTIME: 24,
  BMPSTRING: 30
};
asn1$8.maxDepth = 256;
asn1$8.create = function(tagClass, type3, constructed, value, options2) {
  if (forge$w.util.isArray(value)) {
    var tmp = [];
    for (var i = 0; i < value.length; ++i) {
      if (value[i] !== void 0) {
        tmp.push(value[i]);
      }
    }
    value = tmp;
  }
  var obj = {
    tagClass,
    type: type3,
    constructed,
    composed: constructed || forge$w.util.isArray(value),
    value
  };
  if (options2 && "bitStringContents" in options2) {
    obj.bitStringContents = options2.bitStringContents;
    obj.original = asn1$8.copy(obj);
  }
  return obj;
};
asn1$8.copy = function(obj, options2) {
  var copy;
  if (forge$w.util.isArray(obj)) {
    copy = [];
    for (var i = 0; i < obj.length; ++i) {
      copy.push(asn1$8.copy(obj[i], options2));
    }
    return copy;
  }
  if (typeof obj === "string") {
    return obj;
  }
  copy = {
    tagClass: obj.tagClass,
    type: obj.type,
    constructed: obj.constructed,
    composed: obj.composed,
    value: asn1$8.copy(obj.value, options2)
  };
  if (options2 && !options2.excludeBitStringContents) {
    copy.bitStringContents = obj.bitStringContents;
  }
  return copy;
};
asn1$8.equals = function(obj1, obj2, options2) {
  if (forge$w.util.isArray(obj1)) {
    if (!forge$w.util.isArray(obj2)) {
      return false;
    }
    if (obj1.length !== obj2.length) {
      return false;
    }
    for (var i = 0; i < obj1.length; ++i) {
      if (!asn1$8.equals(obj1[i], obj2[i])) {
        return false;
      }
    }
    return true;
  }
  if (typeof obj1 !== typeof obj2) {
    return false;
  }
  if (typeof obj1 === "string") {
    return obj1 === obj2;
  }
  var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$8.equals(obj1.value, obj2.value);
  if (options2 && options2.includeBitStringContents) {
    equal = equal && obj1.bitStringContents === obj2.bitStringContents;
  }
  return equal;
};
asn1$8.getBerValueLength = function(b) {
  var b2 = b.getByte();
  if (b2 === 128) {
    return void 0;
  }
  var length;
  var longForm = b2 & 128;
  if (!longForm) {
    length = b2;
  } else {
    length = b.getInt((b2 & 127) << 3);
  }
  return length;
};
function _checkBufferLength(bytes2, remaining, n) {
  if (n > remaining) {
    var error2 = new Error("Too few bytes to parse DER.");
    error2.available = bytes2.length();
    error2.remaining = remaining;
    error2.requested = n;
    throw error2;
  }
}
var _getValueLength = function(bytes2, remaining) {
  var b2 = bytes2.getByte();
  remaining--;
  if (b2 === 128) {
    return void 0;
  }
  var length;
  var longForm = b2 & 128;
  if (!longForm) {
    length = b2;
  } else {
    var longFormBytes = b2 & 127;
    _checkBufferLength(bytes2, remaining, longFormBytes);
    length = bytes2.getInt(longFormBytes << 3);
  }
  if (length < 0) {
    throw new Error("Negative length: " + length);
  }
  return length;
};
asn1$8.fromDer = function(bytes2, options2) {
  if (options2 === void 0) {
    options2 = {
      strict: true,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if (typeof options2 === "boolean") {
    options2 = {
      strict: options2,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if (!("strict" in options2)) {
    options2.strict = true;
  }
  if (!("parseAllBytes" in options2)) {
    options2.parseAllBytes = true;
  }
  if (!("decodeBitStrings" in options2)) {
    options2.decodeBitStrings = true;
  }
  if (!("maxDepth" in options2)) {
    options2.maxDepth = asn1$8.maxDepth;
  }
  if (typeof bytes2 === "string") {
    bytes2 = forge$w.util.createBuffer(bytes2);
  }
  var byteCount = bytes2.length();
  var value = _fromDer(bytes2, bytes2.length(), 0, options2);
  if (options2.parseAllBytes && bytes2.length() !== 0) {
    var error2 = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
    error2.byteCount = byteCount;
    error2.remaining = bytes2.length();
    throw error2;
  }
  return value;
};
function _fromDer(bytes2, remaining, depth, options2) {
  if (depth >= options2.maxDepth) {
    throw new Error("ASN.1 parsing error: Max depth exceeded.");
  }
  var start;
  _checkBufferLength(bytes2, remaining, 2);
  var b1 = bytes2.getByte();
  remaining--;
  var tagClass = b1 & 192;
  var type3 = b1 & 31;
  start = bytes2.length();
  var length = _getValueLength(bytes2, remaining);
  remaining -= start - bytes2.length();
  if (length !== void 0 && length > remaining) {
    if (options2.strict) {
      var error2 = new Error("Too few bytes to read ASN.1 value.");
      error2.available = bytes2.length();
      error2.remaining = remaining;
      error2.requested = length;
      throw error2;
    }
    length = remaining;
  }
  var value;
  var bitStringContents;
  var constructed = (b1 & 32) === 32;
  if (constructed) {
    value = [];
    if (length === void 0) {
      for (; ; ) {
        _checkBufferLength(bytes2, remaining, 2);
        if (bytes2.bytes(2) === String.fromCharCode(0, 0)) {
          bytes2.getBytes(2);
          remaining -= 2;
          break;
        }
        start = bytes2.length();
        value.push(_fromDer(bytes2, remaining, depth + 1, options2));
        remaining -= start - bytes2.length();
      }
    } else {
      while (length > 0) {
        start = bytes2.length();
        value.push(_fromDer(bytes2, length, depth + 1, options2));
        remaining -= start - bytes2.length();
        length -= start - bytes2.length();
      }
    }
  }
  if (value === void 0 && tagClass === asn1$8.Class.UNIVERSAL && type3 === asn1$8.Type.BITSTRING) {
    bitStringContents = bytes2.bytes(length);
  }
  if (value === void 0 && options2.decodeBitStrings && tagClass === asn1$8.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
  // .. other parts of forge expect to decode OCTET STRINGs manually
  type3 === asn1$8.Type.BITSTRING && length > 1) {
    var savedRead = bytes2.read;
    var savedRemaining = remaining;
    var unused = 0;
    if (type3 === asn1$8.Type.BITSTRING) {
      _checkBufferLength(bytes2, remaining, 1);
      unused = bytes2.getByte();
      remaining--;
    }
    if (unused === 0) {
      try {
        start = bytes2.length();
        var subOptions = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          strict: true,
          decodeBitStrings: true
        };
        var composed = _fromDer(bytes2, remaining, depth + 1, subOptions);
        var used = start - bytes2.length();
        remaining -= used;
        if (type3 == asn1$8.Type.BITSTRING) {
          used++;
        }
        var tc = composed.tagClass;
        if (used === length && (tc === asn1$8.Class.UNIVERSAL || tc === asn1$8.Class.CONTEXT_SPECIFIC)) {
          value = [composed];
        }
      } catch (ex) {
      }
    }
    if (value === void 0) {
      bytes2.read = savedRead;
      remaining = savedRemaining;
    }
  }
  if (value === void 0) {
    if (length === void 0) {
      if (options2.strict) {
        throw new Error("Non-constructed ASN.1 object of indefinite length.");
      }
      length = remaining;
    }
    if (type3 === asn1$8.Type.BMPSTRING) {
      value = "";
      for (; length > 0; length -= 2) {
        _checkBufferLength(bytes2, remaining, 2);
        value += String.fromCharCode(bytes2.getInt16());
        remaining -= 2;
      }
    } else {
      value = bytes2.getBytes(length);
      remaining -= length;
    }
  }
  var asn1Options = bitStringContents === void 0 ? null : {
    bitStringContents
  };
  return asn1$8.create(tagClass, type3, constructed, value, asn1Options);
}
asn1$8.toDer = function(obj) {
  var bytes2 = forge$w.util.createBuffer();
  var b1 = obj.tagClass | obj.type;
  var value = forge$w.util.createBuffer();
  var useBitStringContents = false;
  if ("bitStringContents" in obj) {
    useBitStringContents = true;
    if (obj.original) {
      useBitStringContents = asn1$8.equals(obj, obj.original);
    }
  }
  if (useBitStringContents) {
    value.putBytes(obj.bitStringContents);
  } else if (obj.composed) {
    if (obj.constructed) {
      b1 |= 32;
    } else {
      value.putByte(0);
    }
    for (var i = 0; i < obj.value.length; ++i) {
      if (obj.value[i] !== void 0) {
        value.putBuffer(asn1$8.toDer(obj.value[i]));
      }
    }
  } else {
    if (obj.type === asn1$8.Type.BMPSTRING) {
      for (var i = 0; i < obj.value.length; ++i) {
        value.putInt16(obj.value.charCodeAt(i));
      }
    } else {
      if (obj.type === asn1$8.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
      (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
        value.putBytes(obj.value.substr(1));
      } else {
        value.putBytes(obj.value);
      }
    }
  }
  bytes2.putByte(b1);
  if (value.length() <= 127) {
    bytes2.putByte(value.length() & 127);
  } else {
    var len = value.length();
    var lenBytes = "";
    do {
      lenBytes += String.fromCharCode(len & 255);
      len = len >>> 8;
    } while (len > 0);
    bytes2.putByte(lenBytes.length | 128);
    for (var i = lenBytes.length - 1; i >= 0; --i) {
      bytes2.putByte(lenBytes.charCodeAt(i));
    }
  }
  bytes2.putBuffer(value);
  return bytes2;
};
asn1$8.oidToDer = function(oid) {
  var values = oid.split(".");
  var bytes2 = forge$w.util.createBuffer();
  bytes2.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
  var last, valueBytes, value, b;
  for (var i = 2; i < values.length; ++i) {
    last = true;
    valueBytes = [];
    value = parseInt(values[i], 10);
    if (value > 4294967295) {
      throw new Error("OID value too large; max is 32-bits.");
    }
    do {
      b = value & 127;
      value = value >>> 7;
      if (!last) {
        b |= 128;
      }
      valueBytes.push(b);
      last = false;
    } while (value > 0);
    for (var n = valueBytes.length - 1; n >= 0; --n) {
      bytes2.putByte(valueBytes[n]);
    }
  }
  return bytes2;
};
asn1$8.derToOid = function(bytes2) {
  var oid;
  if (typeof bytes2 === "string") {
    bytes2 = forge$w.util.createBuffer(bytes2);
  }
  var b = bytes2.getByte();
  oid = Math.floor(b / 40) + "." + b % 40;
  var value = 0;
  while (bytes2.length() > 0) {
    if (value > 70368744177663) {
      throw new Error("OID value too large; max is 53-bits.");
    }
    b = bytes2.getByte();
    value = value * 128;
    if (b & 128) {
      value += b & 127;
    } else {
      oid += "." + (value + b);
      value = 0;
    }
  }
  return oid;
};
asn1$8.utcTimeToDate = function(utc) {
  var date = /* @__PURE__ */ new Date();
  var year = parseInt(utc.substr(0, 2), 10);
  year = year >= 50 ? 1900 + year : 2e3 + year;
  var MM = parseInt(utc.substr(2, 2), 10) - 1;
  var DD = parseInt(utc.substr(4, 2), 10);
  var hh = parseInt(utc.substr(6, 2), 10);
  var mm = parseInt(utc.substr(8, 2), 10);
  var ss = 0;
  if (utc.length > 11) {
    var c = utc.charAt(10);
    var end = 10;
    if (c !== "+" && c !== "-") {
      ss = parseInt(utc.substr(10, 2), 10);
      end += 2;
    }
  }
  date.setUTCFullYear(year, MM, DD);
  date.setUTCHours(hh, mm, ss, 0);
  if (end) {
    c = utc.charAt(end);
    if (c === "+" || c === "-") {
      var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
      var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
      var offset = hhoffset * 60 + mmoffset;
      offset *= 6e4;
      if (c === "+") {
        date.setTime(+date - offset);
      } else {
        date.setTime(+date + offset);
      }
    }
  }
  return date;
};
asn1$8.generalizedTimeToDate = function(gentime) {
  var date = /* @__PURE__ */ new Date();
  var YYYY = parseInt(gentime.substr(0, 4), 10);
  var MM = parseInt(gentime.substr(4, 2), 10) - 1;
  var DD = parseInt(gentime.substr(6, 2), 10);
  var hh = parseInt(gentime.substr(8, 2), 10);
  var mm = parseInt(gentime.substr(10, 2), 10);
  var ss = parseInt(gentime.substr(12, 2), 10);
  var fff = 0;
  var offset = 0;
  var isUTC = false;
  if (gentime.charAt(gentime.length - 1) === "Z") {
    isUTC = true;
  }
  var end = gentime.length - 5, c = gentime.charAt(end);
  if (c === "+" || c === "-") {
    var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
    var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
    offset = hhoffset * 60 + mmoffset;
    offset *= 6e4;
    if (c === "+") {
      offset *= -1;
    }
    isUTC = true;
  }
  if (gentime.charAt(14) === ".") {
    fff = parseFloat(gentime.substr(14), 10) * 1e3;
  }
  if (isUTC) {
    date.setUTCFullYear(YYYY, MM, DD);
    date.setUTCHours(hh, mm, ss, fff);
    date.setTime(+date + offset);
  } else {
    date.setFullYear(YYYY, MM, DD);
    date.setHours(hh, mm, ss, fff);
  }
  return date;
};
asn1$8.dateToUtcTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format2 = [];
  format2.push(("" + date.getUTCFullYear()).substr(2));
  format2.push("" + (date.getUTCMonth() + 1));
  format2.push("" + date.getUTCDate());
  format2.push("" + date.getUTCHours());
  format2.push("" + date.getUTCMinutes());
  format2.push("" + date.getUTCSeconds());
  for (var i = 0; i < format2.length; ++i) {
    if (format2[i].length < 2) {
      rval += "0";
    }
    rval += format2[i];
  }
  rval += "Z";
  return rval;
};
asn1$8.dateToGeneralizedTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format2 = [];
  format2.push("" + date.getUTCFullYear());
  format2.push("" + (date.getUTCMonth() + 1));
  format2.push("" + date.getUTCDate());
  format2.push("" + date.getUTCHours());
  format2.push("" + date.getUTCMinutes());
  format2.push("" + date.getUTCSeconds());
  for (var i = 0; i < format2.length; ++i) {
    if (format2[i].length < 2) {
      rval += "0";
    }
    rval += format2[i];
  }
  rval += "Z";
  return rval;
};
asn1$8.integerToDer = function(x) {
  var rval = forge$w.util.createBuffer();
  if (x >= -128 && x < 128) {
    return rval.putSignedInt(x, 8);
  }
  if (x >= -32768 && x < 32768) {
    return rval.putSignedInt(x, 16);
  }
  if (x >= -8388608 && x < 8388608) {
    return rval.putSignedInt(x, 24);
  }
  if (x >= -2147483648 && x < 2147483648) {
    return rval.putSignedInt(x, 32);
  }
  var error2 = new Error("Integer too large; max is 32-bits.");
  error2.integer = x;
  throw error2;
};
asn1$8.derToInteger = function(bytes2) {
  if (typeof bytes2 === "string") {
    bytes2 = forge$w.util.createBuffer(bytes2);
  }
  var n = bytes2.length() * 8;
  if (n > 32) {
    throw new Error("Integer too large; max is 32-bits.");
  }
  return bytes2.getSignedInt(n);
};
asn1$8.validate = function(obj, v, capture, errors2) {
  var rval = false;
  if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
    if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
      rval = true;
      if (v.value && forge$w.util.isArray(v.value)) {
        var j = 0;
        for (var i = 0; rval && i < v.value.length; ++i) {
          var schemaItem = v.value[i];
          rval = !!schemaItem.optional;
          var objChild = obj.value[j];
          if (!objChild) {
            if (!schemaItem.optional) {
              rval = false;
              if (errors2) {
                errors2.push("[" + v.name + '] Missing required element. Expected tag class "' + schemaItem.tagClass + '", type "' + schemaItem.type + '"');
              }
            }
            continue;
          }
          var schemaHasTag = typeof schemaItem.tagClass !== "undefined" && typeof schemaItem.type !== "undefined";
          if (schemaHasTag && (objChild.tagClass !== schemaItem.tagClass || objChild.type !== schemaItem.type)) {
            if (schemaItem.optional) {
              rval = true;
              continue;
            } else {
              rval = false;
              if (errors2) {
                errors2.push("[" + v.name + "] Tag mismatch. Expected (" + schemaItem.tagClass + "," + schemaItem.type + "), got (" + objChild.tagClass + "," + objChild.type + ")");
              }
              break;
            }
          }
          var childRval = asn1$8.validate(objChild, schemaItem, capture, errors2);
          if (childRval) {
            ++j;
            rval = true;
          } else if (schemaItem.optional) {
            rval = true;
          } else {
            rval = false;
            break;
          }
        }
      }
      if (rval && capture) {
        if (v.capture) {
          capture[v.capture] = obj.value;
        }
        if (v.captureAsn1) {
          capture[v.captureAsn1] = obj;
        }
        if (v.captureBitStringContents && "bitStringContents" in obj) {
          capture[v.captureBitStringContents] = obj.bitStringContents;
        }
        if (v.captureBitStringValue && "bitStringContents" in obj) {
          if (obj.bitStringContents.length < 2) {
            capture[v.captureBitStringValue] = "";
          } else {
            var unused = obj.bitStringContents.charCodeAt(0);
            if (unused !== 0) {
              throw new Error(
                "captureBitStringValue only supported for zero unused bits"
              );
            }
            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
          }
        }
      }
    } else if (errors2) {
      errors2.push(
        "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
      );
    }
  } else if (errors2) {
    if (obj.tagClass !== v.tagClass) {
      errors2.push(
        "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
      );
    }
    if (obj.type !== v.type) {
      errors2.push(
        "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
      );
    }
  }
  return rval;
};
var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
asn1$8.prettyPrint = function(obj, level, indentation) {
  var rval = "";
  level = level || 0;
  indentation = indentation || 2;
  if (level > 0) {
    rval += "\n";
  }
  var indent = "";
  for (var i = 0; i < level * indentation; ++i) {
    indent += " ";
  }
  rval += indent + "Tag: ";
  switch (obj.tagClass) {
    case asn1$8.Class.UNIVERSAL:
      rval += "Universal:";
      break;
    case asn1$8.Class.APPLICATION:
      rval += "Application:";
      break;
    case asn1$8.Class.CONTEXT_SPECIFIC:
      rval += "Context-Specific:";
      break;
    case asn1$8.Class.PRIVATE:
      rval += "Private:";
      break;
  }
  if (obj.tagClass === asn1$8.Class.UNIVERSAL) {
    rval += obj.type;
    switch (obj.type) {
      case asn1$8.Type.NONE:
        rval += " (None)";
        break;
      case asn1$8.Type.BOOLEAN:
        rval += " (Boolean)";
        break;
      case asn1$8.Type.INTEGER:
        rval += " (Integer)";
        break;
      case asn1$8.Type.BITSTRING:
        rval += " (Bit string)";
        break;
      case asn1$8.Type.OCTETSTRING:
        rval += " (Octet string)";
        break;
      case asn1$8.Type.NULL:
        rval += " (Null)";
        break;
      case asn1$8.Type.OID:
        rval += " (Object Identifier)";
        break;
      case asn1$8.Type.ODESC:
        rval += " (Object Descriptor)";
        break;
      case asn1$8.Type.EXTERNAL:
        rval += " (External or Instance of)";
        break;
      case asn1$8.Type.REAL:
        rval += " (Real)";
        break;
      case asn1$8.Type.ENUMERATED:
        rval += " (Enumerated)";
        break;
      case asn1$8.Type.EMBEDDED:
        rval += " (Embedded PDV)";
        break;
      case asn1$8.Type.UTF8:
        rval += " (UTF8)";
        break;
      case asn1$8.Type.ROID:
        rval += " (Relative Object Identifier)";
        break;
      case asn1$8.Type.SEQUENCE:
        rval += " (Sequence)";
        break;
      case asn1$8.Type.SET:
        rval += " (Set)";
        break;
      case asn1$8.Type.PRINTABLESTRING:
        rval += " (Printable String)";
        break;
      case asn1$8.Type.IA5String:
        rval += " (IA5String (ASCII))";
        break;
      case asn1$8.Type.UTCTIME:
        rval += " (UTC time)";
        break;
      case asn1$8.Type.GENERALIZEDTIME:
        rval += " (Generalized time)";
        break;
      case asn1$8.Type.BMPSTRING:
        rval += " (BMP String)";
        break;
    }
  } else {
    rval += obj.type;
  }
  rval += "\n";
  rval += indent + "Constructed: " + obj.constructed + "\n";
  if (obj.composed) {
    var subvalues = 0;
    var sub = "";
    for (var i = 0; i < obj.value.length; ++i) {
      if (obj.value[i] !== void 0) {
        subvalues += 1;
        sub += asn1$8.prettyPrint(obj.value[i], level + 1, indentation);
        if (i + 1 < obj.value.length) {
          sub += ",";
        }
      }
    }
    rval += indent + "Sub values: " + subvalues + sub;
  } else {
    rval += indent + "Value: ";
    if (obj.type === asn1$8.Type.OID) {
      var oid = asn1$8.derToOid(obj.value);
      rval += oid;
      if (forge$w.pki && forge$w.pki.oids) {
        if (oid in forge$w.pki.oids) {
          rval += " (" + forge$w.pki.oids[oid] + ") ";
        }
      }
    }
    if (obj.type === asn1$8.Type.INTEGER) {
      try {
        rval += asn1$8.derToInteger(obj.value);
      } catch (ex) {
        rval += "0x" + forge$w.util.bytesToHex(obj.value);
      }
    } else if (obj.type === asn1$8.Type.BITSTRING) {
      if (obj.value.length > 1) {
        rval += "0x" + forge$w.util.bytesToHex(obj.value.slice(1));
      } else {
        rval += "(none)";
      }
      if (obj.value.length > 0) {
        var unused = obj.value.charCodeAt(0);
        if (unused == 1) {
          rval += " (1 unused bit shown)";
        } else if (unused > 1) {
          rval += " (" + unused + " unused bits shown)";
        }
      }
    } else if (obj.type === asn1$8.Type.OCTETSTRING) {
      if (!_nonLatinRegex.test(obj.value)) {
        rval += "(" + obj.value + ") ";
      }
      rval += "0x" + forge$w.util.bytesToHex(obj.value);
    } else if (obj.type === asn1$8.Type.UTF8) {
      try {
        rval += forge$w.util.decodeUtf8(obj.value);
      } catch (e) {
        if (e.message === "URI malformed") {
          rval += "0x" + forge$w.util.bytesToHex(obj.value) + " (malformed UTF8)";
        } else {
          throw e;
        }
      }
    } else if (obj.type === asn1$8.Type.PRINTABLESTRING || obj.type === asn1$8.Type.IA5String) {
      rval += obj.value;
    } else if (_nonLatinRegex.test(obj.value)) {
      rval += "0x" + forge$w.util.bytesToHex(obj.value);
    } else if (obj.value.length === 0) {
      rval += "[null]";
    } else {
      rval += obj.value;
    }
  }
  return rval;
};
var forge$v = forge$C;
forge$v.md = forge$v.md || {};
forge$v.md.algorithms = forge$v.md.algorithms || {};
var forge$u = forge$C;
var hmac = forge$u.hmac = forge$u.hmac || {};
hmac.create = function() {
  var _key = null;
  var _md = null;
  var _ipadding = null;
  var _opadding = null;
  var ctx = {};
  ctx.start = function(md, key) {
    if (md !== null) {
      if (typeof md === "string") {
        md = md.toLowerCase();
        if (md in forge$u.md.algorithms) {
          _md = forge$u.md.algorithms[md].create();
        } else {
          throw new Error('Unknown hash algorithm "' + md + '"');
        }
      } else {
        _md = md;
      }
    }
    if (key === null) {
      key = _key;
    } else {
      if (typeof key === "string") {
        key = forge$u.util.createBuffer(key);
      } else if (forge$u.util.isArray(key)) {
        var tmp = key;
        key = forge$u.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      var keylen = key.length();
      if (keylen > _md.blockLength) {
        _md.start();
        _md.update(key.bytes());
        key = _md.digest();
      }
      _ipadding = forge$u.util.createBuffer();
      _opadding = forge$u.util.createBuffer();
      keylen = key.length();
      for (var i = 0; i < keylen; ++i) {
        var tmp = key.at(i);
        _ipadding.putByte(54 ^ tmp);
        _opadding.putByte(92 ^ tmp);
      }
      if (keylen < _md.blockLength) {
        var tmp = _md.blockLength - keylen;
        for (var i = 0; i < tmp; ++i) {
          _ipadding.putByte(54);
          _opadding.putByte(92);
        }
      }
      _key = key;
      _ipadding = _ipadding.bytes();
      _opadding = _opadding.bytes();
    }
    _md.start();
    _md.update(_ipadding);
  };
  ctx.update = function(bytes2) {
    _md.update(bytes2);
  };
  ctx.getMac = function() {
    var inner = _md.digest().bytes();
    _md.start();
    _md.update(_opadding);
    _md.update(inner);
    return _md.digest();
  };
  ctx.digest = ctx.getMac;
  return ctx;
};
var forge$t = forge$C;
var md5 = forge$t.md5 = forge$t.md5 || {};
forge$t.md.md5 = forge$t.md.algorithms.md5 = md5;
md5.create = function() {
  if (!_initialized$3) {
    _init$3();
  }
  var _state2 = null;
  var _input = forge$t.util.createBuffer();
  var _w = new Array(16);
  var md = {
    algorithm: "md5",
    blockLength: 64,
    digestLength: 16,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge$t.util.createBuffer();
    _state2 = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878
    };
    return md;
  };
  md.start();
  md.update = function(msg, encoding3) {
    if (encoding3 === "utf8") {
      msg = forge$t.util.encodeUtf8(msg);
    }
    var len = msg.length;
    md.messageLength += len;
    len = [len / 4294967296 >>> 0, len >>> 0];
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$3(_state2, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$t.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$3.substr(0, md.blockLength - overflow));
    var bits, carry = 0;
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      bits = md.fullMessageLength[i] * 8 + carry;
      carry = bits / 4294967296 >>> 0;
      finalBlock.putInt32Le(bits >>> 0);
    }
    var s2 = {
      h0: _state2.h0,
      h1: _state2.h1,
      h2: _state2.h2,
      h3: _state2.h3
    };
    _update$3(s2, _w, finalBlock);
    var rval = forge$t.util.createBuffer();
    rval.putInt32Le(s2.h0);
    rval.putInt32Le(s2.h1);
    rval.putInt32Le(s2.h2);
    rval.putInt32Le(s2.h3);
    return rval;
  };
  return md;
};
var _padding$3 = null;
var _g = null;
var _r = null;
var _k$2 = null;
var _initialized$3 = false;
function _init$3() {
  _padding$3 = String.fromCharCode(128);
  _padding$3 += forge$t.util.fillString(String.fromCharCode(0), 64);
  _g = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    1,
    6,
    11,
    0,
    5,
    10,
    15,
    4,
    9,
    14,
    3,
    8,
    13,
    2,
    7,
    12,
    5,
    8,
    11,
    14,
    1,
    4,
    7,
    10,
    13,
    0,
    3,
    6,
    9,
    12,
    15,
    2,
    0,
    7,
    14,
    5,
    12,
    3,
    10,
    1,
    8,
    15,
    6,
    13,
    4,
    11,
    2,
    9
  ];
  _r = [
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21
  ];
  _k$2 = new Array(64);
  for (var i = 0; i < 64; ++i) {
    _k$2[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
  }
  _initialized$3 = true;
}
function _update$3(s2, w2, bytes2) {
  var t2, a, b, c, d2, f, r, i;
  var len = bytes2.length();
  while (len >= 64) {
    a = s2.h0;
    b = s2.h1;
    c = s2.h2;
    d2 = s2.h3;
    for (i = 0; i < 16; ++i) {
      w2[i] = bytes2.getInt32Le();
      f = d2 ^ b & (c ^ d2);
      t2 = a + f + _k$2[i] + w2[i];
      r = _r[i];
      a = d2;
      d2 = c;
      c = b;
      b += t2 << r | t2 >>> 32 - r;
    }
    for (; i < 32; ++i) {
      f = c ^ d2 & (b ^ c);
      t2 = a + f + _k$2[i] + w2[_g[i]];
      r = _r[i];
      a = d2;
      d2 = c;
      c = b;
      b += t2 << r | t2 >>> 32 - r;
    }
    for (; i < 48; ++i) {
      f = b ^ c ^ d2;
      t2 = a + f + _k$2[i] + w2[_g[i]];
      r = _r[i];
      a = d2;
      d2 = c;
      c = b;
      b += t2 << r | t2 >>> 32 - r;
    }
    for (; i < 64; ++i) {
      f = c ^ (b | ~d2);
      t2 = a + f + _k$2[i] + w2[_g[i]];
      r = _r[i];
      a = d2;
      d2 = c;
      c = b;
      b += t2 << r | t2 >>> 32 - r;
    }
    s2.h0 = s2.h0 + a | 0;
    s2.h1 = s2.h1 + b | 0;
    s2.h2 = s2.h2 + c | 0;
    s2.h3 = s2.h3 + d2 | 0;
    len -= 64;
  }
}
var forge$s = forge$C;
var pem = forge$s.pem = forge$s.pem || {};
pem.encode = function(msg, options2) {
  options2 = options2 || {};
  var rval = "-----BEGIN " + msg.type + "-----\r\n";
  var header3;
  if (msg.procType) {
    header3 = {
      name: "Proc-Type",
      values: [String(msg.procType.version), msg.procType.type]
    };
    rval += foldHeader(header3);
  }
  if (msg.contentDomain) {
    header3 = { name: "Content-Domain", values: [msg.contentDomain] };
    rval += foldHeader(header3);
  }
  if (msg.dekInfo) {
    header3 = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
    if (msg.dekInfo.parameters) {
      header3.values.push(msg.dekInfo.parameters);
    }
    rval += foldHeader(header3);
  }
  if (msg.headers) {
    for (var i = 0; i < msg.headers.length; ++i) {
      rval += foldHeader(msg.headers[i]);
    }
  }
  if (msg.procType) {
    rval += "\r\n";
  }
  rval += forge$s.util.encode64(msg.body, options2.maxline || 64) + "\r\n";
  rval += "-----END " + msg.type + "-----\r\n";
  return rval;
};
pem.decode = function(str2) {
  var rval = [];
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match2;
  while (true) {
    match2 = rMessage.exec(str2);
    if (!match2) {
      break;
    }
    var type3 = match2[1];
    if (type3 === "NEW CERTIFICATE REQUEST") {
      type3 = "CERTIFICATE REQUEST";
    }
    var msg = {
      type: type3,
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge$s.util.decode64(match2[3])
    };
    rval.push(msg);
    if (!match2[2]) {
      continue;
    }
    var lines = match2[2].split(rCRLF);
    var li = 0;
    while (match2 && li < lines.length) {
      var line = lines[li].replace(/\s+$/, "");
      for (var nl = li + 1; nl < lines.length; ++nl) {
        var next = lines[nl];
        if (!/\s/.test(next[0])) {
          break;
        }
        line += next;
        li = nl;
      }
      match2 = line.match(rHeader);
      if (match2) {
        var header3 = { name: match2[1], values: [] };
        var values = match2[2].split(",");
        for (var vi = 0; vi < values.length; ++vi) {
          header3.values.push(ltrim(values[vi]));
        }
        if (!msg.procType) {
          if (header3.name !== "Proc-Type") {
            throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
          } else if (header3.values.length !== 2) {
            throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
          }
          msg.procType = { version: values[0], type: values[1] };
        } else if (!msg.contentDomain && header3.name === "Content-Domain") {
          msg.contentDomain = values[0] || "";
        } else if (!msg.dekInfo && header3.name === "DEK-Info") {
          if (header3.values.length === 0) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
          }
          msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
        } else {
          msg.headers.push(header3);
        }
      }
      ++li;
    }
    if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
      throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (rval.length === 0) {
    throw new Error("Invalid PEM formatted message.");
  }
  return rval;
};
function foldHeader(header3) {
  var rval = header3.name + ": ";
  var values = [];
  var insertSpace = function(match2, $1) {
    return " " + $1;
  };
  for (var i = 0; i < header3.values.length; ++i) {
    values.push(header3.values[i].replace(/^(\S+\r\n)/, insertSpace));
  }
  rval += values.join(",") + "\r\n";
  var length = 0;
  var candidate = -1;
  for (var i = 0; i < rval.length; ++i, ++length) {
    if (length > 65 && candidate !== -1) {
      var insert2 = rval[candidate];
      if (insert2 === ",") {
        ++candidate;
        rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
      } else {
        rval = rval.substr(0, candidate) + "\r\n" + insert2 + rval.substr(candidate + 1);
      }
      length = i - candidate - 1;
      candidate = -1;
      ++i;
    } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
      candidate = i;
    }
  }
  return rval;
}
function ltrim(str2) {
  return str2.replace(/^\s+/, "");
}
var forge$r = forge$C;
forge$r.des = forge$r.des || {};
forge$r.des.startEncrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key,
    output,
    decrypt: false,
    mode: mode || (iv === null ? "ECB" : "CBC")
  });
  cipher.start(iv);
  return cipher;
};
forge$r.des.createEncryptionCipher = function(key, mode) {
  return _createCipher({
    key,
    output: null,
    decrypt: false,
    mode
  });
};
forge$r.des.startDecrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key,
    output,
    decrypt: true,
    mode: mode || (iv === null ? "ECB" : "CBC")
  });
  cipher.start(iv);
  return cipher;
};
forge$r.des.createDecryptionCipher = function(key, mode) {
  return _createCipher({
    key,
    output: null,
    decrypt: true,
    mode
  });
};
forge$r.des.Algorithm = function(name, mode) {
  var self2 = this;
  self2.name = name;
  self2.mode = new mode({
    blockSize: 8,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self2._keys, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self2._keys, inBlock, outBlock, true);
      }
    }
  });
  self2._init = false;
};
forge$r.des.Algorithm.prototype.initialize = function(options2) {
  if (this._init) {
    return;
  }
  var key = forge$r.util.createBuffer(options2.key);
  if (this.name.indexOf("3DES") === 0) {
    if (key.length() !== 24) {
      throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
    }
  }
  this._keys = _createKeys(key);
  this._init = true;
};
registerAlgorithm("DES-ECB", forge$r.cipher.modes.ecb);
registerAlgorithm("DES-CBC", forge$r.cipher.modes.cbc);
registerAlgorithm("DES-CFB", forge$r.cipher.modes.cfb);
registerAlgorithm("DES-OFB", forge$r.cipher.modes.ofb);
registerAlgorithm("DES-CTR", forge$r.cipher.modes.ctr);
registerAlgorithm("3DES-ECB", forge$r.cipher.modes.ecb);
registerAlgorithm("3DES-CBC", forge$r.cipher.modes.cbc);
registerAlgorithm("3DES-CFB", forge$r.cipher.modes.cfb);
registerAlgorithm("3DES-OFB", forge$r.cipher.modes.ofb);
registerAlgorithm("3DES-CTR", forge$r.cipher.modes.ctr);
function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge$r.des.Algorithm(name, mode);
  };
  forge$r.cipher.registerAlgorithm(name, factory);
}
var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function _createKeys(key) {
  var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
  var iterations = key.length() > 8 ? 3 : 1;
  var keys = [];
  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
  var n = 0, tmp;
  for (var j = 0; j < iterations; j++) {
    var left = key.getInt32();
    var right = key.getInt32();
    tmp = (left >>> 4 ^ right) & 252645135;
    right ^= tmp;
    left ^= tmp << 4;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 2 ^ right) & 858993459;
    right ^= tmp;
    left ^= tmp << 2;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = (right >>> 8 ^ left) & 16711935;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = left << 8 | right >>> 20 & 240;
    left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
    right = tmp;
    for (var i = 0; i < shifts.length; ++i) {
      if (shifts[i]) {
        left = left << 2 | left >>> 26;
        right = right << 2 | right >>> 26;
      } else {
        left = left << 1 | left >>> 27;
        right = right << 1 | right >>> 27;
      }
      left &= -15;
      right &= -15;
      var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
      var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
      tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
      keys[n++] = lefttmp ^ tmp;
      keys[n++] = righttmp ^ tmp << 16;
    }
  }
  return keys;
}
function _updateBlock(keys, input, output, decrypt2) {
  var iterations = keys.length === 32 ? 3 : 9;
  var looping;
  if (iterations === 3) {
    looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
  } else {
    looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  }
  var tmp;
  var left = input[0];
  var right = input[1];
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  left = left << 1 | left >>> 31;
  right = right << 1 | right >>> 31;
  for (var j = 0; j < iterations; j += 3) {
    var endloop = looping[j + 1];
    var loopinc = looping[j + 2];
    for (var i = looping[j]; i != endloop; i += loopinc) {
      var right1 = right ^ keys[i];
      var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
      tmp = left;
      left = right;
      right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
    }
    tmp = left;
    left = right;
    right = tmp;
  }
  left = left >>> 1 | left << 31;
  right = right >>> 1 | right << 31;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  output[0] = left;
  output[1] = right;
}
function _createCipher(options2) {
  options2 = options2 || {};
  var mode = (options2.mode || "CBC").toUpperCase();
  var algorithm = "DES-" + mode;
  var cipher;
  if (options2.decrypt) {
    cipher = forge$r.cipher.createDecipher(algorithm, options2.key);
  } else {
    cipher = forge$r.cipher.createCipher(algorithm, options2.key);
  }
  var start = cipher.start;
  cipher.start = function(iv, options3) {
    var output = null;
    if (options3 instanceof forge$r.util.ByteBuffer) {
      output = options3;
      options3 = {};
    }
    options3 = options3 || {};
    options3.output = output;
    options3.iv = iv;
    start.call(cipher, options3);
  };
  return cipher;
}
var forge$q = forge$C;
var pkcs5 = forge$q.pkcs5 = forge$q.pkcs5 || {};
var crypto$2;
if (forge$q.util.isNodejs && !forge$q.options.usePureJavaScript) {
  crypto$2 = require$$0$6;
}
forge$q.pbkdf2 = pkcs5.pbkdf2 = function(p, s2, c, dkLen, md, callback) {
  if (typeof md === "function") {
    callback = md;
    md = null;
  }
  if (forge$q.util.isNodejs && !forge$q.options.usePureJavaScript && crypto$2.pbkdf2 && (md === null || typeof md !== "object") && (crypto$2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
    if (typeof md !== "string") {
      md = "sha1";
    }
    p = Buffer.from(p, "binary");
    s2 = Buffer.from(s2, "binary");
    if (!callback) {
      if (crypto$2.pbkdf2Sync.length === 4) {
        return crypto$2.pbkdf2Sync(p, s2, c, dkLen).toString("binary");
      }
      return crypto$2.pbkdf2Sync(p, s2, c, dkLen, md).toString("binary");
    }
    if (crypto$2.pbkdf2Sync.length === 4) {
      return crypto$2.pbkdf2(p, s2, c, dkLen, function(err2, key) {
        if (err2) {
          return callback(err2);
        }
        callback(null, key.toString("binary"));
      });
    }
    return crypto$2.pbkdf2(p, s2, c, dkLen, md, function(err2, key) {
      if (err2) {
        return callback(err2);
      }
      callback(null, key.toString("binary"));
    });
  }
  if (typeof md === "undefined" || md === null) {
    md = "sha1";
  }
  if (typeof md === "string") {
    if (!(md in forge$q.md.algorithms)) {
      throw new Error("Unknown hash algorithm: " + md);
    }
    md = forge$q.md[md].create();
  }
  var hLen = md.digestLength;
  if (dkLen > 4294967295 * hLen) {
    var err = new Error("Derived key is too long.");
    if (callback) {
      return callback(err);
    }
    throw err;
  }
  var len = Math.ceil(dkLen / hLen);
  var r = dkLen - (len - 1) * hLen;
  var prf = forge$q.hmac.create();
  prf.start(md, p);
  var dk = "";
  var xor, u_c, u_c1;
  if (!callback) {
    for (var i = 1; i <= len; ++i) {
      prf.start(null, null);
      prf.update(s2);
      prf.update(forge$q.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();
      for (var j = 2; j <= c; ++j) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        xor = forge$q.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }
      dk += i < len ? xor : xor.substr(0, r);
    }
    return dk;
  }
  var i = 1, j;
  function outer() {
    if (i > len) {
      return callback(null, dk);
    }
    prf.start(null, null);
    prf.update(s2);
    prf.update(forge$q.util.int32ToBytes(i));
    xor = u_c1 = prf.digest().getBytes();
    j = 2;
    inner();
  }
  function inner() {
    if (j <= c) {
      prf.start(null, null);
      prf.update(u_c1);
      u_c = prf.digest().getBytes();
      xor = forge$q.util.xorBytes(xor, u_c, hLen);
      u_c1 = u_c;
      ++j;
      return forge$q.util.setImmediate(inner);
    }
    dk += i < len ? xor : xor.substr(0, r);
    ++i;
    outer();
  }
  outer();
};
var forge$p = forge$C;
var sha256 = forge$p.sha256 = forge$p.sha256 || {};
forge$p.md.sha256 = forge$p.md.algorithms.sha256 = sha256;
sha256.create = function() {
  if (!_initialized$2) {
    _init$2();
  }
  var _state2 = null;
  var _input = forge$p.util.createBuffer();
  var _w = new Array(64);
  var md = {
    algorithm: "sha256",
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge$p.util.createBuffer();
    _state2 = {
      h0: 1779033703,
      h1: 3144134277,
      h2: 1013904242,
      h3: 2773480762,
      h4: 1359893119,
      h5: 2600822924,
      h6: 528734635,
      h7: 1541459225
    };
    return md;
  };
  md.start();
  md.update = function(msg, encoding3) {
    if (encoding3 === "utf8") {
      msg = forge$p.util.encodeUtf8(msg);
    }
    var len = msg.length;
    md.messageLength += len;
    len = [len / 4294967296 >>> 0, len >>> 0];
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$2(_state2, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$p.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$2.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state2.h0,
      h1: _state2.h1,
      h2: _state2.h2,
      h3: _state2.h3,
      h4: _state2.h4,
      h5: _state2.h5,
      h6: _state2.h6,
      h7: _state2.h7
    };
    _update$2(s2, _w, finalBlock);
    var rval = forge$p.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };
  return md;
};
var _padding$2 = null;
var _initialized$2 = false;
var _k$1 = null;
function _init$2() {
  _padding$2 = String.fromCharCode(128);
  _padding$2 += forge$p.util.fillString(String.fromCharCode(0), 64);
  _k$1 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  _initialized$2 = true;
}
function _update$2(s2, w2, bytes2) {
  var t1, t2, s0, s1, ch, maj, i, a, b, c, d2, e, f, g, h2;
  var len = bytes2.length();
  while (len >= 64) {
    for (i = 0; i < 16; ++i) {
      w2[i] = bytes2.getInt32();
    }
    for (; i < 64; ++i) {
      t1 = w2[i - 2];
      t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
      t2 = w2[i - 15];
      t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
      w2[i] = t1 + w2[i - 7] + t2 + w2[i - 16] | 0;
    }
    a = s2.h0;
    b = s2.h1;
    c = s2.h2;
    d2 = s2.h3;
    e = s2.h4;
    f = s2.h5;
    g = s2.h6;
    h2 = s2.h7;
    for (i = 0; i < 64; ++i) {
      s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
      ch = g ^ e & (f ^ g);
      s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
      maj = a & b | c & (a ^ b);
      t1 = h2 + s1 + ch + _k$1[i] + w2[i];
      t2 = s0 + maj;
      h2 = g;
      g = f;
      f = e;
      e = d2 + t1 >>> 0;
      d2 = c;
      c = b;
      b = a;
      a = t1 + t2 >>> 0;
    }
    s2.h0 = s2.h0 + a | 0;
    s2.h1 = s2.h1 + b | 0;
    s2.h2 = s2.h2 + c | 0;
    s2.h3 = s2.h3 + d2 | 0;
    s2.h4 = s2.h4 + e | 0;
    s2.h5 = s2.h5 + f | 0;
    s2.h6 = s2.h6 + g | 0;
    s2.h7 = s2.h7 + h2 | 0;
    len -= 64;
  }
}
var forge$o = forge$C;
var _crypto$1 = null;
if (forge$o.util.isNodejs && !forge$o.options.usePureJavaScript && !process.versions["node-webkit"]) {
  _crypto$1 = require$$0$6;
}
var prng = forge$o.prng = forge$o.prng || {};
prng.create = function(plugin) {
  var ctx = {
    plugin,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ""
  };
  var md = plugin.md;
  var pools = new Array(32);
  for (var i = 0; i < 32; ++i) {
    pools[i] = md.create();
  }
  ctx.pools = pools;
  ctx.pool = 0;
  ctx.generate = function(count, callback) {
    if (!callback) {
      return ctx.generateSync(count);
    }
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b = forge$o.util.createBuffer();
    ctx.key = null;
    generate();
    function generate(err) {
      if (err) {
        return callback(err);
      }
      if (b.length() >= count) {
        return callback(null, b.getBytes(count));
      }
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        return forge$o.util.nextTick(function() {
          _reseed(generate);
        });
      }
      var bytes2 = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes2.length;
      b.putBytes(bytes2);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      forge$o.util.setImmediate(generate);
    }
  };
  ctx.generateSync = function(count) {
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    ctx.key = null;
    var b = forge$o.util.createBuffer();
    while (b.length() < count) {
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        _reseedSync();
      }
      var bytes2 = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes2.length;
      b.putBytes(bytes2);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    }
    return b.getBytes(count);
  };
  function _reseed(callback) {
    if (ctx.pools[0].messageLength >= 32) {
      _seed();
      return callback();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.seedFile(needed, function(err, bytes2) {
      if (err) {
        return callback(err);
      }
      ctx.collect(bytes2);
      _seed();
      callback();
    });
  }
  function _reseedSync() {
    if (ctx.pools[0].messageLength >= 32) {
      return _seed();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.collect(ctx.seedFileSync(needed));
    _seed();
  }
  function _seed() {
    ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
    var md2 = ctx.plugin.md.create();
    md2.update(ctx.keyBytes);
    var _2powK = 1;
    for (var k = 0; k < 32; ++k) {
      if (ctx.reseeds % _2powK === 0) {
        md2.update(ctx.pools[k].digest().getBytes());
        ctx.pools[k].start();
      }
      _2powK = _2powK << 1;
    }
    ctx.keyBytes = md2.digest().getBytes();
    md2.start();
    md2.update(ctx.keyBytes);
    var seedBytes = md2.digest().getBytes();
    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
    ctx.seed = ctx.plugin.formatSeed(seedBytes);
    ctx.generated = 0;
  }
  function defaultSeedFile(needed) {
    var getRandomValues = null;
    var globalScope = forge$o.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    var b = forge$o.util.createBuffer();
    if (getRandomValues) {
      while (b.length() < needed) {
        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
        var entropy = new Uint32Array(Math.floor(count));
        try {
          getRandomValues(entropy);
          for (var i2 = 0; i2 < entropy.length; ++i2) {
            b.putInt32(entropy[i2]);
          }
        } catch (e) {
          if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
            throw e;
          }
        }
      }
    }
    if (b.length() < needed) {
      var hi, lo, next;
      var seed = Math.floor(Math.random() * 65536);
      while (b.length() < needed) {
        lo = 16807 * (seed & 65535);
        hi = 16807 * (seed >> 16);
        lo += (hi & 32767) << 16;
        lo += hi >> 15;
        lo = (lo & 2147483647) + (lo >> 31);
        seed = lo & 4294967295;
        for (var i2 = 0; i2 < 3; ++i2) {
          next = seed >>> (i2 << 3);
          next ^= Math.floor(Math.random() * 256);
          b.putByte(next & 255);
        }
      }
    }
    return b.getBytes(needed);
  }
  if (_crypto$1) {
    ctx.seedFile = function(needed, callback) {
      _crypto$1.randomBytes(needed, function(err, bytes2) {
        if (err) {
          return callback(err);
        }
        callback(null, bytes2.toString());
      });
    };
    ctx.seedFileSync = function(needed) {
      return _crypto$1.randomBytes(needed).toString();
    };
  } else {
    ctx.seedFile = function(needed, callback) {
      try {
        callback(null, defaultSeedFile(needed));
      } catch (e) {
        callback(e);
      }
    };
    ctx.seedFileSync = defaultSeedFile;
  }
  ctx.collect = function(bytes2) {
    var count = bytes2.length;
    for (var i2 = 0; i2 < count; ++i2) {
      ctx.pools[ctx.pool].update(bytes2.substr(i2, 1));
      ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
    }
  };
  ctx.collectInt = function(i2, n) {
    var bytes2 = "";
    for (var x = 0; x < n; x += 8) {
      bytes2 += String.fromCharCode(i2 >> x & 255);
    }
    ctx.collect(bytes2);
  };
  ctx.registerWorker = function(worker) {
    if (worker === self) {
      ctx.seedFile = function(needed, callback) {
        function listener3(e) {
          var data = e.data;
          if (data.forge && data.forge.prng) {
            self.removeEventListener("message", listener3);
            callback(data.forge.prng.err, data.forge.prng.bytes);
          }
        }
        self.addEventListener("message", listener3);
        self.postMessage({ forge: { prng: { needed } } });
      };
    } else {
      var listener2 = function(e) {
        var data = e.data;
        if (data.forge && data.forge.prng) {
          ctx.seedFile(data.forge.prng.needed, function(err, bytes2) {
            worker.postMessage({ forge: { prng: { err, bytes: bytes2 } } });
          });
        }
      };
      worker.addEventListener("message", listener2);
    }
  };
  return ctx;
};
var forge$n = forge$C;
(function() {
  if (forge$n.random && forge$n.random.getBytes) {
    forge$n.random;
    return;
  }
  (function(jQuery2) {
    var prng_aes = {};
    var _prng_aes_output = new Array(4);
    var _prng_aes_buffer = forge$n.util.createBuffer();
    prng_aes.formatKey = function(key2) {
      var tmp = forge$n.util.createBuffer(key2);
      key2 = new Array(4);
      key2[0] = tmp.getInt32();
      key2[1] = tmp.getInt32();
      key2[2] = tmp.getInt32();
      key2[3] = tmp.getInt32();
      return forge$n.aes._expandKey(key2, false);
    };
    prng_aes.formatSeed = function(seed) {
      var tmp = forge$n.util.createBuffer(seed);
      seed = new Array(4);
      seed[0] = tmp.getInt32();
      seed[1] = tmp.getInt32();
      seed[2] = tmp.getInt32();
      seed[3] = tmp.getInt32();
      return seed;
    };
    prng_aes.cipher = function(key2, seed) {
      forge$n.aes._updateBlock(key2, seed, _prng_aes_output, false);
      _prng_aes_buffer.putInt32(_prng_aes_output[0]);
      _prng_aes_buffer.putInt32(_prng_aes_output[1]);
      _prng_aes_buffer.putInt32(_prng_aes_output[2]);
      _prng_aes_buffer.putInt32(_prng_aes_output[3]);
      return _prng_aes_buffer.getBytes();
    };
    prng_aes.increment = function(seed) {
      ++seed[3];
      return seed;
    };
    prng_aes.md = forge$n.md.sha256;
    function spawnPrng() {
      var ctx = forge$n.prng.create(prng_aes);
      ctx.getBytes = function(count, callback) {
        return ctx.generate(count, callback);
      };
      ctx.getBytesSync = function(count) {
        return ctx.generate(count);
      };
      return ctx;
    }
    var _ctx = spawnPrng();
    var getRandomValues = null;
    var globalScope = forge$n.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    if (forge$n.options.usePureJavaScript || !forge$n.util.isNodejs && !getRandomValues) {
      _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
      if (typeof navigator !== "undefined") {
        var _navBytes = "";
        for (var key in navigator) {
          try {
            if (typeof navigator[key] == "string") {
              _navBytes += navigator[key];
            }
          } catch (e) {
          }
        }
        _ctx.collect(_navBytes);
        _navBytes = null;
      }
      if (jQuery2) {
        jQuery2().mousemove(function(e) {
          _ctx.collectInt(e.clientX, 16);
          _ctx.collectInt(e.clientY, 16);
        });
        jQuery2().keypress(function(e) {
          _ctx.collectInt(e.charCode, 8);
        });
      }
    }
    if (!forge$n.random) {
      forge$n.random = _ctx;
    } else {
      for (var key in _ctx) {
        forge$n.random[key] = _ctx[key];
      }
    }
    forge$n.random.createInstance = spawnPrng;
    forge$n.random;
  })(typeof jQuery !== "undefined" ? jQuery : null);
})();
var forge$m = forge$C;
var piTable = [
  217,
  120,
  249,
  196,
  25,
  221,
  181,
  237,
  40,
  233,
  253,
  121,
  74,
  160,
  216,
  157,
  198,
  126,
  55,
  131,
  43,
  118,
  83,
  142,
  98,
  76,
  100,
  136,
  68,
  139,
  251,
  162,
  23,
  154,
  89,
  245,
  135,
  179,
  79,
  19,
  97,
  69,
  109,
  141,
  9,
  129,
  125,
  50,
  189,
  143,
  64,
  235,
  134,
  183,
  123,
  11,
  240,
  149,
  33,
  34,
  92,
  107,
  78,
  130,
  84,
  214,
  101,
  147,
  206,
  96,
  178,
  28,
  115,
  86,
  192,
  20,
  167,
  140,
  241,
  220,
  18,
  117,
  202,
  31,
  59,
  190,
  228,
  209,
  66,
  61,
  212,
  48,
  163,
  60,
  182,
  38,
  111,
  191,
  14,
  218,
  70,
  105,
  7,
  87,
  39,
  242,
  29,
  155,
  188,
  148,
  67,
  3,
  248,
  17,
  199,
  246,
  144,
  239,
  62,
  231,
  6,
  195,
  213,
  47,
  200,
  102,
  30,
  215,
  8,
  232,
  234,
  222,
  128,
  82,
  238,
  247,
  132,
  170,
  114,
  172,
  53,
  77,
  106,
  42,
  150,
  26,
  210,
  113,
  90,
  21,
  73,
  116,
  75,
  159,
  208,
  94,
  4,
  24,
  164,
  236,
  194,
  224,
  65,
  110,
  15,
  81,
  203,
  204,
  36,
  145,
  175,
  80,
  161,
  244,
  112,
  57,
  153,
  124,
  58,
  133,
  35,
  184,
  180,
  122,
  252,
  2,
  54,
  91,
  37,
  85,
  151,
  49,
  45,
  93,
  250,
  152,
  227,
  138,
  146,
  174,
  5,
  223,
  41,
  16,
  103,
  108,
  186,
  201,
  211,
  0,
  230,
  207,
  225,
  158,
  168,
  44,
  99,
  22,
  1,
  63,
  88,
  226,
  137,
  169,
  13,
  56,
  52,
  27,
  171,
  51,
  255,
  176,
  187,
  72,
  12,
  95,
  185,
  177,
  205,
  46,
  197,
  243,
  219,
  71,
  229,
  165,
  156,
  119,
  10,
  166,
  32,
  104,
  254,
  127,
  193,
  173
];
var s = [1, 2, 3, 5];
var rol = function(word, bits) {
  return word << bits & 65535 | (word & 65535) >> 16 - bits;
};
var ror = function(word, bits) {
  return (word & 65535) >> bits | word << 16 - bits & 65535;
};
forge$m.rc2 = forge$m.rc2 || {};
forge$m.rc2.expandKey = function(key, effKeyBits) {
  if (typeof key === "string") {
    key = forge$m.util.createBuffer(key);
  }
  effKeyBits = effKeyBits || 128;
  var L2 = key;
  var T = key.length();
  var T1 = effKeyBits;
  var T8 = Math.ceil(T1 / 8);
  var TM = 255 >> (T1 & 7);
  var i;
  for (i = T; i < 128; i++) {
    L2.putByte(piTable[L2.at(i - 1) + L2.at(i - T) & 255]);
  }
  L2.setAt(128 - T8, piTable[L2.at(128 - T8) & TM]);
  for (i = 127 - T8; i >= 0; i--) {
    L2.setAt(i, piTable[L2.at(i + 1) ^ L2.at(i + T8)]);
  }
  return L2;
};
var createCipher = function(key, bits, encrypt) {
  var _finish = false, _input = null, _output = null, _iv = null;
  var mixRound, mashRound;
  var i, j, K = [];
  key = forge$m.rc2.expandKey(key, bits);
  for (i = 0; i < 64; i++) {
    K.push(key.getInt16Le());
  }
  if (encrypt) {
    mixRound = function(R) {
      for (i = 0; i < 4; i++) {
        R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
        R[i] = rol(R[i], s[i]);
        j++;
      }
    };
    mashRound = function(R) {
      for (i = 0; i < 4; i++) {
        R[i] += K[R[(i + 3) % 4] & 63];
      }
    };
  } else {
    mixRound = function(R) {
      for (i = 3; i >= 0; i--) {
        R[i] = ror(R[i], s[i]);
        R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
        j--;
      }
    };
    mashRound = function(R) {
      for (i = 3; i >= 0; i--) {
        R[i] -= K[R[(i + 3) % 4] & 63];
      }
    };
  }
  var runPlan = function(plan2) {
    var R = [];
    for (i = 0; i < 4; i++) {
      var val = _input.getInt16Le();
      if (_iv !== null) {
        if (encrypt) {
          val ^= _iv.getInt16Le();
        } else {
          _iv.putInt16Le(val);
        }
      }
      R.push(val & 65535);
    }
    j = encrypt ? 0 : 63;
    for (var ptr = 0; ptr < plan2.length; ptr++) {
      for (var ctr = 0; ctr < plan2[ptr][0]; ctr++) {
        plan2[ptr][1](R);
      }
    }
    for (i = 0; i < 4; i++) {
      if (_iv !== null) {
        if (encrypt) {
          _iv.putInt16Le(R[i]);
        } else {
          R[i] ^= _iv.getInt16Le();
        }
      }
      _output.putInt16Le(R[i]);
    }
  };
  var cipher = null;
  cipher = {
    /**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */
    start: function(iv, output) {
      if (iv) {
        if (typeof iv === "string") {
          iv = forge$m.util.createBuffer(iv);
        }
      }
      _finish = false;
      _input = forge$m.util.createBuffer();
      _output = output || new forge$m.util.createBuffer();
      _iv = iv;
      cipher.output = _output;
    },
    /**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */
    update: function(input) {
      if (!_finish) {
        _input.putBuffer(input);
      }
      while (_input.length() >= 8) {
        runPlan([
          [5, mixRound],
          [1, mashRound],
          [6, mixRound],
          [1, mashRound],
          [5, mixRound]
        ]);
      }
    },
    /**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */
    finish: function(pad) {
      var rval = true;
      if (encrypt) {
        if (pad) {
          rval = pad(8, _input, !encrypt);
        } else {
          var padding = _input.length() === 8 ? 8 : 8 - _input.length();
          _input.fillWithByte(padding, padding);
        }
      }
      if (rval) {
        _finish = true;
        cipher.update();
      }
      if (!encrypt) {
        rval = _input.length() === 0;
        if (rval) {
          if (pad) {
            rval = pad(8, _output, !encrypt);
          } else {
            var len = _output.length();
            var count = _output.at(len - 1);
            if (count > len) {
              rval = false;
            } else {
              _output.truncate(count);
            }
          }
        }
      }
      return rval;
    }
  };
  return cipher;
};
forge$m.rc2.startEncrypting = function(key, iv, output) {
  var cipher = forge$m.rc2.createEncryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};
forge$m.rc2.createEncryptionCipher = function(key, bits) {
  return createCipher(key, bits, true);
};
forge$m.rc2.startDecrypting = function(key, iv, output) {
  var cipher = forge$m.rc2.createDecryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};
forge$m.rc2.createDecryptionCipher = function(key, bits) {
  return createCipher(key, bits, false);
};
var forge$l = forge$C;
forge$l.jsbn = forge$l.jsbn || {};
var dbits;
function BigInteger$5(a, b, c) {
  this.data = [];
  if (a != null)
    if ("number" == typeof a) this.fromNumber(a, b, c);
    else if (b == null && "string" != typeof a) this.fromString(a, 256);
    else this.fromString(a, b);
}
forge$l.jsbn.BigInteger = BigInteger$5;
function nbi() {
  return new BigInteger$5(null);
}
function am1(i, x, w2, j, c, n) {
  while (--n >= 0) {
    var v = x * this.data[i++] + w2.data[j] + c;
    c = Math.floor(v / 67108864);
    w2.data[j++] = v & 67108863;
  }
  return c;
}
function am2(i, x, w2, j, c, n) {
  var xl = x & 32767, xh = x >> 15;
  while (--n >= 0) {
    var l = this.data[i] & 32767;
    var h2 = this.data[i++] >> 15;
    var m2 = xh * l + h2 * xl;
    l = xl * l + ((m2 & 32767) << 15) + w2.data[j] + (c & 1073741823);
    c = (l >>> 30) + (m2 >>> 15) + xh * h2 + (c >>> 30);
    w2.data[j++] = l & 1073741823;
  }
  return c;
}
function am3(i, x, w2, j, c, n) {
  var xl = x & 16383, xh = x >> 14;
  while (--n >= 0) {
    var l = this.data[i] & 16383;
    var h2 = this.data[i++] >> 14;
    var m2 = xh * l + h2 * xl;
    l = xl * l + ((m2 & 16383) << 14) + w2.data[j] + c;
    c = (l >> 28) + (m2 >> 14) + xh * h2;
    w2.data[j++] = l & 268435455;
  }
  return c;
}
if (typeof navigator === "undefined") {
  BigInteger$5.prototype.am = am3;
  dbits = 28;
} else if (navigator.appName == "Microsoft Internet Explorer") {
  BigInteger$5.prototype.am = am2;
  dbits = 30;
} else if (navigator.appName != "Netscape") {
  BigInteger$5.prototype.am = am1;
  dbits = 26;
} else {
  BigInteger$5.prototype.am = am3;
  dbits = 28;
}
BigInteger$5.prototype.DB = dbits;
BigInteger$5.prototype.DM = (1 << dbits) - 1;
BigInteger$5.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger$5.prototype.FV = Math.pow(2, BI_FP);
BigInteger$5.prototype.F1 = BI_FP - dbits;
BigInteger$5.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
function int2char(n) {
  return BI_RM.charAt(n);
}
function intAt(s2, i) {
  var c = BI_RC[s2.charCodeAt(i)];
  return c == null ? -1 : c;
}
function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
  r.t = this.t;
  r.s = this.s;
}
function bnpFromInt(x) {
  this.t = 1;
  this.s = x < 0 ? -1 : 0;
  if (x > 0) this.data[0] = x;
  else if (x < -1) this.data[0] = x + this.DV;
  else this.t = 0;
}
function nbv(i) {
  var r = nbi();
  r.fromInt(i);
  return r;
}
function bnpFromString(s2, b) {
  var k;
  if (b == 16) k = 4;
  else if (b == 8) k = 3;
  else if (b == 256) k = 8;
  else if (b == 2) k = 1;
  else if (b == 32) k = 5;
  else if (b == 4) k = 2;
  else {
    this.fromRadix(s2, b);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i = s2.length, mi = false, sh = 0;
  while (--i >= 0) {
    var x = k == 8 ? s2[i] & 255 : intAt(s2, i);
    if (x < 0) {
      if (s2.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if (sh == 0)
      this.data[this.t++] = x;
    else if (sh + k > this.DB) {
      this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
      this.data[this.t++] = x >> this.DB - sh;
    } else
      this.data[this.t - 1] |= x << sh;
    sh += k;
    if (sh >= this.DB) sh -= this.DB;
  }
  if (k == 8 && (s2[0] & 128) != 0) {
    this.s = -1;
    if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
  }
  this.clamp();
  if (mi) BigInteger$5.ZERO.subTo(this, this);
}
function bnpClamp() {
  var c = this.s & this.DM;
  while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
}
function bnToString(b) {
  if (this.s < 0) return "-" + this.negate().toString(b);
  var k;
  if (b == 16) k = 4;
  else if (b == 8) k = 3;
  else if (b == 2) k = 1;
  else if (b == 32) k = 5;
  else if (b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1 << k) - 1, d2, m2 = false, r = "", i = this.t;
  var p = this.DB - i * this.DB % k;
  if (i-- > 0) {
    if (p < this.DB && (d2 = this.data[i] >> p) > 0) {
      m2 = true;
      r = int2char(d2);
    }
    while (i >= 0) {
      if (p < k) {
        d2 = (this.data[i] & (1 << p) - 1) << k - p;
        d2 |= this.data[--i] >> (p += this.DB - k);
      } else {
        d2 = this.data[i] >> (p -= k) & km;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if (d2 > 0) m2 = true;
      if (m2) r += int2char(d2);
    }
  }
  return m2 ? r : "0";
}
function bnNegate() {
  var r = nbi();
  BigInteger$5.ZERO.subTo(this, r);
  return r;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(a) {
  var r = this.s - a.s;
  if (r != 0) return r;
  var i = this.t;
  r = i - a.t;
  if (r != 0) return this.s < 0 ? -r : r;
  while (--i >= 0) if ((r = this.data[i] - a.data[i]) != 0) return r;
  return 0;
}
function nbits(x) {
  var r = 1, t2;
  if ((t2 = x >>> 16) != 0) {
    x = t2;
    r += 16;
  }
  if ((t2 = x >> 8) != 0) {
    x = t2;
    r += 8;
  }
  if ((t2 = x >> 4) != 0) {
    x = t2;
    r += 4;
  }
  if ((t2 = x >> 2) != 0) {
    x = t2;
    r += 2;
  }
  if ((t2 = x >> 1) != 0) {
    x = t2;
    r += 1;
  }
  return r;
}
function bnBitLength() {
  if (this.t <= 0) return 0;
  return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(n, r) {
  var i;
  for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
  for (i = n - 1; i >= 0; --i) r.data[i] = 0;
  r.t = this.t + n;
  r.s = this.s;
}
function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
  r.t = Math.max(this.t - n, 0);
  r.s = this.s;
}
function bnpLShiftTo(n, r) {
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
  for (i = this.t - 1; i >= 0; --i) {
    r.data[i + ds + 1] = this.data[i] >> cbs | c;
    c = (this.data[i] & bm) << bs;
  }
  for (i = ds - 1; i >= 0; --i) r.data[i] = 0;
  r.data[ds] = c;
  r.t = this.t + ds + 1;
  r.s = this.s;
  r.clamp();
}
function bnpRShiftTo(n, r) {
  r.s = this.s;
  var ds = Math.floor(n / this.DB);
  if (ds >= this.t) {
    r.t = 0;
    return;
  }
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r.data[0] = this.data[ds] >> bs;
  for (var i = ds + 1; i < this.t; ++i) {
    r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
    r.data[i - ds] = this.data[i] >> bs;
  }
  if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
  r.t = this.t - ds;
  r.clamp();
}
function bnpSubTo(a, r) {
  var i = 0, c = 0, m2 = Math.min(a.t, this.t);
  while (i < m2) {
    c += this.data[i] - a.data[i];
    r.data[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c -= a.s;
    while (i < this.t) {
      c += this.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c -= a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c < -1) r.data[i++] = this.DV + c;
  else if (c > 0) r.data[i++] = c;
  r.t = i;
  r.clamp();
}
function bnpMultiplyTo(a, r) {
  var x = this.abs(), y2 = a.abs();
  var i = x.t;
  r.t = i + y2.t;
  while (--i >= 0) r.data[i] = 0;
  for (i = 0; i < y2.t; ++i) r.data[i + x.t] = x.am(0, y2.data[i], r, i, 0, x.t);
  r.s = 0;
  r.clamp();
  if (this.s != a.s) BigInteger$5.ZERO.subTo(r, r);
}
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2 * x.t;
  while (--i >= 0) r.data[i] = 0;
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
    if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r.data[i + x.t] -= x.DV;
      r.data[i + x.t + 1] = 1;
    }
  }
  if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
  r.s = 0;
  r.clamp();
}
function bnpDivRemTo(m2, q, r) {
  var pm = m2.abs();
  if (pm.t <= 0) return;
  var pt = this.abs();
  if (pt.t < pm.t) {
    if (q != null) q.fromInt(0);
    if (r != null) this.copyTo(r);
    return;
  }
  if (r == null) r = nbi();
  var y2 = nbi(), ts = this.s, ms2 = m2.s;
  var nsh = this.DB - nbits(pm.data[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y2);
    pt.lShiftTo(nsh, r);
  } else {
    pm.copyTo(y2);
    pt.copyTo(r);
  }
  var ys = y2.t;
  var y0 = y2.data[ys - 1];
  if (y0 == 0) return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y2.data[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
  var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
  y2.dlShiftTo(j, t2);
  if (r.compareTo(t2) >= 0) {
    r.data[r.t++] = 1;
    r.subTo(t2, r);
  }
  BigInteger$5.ONE.dlShiftTo(ys, t2);
  t2.subTo(y2, y2);
  while (y2.t < ys) y2.data[y2.t++] = 0;
  while (--j >= 0) {
    var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
    if ((r.data[i] += y2.am(0, qd, r, j, 0, ys)) < qd) {
      y2.dlShiftTo(j, t2);
      r.subTo(t2, r);
      while (r.data[i] < --qd) r.subTo(t2, r);
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q);
    if (ts != ms2) BigInteger$5.ZERO.subTo(q, q);
  }
  r.t = ys;
  r.clamp();
  if (nsh > 0) r.rShiftTo(nsh, r);
  if (ts < 0) BigInteger$5.ZERO.subTo(r, r);
}
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a, null, r);
  if (this.s < 0 && r.compareTo(BigInteger$5.ZERO) > 0) a.subTo(r, r);
  return r;
}
function Classic(m2) {
  this.m = m2;
}
function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) {
  return x;
}
function cReduce(x) {
  x.divRemTo(this.m, null, x);
}
function cMulTo(x, y2, r) {
  x.multiplyTo(y2, r);
  this.reduce(r);
}
function cSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
  if (this.t < 1) return 0;
  var x = this.data[0];
  if ((x & 1) == 0) return 0;
  var y2 = x & 3;
  y2 = y2 * (2 - (x & 15) * y2) & 15;
  y2 = y2 * (2 - (x & 255) * y2) & 255;
  y2 = y2 * (2 - ((x & 65535) * y2 & 65535)) & 65535;
  y2 = y2 * (2 - x * y2 % this.DV) % this.DV;
  return y2 > 0 ? this.DV - y2 : -y2;
}
function Montgomery(m2) {
  this.m = m2;
  this.mp = m2.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m2.DB - 15) - 1;
  this.mt2 = 2 * m2.t;
}
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t, r);
  r.divRemTo(this.m, null, r);
  if (x.s < 0 && r.compareTo(BigInteger$5.ZERO) > 0) this.m.subTo(r, r);
  return r;
}
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}
function montReduce(x) {
  while (x.t <= this.mt2)
    x.data[x.t++] = 0;
  for (var i = 0; i < this.m.t; ++i) {
    var j = x.data[i] & 32767;
    var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
    j = i + this.m.t;
    x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
    while (x.data[j] >= x.DV) {
      x.data[j] -= x.DV;
      x.data[++j]++;
    }
  }
  x.clamp();
  x.drShiftTo(this.m.t, x);
  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}
function montSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function montMulTo(x, y2, r) {
  x.multiplyTo(y2, r);
  this.reduce(r);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function bnpExp(e, z2) {
  if (e > 4294967295 || e < 1) return BigInteger$5.ONE;
  var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
  g.copyTo(r);
  while (--i >= 0) {
    z2.sqrTo(r, r2);
    if ((e & 1 << i) > 0) z2.mulTo(r2, g, r);
    else {
      var t2 = r;
      r = r2;
      r2 = t2;
    }
  }
  return z2.revert(r);
}
function bnModPowInt(e, m2) {
  var z2;
  if (e < 256 || m2.isEven()) z2 = new Classic(m2);
  else z2 = new Montgomery(m2);
  return this.exp(e, z2);
}
BigInteger$5.prototype.copyTo = bnpCopyTo;
BigInteger$5.prototype.fromInt = bnpFromInt;
BigInteger$5.prototype.fromString = bnpFromString;
BigInteger$5.prototype.clamp = bnpClamp;
BigInteger$5.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger$5.prototype.drShiftTo = bnpDRShiftTo;
BigInteger$5.prototype.lShiftTo = bnpLShiftTo;
BigInteger$5.prototype.rShiftTo = bnpRShiftTo;
BigInteger$5.prototype.subTo = bnpSubTo;
BigInteger$5.prototype.multiplyTo = bnpMultiplyTo;
BigInteger$5.prototype.squareTo = bnpSquareTo;
BigInteger$5.prototype.divRemTo = bnpDivRemTo;
BigInteger$5.prototype.invDigit = bnpInvDigit;
BigInteger$5.prototype.isEven = bnpIsEven;
BigInteger$5.prototype.exp = bnpExp;
BigInteger$5.prototype.toString = bnToString;
BigInteger$5.prototype.negate = bnNegate;
BigInteger$5.prototype.abs = bnAbs;
BigInteger$5.prototype.compareTo = bnCompareTo;
BigInteger$5.prototype.bitLength = bnBitLength;
BigInteger$5.prototype.mod = bnMod;
BigInteger$5.prototype.modPowInt = bnModPowInt;
BigInteger$5.ZERO = nbv(0);
BigInteger$5.ONE = nbv(1);
function bnClone() {
  var r = nbi();
  this.copyTo(r);
  return r;
}
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) return this.data[0] - this.DV;
    else if (this.t == 0) return -1;
  } else if (this.t == 1) return this.data[0];
  else if (this.t == 0) return 0;
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function bnByteValue() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function bnShortValue() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r));
}
function bnSigNum() {
  if (this.s < 0) return -1;
  else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
  else return 1;
}
function bnpToRadix(b) {
  if (b == null) b = 10;
  if (this.signum() == 0 || b < 2 || b > 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b, cs);
  var d2 = nbv(a), y2 = nbi(), z2 = nbi(), r = "";
  this.divRemTo(d2, y2, z2);
  while (y2.signum() > 0) {
    r = (a + z2.intValue()).toString(b).substr(1) + r;
    y2.divRemTo(d2, y2, z2);
  }
  return z2.intValue().toString(b) + r;
}
function bnpFromRadix(s2, b) {
  this.fromInt(0);
  if (b == null) b = 10;
  var cs = this.chunkSize(b);
  var d2 = Math.pow(b, cs), mi = false, j = 0, w2 = 0;
  for (var i = 0; i < s2.length; ++i) {
    var x = intAt(s2, i);
    if (x < 0) {
      if (s2.charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }
    w2 = b * w2 + x;
    if (++j >= cs) {
      this.dMultiply(d2);
      this.dAddOffset(w2, 0);
      j = 0;
      w2 = 0;
    }
  }
  if (j > 0) {
    this.dMultiply(Math.pow(b, j));
    this.dAddOffset(w2, 0);
  }
  if (mi) BigInteger$5.ZERO.subTo(this, this);
}
function bnpFromNumber(a, b, c) {
  if ("number" == typeof b) {
    if (a < 2) this.fromInt(1);
    else {
      this.fromNumber(a, c);
      if (!this.testBit(a - 1))
        this.bitwiseTo(BigInteger$5.ONE.shiftLeft(a - 1), op_or, this);
      if (this.isEven()) this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a) this.subTo(BigInteger$5.ONE.shiftLeft(a - 1), this);
      }
    }
  } else {
    var x = new Array(), t2 = a & 7;
    x.length = (a >> 3) + 1;
    b.nextBytes(x);
    if (t2 > 0) x[0] &= (1 << t2) - 1;
    else x[0] = 0;
    this.fromString(x, 256);
  }
}
function bnToByteArray() {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB - i * this.DB % 8, d2, k = 0;
  if (i-- > 0) {
    if (p < this.DB && (d2 = this.data[i] >> p) != (this.s & this.DM) >> p)
      r[k++] = d2 | this.s << this.DB - p;
    while (i >= 0) {
      if (p < 8) {
        d2 = (this.data[i] & (1 << p) - 1) << 8 - p;
        d2 |= this.data[--i] >> (p += this.DB - 8);
      } else {
        d2 = this.data[i] >> (p -= 8) & 255;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if ((d2 & 128) != 0) d2 |= -256;
      if (k == 0 && (this.s & 128) != (d2 & 128)) ++k;
      if (k > 0 || d2 != this.s) r[k++] = d2;
    }
  }
  return r;
}
function bnEquals(a) {
  return this.compareTo(a) == 0;
}
function bnMin(a) {
  return this.compareTo(a) < 0 ? this : a;
}
function bnMax(a) {
  return this.compareTo(a) > 0 ? this : a;
}
function bnpBitwiseTo(a, op, r) {
  var i, f, m2 = Math.min(a.t, this.t);
  for (i = 0; i < m2; ++i) r.data[i] = op(this.data[i], a.data[i]);
  if (a.t < this.t) {
    f = a.s & this.DM;
    for (i = m2; i < this.t; ++i) r.data[i] = op(this.data[i], f);
    r.t = this.t;
  } else {
    f = this.s & this.DM;
    for (i = m2; i < a.t; ++i) r.data[i] = op(f, a.data[i]);
    r.t = a.t;
  }
  r.s = op(this.s, a.s);
  r.clamp();
}
function op_and(x, y2) {
  return x & y2;
}
function bnAnd(a) {
  var r = nbi();
  this.bitwiseTo(a, op_and, r);
  return r;
}
function op_or(x, y2) {
  return x | y2;
}
function bnOr(a) {
  var r = nbi();
  this.bitwiseTo(a, op_or, r);
  return r;
}
function op_xor(x, y2) {
  return x ^ y2;
}
function bnXor(a) {
  var r = nbi();
  this.bitwiseTo(a, op_xor, r);
  return r;
}
function op_andnot(x, y2) {
  return x & ~y2;
}
function bnAndNot(a) {
  var r = nbi();
  this.bitwiseTo(a, op_andnot, r);
  return r;
}
function bnNot() {
  var r = nbi();
  for (var i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}
function bnShiftLeft(n) {
  var r = nbi();
  if (n < 0) this.rShiftTo(-n, r);
  else this.lShiftTo(n, r);
  return r;
}
function bnShiftRight(n) {
  var r = nbi();
  if (n < 0) this.lShiftTo(-n, r);
  else this.rShiftTo(n, r);
  return r;
}
function lbit(x) {
  if (x == 0) return -1;
  var r = 0;
  if ((x & 65535) == 0) {
    x >>= 16;
    r += 16;
  }
  if ((x & 255) == 0) {
    x >>= 8;
    r += 8;
  }
  if ((x & 15) == 0) {
    x >>= 4;
    r += 4;
  }
  if ((x & 3) == 0) {
    x >>= 2;
    r += 2;
  }
  if ((x & 1) == 0) ++r;
  return r;
}
function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i)
    if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
  if (this.s < 0) return this.t * this.DB;
  return -1;
}
function cbit(x) {
  var r = 0;
  while (x != 0) {
    x &= x - 1;
    ++r;
  }
  return r;
}
function bnBitCount() {
  var r = 0, x = this.s & this.DM;
  for (var i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
  return r;
}
function bnTestBit(n) {
  var j = Math.floor(n / this.DB);
  if (j >= this.t) return this.s != 0;
  return (this.data[j] & 1 << n % this.DB) != 0;
}
function bnpChangeBit(n, op) {
  var r = BigInteger$5.ONE.shiftLeft(n);
  this.bitwiseTo(r, op, r);
  return r;
}
function bnSetBit(n) {
  return this.changeBit(n, op_or);
}
function bnClearBit(n) {
  return this.changeBit(n, op_andnot);
}
function bnFlipBit(n) {
  return this.changeBit(n, op_xor);
}
function bnpAddTo(a, r) {
  var i = 0, c = 0, m2 = Math.min(a.t, this.t);
  while (i < m2) {
    c += this.data[i] + a.data[i];
    r.data[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c += a.s;
    while (i < this.t) {
      c += this.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c += a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c > 0) r.data[i++] = c;
  else if (c < -1) r.data[i++] = this.DV + c;
  r.t = i;
  r.clamp();
}
function bnAdd(a) {
  var r = nbi();
  this.addTo(a, r);
  return r;
}
function bnSubtract(a) {
  var r = nbi();
  this.subTo(a, r);
  return r;
}
function bnMultiply(a) {
  var r = nbi();
  this.multiplyTo(a, r);
  return r;
}
function bnDivide(a) {
  var r = nbi();
  this.divRemTo(a, r, null);
  return r;
}
function bnRemainder(a) {
  var r = nbi();
  this.divRemTo(a, null, r);
  return r;
}
function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a, q, r);
  return new Array(q, r);
}
function bnpDMultiply(n) {
  this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
}
function bnpDAddOffset(n, w2) {
  if (n == 0) return;
  while (this.t <= w2) this.data[this.t++] = 0;
  this.data[w2] += n;
  while (this.data[w2] >= this.DV) {
    this.data[w2] -= this.DV;
    if (++w2 >= this.t) this.data[this.t++] = 0;
    ++this.data[w2];
  }
}
function NullExp() {
}
function nNop(x) {
  return x;
}
function nMulTo(x, y2, r) {
  x.multiplyTo(y2, r);
}
function nSqrTo(x, r) {
  x.squareTo(r);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(e) {
  return this.exp(e, new NullExp());
}
function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n);
  r.s = 0;
  r.t = i;
  while (i > 0) r.data[--i] = 0;
  var j;
  for (j = r.t - this.t; i < j; ++i) r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a.data[i], r, i, 0, n - i);
  r.clamp();
}
function bnpMultiplyUpperTo(a, n, r) {
  --n;
  var i = r.t = this.t + a.t - n;
  r.s = 0;
  while (--i >= 0) r.data[i] = 0;
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
  r.clamp();
  r.drShiftTo(1, r);
}
function Barrett(m2) {
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger$5.ONE.dlShiftTo(2 * m2.t, this.r2);
  this.mu = this.r2.divide(m2);
  this.m = m2;
}
function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
  else if (x.compareTo(this.m) < 0) return x;
  else {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
}
function barrettRevert(x) {
  return x;
}
function barrettReduce(x) {
  x.drShiftTo(this.m.t - 1, this.r2);
  if (x.t > this.m.t + 1) {
    x.t = this.m.t + 1;
    x.clamp();
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
  x.subTo(this.r2, x);
  while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}
function barrettSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function barrettMulTo(x, y2, r) {
  x.multiplyTo(y2, r);
  this.reduce(r);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(e, m2) {
  var i = e.bitLength(), k, r = nbv(1), z2;
  if (i <= 0) return r;
  else if (i < 18) k = 1;
  else if (i < 48) k = 3;
  else if (i < 144) k = 4;
  else if (i < 768) k = 5;
  else k = 6;
  if (i < 8)
    z2 = new Classic(m2);
  else if (m2.isEven())
    z2 = new Barrett(m2);
  else
    z2 = new Montgomery(m2);
  var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
  g[1] = z2.convert(this);
  if (k > 1) {
    var g2 = nbi();
    z2.sqrTo(g[1], g2);
    while (n <= km) {
      g[n] = nbi();
      z2.mulTo(g2, g[n - 2], g[n]);
      n += 2;
    }
  }
  var j = e.t - 1, w2, is1 = true, r2 = nbi(), t2;
  i = nbits(e.data[j]) - 1;
  while (j >= 0) {
    if (i >= k1) w2 = e.data[j] >> i - k1 & km;
    else {
      w2 = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
      if (j > 0) w2 |= e.data[j - 1] >> this.DB + i - k1;
    }
    n = k;
    while ((w2 & 1) == 0) {
      w2 >>= 1;
      --n;
    }
    if ((i -= n) < 0) {
      i += this.DB;
      --j;
    }
    if (is1) {
      g[w2].copyTo(r);
      is1 = false;
    } else {
      while (n > 1) {
        z2.sqrTo(r, r2);
        z2.sqrTo(r2, r);
        n -= 2;
      }
      if (n > 0) z2.sqrTo(r, r2);
      else {
        t2 = r;
        r = r2;
        r2 = t2;
      }
      z2.mulTo(r2, g[w2], r);
    }
    while (j >= 0 && (e.data[j] & 1 << i) == 0) {
      z2.sqrTo(r, r2);
      t2 = r;
      r = r2;
      r2 = t2;
      if (--i < 0) {
        i = this.DB - 1;
        --j;
      }
    }
  }
  return z2.revert(r);
}
function bnGCD(a) {
  var x = this.s < 0 ? this.negate() : this.clone();
  var y2 = a.s < 0 ? a.negate() : a.clone();
  if (x.compareTo(y2) < 0) {
    var t2 = x;
    x = y2;
    y2 = t2;
  }
  var i = x.getLowestSetBit(), g = y2.getLowestSetBit();
  if (g < 0) return x;
  if (i < g) g = i;
  if (g > 0) {
    x.rShiftTo(g, x);
    y2.rShiftTo(g, y2);
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
    if ((i = y2.getLowestSetBit()) > 0) y2.rShiftTo(i, y2);
    if (x.compareTo(y2) >= 0) {
      x.subTo(y2, x);
      x.rShiftTo(1, x);
    } else {
      y2.subTo(x, y2);
      y2.rShiftTo(1, y2);
    }
  }
  if (g > 0) y2.lShiftTo(g, y2);
  return y2;
}
function bnpModInt(n) {
  if (n <= 0) return 0;
  var d2 = this.DV % n, r = this.s < 0 ? n - 1 : 0;
  if (this.t > 0)
    if (d2 == 0) r = this.data[0] % n;
    else for (var i = this.t - 1; i >= 0; --i) r = (d2 * r + this.data[i]) % n;
  return r;
}
function bnModInverse(m2) {
  var ac = m2.isEven();
  if (this.isEven() && ac || m2.signum() == 0) return BigInteger$5.ZERO;
  var u = m2.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d2 = nbv(1);
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u);
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a);
          b.subTo(m2, b);
        }
        a.rShiftTo(1, a);
      } else if (!b.isEven()) b.subTo(m2, b);
      b.rShiftTo(1, b);
    }
    while (v.isEven()) {
      v.rShiftTo(1, v);
      if (ac) {
        if (!c.isEven() || !d2.isEven()) {
          c.addTo(this, c);
          d2.subTo(m2, d2);
        }
        c.rShiftTo(1, c);
      } else if (!d2.isEven()) d2.subTo(m2, d2);
      d2.rShiftTo(1, d2);
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u);
      if (ac) a.subTo(c, a);
      b.subTo(d2, b);
    } else {
      v.subTo(u, v);
      if (ac) c.subTo(a, c);
      d2.subTo(b, d2);
    }
  }
  if (v.compareTo(BigInteger$5.ONE) != 0) return BigInteger$5.ZERO;
  if (d2.compareTo(m2) >= 0) return d2.subtract(m2);
  if (d2.signum() < 0) d2.addTo(m2, d2);
  else return d2;
  if (d2.signum() < 0) return d2.add(m2);
  else return d2;
}
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(t2) {
  var i, x = this.abs();
  if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i)
      if (x.data[0] == lowprimes[i]) return true;
    return false;
  }
  if (x.isEven()) return false;
  i = 1;
  while (i < lowprimes.length) {
    var m2 = lowprimes[i], j = i + 1;
    while (j < lowprimes.length && m2 < lplim) m2 *= lowprimes[j++];
    m2 = x.modInt(m2);
    while (i < j) if (m2 % lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t2);
}
function bnpMillerRabin(t2) {
  var n1 = this.subtract(BigInteger$5.ONE);
  var k = n1.getLowestSetBit();
  if (k <= 0) return false;
  var r = n1.shiftRight(k);
  var prng2 = bnGetPrng();
  var a;
  for (var i = 0; i < t2; ++i) {
    do {
      a = new BigInteger$5(this.bitLength(), prng2);
    } while (a.compareTo(BigInteger$5.ONE) <= 0 || a.compareTo(n1) >= 0);
    var y2 = a.modPow(r, this);
    if (y2.compareTo(BigInteger$5.ONE) != 0 && y2.compareTo(n1) != 0) {
      var j = 1;
      while (j++ < k && y2.compareTo(n1) != 0) {
        y2 = y2.modPowInt(2, this);
        if (y2.compareTo(BigInteger$5.ONE) == 0) return false;
      }
      if (y2.compareTo(n1) != 0) return false;
    }
  }
  return true;
}
function bnGetPrng() {
  return {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      for (var i = 0; i < x.length; ++i) {
        x[i] = Math.floor(Math.random() * 256);
      }
    }
  };
}
BigInteger$5.prototype.chunkSize = bnpChunkSize;
BigInteger$5.prototype.toRadix = bnpToRadix;
BigInteger$5.prototype.fromRadix = bnpFromRadix;
BigInteger$5.prototype.fromNumber = bnpFromNumber;
BigInteger$5.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger$5.prototype.changeBit = bnpChangeBit;
BigInteger$5.prototype.addTo = bnpAddTo;
BigInteger$5.prototype.dMultiply = bnpDMultiply;
BigInteger$5.prototype.dAddOffset = bnpDAddOffset;
BigInteger$5.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger$5.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger$5.prototype.modInt = bnpModInt;
BigInteger$5.prototype.millerRabin = bnpMillerRabin;
BigInteger$5.prototype.clone = bnClone;
BigInteger$5.prototype.intValue = bnIntValue;
BigInteger$5.prototype.byteValue = bnByteValue;
BigInteger$5.prototype.shortValue = bnShortValue;
BigInteger$5.prototype.signum = bnSigNum;
BigInteger$5.prototype.toByteArray = bnToByteArray;
BigInteger$5.prototype.equals = bnEquals;
BigInteger$5.prototype.min = bnMin;
BigInteger$5.prototype.max = bnMax;
BigInteger$5.prototype.and = bnAnd;
BigInteger$5.prototype.or = bnOr;
BigInteger$5.prototype.xor = bnXor;
BigInteger$5.prototype.andNot = bnAndNot;
BigInteger$5.prototype.not = bnNot;
BigInteger$5.prototype.shiftLeft = bnShiftLeft;
BigInteger$5.prototype.shiftRight = bnShiftRight;
BigInteger$5.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger$5.prototype.bitCount = bnBitCount;
BigInteger$5.prototype.testBit = bnTestBit;
BigInteger$5.prototype.setBit = bnSetBit;
BigInteger$5.prototype.clearBit = bnClearBit;
BigInteger$5.prototype.flipBit = bnFlipBit;
BigInteger$5.prototype.add = bnAdd;
BigInteger$5.prototype.subtract = bnSubtract;
BigInteger$5.prototype.multiply = bnMultiply;
BigInteger$5.prototype.divide = bnDivide;
BigInteger$5.prototype.remainder = bnRemainder;
BigInteger$5.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger$5.prototype.modPow = bnModPow;
BigInteger$5.prototype.modInverse = bnModInverse;
BigInteger$5.prototype.pow = bnPow;
BigInteger$5.prototype.gcd = bnGCD;
BigInteger$5.prototype.isProbablePrime = bnIsProbablePrime;
var forge$k = forge$C;
var sha1 = forge$k.sha1 = forge$k.sha1 || {};
forge$k.md.sha1 = forge$k.md.algorithms.sha1 = sha1;
sha1.create = function() {
  if (!_initialized$1) {
    _init$1();
  }
  var _state2 = null;
  var _input = forge$k.util.createBuffer();
  var _w = new Array(80);
  var md = {
    algorithm: "sha1",
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge$k.util.createBuffer();
    _state2 = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878,
      h4: 3285377520
    };
    return md;
  };
  md.start();
  md.update = function(msg, encoding3) {
    if (encoding3 === "utf8") {
      msg = forge$k.util.encodeUtf8(msg);
    }
    var len = msg.length;
    md.messageLength += len;
    len = [len / 4294967296 >>> 0, len >>> 0];
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$1(_state2, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$k.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$1.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state2.h0,
      h1: _state2.h1,
      h2: _state2.h2,
      h3: _state2.h3,
      h4: _state2.h4
    };
    _update$1(s2, _w, finalBlock);
    var rval = forge$k.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };
  return md;
};
var _padding$1 = null;
var _initialized$1 = false;
function _init$1() {
  _padding$1 = String.fromCharCode(128);
  _padding$1 += forge$k.util.fillString(String.fromCharCode(0), 64);
  _initialized$1 = true;
}
function _update$1(s2, w2, bytes2) {
  var t2, a, b, c, d2, e, f, i;
  var len = bytes2.length();
  while (len >= 64) {
    a = s2.h0;
    b = s2.h1;
    c = s2.h2;
    d2 = s2.h3;
    e = s2.h4;
    for (i = 0; i < 16; ++i) {
      t2 = bytes2.getInt32();
      w2[i] = t2;
      f = d2 ^ b & (c ^ d2);
      t2 = (a << 5 | a >>> 27) + f + e + 1518500249 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 20; ++i) {
      t2 = w2[i - 3] ^ w2[i - 8] ^ w2[i - 14] ^ w2[i - 16];
      t2 = t2 << 1 | t2 >>> 31;
      w2[i] = t2;
      f = d2 ^ b & (c ^ d2);
      t2 = (a << 5 | a >>> 27) + f + e + 1518500249 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 32; ++i) {
      t2 = w2[i - 3] ^ w2[i - 8] ^ w2[i - 14] ^ w2[i - 16];
      t2 = t2 << 1 | t2 >>> 31;
      w2[i] = t2;
      f = b ^ c ^ d2;
      t2 = (a << 5 | a >>> 27) + f + e + 1859775393 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 40; ++i) {
      t2 = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i] = t2;
      f = b ^ c ^ d2;
      t2 = (a << 5 | a >>> 27) + f + e + 1859775393 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 60; ++i) {
      t2 = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i] = t2;
      f = b & c | d2 & (b ^ c);
      t2 = (a << 5 | a >>> 27) + f + e + 2400959708 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 80; ++i) {
      t2 = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i] = t2;
      f = b ^ c ^ d2;
      t2 = (a << 5 | a >>> 27) + f + e + 3395469782 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    s2.h0 = s2.h0 + a | 0;
    s2.h1 = s2.h1 + b | 0;
    s2.h2 = s2.h2 + c | 0;
    s2.h3 = s2.h3 + d2 | 0;
    s2.h4 = s2.h4 + e | 0;
    len -= 64;
  }
}
var forge$j = forge$C;
var pkcs1 = forge$j.pkcs1 = forge$j.pkcs1 || {};
pkcs1.encode_rsa_oaep = function(key, message, options2) {
  var label;
  var seed;
  var md;
  var mgf1Md;
  if (typeof options2 === "string") {
    label = options2;
    seed = arguments[3] || void 0;
    md = arguments[4] || void 0;
  } else if (options2) {
    label = options2.label || void 0;
    seed = options2.seed || void 0;
    md = options2.md || void 0;
    if (options2.mgf1 && options2.mgf1.md) {
      mgf1Md = options2.mgf1.md;
    }
  }
  if (!md) {
    md = forge$j.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  var keyLength = Math.ceil(key.n.bitLength() / 8);
  var maxLength = keyLength - 2 * md.digestLength - 2;
  if (message.length > maxLength) {
    var error2 = new Error("RSAES-OAEP input message length is too long.");
    error2.length = message.length;
    error2.maxLength = maxLength;
    throw error2;
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest();
  var PS = "";
  var PS_length = maxLength - message.length;
  for (var i = 0; i < PS_length; i++) {
    PS += "\0";
  }
  var DB = lHash.getBytes() + PS + "" + message;
  if (!seed) {
    seed = forge$j.random.getBytes(md.digestLength);
  } else if (seed.length !== md.digestLength) {
    var error2 = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    error2.seedLength = seed.length;
    error2.digestLength = md.digestLength;
    throw error2;
  }
  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var maskedDB = forge$j.util.xorBytes(DB, dbMask, DB.length);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var maskedSeed = forge$j.util.xorBytes(seed, seedMask, seed.length);
  return "\0" + maskedSeed + maskedDB;
};
pkcs1.decode_rsa_oaep = function(key, em, options2) {
  var label;
  var md;
  var mgf1Md;
  if (typeof options2 === "string") {
    label = options2;
    md = arguments[3] || void 0;
  } else if (options2) {
    label = options2.label || void 0;
    md = options2.md || void 0;
    if (options2.mgf1 && options2.mgf1.md) {
      mgf1Md = options2.mgf1.md;
    }
  }
  var keyLength = Math.ceil(key.n.bitLength() / 8);
  if (em.length !== keyLength) {
    var error2 = new Error("RSAES-OAEP encoded message length is invalid.");
    error2.length = em.length;
    error2.expectedLength = keyLength;
    throw error2;
  }
  if (md === void 0) {
    md = forge$j.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  if (keyLength < 2 * md.digestLength + 2) {
    throw new Error("RSAES-OAEP key is too short for the hash function.");
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest().getBytes();
  var y2 = em.charAt(0);
  var maskedSeed = em.substring(1, md.digestLength + 1);
  var maskedDB = em.substring(1 + md.digestLength);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var seed = forge$j.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var db = forge$j.util.xorBytes(maskedDB, dbMask, maskedDB.length);
  var lHashPrime = db.substring(0, md.digestLength);
  var error2 = y2 !== "\0";
  for (var i = 0; i < md.digestLength; ++i) {
    error2 |= lHash.charAt(i) !== lHashPrime.charAt(i);
  }
  var in_ps = 1;
  var index2 = md.digestLength;
  for (var j = md.digestLength; j < db.length; j++) {
    var code = db.charCodeAt(j);
    var is_0 = code & 1 ^ 1;
    var error_mask = in_ps ? 65534 : 0;
    error2 |= code & error_mask;
    in_ps = in_ps & is_0;
    index2 += in_ps;
  }
  if (error2 || db.charCodeAt(index2) !== 1) {
    throw new Error("Invalid RSAES-OAEP padding.");
  }
  return db.substring(index2 + 1);
};
function rsa_mgf1(seed, maskLength, hash2) {
  if (!hash2) {
    hash2 = forge$j.md.sha1.create();
  }
  var t2 = "";
  var count = Math.ceil(maskLength / hash2.digestLength);
  for (var i = 0; i < count; ++i) {
    var c = String.fromCharCode(
      i >> 24 & 255,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255
    );
    hash2.start();
    hash2.update(seed + c);
    t2 += hash2.digest().getBytes();
  }
  return t2.substring(0, maskLength);
}
var forge$i = forge$C;
(function() {
  if (forge$i.prime) {
    forge$i.prime;
    return;
  }
  var prime = forge$i.prime = forge$i.prime || {};
  var BigInteger2 = forge$i.jsbn.BigInteger;
  var GCD_30_DELTA2 = [6, 4, 2, 4, 2, 4, 6, 2];
  var THIRTY = new BigInteger2(null);
  THIRTY.fromInt(30);
  var op_or2 = function(x, y2) {
    return x | y2;
  };
  prime.generateProbablePrime = function(bits, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    options2 = options2 || {};
    var algorithm = options2.algorithm || "PRIMEINC";
    if (typeof algorithm === "string") {
      algorithm = { name: algorithm };
    }
    algorithm.options = algorithm.options || {};
    var prng2 = options2.prng || forge$i.random;
    var rng2 = {
      // x is an array to fill with bytes
      nextBytes: function(x) {
        var b = prng2.getBytesSync(x.length);
        for (var i = 0; i < x.length; ++i) {
          x[i] = b.charCodeAt(i);
        }
      }
    };
    if (algorithm.name === "PRIMEINC") {
      return primeincFindPrime(bits, rng2, algorithm.options, callback);
    }
    throw new Error("Invalid prime generation algorithm: " + algorithm.name);
  };
  function primeincFindPrime(bits, rng2, options2, callback) {
    if ("workers" in options2) {
      return primeincFindPrimeWithWorkers(bits, rng2, options2, callback);
    }
    return primeincFindPrimeWithoutWorkers(bits, rng2, options2, callback);
  }
  function primeincFindPrimeWithoutWorkers(bits, rng2, options2, callback) {
    var num = generateRandom(bits, rng2);
    var deltaIdx = 0;
    var mrTests = getMillerRabinTests(num.bitLength());
    if ("millerRabinTests" in options2) {
      mrTests = options2.millerRabinTests;
    }
    var maxBlockTime = 10;
    if ("maxBlockTime" in options2) {
      maxBlockTime = options2.maxBlockTime;
    }
    _primeinc(num, bits, rng2, deltaIdx, mrTests, maxBlockTime, callback);
  }
  function _primeinc(num, bits, rng2, deltaIdx, mrTests, maxBlockTime, callback) {
    var start = +/* @__PURE__ */ new Date();
    do {
      if (num.bitLength() > bits) {
        num = generateRandom(bits, rng2);
      }
      if (num.isProbablePrime(mrTests)) {
        return callback(null, num);
      }
      num.dAddOffset(GCD_30_DELTA2[deltaIdx++ % 8], 0);
    } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
    forge$i.util.setImmediate(function() {
      _primeinc(num, bits, rng2, deltaIdx, mrTests, maxBlockTime, callback);
    });
  }
  function primeincFindPrimeWithWorkers(bits, rng2, options2, callback) {
    if (typeof Worker === "undefined") {
      return primeincFindPrimeWithoutWorkers(bits, rng2, options2, callback);
    }
    var num = generateRandom(bits, rng2);
    var numWorkers = options2.workers;
    var workLoad = options2.workLoad || 100;
    var range3 = workLoad * 30 / 8;
    var workerScript = options2.workerScript || "forge/prime.worker.js";
    if (numWorkers === -1) {
      return forge$i.util.estimateCores(function(err, cores) {
        if (err) {
          cores = 2;
        }
        numWorkers = cores - 1;
        generate();
      });
    }
    generate();
    function generate() {
      numWorkers = Math.max(1, numWorkers);
      var workers = [];
      for (var i = 0; i < numWorkers; ++i) {
        workers[i] = new Worker(workerScript);
      }
      for (var i = 0; i < numWorkers; ++i) {
        workers[i].addEventListener("message", workerMessage);
      }
      var found = false;
      function workerMessage(e) {
        if (found) {
          return;
        }
        var data = e.data;
        if (data.found) {
          for (var i2 = 0; i2 < workers.length; ++i2) {
            workers[i2].terminate();
          }
          found = true;
          return callback(null, new BigInteger2(data.prime, 16));
        }
        if (num.bitLength() > bits) {
          num = generateRandom(bits, rng2);
        }
        var hex = num.toString(16);
        e.target.postMessage({
          hex,
          workLoad
        });
        num.dAddOffset(range3, 0);
      }
    }
  }
  function generateRandom(bits, rng2) {
    var num = new BigInteger2(bits, rng2);
    var bits1 = bits - 1;
    if (!num.testBit(bits1)) {
      num.bitwiseTo(BigInteger2.ONE.shiftLeft(bits1), op_or2, num);
    }
    num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
    return num;
  }
  function getMillerRabinTests(bits) {
    if (bits <= 100) return 27;
    if (bits <= 150) return 18;
    if (bits <= 200) return 15;
    if (bits <= 250) return 12;
    if (bits <= 300) return 9;
    if (bits <= 350) return 8;
    if (bits <= 400) return 7;
    if (bits <= 500) return 6;
    if (bits <= 600) return 5;
    if (bits <= 800) return 4;
    if (bits <= 1250) return 3;
    return 2;
  }
})();
var forge$h = forge$C;
if (typeof BigInteger$4 === "undefined") {
  var BigInteger$4 = forge$h.jsbn.BigInteger;
}
var _crypto = forge$h.util.isNodejs ? require$$0$6 : null;
var asn1$7 = forge$h.asn1;
var util$1 = forge$h.util;
forge$h.pki = forge$h.pki || {};
forge$h.pki.rsa = forge$h.rsa = forge$h.rsa || {};
var pki$4 = forge$h.pki;
var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
var privateKeyValidator$1 = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.OID,
      constructed: false,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.OCTETSTRING,
    constructed: false,
    capture: "privateKey"
  }]
};
var rsaPrivateKeyValidator = {
  // RSAPrivateKey
  name: "RSAPrivateKey",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "RSAPrivateKey.version",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // modulus (n)
    name: "RSAPrivateKey.modulus",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPrivateKey.publicExponent",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPublicExponent"
  }, {
    // privateExponent (d)
    name: "RSAPrivateKey.privateExponent",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrivateExponent"
  }, {
    // prime1 (p)
    name: "RSAPrivateKey.prime1",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime1"
  }, {
    // prime2 (q)
    name: "RSAPrivateKey.prime2",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime2"
  }, {
    // exponent1 (d mod (p-1))
    name: "RSAPrivateKey.exponent1",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent1"
  }, {
    // exponent2 (d mod (q-1))
    name: "RSAPrivateKey.exponent2",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent2"
  }, {
    // coefficient ((inverse of q) mod p)
    name: "RSAPrivateKey.coefficient",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyCoefficient"
  }]
};
var rsaPublicKeyValidator = {
  // RSAPublicKey
  name: "RSAPublicKey",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  value: [{
    // modulus (n)
    name: "RSAPublicKey.modulus",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "publicKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPublicKey.exponent",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "publicKeyExponent"
  }]
};
var publicKeyValidator$2 = forge$h.pki.rsa.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "subjectPublicKeyInfo",
  value: [{
    name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.OID,
      constructed: false,
      capture: "publicKeyOid"
    }]
  }, {
    // subjectPublicKey
    name: "SubjectPublicKeyInfo.subjectPublicKey",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.BITSTRING,
    constructed: false,
    value: [{
      // RSAPublicKey
      name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.SEQUENCE,
      constructed: true,
      optional: true,
      captureAsn1: "rsaPublicKey"
    }]
  }]
};
var digestInfoValidator = {
  name: "DigestInfo",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "DigestInfo.DigestAlgorithm",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.OID,
      constructed: false,
      capture: "algorithmIdentifier"
    }, {
      // NULL parameters
      name: "DigestInfo.DigestAlgorithm.parameters",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.NULL,
      // captured only to check existence for md2 and md5
      capture: "parameters",
      optional: true,
      constructed: false
    }]
  }, {
    // digest
    name: "DigestInfo.digest",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.OCTETSTRING,
    constructed: false,
    capture: "digest"
  }]
};
var emsaPkcs1v15encode = function(md) {
  var oid;
  if (md.algorithm in pki$4.oids) {
    oid = pki$4.oids[md.algorithm];
  } else {
    var error2 = new Error("Unknown message digest algorithm.");
    error2.algorithm = md.algorithm;
    throw error2;
  }
  var oidBytes = asn1$7.oidToDer(oid).getBytes();
  var digestInfo = asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.SEQUENCE,
    true,
    []
  );
  var digestAlgorithm = asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.SEQUENCE,
    true,
    []
  );
  digestAlgorithm.value.push(asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.OID,
    false,
    oidBytes
  ));
  digestAlgorithm.value.push(asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.NULL,
    false,
    ""
  ));
  var digest = asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.OCTETSTRING,
    false,
    md.digest().getBytes()
  );
  digestInfo.value.push(digestAlgorithm);
  digestInfo.value.push(digest);
  return asn1$7.toDer(digestInfo).getBytes();
};
var _modPow = function(x, key, pub) {
  if (pub) {
    return x.modPow(key.e, key.n);
  }
  if (!key.p || !key.q) {
    return x.modPow(key.d, key.n);
  }
  if (!key.dP) {
    key.dP = key.d.mod(key.p.subtract(BigInteger$4.ONE));
  }
  if (!key.dQ) {
    key.dQ = key.d.mod(key.q.subtract(BigInteger$4.ONE));
  }
  if (!key.qInv) {
    key.qInv = key.q.modInverse(key.p);
  }
  var r;
  do {
    r = new BigInteger$4(
      forge$h.util.bytesToHex(forge$h.random.getBytes(key.n.bitLength() / 8)),
      16
    );
  } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger$4.ONE));
  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
  var xp = x.mod(key.p).modPow(key.dP, key.p);
  var xq = x.mod(key.q).modPow(key.dQ, key.q);
  while (xp.compareTo(xq) < 0) {
    xp = xp.add(key.p);
  }
  var y2 = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
  y2 = y2.multiply(r.modInverse(key.n)).mod(key.n);
  return y2;
};
pki$4.rsa.encrypt = function(m2, key, bt) {
  var pub = bt;
  var eb;
  var k = Math.ceil(key.n.bitLength() / 8);
  if (bt !== false && bt !== true) {
    pub = bt === 2;
    eb = _encodePkcs1_v1_5(m2, key, bt);
  } else {
    eb = forge$h.util.createBuffer();
    eb.putBytes(m2);
  }
  var x = new BigInteger$4(eb.toHex(), 16);
  var y2 = _modPow(x, key, pub);
  var yhex = y2.toString(16);
  var ed = forge$h.util.createBuffer();
  var zeros = k - Math.ceil(yhex.length / 2);
  while (zeros > 0) {
    ed.putByte(0);
    --zeros;
  }
  ed.putBytes(forge$h.util.hexToBytes(yhex));
  return ed.getBytes();
};
pki$4.rsa.decrypt = function(ed, key, pub, ml) {
  var k = Math.ceil(key.n.bitLength() / 8);
  if (ed.length !== k) {
    var error2 = new Error("Encrypted message length is invalid.");
    error2.length = ed.length;
    error2.expected = k;
    throw error2;
  }
  var y2 = new BigInteger$4(forge$h.util.createBuffer(ed).toHex(), 16);
  if (y2.compareTo(key.n) >= 0) {
    throw new Error("Encrypted message is invalid.");
  }
  var x = _modPow(y2, key, pub);
  var xhex = x.toString(16);
  var eb = forge$h.util.createBuffer();
  var zeros = k - Math.ceil(xhex.length / 2);
  while (zeros > 0) {
    eb.putByte(0);
    --zeros;
  }
  eb.putBytes(forge$h.util.hexToBytes(xhex));
  if (ml !== false) {
    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
  }
  return eb.getBytes();
};
pki$4.rsa.createKeyPairGenerationState = function(bits, e, options2) {
  if (typeof bits === "string") {
    bits = parseInt(bits, 10);
  }
  bits = bits || 2048;
  options2 = options2 || {};
  var prng2 = options2.prng || forge$h.random;
  var rng2 = {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      var b = prng2.getBytesSync(x.length);
      for (var i = 0; i < x.length; ++i) {
        x[i] = b.charCodeAt(i);
      }
    }
  };
  var algorithm = options2.algorithm || "PRIMEINC";
  var rval;
  if (algorithm === "PRIMEINC") {
    rval = {
      algorithm,
      state: 0,
      bits,
      rng: rng2,
      eInt: e || 65537,
      e: new BigInteger$4(null),
      p: null,
      q: null,
      qBits: bits >> 1,
      pBits: bits - (bits >> 1),
      pqState: 0,
      num: null,
      keys: null
    };
    rval.e.fromInt(rval.eInt);
  } else {
    throw new Error("Invalid key generation algorithm: " + algorithm);
  }
  return rval;
};
pki$4.rsa.stepKeyPairGenerationState = function(state, n) {
  if (!("algorithm" in state)) {
    state.algorithm = "PRIMEINC";
  }
  var THIRTY = new BigInteger$4(null);
  THIRTY.fromInt(30);
  var deltaIdx = 0;
  var op_or2 = function(x, y2) {
    return x | y2;
  };
  var t1 = +/* @__PURE__ */ new Date();
  var t2;
  var total = 0;
  while (state.keys === null && (n <= 0 || total < n)) {
    if (state.state === 0) {
      var bits = state.p === null ? state.pBits : state.qBits;
      var bits1 = bits - 1;
      if (state.pqState === 0) {
        state.num = new BigInteger$4(bits, state.rng);
        if (!state.num.testBit(bits1)) {
          state.num.bitwiseTo(
            BigInteger$4.ONE.shiftLeft(bits1),
            op_or2,
            state.num
          );
        }
        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
        deltaIdx = 0;
        ++state.pqState;
      } else if (state.pqState === 1) {
        if (state.num.bitLength() > bits) {
          state.pqState = 0;
        } else if (state.num.isProbablePrime(
          _getMillerRabinTests(state.num.bitLength())
        )) {
          ++state.pqState;
        } else {
          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        }
      } else if (state.pqState === 2) {
        state.pqState = state.num.subtract(BigInteger$4.ONE).gcd(state.e).compareTo(BigInteger$4.ONE) === 0 ? 3 : 0;
      } else if (state.pqState === 3) {
        state.pqState = 0;
        if (state.p === null) {
          state.p = state.num;
        } else {
          state.q = state.num;
        }
        if (state.p !== null && state.q !== null) {
          ++state.state;
        }
        state.num = null;
      }
    } else if (state.state === 1) {
      if (state.p.compareTo(state.q) < 0) {
        state.num = state.p;
        state.p = state.q;
        state.q = state.num;
      }
      ++state.state;
    } else if (state.state === 2) {
      state.p1 = state.p.subtract(BigInteger$4.ONE);
      state.q1 = state.q.subtract(BigInteger$4.ONE);
      state.phi = state.p1.multiply(state.q1);
      ++state.state;
    } else if (state.state === 3) {
      if (state.phi.gcd(state.e).compareTo(BigInteger$4.ONE) === 0) {
        ++state.state;
      } else {
        state.p = null;
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 4) {
      state.n = state.p.multiply(state.q);
      if (state.n.bitLength() === state.bits) {
        ++state.state;
      } else {
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 5) {
      var d2 = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki$4.rsa.setPrivateKey(
          state.n,
          state.e,
          d2,
          state.p,
          state.q,
          d2.mod(state.p1),
          d2.mod(state.q1),
          state.q.modInverse(state.p)
        ),
        publicKey: pki$4.rsa.setPublicKey(state.n, state.e)
      };
    }
    t2 = +/* @__PURE__ */ new Date();
    total += t2 - t1;
    t1 = t2;
  }
  return state.keys !== null;
};
pki$4.rsa.generateKeyPair = function(bits, e, options2, callback) {
  if (arguments.length === 1) {
    if (typeof bits === "object") {
      options2 = bits;
      bits = void 0;
    } else if (typeof bits === "function") {
      callback = bits;
      bits = void 0;
    }
  } else if (arguments.length === 2) {
    if (typeof bits === "number") {
      if (typeof e === "function") {
        callback = e;
        e = void 0;
      } else if (typeof e !== "number") {
        options2 = e;
        e = void 0;
      }
    } else {
      options2 = bits;
      callback = e;
      bits = void 0;
      e = void 0;
    }
  } else if (arguments.length === 3) {
    if (typeof e === "number") {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = void 0;
      }
    } else {
      callback = options2;
      options2 = e;
      e = void 0;
    }
  }
  options2 = options2 || {};
  if (bits === void 0) {
    bits = options2.bits || 2048;
  }
  if (e === void 0) {
    e = options2.e || 65537;
  }
  if (!forge$h.options.usePureJavaScript && !options2.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
    if (callback) {
      if (_detectNodeCrypto("generateKeyPair")) {
        return _crypto.generateKeyPair("rsa", {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        }, function(err, pub, priv) {
          if (err) {
            return callback(err);
          }
          callback(null, {
            privateKey: pki$4.privateKeyFromPem(priv),
            publicKey: pki$4.publicKeyFromPem(pub)
          });
        });
      }
      if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
        return util$1.globalScope.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]).then(function(pair) {
          return util$1.globalScope.crypto.subtle.exportKey(
            "pkcs8",
            pair.privateKey
          );
        }).then(void 0, function(err) {
          callback(err);
        }).then(function(pkcs8) {
          if (pkcs8) {
            var privateKey = pki$4.privateKeyFromAsn1(
              asn1$7.fromDer(forge$h.util.createBuffer(pkcs8))
            );
            callback(null, {
              privateKey,
              publicKey: pki$4.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          }
        });
      }
      if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
        var genOp = util$1.globalScope.msCrypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]);
        genOp.oncomplete = function(e2) {
          var pair = e2.target.result;
          var exportOp = util$1.globalScope.msCrypto.subtle.exportKey(
            "pkcs8",
            pair.privateKey
          );
          exportOp.oncomplete = function(e3) {
            var pkcs8 = e3.target.result;
            var privateKey = pki$4.privateKeyFromAsn1(
              asn1$7.fromDer(forge$h.util.createBuffer(pkcs8))
            );
            callback(null, {
              privateKey,
              publicKey: pki$4.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          };
          exportOp.onerror = function(err) {
            callback(err);
          };
        };
        genOp.onerror = function(err) {
          callback(err);
        };
        return;
      }
    } else {
      if (_detectNodeCrypto("generateKeyPairSync")) {
        var keypair = _crypto.generateKeyPairSync("rsa", {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        });
        return {
          privateKey: pki$4.privateKeyFromPem(keypair.privateKey),
          publicKey: pki$4.publicKeyFromPem(keypair.publicKey)
        };
      }
    }
  }
  var state = pki$4.rsa.createKeyPairGenerationState(bits, e, options2);
  if (!callback) {
    pki$4.rsa.stepKeyPairGenerationState(state, 0);
    return state.keys;
  }
  _generateKeyPair(state, options2, callback);
};
pki$4.setRsaPublicKey = pki$4.rsa.setPublicKey = function(n, e) {
  var key = {
    n,
    e
  };
  key.encrypt = function(data, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = {
        encode: function(m2, key2, pub) {
          return _encodePkcs1_v1_5(m2, key2, 2).getBytes();
        }
      };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = {
        encode: function(m2, key2) {
          return forge$h.pkcs1.encode_rsa_oaep(key2, m2, schemeOptions);
        }
      };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { encode: function(e3) {
        return e3;
      } };
    } else if (typeof scheme === "string") {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    var e2 = scheme.encode(data, key, true);
    return pki$4.rsa.encrypt(e2, key, true);
  };
  key.verify = function(digest, signature, scheme, options2) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSASSA-PKCS1-V1_5";
    }
    if (options2 === void 0) {
      options2 = {
        _parseAllDigestBytes: true
      };
    }
    if (!("_parseAllDigestBytes" in options2)) {
      options2._parseAllDigestBytes = true;
    }
    if (scheme === "RSASSA-PKCS1-V1_5") {
      scheme = {
        verify: function(digest2, d3) {
          d3 = _decodePkcs1_v1_5(d3, key, true);
          var obj = asn1$7.fromDer(d3, {
            parseAllBytes: options2._parseAllDigestBytes
          });
          var capture = {};
          var errors2 = [];
          if (!asn1$7.validate(obj, digestInfoValidator, capture, errors2)) {
            var error2 = new Error(
              "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
            );
            error2.errors = errors2;
            throw error2;
          }
          var oid = asn1$7.derToOid(capture.algorithmIdentifier);
          if (!(oid === forge$h.oids.md2 || oid === forge$h.oids.md5 || oid === forge$h.oids.sha1 || oid === forge$h.oids.sha224 || oid === forge$h.oids.sha256 || oid === forge$h.oids.sha384 || oid === forge$h.oids.sha512 || oid === forge$h.oids["sha512-224"] || oid === forge$h.oids["sha512-256"])) {
            var error2 = new Error(
              "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
            );
            error2.oid = oid;
            throw error2;
          }
          if (oid === forge$h.oids.md2 || oid === forge$h.oids.md5) {
            if (!("parameters" in capture)) {
              throw new Error(
                "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifier NULL parameters."
              );
            }
          }
          return digest2 === capture.digest;
        }
      };
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = {
        verify: function(digest2, d3) {
          d3 = _decodePkcs1_v1_5(d3, key, true);
          return digest2 === d3;
        }
      };
    }
    var d2 = pki$4.rsa.decrypt(signature, key, true, false);
    return scheme.verify(digest, d2, key.n.bitLength());
  };
  return key;
};
pki$4.setRsaPrivateKey = pki$4.rsa.setPrivateKey = function(n, e, d2, p, q, dP, dQ, qInv) {
  var key = {
    n,
    e,
    d: d2,
    p,
    q,
    dP,
    dQ,
    qInv
  };
  key.decrypt = function(data, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    var d3 = pki$4.rsa.decrypt(data, key, false, false);
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = { decode: _decodePkcs1_v1_5 };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = {
        decode: function(d4, key2) {
          return forge$h.pkcs1.decode_rsa_oaep(key2, d4, schemeOptions);
        }
      };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { decode: function(d4) {
        return d4;
      } };
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    return scheme.decode(d3, key, false);
  };
  key.sign = function(md, scheme) {
    var bt = false;
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    }
    if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
      scheme = { encode: emsaPkcs1v15encode };
      bt = 1;
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = { encode: function() {
        return md;
      } };
      bt = 1;
    }
    var d3 = scheme.encode(md, key.n.bitLength());
    return pki$4.rsa.encrypt(d3, key, bt);
  };
  return key;
};
pki$4.wrapRsaPrivateKey = function(rsaKey) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
    // version (0)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      asn1$7.integerToDer(0).getBytes()
    ),
    // privateKeyAlgorithm
    asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
      asn1$7.create(
        asn1$7.Class.UNIVERSAL,
        asn1$7.Type.OID,
        false,
        asn1$7.oidToDer(pki$4.oids.rsaEncryption).getBytes()
      ),
      asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.NULL, false, "")
    ]),
    // PrivateKey
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.OCTETSTRING,
      false,
      asn1$7.toDer(rsaKey).getBytes()
    )
  ]);
};
pki$4.privateKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  if (asn1$7.validate(obj, privateKeyValidator$1, capture, errors2)) {
    obj = asn1$7.fromDer(forge$h.util.createBuffer(capture.privateKey));
  }
  capture = {};
  errors2 = [];
  if (!asn1$7.validate(obj, rsaPrivateKeyValidator, capture, errors2)) {
    var error2 = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    error2.errors = errors2;
    throw error2;
  }
  var n, e, d2, p, q, dP, dQ, qInv;
  n = forge$h.util.createBuffer(capture.privateKeyModulus).toHex();
  e = forge$h.util.createBuffer(capture.privateKeyPublicExponent).toHex();
  d2 = forge$h.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
  p = forge$h.util.createBuffer(capture.privateKeyPrime1).toHex();
  q = forge$h.util.createBuffer(capture.privateKeyPrime2).toHex();
  dP = forge$h.util.createBuffer(capture.privateKeyExponent1).toHex();
  dQ = forge$h.util.createBuffer(capture.privateKeyExponent2).toHex();
  qInv = forge$h.util.createBuffer(capture.privateKeyCoefficient).toHex();
  return pki$4.setRsaPrivateKey(
    new BigInteger$4(n, 16),
    new BigInteger$4(e, 16),
    new BigInteger$4(d2, 16),
    new BigInteger$4(p, 16),
    new BigInteger$4(q, 16),
    new BigInteger$4(dP, 16),
    new BigInteger$4(dQ, 16),
    new BigInteger$4(qInv, 16)
  );
};
pki$4.privateKeyToAsn1 = pki$4.privateKeyToRSAPrivateKey = function(key) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      asn1$7.integerToDer(0).getBytes()
    ),
    // modulus (n)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.n)
    ),
    // publicExponent (e)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.e)
    ),
    // privateExponent (d)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.d)
    ),
    // privateKeyPrime1 (p)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.p)
    ),
    // privateKeyPrime2 (q)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.q)
    ),
    // privateKeyExponent1 (dP)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.dP)
    ),
    // privateKeyExponent2 (dQ)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.dQ)
    ),
    // coefficient (qInv)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.qInv)
    )
  ]);
};
pki$4.publicKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  if (asn1$7.validate(obj, publicKeyValidator$2, capture, errors2)) {
    var oid = asn1$7.derToOid(capture.publicKeyOid);
    if (oid !== pki$4.oids.rsaEncryption) {
      var error2 = new Error("Cannot read public key. Unknown OID.");
      error2.oid = oid;
      throw error2;
    }
    obj = capture.rsaPublicKey;
  }
  errors2 = [];
  if (!asn1$7.validate(obj, rsaPublicKeyValidator, capture, errors2)) {
    var error2 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    error2.errors = errors2;
    throw error2;
  }
  var n = forge$h.util.createBuffer(capture.publicKeyModulus).toHex();
  var e = forge$h.util.createBuffer(capture.publicKeyExponent).toHex();
  return pki$4.setRsaPublicKey(
    new BigInteger$4(n, 16),
    new BigInteger$4(e, 16)
  );
};
pki$4.publicKeyToAsn1 = pki$4.publicKeyToSubjectPublicKeyInfo = function(key) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
    // AlgorithmIdentifier
    asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
      // algorithm
      asn1$7.create(
        asn1$7.Class.UNIVERSAL,
        asn1$7.Type.OID,
        false,
        asn1$7.oidToDer(pki$4.oids.rsaEncryption).getBytes()
      ),
      // parameters (null)
      asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.NULL, false, "")
    ]),
    // subjectPublicKey
    asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.BITSTRING, false, [
      pki$4.publicKeyToRSAPublicKey(key)
    ])
  ]);
};
pki$4.publicKeyToRSAPublicKey = function(key) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
    // modulus (n)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.n)
    ),
    // publicExponent (e)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.e)
    )
  ]);
};
function _encodePkcs1_v1_5(m2, key, bt) {
  var eb = forge$h.util.createBuffer();
  var k = Math.ceil(key.n.bitLength() / 8);
  if (m2.length > k - 11) {
    var error2 = new Error("Message is too long for PKCS#1 v1.5 padding.");
    error2.length = m2.length;
    error2.max = k - 11;
    throw error2;
  }
  eb.putByte(0);
  eb.putByte(bt);
  var padNum = k - 3 - m2.length;
  var padByte;
  if (bt === 0 || bt === 1) {
    padByte = bt === 0 ? 0 : 255;
    for (var i = 0; i < padNum; ++i) {
      eb.putByte(padByte);
    }
  } else {
    while (padNum > 0) {
      var numZeros = 0;
      var padBytes = forge$h.random.getBytes(padNum);
      for (var i = 0; i < padNum; ++i) {
        padByte = padBytes.charCodeAt(i);
        if (padByte === 0) {
          ++numZeros;
        } else {
          eb.putByte(padByte);
        }
      }
      padNum = numZeros;
    }
  }
  eb.putByte(0);
  eb.putBytes(m2);
  return eb;
}
function _decodePkcs1_v1_5(em, key, pub, ml) {
  var k = Math.ceil(key.n.bitLength() / 8);
  var eb = forge$h.util.createBuffer(em);
  var first2 = eb.getByte();
  var bt = eb.getByte();
  if (first2 !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
    throw new Error("Encryption block is invalid.");
  }
  var padNum = 0;
  if (bt === 0) {
    padNum = k - 3 - ml;
    for (var i = 0; i < padNum; ++i) {
      if (eb.getByte() !== 0) {
        throw new Error("Encryption block is invalid.");
      }
    }
  } else if (bt === 1) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() !== 255) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  } else if (bt === 2) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() === 0) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  }
  var zero = eb.getByte();
  if (zero !== 0 || padNum !== k - 3 - eb.length()) {
    throw new Error("Encryption block is invalid.");
  }
  return eb.getBytes();
}
function _generateKeyPair(state, options2, callback) {
  if (typeof options2 === "function") {
    callback = options2;
    options2 = {};
  }
  options2 = options2 || {};
  var opts = {
    algorithm: {
      name: options2.algorithm || "PRIMEINC",
      options: {
        workers: options2.workers || 2,
        workLoad: options2.workLoad || 100,
        workerScript: options2.workerScript
      }
    }
  };
  if ("prng" in options2) {
    opts.prng = options2.prng;
  }
  generate();
  function generate() {
    getPrime(state.pBits, function(err, num) {
      if (err) {
        return callback(err);
      }
      state.p = num;
      if (state.q !== null) {
        return finish(err, state.q);
      }
      getPrime(state.qBits, finish);
    });
  }
  function getPrime(bits, callback2) {
    forge$h.prime.generateProbablePrime(bits, opts, callback2);
  }
  function finish(err, num) {
    if (err) {
      return callback(err);
    }
    state.q = num;
    if (state.p.compareTo(state.q) < 0) {
      var tmp = state.p;
      state.p = state.q;
      state.q = tmp;
    }
    if (state.p.subtract(BigInteger$4.ONE).gcd(state.e).compareTo(BigInteger$4.ONE) !== 0) {
      state.p = null;
      generate();
      return;
    }
    if (state.q.subtract(BigInteger$4.ONE).gcd(state.e).compareTo(BigInteger$4.ONE) !== 0) {
      state.q = null;
      getPrime(state.qBits, finish);
      return;
    }
    state.p1 = state.p.subtract(BigInteger$4.ONE);
    state.q1 = state.q.subtract(BigInteger$4.ONE);
    state.phi = state.p1.multiply(state.q1);
    if (state.phi.gcd(state.e).compareTo(BigInteger$4.ONE) !== 0) {
      state.p = state.q = null;
      generate();
      return;
    }
    state.n = state.p.multiply(state.q);
    if (state.n.bitLength() !== state.bits) {
      state.q = null;
      getPrime(state.qBits, finish);
      return;
    }
    var d2 = state.e.modInverse(state.phi);
    state.keys = {
      privateKey: pki$4.rsa.setPrivateKey(
        state.n,
        state.e,
        d2,
        state.p,
        state.q,
        d2.mod(state.p1),
        d2.mod(state.q1),
        state.q.modInverse(state.p)
      ),
      publicKey: pki$4.rsa.setPublicKey(state.n, state.e)
    };
    callback(null, state.keys);
  }
}
function _bnToBytes(b) {
  var hex = b.toString(16);
  if (hex[0] >= "8") {
    hex = "00" + hex;
  }
  var bytes2 = forge$h.util.hexToBytes(hex);
  if (bytes2.length > 1 && // leading 0x00 for positive integer
  (bytes2.charCodeAt(0) === 0 && (bytes2.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
  bytes2.charCodeAt(0) === 255 && (bytes2.charCodeAt(1) & 128) === 128)) {
    return bytes2.substr(1);
  }
  return bytes2;
}
function _getMillerRabinTests(bits) {
  if (bits <= 100) return 27;
  if (bits <= 150) return 18;
  if (bits <= 200) return 15;
  if (bits <= 250) return 12;
  if (bits <= 300) return 9;
  if (bits <= 350) return 8;
  if (bits <= 400) return 7;
  if (bits <= 500) return 6;
  if (bits <= 600) return 5;
  if (bits <= 800) return 4;
  if (bits <= 1250) return 3;
  return 2;
}
function _detectNodeCrypto(fn) {
  return forge$h.util.isNodejs && typeof _crypto[fn] === "function";
}
function _detectSubtleCrypto(fn) {
  return typeof util$1.globalScope !== "undefined" && typeof util$1.globalScope.crypto === "object" && typeof util$1.globalScope.crypto.subtle === "object" && typeof util$1.globalScope.crypto.subtle[fn] === "function";
}
function _detectSubtleMsCrypto(fn) {
  return typeof util$1.globalScope !== "undefined" && typeof util$1.globalScope.msCrypto === "object" && typeof util$1.globalScope.msCrypto.subtle === "object" && typeof util$1.globalScope.msCrypto.subtle[fn] === "function";
}
function _intToUint8Array(x) {
  var bytes2 = forge$h.util.hexToBytes(x.toString(16));
  var buffer2 = new Uint8Array(bytes2.length);
  for (var i = 0; i < bytes2.length; ++i) {
    buffer2[i] = bytes2.charCodeAt(i);
  }
  return buffer2;
}
var forge$g = forge$C;
if (typeof BigInteger$3 === "undefined") {
  var BigInteger$3 = forge$g.jsbn.BigInteger;
}
var asn1$6 = forge$g.asn1;
var pki$3 = forge$g.pki = forge$g.pki || {};
pki$3.pbe = forge$g.pbe = forge$g.pbe || {};
var oids$1 = pki$3.oids;
var encryptedPrivateKeyValidator = {
  name: "EncryptedPrivateKeyInfo",
  tagClass: asn1$6.Class.UNIVERSAL,
  type: asn1$6.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OID,
      constructed: false,
      capture: "encryptionOid"
    }, {
      name: "AlgorithmIdentifier.parameters",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "encryptionParams"
    }]
  }, {
    // encryptedData
    name: "EncryptedPrivateKeyInfo.encryptedData",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.OCTETSTRING,
    constructed: false,
    capture: "encryptedData"
  }]
};
var PBES2AlgorithmsValidator = {
  name: "PBES2Algorithms",
  tagClass: asn1$6.Class.UNIVERSAL,
  type: asn1$6.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "PBES2Algorithms.keyDerivationFunc",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc.oid",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OID,
      constructed: false,
      capture: "kdfOid"
    }, {
      name: "PBES2Algorithms.params",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.params.salt",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.OCTETSTRING,
        constructed: false,
        capture: "kdfSalt"
      }, {
        name: "PBES2Algorithms.params.iterationCount",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.INTEGER,
        constructed: false,
        capture: "kdfIterationCount"
      }, {
        name: "PBES2Algorithms.params.keyLength",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.INTEGER,
        constructed: false,
        optional: true,
        capture: "keyLength"
      }, {
        // prf
        name: "PBES2Algorithms.params.prf",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: "PBES2Algorithms.params.prf.algorithm",
          tagClass: asn1$6.Class.UNIVERSAL,
          type: asn1$6.Type.OID,
          constructed: false,
          capture: "prfOid"
        }]
      }]
    }]
  }, {
    name: "PBES2Algorithms.encryptionScheme",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PBES2Algorithms.encryptionScheme.oid",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OID,
      constructed: false,
      capture: "encOid"
    }, {
      name: "PBES2Algorithms.encryptionScheme.iv",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OCTETSTRING,
      constructed: false,
      capture: "encIv"
    }]
  }]
};
var pkcs12PbeParamsValidator = {
  name: "pkcs-12PbeParams",
  tagClass: asn1$6.Class.UNIVERSAL,
  type: asn1$6.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "pkcs-12PbeParams.salt",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.OCTETSTRING,
    constructed: false,
    capture: "salt"
  }, {
    name: "pkcs-12PbeParams.iterations",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.INTEGER,
    constructed: false,
    capture: "iterations"
  }]
};
pki$3.encryptPrivateKeyInfo = function(obj, password, options2) {
  options2 = options2 || {};
  options2.saltSize = options2.saltSize || 8;
  options2.count = options2.count || 2048;
  options2.algorithm = options2.algorithm || "aes128";
  options2.prfAlgorithm = options2.prfAlgorithm || "sha1";
  var salt = forge$g.random.getBytesSync(options2.saltSize);
  var count = options2.count;
  var countBytes = asn1$6.integerToDer(count);
  var dkLen;
  var encryptionAlgorithm;
  var encryptedData;
  if (options2.algorithm.indexOf("aes") === 0 || options2.algorithm === "des") {
    var ivLen, encOid, cipherFn;
    switch (options2.algorithm) {
      case "aes128":
        dkLen = 16;
        ivLen = 16;
        encOid = oids$1["aes128-CBC"];
        cipherFn = forge$g.aes.createEncryptionCipher;
        break;
      case "aes192":
        dkLen = 24;
        ivLen = 16;
        encOid = oids$1["aes192-CBC"];
        cipherFn = forge$g.aes.createEncryptionCipher;
        break;
      case "aes256":
        dkLen = 32;
        ivLen = 16;
        encOid = oids$1["aes256-CBC"];
        cipherFn = forge$g.aes.createEncryptionCipher;
        break;
      case "des":
        dkLen = 8;
        ivLen = 8;
        encOid = oids$1["desCBC"];
        cipherFn = forge$g.des.createEncryptionCipher;
        break;
      default:
        var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error2.algorithm = options2.algorithm;
        throw error2;
    }
    var prfAlgorithm = "hmacWith" + options2.prfAlgorithm.toUpperCase();
    var md = prfAlgorithmToMessageDigest(prfAlgorithm);
    var dk = forge$g.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv = forge$g.random.getBytesSync(ivLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1$6.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();
    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
    encryptionAlgorithm = asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.SEQUENCE,
      true,
      [
        asn1$6.create(
          asn1$6.Class.UNIVERSAL,
          asn1$6.Type.OID,
          false,
          asn1$6.oidToDer(oids$1["pkcs5PBES2"]).getBytes()
        ),
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
          // keyDerivationFunc
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
            asn1$6.create(
              asn1$6.Class.UNIVERSAL,
              asn1$6.Type.OID,
              false,
              asn1$6.oidToDer(oids$1["pkcs5PBKDF2"]).getBytes()
            ),
            // PBKDF2-params
            params
          ]),
          // encryptionScheme
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
            asn1$6.create(
              asn1$6.Class.UNIVERSAL,
              asn1$6.Type.OID,
              false,
              asn1$6.oidToDer(encOid).getBytes()
            ),
            // iv
            asn1$6.create(
              asn1$6.Class.UNIVERSAL,
              asn1$6.Type.OCTETSTRING,
              false,
              iv
            )
          ])
        ])
      ]
    );
  } else if (options2.algorithm === "3des") {
    dkLen = 24;
    var saltBytes = new forge$g.util.ByteBuffer(salt);
    var dk = pki$3.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
    var iv = pki$3.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
    var cipher = forge$g.des.createEncryptionCipher(dk);
    cipher.start(iv);
    cipher.update(asn1$6.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();
    encryptionAlgorithm = asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.SEQUENCE,
      true,
      [
        asn1$6.create(
          asn1$6.Class.UNIVERSAL,
          asn1$6.Type.OID,
          false,
          asn1$6.oidToDer(oids$1["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
        ),
        // pkcs-12PbeParams
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
          // salt
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OCTETSTRING, false, salt),
          // iteration count
          asn1$6.create(
            asn1$6.Class.UNIVERSAL,
            asn1$6.Type.INTEGER,
            false,
            countBytes.getBytes()
          )
        ])
      ]
    );
  } else {
    var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
    error2.algorithm = options2.algorithm;
    throw error2;
  }
  var rval = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
    // encryptionAlgorithm
    encryptionAlgorithm,
    // encryptedData
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.OCTETSTRING,
      false,
      encryptedData
    )
  ]);
  return rval;
};
pki$3.decryptPrivateKeyInfo = function(obj, password) {
  var rval = null;
  var capture = {};
  var errors2 = [];
  if (!asn1$6.validate(obj, encryptedPrivateKeyValidator, capture, errors2)) {
    var error2 = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$6.derToOid(capture.encryptionOid);
  var cipher = pki$3.pbe.getCipher(oid, capture.encryptionParams, password);
  var encrypted = forge$g.util.createBuffer(capture.encryptedData);
  cipher.update(encrypted);
  if (cipher.finish()) {
    rval = asn1$6.fromDer(cipher.output);
  }
  return rval;
};
pki$3.encryptedPrivateKeyToPem = function(epki, maxline) {
  var msg = {
    type: "ENCRYPTED PRIVATE KEY",
    body: asn1$6.toDer(epki).getBytes()
  };
  return forge$g.pem.encode(msg, { maxline });
};
pki$3.encryptedPrivateKeyFromPem = function(pem2) {
  var msg = forge$g.pem.decode(pem2)[0];
  if (msg.type !== "ENCRYPTED PRIVATE KEY") {
    var error2 = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  }
  return asn1$6.fromDer(msg.body);
};
pki$3.encryptRsaPrivateKey = function(rsaKey, password, options2) {
  options2 = options2 || {};
  if (!options2.legacy) {
    var rval = pki$3.wrapRsaPrivateKey(pki$3.privateKeyToAsn1(rsaKey));
    rval = pki$3.encryptPrivateKeyInfo(rval, password, options2);
    return pki$3.encryptedPrivateKeyToPem(rval);
  }
  var algorithm;
  var iv;
  var dkLen;
  var cipherFn;
  switch (options2.algorithm) {
    case "aes128":
      algorithm = "AES-128-CBC";
      dkLen = 16;
      iv = forge$g.random.getBytesSync(16);
      cipherFn = forge$g.aes.createEncryptionCipher;
      break;
    case "aes192":
      algorithm = "AES-192-CBC";
      dkLen = 24;
      iv = forge$g.random.getBytesSync(16);
      cipherFn = forge$g.aes.createEncryptionCipher;
      break;
    case "aes256":
      algorithm = "AES-256-CBC";
      dkLen = 32;
      iv = forge$g.random.getBytesSync(16);
      cipherFn = forge$g.aes.createEncryptionCipher;
      break;
    case "3des":
      algorithm = "DES-EDE3-CBC";
      dkLen = 24;
      iv = forge$g.random.getBytesSync(8);
      cipherFn = forge$g.des.createEncryptionCipher;
      break;
    case "des":
      algorithm = "DES-CBC";
      dkLen = 8;
      iv = forge$g.random.getBytesSync(8);
      cipherFn = forge$g.des.createEncryptionCipher;
      break;
    default:
      var error2 = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options2.algorithm + '".');
      error2.algorithm = options2.algorithm;
      throw error2;
  }
  var dk = forge$g.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
  var cipher = cipherFn(dk);
  cipher.start(iv);
  cipher.update(asn1$6.toDer(pki$3.privateKeyToAsn1(rsaKey)));
  cipher.finish();
  var msg = {
    type: "RSA PRIVATE KEY",
    procType: {
      version: "4",
      type: "ENCRYPTED"
    },
    dekInfo: {
      algorithm,
      parameters: forge$g.util.bytesToHex(iv).toUpperCase()
    },
    body: cipher.output.getBytes()
  };
  return forge$g.pem.encode(msg);
};
pki$3.decryptRsaPrivateKey = function(pem2, password) {
  var rval = null;
  var msg = forge$g.pem.decode(pem2)[0];
  if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
    var error2 = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    error2.headerType = error2;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    var dkLen;
    var cipherFn;
    switch (msg.dekInfo.algorithm) {
      case "DES-CBC":
        dkLen = 8;
        cipherFn = forge$g.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        dkLen = 24;
        cipherFn = forge$g.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        dkLen = 16;
        cipherFn = forge$g.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        dkLen = 24;
        cipherFn = forge$g.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        dkLen = 32;
        cipherFn = forge$g.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        dkLen = 5;
        cipherFn = function(key) {
          return forge$g.rc2.createDecryptionCipher(key, 40);
        };
        break;
      case "RC2-64-CBC":
        dkLen = 8;
        cipherFn = function(key) {
          return forge$g.rc2.createDecryptionCipher(key, 64);
        };
        break;
      case "RC2-128-CBC":
        dkLen = 16;
        cipherFn = function(key) {
          return forge$g.rc2.createDecryptionCipher(key, 128);
        };
        break;
      default:
        var error2 = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
        error2.algorithm = msg.dekInfo.algorithm;
        throw error2;
    }
    var iv = forge$g.util.hexToBytes(msg.dekInfo.parameters);
    var dk = forge$g.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(forge$g.util.createBuffer(msg.body));
    if (cipher.finish()) {
      rval = cipher.output.getBytes();
    } else {
      return rval;
    }
  } else {
    rval = msg.body;
  }
  if (msg.type === "ENCRYPTED PRIVATE KEY") {
    rval = pki$3.decryptPrivateKeyInfo(asn1$6.fromDer(rval), password);
  } else {
    rval = asn1$6.fromDer(rval);
  }
  if (rval !== null) {
    rval = pki$3.privateKeyFromAsn1(rval);
  }
  return rval;
};
pki$3.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
  var j, l;
  if (typeof md === "undefined" || md === null) {
    if (!("sha1" in forge$g.md)) {
      throw new Error('"sha1" hash algorithm unavailable.');
    }
    md = forge$g.md.sha1.create();
  }
  var u = md.digestLength;
  var v = md.blockLength;
  var result = new forge$g.util.ByteBuffer();
  var passBuf = new forge$g.util.ByteBuffer();
  if (password !== null && password !== void 0) {
    for (l = 0; l < password.length; l++) {
      passBuf.putInt16(password.charCodeAt(l));
    }
    passBuf.putInt16(0);
  }
  var p = passBuf.length();
  var s2 = salt.length();
  var D3 = new forge$g.util.ByteBuffer();
  D3.fillWithByte(id, v);
  var Slen = v * Math.ceil(s2 / v);
  var S2 = new forge$g.util.ByteBuffer();
  for (l = 0; l < Slen; l++) {
    S2.putByte(salt.at(l % s2));
  }
  var Plen = v * Math.ceil(p / v);
  var P = new forge$g.util.ByteBuffer();
  for (l = 0; l < Plen; l++) {
    P.putByte(passBuf.at(l % p));
  }
  var I2 = S2;
  I2.putBuffer(P);
  var c = Math.ceil(n / u);
  for (var i = 1; i <= c; i++) {
    var buf = new forge$g.util.ByteBuffer();
    buf.putBytes(D3.bytes());
    buf.putBytes(I2.bytes());
    for (var round2 = 0; round2 < iter; round2++) {
      md.start();
      md.update(buf.getBytes());
      buf = md.digest();
    }
    var B = new forge$g.util.ByteBuffer();
    for (l = 0; l < v; l++) {
      B.putByte(buf.at(l % u));
    }
    var k = Math.ceil(s2 / v) + Math.ceil(p / v);
    var Inew = new forge$g.util.ByteBuffer();
    for (j = 0; j < k; j++) {
      var chunk = new forge$g.util.ByteBuffer(I2.getBytes(v));
      var x = 511;
      for (l = B.length() - 1; l >= 0; l--) {
        x = x >> 8;
        x += B.at(l) + chunk.at(l);
        chunk.setAt(l, x & 255);
      }
      Inew.putBuffer(chunk);
    }
    I2 = Inew;
    result.putBuffer(buf);
  }
  result.truncate(result.length() - n);
  return result;
};
pki$3.pbe.getCipher = function(oid, params, password) {
  switch (oid) {
    case pki$3.oids["pkcs5PBES2"]:
      return pki$3.pbe.getCipherForPBES2(oid, params, password);
    case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return pki$3.pbe.getCipherForPKCS12PBE(oid, params, password);
    default:
      var error2 = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      error2.oid = oid;
      error2.supportedOids = [
        "pkcs5PBES2",
        "pbeWithSHAAnd3-KeyTripleDES-CBC",
        "pbewithSHAAnd40BitRC2-CBC"
      ];
      throw error2;
  }
};
pki$3.pbe.getCipherForPBES2 = function(oid, params, password) {
  var capture = {};
  var errors2 = [];
  if (!asn1$6.validate(params, PBES2AlgorithmsValidator, capture, errors2)) {
    var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error2.errors = errors2;
    throw error2;
  }
  oid = asn1$6.derToOid(capture.kdfOid);
  if (oid !== pki$3.oids["pkcs5PBKDF2"]) {
    var error2 = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
    error2.oid = oid;
    error2.supportedOids = ["pkcs5PBKDF2"];
    throw error2;
  }
  oid = asn1$6.derToOid(capture.encOid);
  if (oid !== pki$3.oids["aes128-CBC"] && oid !== pki$3.oids["aes192-CBC"] && oid !== pki$3.oids["aes256-CBC"] && oid !== pki$3.oids["des-EDE3-CBC"] && oid !== pki$3.oids["desCBC"]) {
    var error2 = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
    error2.oid = oid;
    error2.supportedOids = [
      "aes128-CBC",
      "aes192-CBC",
      "aes256-CBC",
      "des-EDE3-CBC",
      "desCBC"
    ];
    throw error2;
  }
  var salt = capture.kdfSalt;
  var count = forge$g.util.createBuffer(capture.kdfIterationCount);
  count = count.getInt(count.length() << 3);
  var dkLen;
  var cipherFn;
  switch (pki$3.oids[oid]) {
    case "aes128-CBC":
      dkLen = 16;
      cipherFn = forge$g.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      dkLen = 24;
      cipherFn = forge$g.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      dkLen = 32;
      cipherFn = forge$g.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      dkLen = 24;
      cipherFn = forge$g.des.createDecryptionCipher;
      break;
    case "desCBC":
      dkLen = 8;
      cipherFn = forge$g.des.createDecryptionCipher;
      break;
  }
  var md = prfOidToMessageDigest(capture.prfOid);
  var dk = forge$g.pkcs5.pbkdf2(password, salt, count, dkLen, md);
  var iv = capture.encIv;
  var cipher = cipherFn(dk);
  cipher.start(iv);
  return cipher;
};
pki$3.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
  var capture = {};
  var errors2 = [];
  if (!asn1$6.validate(params, pkcs12PbeParamsValidator, capture, errors2)) {
    var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var salt = forge$g.util.createBuffer(capture.salt);
  var count = forge$g.util.createBuffer(capture.iterations);
  count = count.getInt(count.length() << 3);
  var dkLen, dIvLen, cipherFn;
  switch (oid) {
    case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      dkLen = 24;
      dIvLen = 8;
      cipherFn = forge$g.des.startDecrypting;
      break;
    case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
      dkLen = 5;
      dIvLen = 8;
      cipherFn = function(key2, iv2) {
        var cipher = forge$g.rc2.createDecryptionCipher(key2, 40);
        cipher.start(iv2, null);
        return cipher;
      };
      break;
    default:
      var error2 = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
      error2.oid = oid;
      throw error2;
  }
  var md = prfOidToMessageDigest(capture.prfOid);
  var key = pki$3.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
  md.start();
  var iv = pki$3.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
  return cipherFn(key, iv);
};
pki$3.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
  if (typeof md === "undefined" || md === null) {
    if (!("md5" in forge$g.md)) {
      throw new Error('"md5" hash algorithm unavailable.');
    }
    md = forge$g.md.md5.create();
  }
  if (salt === null) {
    salt = "";
  }
  var digests = [hash(md, password + salt)];
  for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
    digests.push(hash(md, digests[i - 1] + password + salt));
  }
  return digests.join("").substr(0, dkLen);
};
function hash(md, bytes2) {
  return md.start().update(bytes2).digest().getBytes();
}
function prfOidToMessageDigest(prfOid) {
  var prfAlgorithm;
  if (!prfOid) {
    prfAlgorithm = "hmacWithSHA1";
  } else {
    prfAlgorithm = pki$3.oids[asn1$6.derToOid(prfOid)];
    if (!prfAlgorithm) {
      var error2 = new Error("Unsupported PRF OID.");
      error2.oid = prfOid;
      error2.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ];
      throw error2;
    }
  }
  return prfAlgorithmToMessageDigest(prfAlgorithm);
}
function prfAlgorithmToMessageDigest(prfAlgorithm) {
  var factory = forge$g.md;
  switch (prfAlgorithm) {
    case "hmacWithSHA224":
      factory = forge$g.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
      break;
    default:
      var error2 = new Error("Unsupported PRF algorithm.");
      error2.algorithm = prfAlgorithm;
      error2.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ];
      throw error2;
  }
  if (!factory || !(prfAlgorithm in factory)) {
    throw new Error("Unknown hash algorithm: " + prfAlgorithm);
  }
  return factory[prfAlgorithm].create();
}
function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
  var params = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
    // salt
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.OCTETSTRING,
      false,
      salt
    ),
    // iteration count
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.INTEGER,
      false,
      countBytes.getBytes()
    )
  ]);
  if (prfAlgorithm !== "hmacWithSHA1") {
    params.value.push(
      // key length
      asn1$6.create(
        asn1$6.Class.UNIVERSAL,
        asn1$6.Type.INTEGER,
        false,
        forge$g.util.hexToBytes(dkLen.toString(16))
      ),
      // AlgorithmIdentifier
      asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
        // algorithm
        asn1$6.create(
          asn1$6.Class.UNIVERSAL,
          asn1$6.Type.OID,
          false,
          asn1$6.oidToDer(pki$3.oids[prfAlgorithm]).getBytes()
        ),
        // parameters (null)
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.NULL, false, "")
      ])
    );
  }
  return params;
}
var forge$f = forge$C;
var asn1$5 = forge$f.asn1;
var p7v = forge$f.pkcs7asn1 = forge$f.pkcs7asn1 || {};
forge$f.pkcs7 = forge$f.pkcs7 || {};
forge$f.pkcs7.asn1 = p7v;
var contentInfoValidator$1 = {
  name: "ContentInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "ContentInfo.ContentType",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OID,
    constructed: false,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    captureAsn1: "content"
  }]
};
p7v.contentInfoValidator = contentInfoValidator$1;
var encryptedContentInfoValidator = {
  name: "EncryptedContentInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EncryptedContentInfo.contentType",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OID,
    constructed: false,
    capture: "contentType"
  }, {
    name: "EncryptedContentInfo.contentEncryptionAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.OID,
      constructed: false,
      capture: "encAlgorithm"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
      tagClass: asn1$5.Class.UNIVERSAL,
      captureAsn1: "encParameter"
    }]
  }, {
    name: "EncryptedContentInfo.encryptedContent",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 0,
    /* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */
    capture: "encryptedContent",
    captureAsn1: "encryptedContentAsn1"
  }]
};
p7v.envelopedDataValidator = {
  name: "EnvelopedData",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EnvelopedData.Version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: false,
    capture: "version"
  }, {
    name: "EnvelopedData.RecipientInfos",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SET,
    constructed: true,
    captureAsn1: "recipientInfos"
  }].concat(encryptedContentInfoValidator)
};
p7v.encryptedDataValidator = {
  name: "EncryptedData",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EncryptedData.Version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: false,
    capture: "version"
  }].concat(encryptedContentInfoValidator)
};
var signerValidator = {
  name: "SignerInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "SignerInfo.version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: false
  }, {
    name: "SignerInfo.issuerAndSerialNumber",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "SignerInfo.issuerAndSerialNumber.issuer",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "issuer"
    }, {
      name: "SignerInfo.issuerAndSerialNumber.serialNumber",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.INTEGER,
      constructed: false,
      capture: "serial"
    }]
  }, {
    name: "SignerInfo.digestAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "SignerInfo.digestAlgorithm.algorithm",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.OID,
      constructed: false,
      capture: "digestAlgorithm"
    }, {
      name: "SignerInfo.digestAlgorithm.parameter",
      tagClass: asn1$5.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: "digestParameter",
      optional: true
    }]
  }, {
    name: "SignerInfo.authenticatedAttributes",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: "authenticatedAttributes"
  }, {
    name: "SignerInfo.digestEncryptionAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    capture: "signatureAlgorithm"
  }, {
    name: "SignerInfo.encryptedDigest",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OCTETSTRING,
    constructed: false,
    capture: "signature"
  }, {
    name: "SignerInfo.unauthenticatedAttributes",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    optional: true,
    capture: "unauthenticatedAttributes"
  }]
};
p7v.signedDataValidator = {
  name: "SignedData",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [
    {
      name: "SignedData.Version",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.INTEGER,
      constructed: false,
      capture: "version"
    },
    {
      name: "SignedData.DigestAlgorithms",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SET,
      constructed: true,
      captureAsn1: "digestAlgorithms"
    },
    contentInfoValidator$1,
    {
      name: "SignedData.Certificates",
      tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
      type: 0,
      optional: true,
      captureAsn1: "certificates"
    },
    {
      name: "SignedData.CertificateRevocationLists",
      tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
      type: 1,
      optional: true,
      captureAsn1: "crls"
    },
    {
      name: "SignedData.SignerInfos",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SET,
      capture: "signerInfos",
      optional: true,
      value: [signerValidator]
    }
  ]
};
p7v.recipientInfoValidator = {
  name: "RecipientInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "RecipientInfo.version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: false,
    capture: "version"
  }, {
    name: "RecipientInfo.issuerAndSerial",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RecipientInfo.issuerAndSerial.issuer",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "issuer"
    }, {
      name: "RecipientInfo.issuerAndSerial.serialNumber",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.INTEGER,
      constructed: false,
      capture: "serial"
    }]
  }, {
    name: "RecipientInfo.keyEncryptionAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.OID,
      constructed: false,
      capture: "encAlgorithm"
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
      tagClass: asn1$5.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: "encParameter",
      optional: true
    }]
  }, {
    name: "RecipientInfo.encryptedKey",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OCTETSTRING,
    constructed: false,
    capture: "encKey"
  }]
};
var forge$e = forge$C;
forge$e.mgf = forge$e.mgf || {};
var mgf1 = forge$e.mgf.mgf1 = forge$e.mgf1 = forge$e.mgf1 || {};
mgf1.create = function(md) {
  var mgf = {
    /**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */
    generate: function(seed, maskLen) {
      var t2 = new forge$e.util.ByteBuffer();
      var len = Math.ceil(maskLen / md.digestLength);
      for (var i = 0; i < len; i++) {
        var c = new forge$e.util.ByteBuffer();
        c.putInt32(i);
        md.start();
        md.update(seed + c.getBytes());
        t2.putBuffer(md.digest());
      }
      t2.truncate(t2.length() - maskLen);
      return t2.getBytes();
    }
  };
  return mgf;
};
var forge$d = forge$C;
forge$d.mgf = forge$d.mgf || {};
forge$d.mgf.mgf1 = forge$d.mgf1;
var forge$c = forge$C;
var pss = forge$c.pss = forge$c.pss || {};
pss.create = function(options2) {
  if (arguments.length === 3) {
    options2 = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    };
  }
  var hash2 = options2.md;
  var mgf = options2.mgf;
  var hLen = hash2.digestLength;
  var salt_ = options2.salt || null;
  if (typeof salt_ === "string") {
    salt_ = forge$c.util.createBuffer(salt_);
  }
  var sLen;
  if ("saltLength" in options2) {
    sLen = options2.saltLength;
  } else if (salt_ !== null) {
    sLen = salt_.length();
  } else {
    throw new Error("Salt length not specified or specific salt not given.");
  }
  if (salt_ !== null && salt_.length() !== sLen) {
    throw new Error("Given salt length does not match length of given salt.");
  }
  var prng2 = options2.prng || forge$c.random;
  var pssobj = {};
  pssobj.encode = function(md, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);
    var mHash = md.digest().getBytes();
    if (emLen < hLen + sLen + 2) {
      throw new Error("Message is too long to encrypt.");
    }
    var salt;
    if (salt_ === null) {
      salt = prng2.getBytesSync(sLen);
    } else {
      salt = salt_.bytes();
    }
    var m_ = new forge$c.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);
    hash2.start();
    hash2.update(m_.getBytes());
    var h2 = hash2.digest().getBytes();
    var ps = new forge$c.util.ByteBuffer();
    ps.fillWithByte(0, emLen - sLen - hLen - 2);
    ps.putByte(1);
    ps.putBytes(salt);
    var db = ps.getBytes();
    var maskLen = emLen - hLen - 1;
    var dbMask = mgf.generate(h2, maskLen);
    var maskedDB = "";
    for (i = 0; i < maskLen; i++) {
      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }
    var mask = 65280 >> 8 * emLen - emBits & 255;
    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
    return maskedDB + h2 + String.fromCharCode(188);
  };
  pssobj.verify = function(mHash, em, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);
    em = em.substr(-emLen);
    if (emLen < hLen + sLen + 2) {
      throw new Error("Inconsistent parameters to PSS signature verification.");
    }
    if (em.charCodeAt(emLen - 1) !== 188) {
      throw new Error("Encoded message does not end in 0xBC.");
    }
    var maskLen = emLen - hLen - 1;
    var maskedDB = em.substr(0, maskLen);
    var h2 = em.substr(maskLen, hLen);
    var mask = 65280 >> 8 * emLen - emBits & 255;
    if ((maskedDB.charCodeAt(0) & mask) !== 0) {
      throw new Error("Bits beyond keysize not zero as expected.");
    }
    var dbMask = mgf.generate(h2, maskLen);
    var db = "";
    for (i = 0; i < maskLen; i++) {
      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }
    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
    var checkLen = emLen - hLen - sLen - 2;
    for (i = 0; i < checkLen; i++) {
      if (db.charCodeAt(i) !== 0) {
        throw new Error("Leftmost octets not zero as expected");
      }
    }
    if (db.charCodeAt(checkLen) !== 1) {
      throw new Error("Inconsistent PSS signature, 0x01 marker not found");
    }
    var salt = db.substr(-sLen);
    var m_ = new forge$c.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);
    hash2.start();
    hash2.update(m_.getBytes());
    var h_ = hash2.digest().getBytes();
    return h2 === h_;
  };
  return pssobj;
};
var forge$b = forge$C;
var asn1$4 = forge$b.asn1;
var pki$2 = forge$b.pki = forge$b.pki || {};
var oids = pki$2.oids;
var _shortNames = {};
_shortNames["CN"] = oids["commonName"];
_shortNames["commonName"] = "CN";
_shortNames["C"] = oids["countryName"];
_shortNames["countryName"] = "C";
_shortNames["L"] = oids["localityName"];
_shortNames["localityName"] = "L";
_shortNames["ST"] = oids["stateOrProvinceName"];
_shortNames["stateOrProvinceName"] = "ST";
_shortNames["O"] = oids["organizationName"];
_shortNames["organizationName"] = "O";
_shortNames["OU"] = oids["organizationalUnitName"];
_shortNames["organizationalUnitName"] = "OU";
_shortNames["E"] = oids["emailAddress"];
_shortNames["emailAddress"] = "E";
var publicKeyValidator$1 = forge$b.pki.rsa.publicKeyValidator;
var x509CertificateValidator = {
  name: "Certificate",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "Certificate.TBSCertificate",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "tbsCertificate",
    value: [
      {
        name: "Certificate.TBSCertificate.version",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        value: [{
          name: "Certificate.TBSCertificate.version.integer",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.INTEGER,
          constructed: false,
          capture: "certVersion"
        }]
      },
      {
        name: "Certificate.TBSCertificate.serialNumber",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.INTEGER,
        constructed: false,
        capture: "certSerialNumber"
      },
      {
        name: "Certificate.TBSCertificate.signature",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.TBSCertificate.signature.algorithm",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false,
          capture: "certinfoSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1$4.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certinfoSignatureParams"
        }]
      },
      {
        name: "Certificate.TBSCertificate.issuer",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certIssuer"
      },
      {
        name: "Certificate.TBSCertificate.validity",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        // Note: UTC and generalized times may both appear so the capture
        // names are based on their detected order, the names used below
        // are only for the common case, which validity time really means
        // "notBefore" and which means "notAfter" will be determined by order
        value: [{
          // notBefore (Time) (UTC time case)
          name: "Certificate.TBSCertificate.validity.notBefore (utc)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.UTCTIME,
          constructed: false,
          optional: true,
          capture: "certValidity1UTCTime"
        }, {
          // notBefore (Time) (generalized time case)
          name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.GENERALIZEDTIME,
          constructed: false,
          optional: true,
          capture: "certValidity2GeneralizedTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (utc)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.UTCTIME,
          constructed: false,
          optional: true,
          capture: "certValidity3UTCTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.GENERALIZEDTIME,
          constructed: false,
          optional: true,
          capture: "certValidity4GeneralizedTime"
        }]
      },
      {
        // Name (subject) (RDNSequence)
        name: "Certificate.TBSCertificate.subject",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certSubject"
      },
      // SubjectPublicKeyInfo
      publicKeyValidator$1,
      {
        // issuerUniqueID (optional)
        name: "Certificate.TBSCertificate.issuerUniqueID",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        value: [{
          name: "Certificate.TBSCertificate.issuerUniqueID.id",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.BITSTRING,
          constructed: false,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certIssuerUniqueId"
        }]
      },
      {
        // subjectUniqueID (optional)
        name: "Certificate.TBSCertificate.subjectUniqueID",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 2,
        constructed: true,
        optional: true,
        value: [{
          name: "Certificate.TBSCertificate.subjectUniqueID.id",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.BITSTRING,
          constructed: false,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certSubjectUniqueId"
        }]
      },
      {
        // Extensions (optional)
        name: "Certificate.TBSCertificate.extensions",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 3,
        constructed: true,
        captureAsn1: "certExtensions",
        optional: true
      }
    ]
  }, {
    // AlgorithmIdentifier (signature algorithm)
    name: "Certificate.signatureAlgorithm",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: true,
    value: [{
      // algorithm
      name: "Certificate.signatureAlgorithm.algorithm",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.OID,
      constructed: false,
      capture: "certSignatureOid"
    }, {
      name: "Certificate.TBSCertificate.signature.parameters",
      tagClass: asn1$4.Class.UNIVERSAL,
      optional: true,
      captureAsn1: "certSignatureParams"
    }]
  }, {
    // SignatureValue
    name: "Certificate.signatureValue",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.BITSTRING,
    constructed: false,
    captureBitStringValue: "certSignature"
  }]
};
var rsassaPssParameterValidator = {
  name: "rsapss",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "rsapss.hashAlgorithm",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    value: [{
      name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OID,
        constructed: false,
        capture: "hashOid"
        /* parameter block omitted, for SHA1 NULL anyhow. */
      }]
    }]
  }, {
    name: "rsapss.maskGenAlgorithm",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    value: [{
      name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OID,
        constructed: false,
        capture: "maskGenOid"
      }, {
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false,
          capture: "maskGenHashOid"
          /* parameter block omitted, for SHA1 NULL anyhow. */
        }]
      }]
    }]
  }, {
    name: "rsapss.saltLength",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: true,
    value: [{
      name: "rsapss.saltLength.saltLength",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.INTEGER,
      constructed: false,
      capture: "saltLength"
    }]
  }, {
    name: "rsapss.trailerField",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: true,
    value: [{
      name: "rsapss.trailer.trailer",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.INTEGER,
      constructed: false,
      capture: "trailer"
    }]
  }]
};
var certificationRequestInfoValidator = {
  name: "CertificationRequestInfo",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "certificationRequestInfo",
  value: [
    {
      name: "CertificationRequestInfo.integer",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.INTEGER,
      constructed: false,
      capture: "certificationRequestInfoVersion"
    },
    {
      // Name (subject) (RDNSequence)
      name: "CertificationRequestInfo.subject",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfoSubject"
    },
    // SubjectPublicKeyInfo
    publicKeyValidator$1,
    {
      name: "CertificationRequestInfo.attributes",
      tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      capture: "certificationRequestInfoAttributes",
      value: [{
        name: "CertificationRequestInfo.attributes",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "CertificationRequestInfo.attributes.type",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false
        }, {
          name: "CertificationRequestInfo.attributes.value",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.SET,
          constructed: true
        }]
      }]
    }
  ]
};
var certificationRequestValidator = {
  name: "CertificationRequest",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "csr",
  value: [
    certificationRequestInfoValidator,
    {
      // AlgorithmIdentifier (signature algorithm)
      name: "CertificationRequest.signatureAlgorithm",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      value: [{
        // algorithm
        name: "CertificationRequest.signatureAlgorithm.algorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OID,
        constructed: false,
        capture: "csrSignatureOid"
      }, {
        name: "CertificationRequest.signatureAlgorithm.parameters",
        tagClass: asn1$4.Class.UNIVERSAL,
        optional: true,
        captureAsn1: "csrSignatureParams"
      }]
    },
    {
      // signature
      name: "CertificationRequest.signature",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.BITSTRING,
      constructed: false,
      captureBitStringValue: "csrSignature"
    }
  ]
};
pki$2.RDNAttributesAsArray = function(rdn, md) {
  var rval = [];
  var set2, attr, obj;
  for (var si = 0; si < rdn.value.length; ++si) {
    set2 = rdn.value[si];
    for (var i = 0; i < set2.value.length; ++i) {
      obj = {};
      attr = set2.value[i];
      obj.type = asn1$4.derToOid(attr.value[0].value);
      obj.value = attr.value[1].value;
      obj.valueTagClass = attr.value[1].type;
      if (obj.type in oids) {
        obj.name = oids[obj.type];
        if (obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if (md) {
        md.update(obj.type);
        md.update(obj.value);
      }
      rval.push(obj);
    }
  }
  return rval;
};
pki$2.CRIAttributesAsArray = function(attributes) {
  var rval = [];
  for (var si = 0; si < attributes.length; ++si) {
    var seq2 = attributes[si];
    var type3 = asn1$4.derToOid(seq2.value[0].value);
    var values = seq2.value[1].value;
    for (var vi = 0; vi < values.length; ++vi) {
      var obj = {};
      obj.type = type3;
      obj.value = values[vi].value;
      obj.valueTagClass = values[vi].type;
      if (obj.type in oids) {
        obj.name = oids[obj.type];
        if (obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if (obj.type === oids.extensionRequest) {
        obj.extensions = [];
        for (var ei = 0; ei < obj.value.length; ++ei) {
          obj.extensions.push(pki$2.certificateExtensionFromAsn1(obj.value[ei]));
        }
      }
      rval.push(obj);
    }
  }
  return rval;
};
function _getAttribute(obj, options2) {
  if (typeof options2 === "string") {
    options2 = { shortName: options2 };
  }
  var rval = null;
  var attr;
  for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
    attr = obj.attributes[i];
    if (options2.type && options2.type === attr.type) {
      rval = attr;
    } else if (options2.name && options2.name === attr.name) {
      rval = attr;
    } else if (options2.shortName && options2.shortName === attr.shortName) {
      rval = attr;
    }
  }
  return rval;
}
var _readSignatureParameters = function(oid, obj, fillDefaults) {
  var params = {};
  if (oid !== oids["RSASSA-PSS"]) {
    return params;
  }
  if (fillDefaults) {
    params = {
      hash: {
        algorithmOid: oids["sha1"]
      },
      mgf: {
        algorithmOid: oids["mgf1"],
        hash: {
          algorithmOid: oids["sha1"]
        }
      },
      saltLength: 20
    };
  }
  var capture = {};
  var errors2 = [];
  if (!asn1$4.validate(obj, rsassaPssParameterValidator, capture, errors2)) {
    var error2 = new Error("Cannot read RSASSA-PSS parameter block.");
    error2.errors = errors2;
    throw error2;
  }
  if (capture.hashOid !== void 0) {
    params.hash = params.hash || {};
    params.hash.algorithmOid = asn1$4.derToOid(capture.hashOid);
  }
  if (capture.maskGenOid !== void 0) {
    params.mgf = params.mgf || {};
    params.mgf.algorithmOid = asn1$4.derToOid(capture.maskGenOid);
    params.mgf.hash = params.mgf.hash || {};
    params.mgf.hash.algorithmOid = asn1$4.derToOid(capture.maskGenHashOid);
  }
  if (capture.saltLength !== void 0) {
    params.saltLength = capture.saltLength.charCodeAt(0);
  }
  return params;
};
var _createSignatureDigest = function(options2) {
  switch (oids[options2.signatureOid]) {
    case "sha1WithRSAEncryption":
    case "sha1WithRSASignature":
      return forge$b.md.sha1.create();
    case "md5WithRSAEncryption":
      return forge$b.md.md5.create();
    case "sha256WithRSAEncryption":
      return forge$b.md.sha256.create();
    case "sha384WithRSAEncryption":
      return forge$b.md.sha384.create();
    case "sha512WithRSAEncryption":
      return forge$b.md.sha512.create();
    case "RSASSA-PSS":
      return forge$b.md.sha256.create();
    default:
      var error2 = new Error(
        "Could not compute " + options2.type + " digest. Unknown signature OID."
      );
      error2.signatureOid = options2.signatureOid;
      throw error2;
  }
};
var _verifySignature = function(options2) {
  var cert = options2.certificate;
  var scheme;
  switch (cert.signatureOid) {
    case oids.sha1WithRSAEncryption:
    case oids.sha1WithRSASignature:
      break;
    case oids["RSASSA-PSS"]:
      var hash2, mgf;
      hash2 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
      if (hash2 === void 0 || forge$b.md[hash2] === void 0) {
        var error2 = new Error("Unsupported MGF hash function.");
        error2.oid = cert.signatureParameters.mgf.hash.algorithmOid;
        error2.name = hash2;
        throw error2;
      }
      mgf = oids[cert.signatureParameters.mgf.algorithmOid];
      if (mgf === void 0 || forge$b.mgf[mgf] === void 0) {
        var error2 = new Error("Unsupported MGF function.");
        error2.oid = cert.signatureParameters.mgf.algorithmOid;
        error2.name = mgf;
        throw error2;
      }
      mgf = forge$b.mgf[mgf].create(forge$b.md[hash2].create());
      hash2 = oids[cert.signatureParameters.hash.algorithmOid];
      if (hash2 === void 0 || forge$b.md[hash2] === void 0) {
        var error2 = new Error("Unsupported RSASSA-PSS hash function.");
        error2.oid = cert.signatureParameters.hash.algorithmOid;
        error2.name = hash2;
        throw error2;
      }
      scheme = forge$b.pss.create(
        forge$b.md[hash2].create(),
        mgf,
        cert.signatureParameters.saltLength
      );
      break;
  }
  return cert.publicKey.verify(
    options2.md.digest().getBytes(),
    options2.signature,
    scheme
  );
};
pki$2.certificateFromPem = function(pem2, computeHash, strict) {
  var msg = forge$b.pem.decode(pem2)[0];
  if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
    var error2 = new Error(
      'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
    );
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error(
      "Could not convert certificate from PEM; PEM is encrypted."
    );
  }
  var obj = asn1$4.fromDer(msg.body, strict);
  return pki$2.certificateFromAsn1(obj, computeHash);
};
pki$2.certificateToPem = function(cert, maxline) {
  var msg = {
    type: "CERTIFICATE",
    body: asn1$4.toDer(pki$2.certificateToAsn1(cert)).getBytes()
  };
  return forge$b.pem.encode(msg, { maxline });
};
pki$2.publicKeyFromPem = function(pem2) {
  var msg = forge$b.pem.decode(pem2)[0];
  if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
    var error2 = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert public key from PEM; PEM is encrypted.");
  }
  var obj = asn1$4.fromDer(msg.body);
  return pki$2.publicKeyFromAsn1(obj);
};
pki$2.publicKeyToPem = function(key, maxline) {
  var msg = {
    type: "PUBLIC KEY",
    body: asn1$4.toDer(pki$2.publicKeyToAsn1(key)).getBytes()
  };
  return forge$b.pem.encode(msg, { maxline });
};
pki$2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
  var msg = {
    type: "RSA PUBLIC KEY",
    body: asn1$4.toDer(pki$2.publicKeyToRSAPublicKey(key)).getBytes()
  };
  return forge$b.pem.encode(msg, { maxline });
};
pki$2.getPublicKeyFingerprint = function(key, options2) {
  options2 = options2 || {};
  var md = options2.md || forge$b.md.sha1.create();
  var type3 = options2.type || "RSAPublicKey";
  var bytes2;
  switch (type3) {
    case "RSAPublicKey":
      bytes2 = asn1$4.toDer(pki$2.publicKeyToRSAPublicKey(key)).getBytes();
      break;
    case "SubjectPublicKeyInfo":
      bytes2 = asn1$4.toDer(pki$2.publicKeyToAsn1(key)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + options2.type + '".');
  }
  md.start();
  md.update(bytes2);
  var digest = md.digest();
  if (options2.encoding === "hex") {
    var hex = digest.toHex();
    if (options2.delimiter) {
      return hex.match(/.{2}/g).join(options2.delimiter);
    }
    return hex;
  } else if (options2.encoding === "binary") {
    return digest.getBytes();
  } else if (options2.encoding) {
    throw new Error('Unknown encoding "' + options2.encoding + '".');
  }
  return digest;
};
pki$2.certificationRequestFromPem = function(pem2, computeHash, strict) {
  var msg = forge$b.pem.decode(pem2)[0];
  if (msg.type !== "CERTIFICATE REQUEST") {
    var error2 = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
  }
  var obj = asn1$4.fromDer(msg.body, strict);
  return pki$2.certificationRequestFromAsn1(obj, computeHash);
};
pki$2.certificationRequestToPem = function(csr, maxline) {
  var msg = {
    type: "CERTIFICATE REQUEST",
    body: asn1$4.toDer(pki$2.certificationRequestToAsn1(csr)).getBytes()
  };
  return forge$b.pem.encode(msg, { maxline });
};
pki$2.createCertificate = function() {
  var cert = {};
  cert.version = 2;
  cert.serialNumber = "00";
  cert.signatureOid = null;
  cert.signature = null;
  cert.siginfo = {};
  cert.siginfo.algorithmOid = null;
  cert.validity = {};
  cert.validity.notBefore = /* @__PURE__ */ new Date();
  cert.validity.notAfter = /* @__PURE__ */ new Date();
  cert.issuer = {};
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = [];
  cert.issuer.hash = null;
  cert.subject = {};
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = [];
  cert.subject.hash = null;
  cert.extensions = [];
  cert.publicKey = null;
  cert.md = null;
  cert.setSubject = function(attrs, uniqueId) {
    _fillMissingFields(attrs);
    cert.subject.attributes = attrs;
    delete cert.subject.uniqueId;
    if (uniqueId) {
      cert.subject.uniqueId = uniqueId;
    }
    cert.subject.hash = null;
  };
  cert.setIssuer = function(attrs, uniqueId) {
    _fillMissingFields(attrs);
    cert.issuer.attributes = attrs;
    delete cert.issuer.uniqueId;
    if (uniqueId) {
      cert.issuer.uniqueId = uniqueId;
    }
    cert.issuer.hash = null;
  };
  cert.setExtensions = function(exts) {
    for (var i = 0; i < exts.length; ++i) {
      _fillMissingExtensionFields(exts[i], { cert });
    }
    cert.extensions = exts;
  };
  cert.getExtension = function(options2) {
    if (typeof options2 === "string") {
      options2 = { name: options2 };
    }
    var rval = null;
    var ext;
    for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
      ext = cert.extensions[i];
      if (options2.id && ext.id === options2.id) {
        rval = ext;
      } else if (options2.name && ext.name === options2.name) {
        rval = ext;
      }
    }
    return rval;
  };
  cert.sign = function(key, md) {
    cert.md = md || forge$b.md.sha1.create();
    var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
    if (!algorithmOid) {
      var error2 = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
      error2.algorithm = cert.md.algorithm;
      throw error2;
    }
    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
    cert.tbsCertificate = pki$2.getTBSCertificate(cert);
    var bytes2 = asn1$4.toDer(cert.tbsCertificate);
    cert.md.update(bytes2.getBytes());
    cert.signature = key.sign(cert.md);
  };
  cert.verify = function(child) {
    var rval = false;
    if (!cert.issued(child)) {
      var issuer = child.issuer;
      var subject = cert.subject;
      var error2 = new Error(
        "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
      );
      error2.expectedIssuer = subject.attributes;
      error2.actualIssuer = issuer.attributes;
      throw error2;
    }
    var md = child.md;
    if (md === null) {
      md = _createSignatureDigest({
        signatureOid: child.signatureOid,
        type: "certificate"
      });
      var tbsCertificate = child.tbsCertificate || pki$2.getTBSCertificate(child);
      var bytes2 = asn1$4.toDer(tbsCertificate);
      md.update(bytes2.getBytes());
    }
    if (md !== null) {
      rval = _verifySignature({
        certificate: cert,
        md,
        signature: child.signature
      });
    }
    return rval;
  };
  cert.isIssuer = function(parent) {
    var rval = false;
    var i = cert.issuer;
    var s2 = parent.subject;
    if (i.hash && s2.hash) {
      rval = i.hash === s2.hash;
    } else if (i.attributes.length === s2.attributes.length) {
      rval = true;
      var iattr, sattr;
      for (var n = 0; rval && n < i.attributes.length; ++n) {
        iattr = i.attributes[n];
        sattr = s2.attributes[n];
        if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
          rval = false;
        }
      }
    }
    return rval;
  };
  cert.issued = function(child) {
    return child.isIssuer(cert);
  };
  cert.generateSubjectKeyIdentifier = function() {
    return pki$2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
  };
  cert.verifySubjectKeyIdentifier = function() {
    var oid = oids["subjectKeyIdentifier"];
    for (var i = 0; i < cert.extensions.length; ++i) {
      var ext = cert.extensions[i];
      if (ext.id === oid) {
        var ski = cert.generateSubjectKeyIdentifier().getBytes();
        return forge$b.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
      }
    }
    return false;
  };
  return cert;
};
pki$2.certificateFromAsn1 = function(obj, computeHash) {
  var capture = {};
  var errors2 = [];
  if (!asn1$4.validate(obj, x509CertificateValidator, capture, errors2)) {
    var error2 = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$4.derToOid(capture.publicKeyOid);
  if (oid !== pki$2.oids.rsaEncryption) {
    throw new Error("Cannot read public key. OID is not RSA.");
  }
  var cert = pki$2.createCertificate();
  cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
  var serial = forge$b.util.createBuffer(capture.certSerialNumber);
  cert.serialNumber = serial.toHex();
  cert.signatureOid = forge$b.asn1.derToOid(capture.certSignatureOid);
  cert.signatureParameters = _readSignatureParameters(
    cert.signatureOid,
    capture.certSignatureParams,
    true
  );
  cert.siginfo.algorithmOid = forge$b.asn1.derToOid(capture.certinfoSignatureOid);
  cert.siginfo.parameters = _readSignatureParameters(
    cert.siginfo.algorithmOid,
    capture.certinfoSignatureParams,
    false
  );
  cert.signature = capture.certSignature;
  var validity = [];
  if (capture.certValidity1UTCTime !== void 0) {
    validity.push(asn1$4.utcTimeToDate(capture.certValidity1UTCTime));
  }
  if (capture.certValidity2GeneralizedTime !== void 0) {
    validity.push(asn1$4.generalizedTimeToDate(
      capture.certValidity2GeneralizedTime
    ));
  }
  if (capture.certValidity3UTCTime !== void 0) {
    validity.push(asn1$4.utcTimeToDate(capture.certValidity3UTCTime));
  }
  if (capture.certValidity4GeneralizedTime !== void 0) {
    validity.push(asn1$4.generalizedTimeToDate(
      capture.certValidity4GeneralizedTime
    ));
  }
  if (validity.length > 2) {
    throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
  }
  if (validity.length < 2) {
    throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
  }
  cert.validity.notBefore = validity[0];
  cert.validity.notAfter = validity[1];
  cert.tbsCertificate = capture.tbsCertificate;
  if (computeHash) {
    cert.md = _createSignatureDigest({
      signatureOid: cert.signatureOid,
      type: "certificate"
    });
    var bytes2 = asn1$4.toDer(cert.tbsCertificate);
    cert.md.update(bytes2.getBytes());
  }
  var imd = forge$b.md.sha1.create();
  var ibytes = asn1$4.toDer(capture.certIssuer);
  imd.update(ibytes.getBytes());
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = pki$2.RDNAttributesAsArray(capture.certIssuer);
  if (capture.certIssuerUniqueId) {
    cert.issuer.uniqueId = capture.certIssuerUniqueId;
  }
  cert.issuer.hash = imd.digest().toHex();
  var smd = forge$b.md.sha1.create();
  var sbytes = asn1$4.toDer(capture.certSubject);
  smd.update(sbytes.getBytes());
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = pki$2.RDNAttributesAsArray(capture.certSubject);
  if (capture.certSubjectUniqueId) {
    cert.subject.uniqueId = capture.certSubjectUniqueId;
  }
  cert.subject.hash = smd.digest().toHex();
  if (capture.certExtensions) {
    cert.extensions = pki$2.certificateExtensionsFromAsn1(capture.certExtensions);
  } else {
    cert.extensions = [];
  }
  cert.publicKey = pki$2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
  return cert;
};
pki$2.certificateExtensionsFromAsn1 = function(exts) {
  var rval = [];
  for (var i = 0; i < exts.value.length; ++i) {
    var extseq = exts.value[i];
    for (var ei = 0; ei < extseq.value.length; ++ei) {
      rval.push(pki$2.certificateExtensionFromAsn1(extseq.value[ei]));
    }
  }
  return rval;
};
pki$2.certificateExtensionFromAsn1 = function(ext) {
  var e = {};
  e.id = asn1$4.derToOid(ext.value[0].value);
  e.critical = false;
  if (ext.value[1].type === asn1$4.Type.BOOLEAN) {
    e.critical = ext.value[1].value.charCodeAt(0) !== 0;
    e.value = ext.value[2].value;
  } else {
    e.value = ext.value[1].value;
  }
  if (e.id in oids) {
    e.name = oids[e.id];
    if (e.name === "keyUsage") {
      var ev = asn1$4.fromDer(e.value);
      var b2 = 0;
      var b3 = 0;
      if (ev.value.length > 1) {
        b2 = ev.value.charCodeAt(1);
        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
      }
      e.digitalSignature = (b2 & 128) === 128;
      e.nonRepudiation = (b2 & 64) === 64;
      e.keyEncipherment = (b2 & 32) === 32;
      e.dataEncipherment = (b2 & 16) === 16;
      e.keyAgreement = (b2 & 8) === 8;
      e.keyCertSign = (b2 & 4) === 4;
      e.cRLSign = (b2 & 2) === 2;
      e.encipherOnly = (b2 & 1) === 1;
      e.decipherOnly = (b3 & 128) === 128;
    } else if (e.name === "basicConstraints") {
      var ev = asn1$4.fromDer(e.value);
      if (ev.value.length > 0 && ev.value[0].type === asn1$4.Type.BOOLEAN) {
        e.cA = ev.value[0].value.charCodeAt(0) !== 0;
      } else {
        e.cA = false;
      }
      var value = null;
      if (ev.value.length > 0 && ev.value[0].type === asn1$4.Type.INTEGER) {
        value = ev.value[0].value;
      } else if (ev.value.length > 1) {
        value = ev.value[1].value;
      }
      if (value !== null) {
        e.pathLenConstraint = asn1$4.derToInteger(value);
      }
    } else if (e.name === "extKeyUsage") {
      var ev = asn1$4.fromDer(e.value);
      for (var vi = 0; vi < ev.value.length; ++vi) {
        var oid = asn1$4.derToOid(ev.value[vi].value);
        if (oid in oids) {
          e[oids[oid]] = true;
        } else {
          e[oid] = true;
        }
      }
    } else if (e.name === "nsCertType") {
      var ev = asn1$4.fromDer(e.value);
      var b2 = 0;
      if (ev.value.length > 1) {
        b2 = ev.value.charCodeAt(1);
      }
      e.client = (b2 & 128) === 128;
      e.server = (b2 & 64) === 64;
      e.email = (b2 & 32) === 32;
      e.objsign = (b2 & 16) === 16;
      e.reserved = (b2 & 8) === 8;
      e.sslCA = (b2 & 4) === 4;
      e.emailCA = (b2 & 2) === 2;
      e.objCA = (b2 & 1) === 1;
    } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
      e.altNames = [];
      var gn;
      var ev = asn1$4.fromDer(e.value);
      for (var n = 0; n < ev.value.length; ++n) {
        gn = ev.value[n];
        var altName = {
          type: gn.type,
          value: gn.value
        };
        e.altNames.push(altName);
        switch (gn.type) {
          case 1:
          case 2:
          case 6:
            break;
          case 7:
            altName.ip = forge$b.util.bytesToIP(gn.value);
            break;
          case 8:
            altName.oid = asn1$4.derToOid(gn.value);
            break;
        }
      }
    } else if (e.name === "subjectKeyIdentifier") {
      var ev = asn1$4.fromDer(e.value);
      e.subjectKeyIdentifier = forge$b.util.bytesToHex(ev.value);
    }
  }
  return e;
};
pki$2.certificationRequestFromAsn1 = function(obj, computeHash) {
  var capture = {};
  var errors2 = [];
  if (!asn1$4.validate(obj, certificationRequestValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$4.derToOid(capture.publicKeyOid);
  if (oid !== pki$2.oids.rsaEncryption) {
    throw new Error("Cannot read public key. OID is not RSA.");
  }
  var csr = pki$2.createCertificationRequest();
  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
  csr.signatureOid = forge$b.asn1.derToOid(capture.csrSignatureOid);
  csr.signatureParameters = _readSignatureParameters(
    csr.signatureOid,
    capture.csrSignatureParams,
    true
  );
  csr.siginfo.algorithmOid = forge$b.asn1.derToOid(capture.csrSignatureOid);
  csr.siginfo.parameters = _readSignatureParameters(
    csr.siginfo.algorithmOid,
    capture.csrSignatureParams,
    false
  );
  csr.signature = capture.csrSignature;
  csr.certificationRequestInfo = capture.certificationRequestInfo;
  if (computeHash) {
    csr.md = _createSignatureDigest({
      signatureOid: csr.signatureOid,
      type: "certification request"
    });
    var bytes2 = asn1$4.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes2.getBytes());
  }
  var smd = forge$b.md.sha1.create();
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = pki$2.RDNAttributesAsArray(
    capture.certificationRequestInfoSubject,
    smd
  );
  csr.subject.hash = smd.digest().toHex();
  csr.publicKey = pki$2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.attributes = pki$2.CRIAttributesAsArray(
    capture.certificationRequestInfoAttributes || []
  );
  return csr;
};
pki$2.createCertificationRequest = function() {
  var csr = {};
  csr.version = 0;
  csr.signatureOid = null;
  csr.signature = null;
  csr.siginfo = {};
  csr.siginfo.algorithmOid = null;
  csr.subject = {};
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = [];
  csr.subject.hash = null;
  csr.publicKey = null;
  csr.attributes = [];
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.md = null;
  csr.setSubject = function(attrs) {
    _fillMissingFields(attrs);
    csr.subject.attributes = attrs;
    csr.subject.hash = null;
  };
  csr.setAttributes = function(attrs) {
    _fillMissingFields(attrs);
    csr.attributes = attrs;
  };
  csr.sign = function(key, md) {
    csr.md = md || forge$b.md.sha1.create();
    var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
    if (!algorithmOid) {
      var error2 = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
      error2.algorithm = csr.md.algorithm;
      throw error2;
    }
    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
    csr.certificationRequestInfo = pki$2.getCertificationRequestInfo(csr);
    var bytes2 = asn1$4.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes2.getBytes());
    csr.signature = key.sign(csr.md);
  };
  csr.verify = function() {
    var rval = false;
    var md = csr.md;
    if (md === null) {
      md = _createSignatureDigest({
        signatureOid: csr.signatureOid,
        type: "certification request"
      });
      var cri = csr.certificationRequestInfo || pki$2.getCertificationRequestInfo(csr);
      var bytes2 = asn1$4.toDer(cri);
      md.update(bytes2.getBytes());
    }
    if (md !== null) {
      rval = _verifySignature({
        certificate: csr,
        md,
        signature: csr.signature
      });
    }
    return rval;
  };
  return csr;
};
function _dnToAsn1(obj) {
  var rval = asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.SEQUENCE,
    true,
    []
  );
  var attr, set2;
  var attrs = obj.attributes;
  for (var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];
    var value = attr.value;
    var valueTagClass = asn1$4.Type.PRINTABLESTRING;
    if ("valueTagClass" in attr) {
      valueTagClass = attr.valueTagClass;
      if (valueTagClass === asn1$4.Type.UTF8) {
        value = forge$b.util.encodeUtf8(value);
      }
    }
    set2 = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SET, true, [
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
        // AttributeType
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.OID,
          false,
          asn1$4.oidToDer(attr.type).getBytes()
        ),
        // AttributeValue
        asn1$4.create(asn1$4.Class.UNIVERSAL, valueTagClass, false, value)
      ])
    ]);
    rval.value.push(set2);
  }
  return rval;
}
function _fillMissingFields(attrs) {
  var attr;
  for (var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];
    if (typeof attr.name === "undefined") {
      if (attr.type && attr.type in pki$2.oids) {
        attr.name = pki$2.oids[attr.type];
      } else if (attr.shortName && attr.shortName in _shortNames) {
        attr.name = pki$2.oids[_shortNames[attr.shortName]];
      }
    }
    if (typeof attr.type === "undefined") {
      if (attr.name && attr.name in pki$2.oids) {
        attr.type = pki$2.oids[attr.name];
      } else {
        var error2 = new Error("Attribute type not specified.");
        error2.attribute = attr;
        throw error2;
      }
    }
    if (typeof attr.shortName === "undefined") {
      if (attr.name && attr.name in _shortNames) {
        attr.shortName = _shortNames[attr.name];
      }
    }
    if (attr.type === oids.extensionRequest) {
      attr.valueConstructed = true;
      attr.valueTagClass = asn1$4.Type.SEQUENCE;
      if (!attr.value && attr.extensions) {
        attr.value = [];
        for (var ei = 0; ei < attr.extensions.length; ++ei) {
          attr.value.push(pki$2.certificateExtensionToAsn1(
            _fillMissingExtensionFields(attr.extensions[ei])
          ));
        }
      }
    }
    if (typeof attr.value === "undefined") {
      var error2 = new Error("Attribute value not specified.");
      error2.attribute = attr;
      throw error2;
    }
  }
}
function _fillMissingExtensionFields(e, options2) {
  options2 = options2 || {};
  if (typeof e.name === "undefined") {
    if (e.id && e.id in pki$2.oids) {
      e.name = pki$2.oids[e.id];
    }
  }
  if (typeof e.id === "undefined") {
    if (e.name && e.name in pki$2.oids) {
      e.id = pki$2.oids[e.name];
    } else {
      var error2 = new Error("Extension ID not specified.");
      error2.extension = e;
      throw error2;
    }
  }
  if (typeof e.value !== "undefined") {
    return e;
  }
  if (e.name === "keyUsage") {
    var unused = 0;
    var b2 = 0;
    var b3 = 0;
    if (e.digitalSignature) {
      b2 |= 128;
      unused = 7;
    }
    if (e.nonRepudiation) {
      b2 |= 64;
      unused = 6;
    }
    if (e.keyEncipherment) {
      b2 |= 32;
      unused = 5;
    }
    if (e.dataEncipherment) {
      b2 |= 16;
      unused = 4;
    }
    if (e.keyAgreement) {
      b2 |= 8;
      unused = 3;
    }
    if (e.keyCertSign) {
      b2 |= 4;
      unused = 2;
    }
    if (e.cRLSign) {
      b2 |= 2;
      unused = 1;
    }
    if (e.encipherOnly) {
      b2 |= 1;
      unused = 0;
    }
    if (e.decipherOnly) {
      b3 |= 128;
      unused = 7;
    }
    var value = String.fromCharCode(unused);
    if (b3 !== 0) {
      value += String.fromCharCode(b2) + String.fromCharCode(b3);
    } else if (b2 !== 0) {
      value += String.fromCharCode(b2);
    }
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      false,
      value
    );
  } else if (e.name === "basicConstraints") {
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.SEQUENCE,
      true,
      []
    );
    if (e.cA) {
      e.value.value.push(asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.BOOLEAN,
        false,
        String.fromCharCode(255)
      ));
    }
    if ("pathLenConstraint" in e) {
      e.value.value.push(asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.INTEGER,
        false,
        asn1$4.integerToDer(e.pathLenConstraint).getBytes()
      ));
    }
  } else if (e.name === "extKeyUsage") {
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.SEQUENCE,
      true,
      []
    );
    var seq2 = e.value.value;
    for (var key in e) {
      if (e[key] !== true) {
        continue;
      }
      if (key in oids) {
        seq2.push(asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.OID,
          false,
          asn1$4.oidToDer(oids[key]).getBytes()
        ));
      } else if (key.indexOf(".") !== -1) {
        seq2.push(asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.OID,
          false,
          asn1$4.oidToDer(key).getBytes()
        ));
      }
    }
  } else if (e.name === "nsCertType") {
    var unused = 0;
    var b2 = 0;
    if (e.client) {
      b2 |= 128;
      unused = 7;
    }
    if (e.server) {
      b2 |= 64;
      unused = 6;
    }
    if (e.email) {
      b2 |= 32;
      unused = 5;
    }
    if (e.objsign) {
      b2 |= 16;
      unused = 4;
    }
    if (e.reserved) {
      b2 |= 8;
      unused = 3;
    }
    if (e.sslCA) {
      b2 |= 4;
      unused = 2;
    }
    if (e.emailCA) {
      b2 |= 2;
      unused = 1;
    }
    if (e.objCA) {
      b2 |= 1;
      unused = 0;
    }
    var value = String.fromCharCode(unused);
    if (b2 !== 0) {
      value += String.fromCharCode(b2);
    }
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      false,
      value
    );
  } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
    e.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
    var altName;
    for (var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value;
      if (altName.type === 7 && altName.ip) {
        value = forge$b.util.bytesFromIP(altName.ip);
        if (value === null) {
          var error2 = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          error2.extension = e;
          throw error2;
        }
      } else if (altName.type === 8) {
        if (altName.oid) {
          value = asn1$4.oidToDer(asn1$4.oidToDer(altName.oid));
        } else {
          value = asn1$4.oidToDer(value);
        }
      }
      e.value.value.push(asn1$4.create(
        asn1$4.Class.CONTEXT_SPECIFIC,
        altName.type,
        false,
        value
      ));
    }
  } else if (e.name === "nsComment" && options2.cert) {
    if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
      throw new Error('Invalid "nsComment" content.');
    }
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.IA5STRING,
      false,
      e.comment
    );
  } else if (e.name === "subjectKeyIdentifier" && options2.cert) {
    var ski = options2.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = ski.toHex();
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.OCTETSTRING,
      false,
      ski.getBytes()
    );
  } else if (e.name === "authorityKeyIdentifier" && options2.cert) {
    e.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
    var seq2 = e.value.value;
    if (e.keyIdentifier) {
      var keyIdentifier = e.keyIdentifier === true ? options2.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
      seq2.push(
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
      );
    }
    if (e.authorityCertIssuer) {
      var authorityCertIssuer = [
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 4, true, [
          _dnToAsn1(e.authorityCertIssuer === true ? options2.cert.issuer : e.authorityCertIssuer)
        ])
      ];
      seq2.push(
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
      );
    }
    if (e.serialNumber) {
      var serialNumber = forge$b.util.hexToBytes(e.serialNumber === true ? options2.cert.serialNumber : e.serialNumber);
      seq2.push(
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
      );
    }
  } else if (e.name === "cRLDistributionPoints") {
    e.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
    var seq2 = e.value.value;
    var subSeq = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.SEQUENCE,
      true,
      []
    );
    var fullNameGeneralNames = asn1$4.create(
      asn1$4.Class.CONTEXT_SPECIFIC,
      0,
      true,
      []
    );
    var altName;
    for (var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value;
      if (altName.type === 7 && altName.ip) {
        value = forge$b.util.bytesFromIP(altName.ip);
        if (value === null) {
          var error2 = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          error2.extension = e;
          throw error2;
        }
      } else if (altName.type === 8) {
        if (altName.oid) {
          value = asn1$4.oidToDer(asn1$4.oidToDer(altName.oid));
        } else {
          value = asn1$4.oidToDer(value);
        }
      }
      fullNameGeneralNames.value.push(asn1$4.create(
        asn1$4.Class.CONTEXT_SPECIFIC,
        altName.type,
        false,
        value
      ));
    }
    subSeq.value.push(asn1$4.create(
      asn1$4.Class.CONTEXT_SPECIFIC,
      0,
      true,
      [fullNameGeneralNames]
    ));
    seq2.push(subSeq);
  }
  if (typeof e.value === "undefined") {
    var error2 = new Error("Extension value not specified.");
    error2.extension = e;
    throw error2;
  }
  return e;
}
function _signatureParametersToAsn1(oid, params) {
  switch (oid) {
    case oids["RSASSA-PSS"]:
      var parts = [];
      if (params.hash.algorithmOid !== void 0) {
        parts.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
            asn1$4.create(
              asn1$4.Class.UNIVERSAL,
              asn1$4.Type.OID,
              false,
              asn1$4.oidToDer(params.hash.algorithmOid).getBytes()
            ),
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
          ])
        ]));
      }
      if (params.mgf.algorithmOid !== void 0) {
        parts.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
            asn1$4.create(
              asn1$4.Class.UNIVERSAL,
              asn1$4.Type.OID,
              false,
              asn1$4.oidToDer(params.mgf.algorithmOid).getBytes()
            ),
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
              asn1$4.create(
                asn1$4.Class.UNIVERSAL,
                asn1$4.Type.OID,
                false,
                asn1$4.oidToDer(params.mgf.hash.algorithmOid).getBytes()
              ),
              asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
            ])
          ])
        ]));
      }
      if (params.saltLength !== void 0) {
        parts.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1$4.create(
            asn1$4.Class.UNIVERSAL,
            asn1$4.Type.INTEGER,
            false,
            asn1$4.integerToDer(params.saltLength).getBytes()
          )
        ]));
      }
      return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, parts);
    default:
      return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "");
  }
}
function _CRIAttributesToAsn1(csr) {
  var rval = asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, []);
  if (csr.attributes.length === 0) {
    return rval;
  }
  var attrs = csr.attributes;
  for (var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];
    var value = attr.value;
    var valueTagClass = asn1$4.Type.UTF8;
    if ("valueTagClass" in attr) {
      valueTagClass = attr.valueTagClass;
    }
    if (valueTagClass === asn1$4.Type.UTF8) {
      value = forge$b.util.encodeUtf8(value);
    }
    var valueConstructed = false;
    if ("valueConstructed" in attr) {
      valueConstructed = attr.valueConstructed;
    }
    var seq2 = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      // AttributeType
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(attr.type).getBytes()
      ),
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SET, true, [
        // AttributeValue
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          valueTagClass,
          valueConstructed,
          value
        )
      ])
    ]);
    rval.value.push(seq2);
  }
  return rval;
}
var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
function _dateToAsn1(date) {
  if (date >= jan_1_1950 && date < jan_1_2050) {
    return asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.UTCTIME,
      false,
      asn1$4.dateToUtcTime(date)
    );
  } else {
    return asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.GENERALIZEDTIME,
      false,
      asn1$4.dateToGeneralizedTime(date)
    );
  }
}
pki$2.getTBSCertificate = function(cert) {
  var notBefore = _dateToAsn1(cert.validity.notBefore);
  var notAfter = _dateToAsn1(cert.validity.notAfter);
  var tbs = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // version
    asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, [
      // integer
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.INTEGER,
        false,
        asn1$4.integerToDer(cert.version).getBytes()
      )
    ]),
    // serialNumber
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      forge$b.util.hexToBytes(cert.serialNumber)
    ),
    // signature
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      // algorithm
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(cert.siginfo.algorithmOid).getBytes()
      ),
      // parameters
      _signatureParametersToAsn1(
        cert.siginfo.algorithmOid,
        cert.siginfo.parameters
      )
    ]),
    // issuer
    _dnToAsn1(cert.issuer),
    // validity
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      notBefore,
      notAfter
    ]),
    // subject
    _dnToAsn1(cert.subject),
    // SubjectPublicKeyInfo
    pki$2.publicKeyToAsn1(cert.publicKey)
  ]);
  if (cert.issuer.uniqueId) {
    tbs.value.push(
      asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, true, [
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.BITSTRING,
          false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0) + cert.issuer.uniqueId
        )
      ])
    );
  }
  if (cert.subject.uniqueId) {
    tbs.value.push(
      asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, true, [
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.BITSTRING,
          false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0) + cert.subject.uniqueId
        )
      ])
    );
  }
  if (cert.extensions.length > 0) {
    tbs.value.push(pki$2.certificateExtensionsToAsn1(cert.extensions));
  }
  return tbs;
};
pki$2.getCertificationRequestInfo = function(csr) {
  var cri = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // version
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      asn1$4.integerToDer(csr.version).getBytes()
    ),
    // subject
    _dnToAsn1(csr.subject),
    // SubjectPublicKeyInfo
    pki$2.publicKeyToAsn1(csr.publicKey),
    // attributes
    _CRIAttributesToAsn1(csr)
  ]);
  return cri;
};
pki$2.distinguishedNameToAsn1 = function(dn) {
  return _dnToAsn1(dn);
};
pki$2.certificateToAsn1 = function(cert) {
  var tbsCertificate = cert.tbsCertificate || pki$2.getTBSCertificate(cert);
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // TBSCertificate
    tbsCertificate,
    // AlgorithmIdentifier (signature algorithm)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      // algorithm
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(cert.signatureOid).getBytes()
      ),
      // parameters
      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
    ]),
    // SignatureValue
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      false,
      String.fromCharCode(0) + cert.signature
    )
  ]);
};
pki$2.certificateExtensionsToAsn1 = function(exts) {
  var rval = asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 3, true, []);
  var seq2 = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
  rval.value.push(seq2);
  for (var i = 0; i < exts.length; ++i) {
    seq2.value.push(pki$2.certificateExtensionToAsn1(exts[i]));
  }
  return rval;
};
pki$2.certificateExtensionToAsn1 = function(ext) {
  var extseq = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
  extseq.value.push(asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.OID,
    false,
    asn1$4.oidToDer(ext.id).getBytes()
  ));
  if (ext.critical) {
    extseq.value.push(asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BOOLEAN,
      false,
      String.fromCharCode(255)
    ));
  }
  var value = ext.value;
  if (typeof ext.value !== "string") {
    value = asn1$4.toDer(value).getBytes();
  }
  extseq.value.push(asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.OCTETSTRING,
    false,
    value
  ));
  return extseq;
};
pki$2.certificationRequestToAsn1 = function(csr) {
  var cri = csr.certificationRequestInfo || pki$2.getCertificationRequestInfo(csr);
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // CertificationRequestInfo
    cri,
    // AlgorithmIdentifier (signature algorithm)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      // algorithm
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(csr.signatureOid).getBytes()
      ),
      // parameters
      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
    ]),
    // signature
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      false,
      String.fromCharCode(0) + csr.signature
    )
  ]);
};
pki$2.createCaStore = function(certs) {
  var caStore = {
    // stored certificates
    certs: {}
  };
  caStore.getIssuer = function(cert2) {
    var rval = getBySubject(cert2.issuer);
    return rval;
  };
  caStore.addCertificate = function(cert2) {
    if (typeof cert2 === "string") {
      cert2 = forge$b.pki.certificateFromPem(cert2);
    }
    ensureSubjectHasHash(cert2.subject);
    if (!caStore.hasCertificate(cert2)) {
      if (cert2.subject.hash in caStore.certs) {
        var tmp = caStore.certs[cert2.subject.hash];
        if (!forge$b.util.isArray(tmp)) {
          tmp = [tmp];
        }
        tmp.push(cert2);
        caStore.certs[cert2.subject.hash] = tmp;
      } else {
        caStore.certs[cert2.subject.hash] = cert2;
      }
    }
  };
  caStore.hasCertificate = function(cert2) {
    if (typeof cert2 === "string") {
      cert2 = forge$b.pki.certificateFromPem(cert2);
    }
    var match2 = getBySubject(cert2.subject);
    if (!match2) {
      return false;
    }
    if (!forge$b.util.isArray(match2)) {
      match2 = [match2];
    }
    var der1 = asn1$4.toDer(pki$2.certificateToAsn1(cert2)).getBytes();
    for (var i2 = 0; i2 < match2.length; ++i2) {
      var der2 = asn1$4.toDer(pki$2.certificateToAsn1(match2[i2])).getBytes();
      if (der1 === der2) {
        return true;
      }
    }
    return false;
  };
  caStore.listAllCertificates = function() {
    var certList = [];
    for (var hash2 in caStore.certs) {
      if (caStore.certs.hasOwnProperty(hash2)) {
        var value = caStore.certs[hash2];
        if (!forge$b.util.isArray(value)) {
          certList.push(value);
        } else {
          for (var i2 = 0; i2 < value.length; ++i2) {
            certList.push(value[i2]);
          }
        }
      }
    }
    return certList;
  };
  caStore.removeCertificate = function(cert2) {
    var result;
    if (typeof cert2 === "string") {
      cert2 = forge$b.pki.certificateFromPem(cert2);
    }
    ensureSubjectHasHash(cert2.subject);
    if (!caStore.hasCertificate(cert2)) {
      return null;
    }
    var match2 = getBySubject(cert2.subject);
    if (!forge$b.util.isArray(match2)) {
      result = caStore.certs[cert2.subject.hash];
      delete caStore.certs[cert2.subject.hash];
      return result;
    }
    var der1 = asn1$4.toDer(pki$2.certificateToAsn1(cert2)).getBytes();
    for (var i2 = 0; i2 < match2.length; ++i2) {
      var der2 = asn1$4.toDer(pki$2.certificateToAsn1(match2[i2])).getBytes();
      if (der1 === der2) {
        result = match2[i2];
        match2.splice(i2, 1);
      }
    }
    if (match2.length === 0) {
      delete caStore.certs[cert2.subject.hash];
    }
    return result;
  };
  function getBySubject(subject) {
    ensureSubjectHasHash(subject);
    return caStore.certs[subject.hash] || null;
  }
  function ensureSubjectHasHash(subject) {
    if (!subject.hash) {
      var md = forge$b.md.sha1.create();
      subject.attributes = pki$2.RDNAttributesAsArray(_dnToAsn1(subject), md);
      subject.hash = md.digest().toHex();
    }
  }
  if (certs) {
    for (var i = 0; i < certs.length; ++i) {
      var cert = certs[i];
      caStore.addCertificate(cert);
    }
  }
  return caStore;
};
pki$2.certificateError = {
  bad_certificate: "forge.pki.BadCertificate",
  unsupported_certificate: "forge.pki.UnsupportedCertificate",
  certificate_revoked: "forge.pki.CertificateRevoked",
  certificate_expired: "forge.pki.CertificateExpired",
  certificate_unknown: "forge.pki.CertificateUnknown",
  unknown_ca: "forge.pki.UnknownCertificateAuthority"
};
pki$2.verifyCertificateChain = function(caStore, chain, options2) {
  if (typeof options2 === "function") {
    options2 = { verify: options2 };
  }
  options2 = options2 || {};
  chain = chain.slice(0);
  var certs = chain.slice(0);
  var validityCheckDate = options2.validityCheckDate;
  if (typeof validityCheckDate === "undefined") {
    validityCheckDate = /* @__PURE__ */ new Date();
  }
  var first2 = true;
  var error2 = null;
  var depth = 0;
  do {
    var cert = chain.shift();
    var parent = null;
    var selfSigned = false;
    if (validityCheckDate) {
      if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
        error2 = {
          message: "Certificate is not valid yet or has expired.",
          error: pki$2.certificateError.certificate_expired,
          notBefore: cert.validity.notBefore,
          notAfter: cert.validity.notAfter,
          // TODO: we might want to reconsider renaming 'now' to
          // 'validityCheckDate' should this API be changed in the future.
          now: validityCheckDate
        };
      }
    }
    if (error2 === null) {
      parent = chain[0] || caStore.getIssuer(cert);
      if (parent === null) {
        if (cert.isIssuer(cert)) {
          selfSigned = true;
          parent = cert;
        }
      }
      if (parent) {
        var parents = parent;
        if (!forge$b.util.isArray(parents)) {
          parents = [parents];
        }
        var verified = false;
        while (!verified && parents.length > 0) {
          parent = parents.shift();
          try {
            verified = parent.verify(cert);
          } catch (ex) {
          }
        }
        if (!verified) {
          error2 = {
            message: "Certificate signature is invalid.",
            error: pki$2.certificateError.bad_certificate
          };
        }
      }
      if (error2 === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
        error2 = {
          message: "Certificate is not trusted.",
          error: pki$2.certificateError.unknown_ca
        };
      }
    }
    if (error2 === null && parent && !cert.isIssuer(parent)) {
      error2 = {
        message: "Certificate issuer is invalid.",
        error: pki$2.certificateError.bad_certificate
      };
    }
    if (error2 === null) {
      var se = {
        keyUsage: true,
        basicConstraints: true
      };
      for (var i = 0; error2 === null && i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        if (ext.critical && !(ext.name in se)) {
          error2 = {
            message: "Certificate has an unsupported critical extension.",
            error: pki$2.certificateError.unsupported_certificate
          };
        }
      }
    }
    if (error2 === null && (!first2 || chain.length === 0 && (!parent || selfSigned))) {
      var bcExt = cert.getExtension("basicConstraints");
      var keyUsageExt = cert.getExtension("keyUsage");
      if (keyUsageExt !== null) {
        if (!keyUsageExt.keyCertSign || bcExt === null) {
          error2 = {
            message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
            error: pki$2.certificateError.bad_certificate
          };
        }
      }
      if (error2 === null && bcExt !== null && !bcExt.cA) {
        error2 = {
          message: "Certificate basicConstraints indicates the certificate is not a CA.",
          error: pki$2.certificateError.bad_certificate
        };
      }
      if (error2 === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
        var pathLen = depth - 1;
        if (pathLen > bcExt.pathLenConstraint) {
          error2 = {
            message: "Certificate basicConstraints pathLenConstraint violated.",
            error: pki$2.certificateError.bad_certificate
          };
        }
      }
    }
    var vfd = error2 === null ? true : error2.error;
    var ret = options2.verify ? options2.verify(vfd, depth, certs) : vfd;
    if (ret === true) {
      error2 = null;
    } else {
      if (vfd === true) {
        error2 = {
          message: "The application rejected the certificate.",
          error: pki$2.certificateError.bad_certificate
        };
      }
      if (ret || ret === 0) {
        if (typeof ret === "object" && !forge$b.util.isArray(ret)) {
          if (ret.message) {
            error2.message = ret.message;
          }
          if (ret.error) {
            error2.error = ret.error;
          }
        } else if (typeof ret === "string") {
          error2.error = ret;
        }
      }
      throw error2;
    }
    first2 = false;
    ++depth;
  } while (chain.length > 0);
  return true;
};
var forge$a = forge$C;
var asn1$3 = forge$a.asn1;
var pki$1 = forge$a.pki;
var p12 = forge$a.pkcs12 = forge$a.pkcs12 || {};
var contentInfoValidator = {
  name: "ContentInfo",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  // a ContentInfo
  constructed: true,
  value: [{
    name: "ContentInfo.contentType",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: false,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
    constructed: true,
    captureAsn1: "content"
  }]
};
var pfxValidator = {
  name: "PFX",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [
    {
      name: "PFX.version",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.INTEGER,
      constructed: false,
      capture: "version"
    },
    contentInfoValidator,
    {
      name: "PFX.macData",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      optional: true,
      captureAsn1: "mac",
      value: [{
        name: "PFX.macData.mac",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        // DigestInfo
        constructed: true,
        value: [{
          name: "PFX.macData.mac.digestAlgorithm",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.SEQUENCE,
          // DigestAlgorithmIdentifier
          constructed: true,
          value: [{
            name: "PFX.macData.mac.digestAlgorithm.algorithm",
            tagClass: asn1$3.Class.UNIVERSAL,
            type: asn1$3.Type.OID,
            constructed: false,
            capture: "macAlgorithm"
          }, {
            name: "PFX.macData.mac.digestAlgorithm.parameters",
            optional: true,
            tagClass: asn1$3.Class.UNIVERSAL,
            captureAsn1: "macAlgorithmParameters"
          }]
        }, {
          name: "PFX.macData.mac.digest",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.OCTETSTRING,
          constructed: false,
          capture: "macDigest"
        }]
      }, {
        name: "PFX.macData.macSalt",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OCTETSTRING,
        constructed: false,
        capture: "macSalt"
      }, {
        name: "PFX.macData.iterations",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.INTEGER,
        constructed: false,
        optional: true,
        capture: "macIterations"
      }]
    }
  ]
};
var safeBagValidator = {
  name: "SafeBag",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "SafeBag.bagId",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: false,
    capture: "bagId"
  }, {
    name: "SafeBag.bagValue",
    tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
    constructed: true,
    captureAsn1: "bagValue"
  }, {
    name: "SafeBag.bagAttributes",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.SET,
    constructed: true,
    optional: true,
    capture: "bagAttributes"
  }]
};
var attributeValidator = {
  name: "Attribute",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "Attribute.attrId",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: false,
    capture: "oid"
  }, {
    name: "Attribute.attrValues",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.SET,
    constructed: true,
    capture: "values"
  }]
};
var certBagValidator = {
  name: "CertBag",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "CertBag.certId",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: false,
    capture: "certId"
  }, {
    name: "CertBag.certValue",
    tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
    constructed: true,
    /* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */
    value: [{
      name: "CertBag.certValue[0]",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Class.OCTETSTRING,
      constructed: false,
      capture: "cert"
    }]
  }]
};
function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
  var result = [];
  for (var i = 0; i < safeContents.length; i++) {
    for (var j = 0; j < safeContents[i].safeBags.length; j++) {
      var bag = safeContents[i].safeBags[j];
      if (bagType !== void 0 && bag.type !== bagType) {
        continue;
      }
      if (attrName === null) {
        result.push(bag);
        continue;
      }
      if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
        result.push(bag);
      }
    }
  }
  return result;
}
p12.pkcs12FromAsn1 = function(obj, strict, password) {
  if (typeof strict === "string") {
    password = strict;
    strict = true;
  } else if (strict === void 0) {
    strict = true;
  }
  var capture = {};
  var errors2 = [];
  if (!asn1$3.validate(obj, pfxValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
    error2.errors = error2;
    throw error2;
  }
  var pfx = {
    version: capture.version.charCodeAt(0),
    safeContents: [],
    /**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */
    getBags: function(filter2) {
      var rval = {};
      var localKeyId;
      if ("localKeyId" in filter2) {
        localKeyId = filter2.localKeyId;
      } else if ("localKeyIdHex" in filter2) {
        localKeyId = forge$a.util.hexToBytes(filter2.localKeyIdHex);
      }
      if (localKeyId === void 0 && !("friendlyName" in filter2) && "bagType" in filter2) {
        rval[filter2.bagType] = _getBagsByAttribute(
          pfx.safeContents,
          null,
          null,
          filter2.bagType
        );
      }
      if (localKeyId !== void 0) {
        rval.localKeyId = _getBagsByAttribute(
          pfx.safeContents,
          "localKeyId",
          localKeyId,
          filter2.bagType
        );
      }
      if ("friendlyName" in filter2) {
        rval.friendlyName = _getBagsByAttribute(
          pfx.safeContents,
          "friendlyName",
          filter2.friendlyName,
          filter2.bagType
        );
      }
      return rval;
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */
    getBagsByFriendlyName: function(friendlyName, bagType) {
      return _getBagsByAttribute(
        pfx.safeContents,
        "friendlyName",
        friendlyName,
        bagType
      );
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */
    getBagsByLocalKeyId: function(localKeyId, bagType) {
      return _getBagsByAttribute(
        pfx.safeContents,
        "localKeyId",
        localKeyId,
        bagType
      );
    }
  };
  if (capture.version.charCodeAt(0) !== 3) {
    var error2 = new Error("PKCS#12 PFX of version other than 3 not supported.");
    error2.version = capture.version.charCodeAt(0);
    throw error2;
  }
  if (asn1$3.derToOid(capture.contentType) !== pki$1.oids.data) {
    var error2 = new Error("Only PKCS#12 PFX in password integrity mode supported.");
    error2.oid = asn1$3.derToOid(capture.contentType);
    throw error2;
  }
  var data = capture.content.value[0];
  if (data.tagClass !== asn1$3.Class.UNIVERSAL || data.type !== asn1$3.Type.OCTETSTRING) {
    throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
  }
  data = _decodePkcs7Data(data);
  if (capture.mac) {
    var md = null;
    var macKeyBytes = 0;
    var macAlgorithm = asn1$3.derToOid(capture.macAlgorithm);
    switch (macAlgorithm) {
      case pki$1.oids.sha1:
        md = forge$a.md.sha1.create();
        macKeyBytes = 20;
        break;
      case pki$1.oids.sha256:
        md = forge$a.md.sha256.create();
        macKeyBytes = 32;
        break;
      case pki$1.oids.sha384:
        md = forge$a.md.sha384.create();
        macKeyBytes = 48;
        break;
      case pki$1.oids.sha512:
        md = forge$a.md.sha512.create();
        macKeyBytes = 64;
        break;
      case pki$1.oids.md5:
        md = forge$a.md.md5.create();
        macKeyBytes = 16;
        break;
    }
    if (md === null) {
      throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
    }
    var macSalt = new forge$a.util.ByteBuffer(capture.macSalt);
    var macIterations = "macIterations" in capture ? parseInt(forge$a.util.bytesToHex(capture.macIterations), 16) : 1;
    var macKey = p12.generateKey(
      password,
      macSalt,
      3,
      macIterations,
      macKeyBytes,
      md
    );
    var mac = forge$a.hmac.create();
    mac.start(md, macKey);
    mac.update(data.value);
    var macValue = mac.getMac();
    if (macValue.getBytes() !== capture.macDigest) {
      throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
    }
  } else if (Array.isArray(obj.value) && obj.value.length > 2) {
    throw new Error("Invalid PKCS#12. macData field present but MAC was not validated.");
  }
  _decodeAuthenticatedSafe(pfx, data.value, strict, password);
  return pfx;
};
function _decodePkcs7Data(data) {
  if (data.composed || data.constructed) {
    var value = forge$a.util.createBuffer();
    for (var i = 0; i < data.value.length; ++i) {
      value.putBytes(data.value[i].value);
    }
    data.composed = data.constructed = false;
    data.value = value.getBytes();
  }
  return data;
}
function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
  authSafe = asn1$3.fromDer(authSafe, strict);
  if (authSafe.tagClass !== asn1$3.Class.UNIVERSAL || authSafe.type !== asn1$3.Type.SEQUENCE || authSafe.constructed !== true) {
    throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
  }
  for (var i = 0; i < authSafe.value.length; i++) {
    var contentInfo = authSafe.value[i];
    var capture = {};
    var errors2 = [];
    if (!asn1$3.validate(contentInfo, contentInfoValidator, capture, errors2)) {
      var error2 = new Error("Cannot read ContentInfo.");
      error2.errors = errors2;
      throw error2;
    }
    var obj = {
      encrypted: false
    };
    var safeContents = null;
    var data = capture.content.value[0];
    switch (asn1$3.derToOid(capture.contentType)) {
      case pki$1.oids.data:
        if (data.tagClass !== asn1$3.Class.UNIVERSAL || data.type !== asn1$3.Type.OCTETSTRING) {
          throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
        }
        safeContents = _decodePkcs7Data(data).value;
        break;
      case pki$1.oids.encryptedData:
        safeContents = _decryptSafeContents(data, password);
        obj.encrypted = true;
        break;
      default:
        var error2 = new Error("Unsupported PKCS#12 contentType.");
        error2.contentType = asn1$3.derToOid(capture.contentType);
        throw error2;
    }
    obj.safeBags = _decodeSafeContents(safeContents, strict, password);
    pfx.safeContents.push(obj);
  }
}
function _decryptSafeContents(data, password) {
  var capture = {};
  var errors2 = [];
  if (!asn1$3.validate(
    data,
    forge$a.pkcs7.asn1.encryptedDataValidator,
    capture,
    errors2
  )) {
    var error2 = new Error("Cannot read EncryptedContentInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$3.derToOid(capture.contentType);
  if (oid !== pki$1.oids.data) {
    var error2 = new Error(
      "PKCS#12 EncryptedContentInfo ContentType is not Data."
    );
    error2.oid = oid;
    throw error2;
  }
  oid = asn1$3.derToOid(capture.encAlgorithm);
  var cipher = pki$1.pbe.getCipher(oid, capture.encParameter, password);
  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
  var encrypted = forge$a.util.createBuffer(encryptedContentAsn1.value);
  cipher.update(encrypted);
  if (!cipher.finish()) {
    throw new Error("Failed to decrypt PKCS#12 SafeContents.");
  }
  return cipher.output.getBytes();
}
function _decodeSafeContents(safeContents, strict, password) {
  if (!strict && safeContents.length === 0) {
    return [];
  }
  safeContents = asn1$3.fromDer(safeContents, strict);
  if (safeContents.tagClass !== asn1$3.Class.UNIVERSAL || safeContents.type !== asn1$3.Type.SEQUENCE || safeContents.constructed !== true) {
    throw new Error(
      "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
    );
  }
  var res2 = [];
  for (var i = 0; i < safeContents.value.length; i++) {
    var safeBag = safeContents.value[i];
    var capture = {};
    var errors2 = [];
    if (!asn1$3.validate(safeBag, safeBagValidator, capture, errors2)) {
      var error2 = new Error("Cannot read SafeBag.");
      error2.errors = errors2;
      throw error2;
    }
    var bag = {
      type: asn1$3.derToOid(capture.bagId),
      attributes: _decodeBagAttributes(capture.bagAttributes)
    };
    res2.push(bag);
    var validator, decoder;
    var bagAsn1 = capture.bagValue.value[0];
    switch (bag.type) {
      case pki$1.oids.pkcs8ShroudedKeyBag:
        bagAsn1 = pki$1.decryptPrivateKeyInfo(bagAsn1, password);
        if (bagAsn1 === null) {
          throw new Error(
            "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
          );
        }
      case pki$1.oids.keyBag:
        try {
          bag.key = pki$1.privateKeyFromAsn1(bagAsn1);
        } catch (e) {
          bag.key = null;
          bag.asn1 = bagAsn1;
        }
        continue;
      case pki$1.oids.certBag:
        validator = certBagValidator;
        decoder = function() {
          if (asn1$3.derToOid(capture.certId) !== pki$1.oids.x509Certificate) {
            var error3 = new Error(
              "Unsupported certificate type, only X.509 supported."
            );
            error3.oid = asn1$3.derToOid(capture.certId);
            throw error3;
          }
          var certAsn1 = asn1$3.fromDer(capture.cert, strict);
          try {
            bag.cert = pki$1.certificateFromAsn1(certAsn1, true);
          } catch (e) {
            bag.cert = null;
            bag.asn1 = certAsn1;
          }
        };
        break;
      default:
        var error2 = new Error("Unsupported PKCS#12 SafeBag type.");
        error2.oid = bag.type;
        throw error2;
    }
    if (validator !== void 0 && !asn1$3.validate(bagAsn1, validator, capture, errors2)) {
      var error2 = new Error("Cannot read PKCS#12 " + validator.name);
      error2.errors = errors2;
      throw error2;
    }
    decoder();
  }
  return res2;
}
function _decodeBagAttributes(attributes) {
  var decodedAttrs = {};
  if (attributes !== void 0) {
    for (var i = 0; i < attributes.length; ++i) {
      var capture = {};
      var errors2 = [];
      if (!asn1$3.validate(attributes[i], attributeValidator, capture, errors2)) {
        var error2 = new Error("Cannot read PKCS#12 BagAttribute.");
        error2.errors = errors2;
        throw error2;
      }
      var oid = asn1$3.derToOid(capture.oid);
      if (pki$1.oids[oid] === void 0) {
        continue;
      }
      decodedAttrs[pki$1.oids[oid]] = [];
      for (var j = 0; j < capture.values.length; ++j) {
        decodedAttrs[pki$1.oids[oid]].push(capture.values[j].value);
      }
    }
  }
  return decodedAttrs;
}
p12.toPkcs12Asn1 = function(key, cert, password, options2) {
  options2 = options2 || {};
  options2.saltSize = options2.saltSize || 8;
  options2.count = options2.count || 2048;
  options2.algorithm = options2.algorithm || options2.encAlgorithm || "aes128";
  if (!("useMac" in options2)) {
    options2.useMac = true;
  }
  if (!("localKeyId" in options2)) {
    options2.localKeyId = null;
  }
  if (!("generateLocalKeyId" in options2)) {
    options2.generateLocalKeyId = true;
  }
  var localKeyId = options2.localKeyId;
  var bagAttrs;
  if (localKeyId !== null) {
    localKeyId = forge$a.util.hexToBytes(localKeyId);
  } else if (options2.generateLocalKeyId) {
    if (cert) {
      var pairedCert = forge$a.util.isArray(cert) ? cert[0] : cert;
      if (typeof pairedCert === "string") {
        pairedCert = pki$1.certificateFromPem(pairedCert);
      }
      var sha12 = forge$a.md.sha1.create();
      sha12.update(asn1$3.toDer(pki$1.certificateToAsn1(pairedCert)).getBytes());
      localKeyId = sha12.digest().getBytes();
    } else {
      localKeyId = forge$a.random.getBytes(20);
    }
  }
  var attrs = [];
  if (localKeyId !== null) {
    attrs.push(
      // localKeyID
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // attrId
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(pki$1.oids.localKeyId).getBytes()
        ),
        // attrValues
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, true, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OCTETSTRING,
            false,
            localKeyId
          )
        ])
      ])
    );
  }
  if ("friendlyName" in options2) {
    attrs.push(
      // friendlyName
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // attrId
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(pki$1.oids.friendlyName).getBytes()
        ),
        // attrValues
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, true, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.BMPSTRING,
            false,
            options2.friendlyName
          )
        ])
      ])
    );
  }
  if (attrs.length > 0) {
    bagAttrs = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, true, attrs);
  }
  var contents = [];
  var chain = [];
  if (cert !== null) {
    if (forge$a.util.isArray(cert)) {
      chain = cert;
    } else {
      chain = [cert];
    }
  }
  var certSafeBags = [];
  for (var i = 0; i < chain.length; ++i) {
    cert = chain[i];
    if (typeof cert === "string") {
      cert = pki$1.certificateFromPem(cert);
    }
    var certBagAttrs = i === 0 ? bagAttrs : void 0;
    var certAsn1 = pki$1.certificateToAsn1(cert);
    var certSafeBag = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
      // bagId
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        false,
        asn1$3.oidToDer(pki$1.oids.certBag).getBytes()
      ),
      // bagValue
      asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
        // CertBag
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          // certId
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OID,
            false,
            asn1$3.oidToDer(pki$1.oids.x509Certificate).getBytes()
          ),
          // certValue (x509Certificate)
          asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$3.create(
              asn1$3.Class.UNIVERSAL,
              asn1$3.Type.OCTETSTRING,
              false,
              asn1$3.toDer(certAsn1).getBytes()
            )
          ])
        ])
      ]),
      // bagAttributes (OPTIONAL)
      certBagAttrs
    ]);
    certSafeBags.push(certSafeBag);
  }
  if (certSafeBags.length > 0) {
    var certSafeContents = asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.SEQUENCE,
      true,
      certSafeBags
    );
    var certCI = (
      // PKCS#7 ContentInfo
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // contentType
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          // OID for the content type is 'data'
          asn1$3.oidToDer(pki$1.oids.data).getBytes()
        ),
        // content
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OCTETSTRING,
            false,
            asn1$3.toDer(certSafeContents).getBytes()
          )
        ])
      ])
    );
    contents.push(certCI);
  }
  var keyBag = null;
  if (key !== null) {
    var pkAsn1 = pki$1.wrapRsaPrivateKey(pki$1.privateKeyToAsn1(key));
    if (password === null) {
      keyBag = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // bagId
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(pki$1.oids.keyBag).getBytes()
        ),
        // bagValue
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
          // PrivateKeyInfo
          pkAsn1
        ]),
        // bagAttributes (OPTIONAL)
        bagAttrs
      ]);
    } else {
      keyBag = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // bagId
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(pki$1.oids.pkcs8ShroudedKeyBag).getBytes()
        ),
        // bagValue
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
          // EncryptedPrivateKeyInfo
          pki$1.encryptPrivateKeyInfo(pkAsn1, password, options2)
        ]),
        // bagAttributes (OPTIONAL)
        bagAttrs
      ]);
    }
    var keySafeContents = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [keyBag]);
    var keyCI = (
      // PKCS#7 ContentInfo
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // contentType
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          // OID for the content type is 'data'
          asn1$3.oidToDer(pki$1.oids.data).getBytes()
        ),
        // content
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OCTETSTRING,
            false,
            asn1$3.toDer(keySafeContents).getBytes()
          )
        ])
      ])
    );
    contents.push(keyCI);
  }
  var safe = asn1$3.create(
    asn1$3.Class.UNIVERSAL,
    asn1$3.Type.SEQUENCE,
    true,
    contents
  );
  var macData;
  if (options2.useMac) {
    var sha12 = forge$a.md.sha1.create();
    var macSalt = new forge$a.util.ByteBuffer(
      forge$a.random.getBytes(options2.saltSize)
    );
    var count = options2.count;
    var key = p12.generateKey(password, macSalt, 3, count, 20);
    var mac = forge$a.hmac.create();
    mac.start(sha12, key);
    mac.update(asn1$3.toDer(safe).getBytes());
    var macValue = mac.getMac();
    macData = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
      // mac DigestInfo
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // digestAlgorithm
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          // algorithm = SHA-1
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OID,
            false,
            asn1$3.oidToDer(pki$1.oids.sha1).getBytes()
          ),
          // parameters = Null
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.NULL, false, "")
        ]),
        // digest
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OCTETSTRING,
          false,
          macValue.getBytes()
        )
      ]),
      // macSalt OCTET STRING
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OCTETSTRING,
        false,
        macSalt.getBytes()
      ),
      // iterations INTEGER (XXX: Only support count < 65536)
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.INTEGER,
        false,
        asn1$3.integerToDer(count).getBytes()
      )
    ]);
  }
  return asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
    // version (3)
    asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.INTEGER,
      false,
      asn1$3.integerToDer(3).getBytes()
    ),
    // PKCS#7 ContentInfo
    asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
      // contentType
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        false,
        // OID for the content type is 'data'
        asn1$3.oidToDer(pki$1.oids.data).getBytes()
      ),
      // content
      asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OCTETSTRING,
          false,
          asn1$3.toDer(safe).getBytes()
        )
      ])
    ]),
    macData
  ]);
};
p12.generateKey = forge$a.pbe.generatePkcs12Key;
var forge$9 = forge$C;
var asn1$2 = forge$9.asn1;
var pki = forge$9.pki = forge$9.pki || {};
pki.pemToDer = function(pem2) {
  var msg = forge$9.pem.decode(pem2)[0];
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert PEM to DER; PEM is encrypted.");
  }
  return forge$9.util.createBuffer(msg.body);
};
pki.privateKeyFromPem = function(pem2) {
  var msg = forge$9.pem.decode(pem2)[0];
  if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
    var error2 = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert private key from PEM; PEM is encrypted.");
  }
  var obj = asn1$2.fromDer(msg.body);
  return pki.privateKeyFromAsn1(obj);
};
pki.privateKeyToPem = function(key, maxline) {
  var msg = {
    type: "RSA PRIVATE KEY",
    body: asn1$2.toDer(pki.privateKeyToAsn1(key)).getBytes()
  };
  return forge$9.pem.encode(msg, { maxline });
};
pki.privateKeyInfoToPem = function(pki2, maxline) {
  var msg = {
    type: "PRIVATE KEY",
    body: asn1$2.toDer(pki2).getBytes()
  };
  return forge$9.pem.encode(msg, { maxline });
};
var forge$8 = forge$C;
var prf_TLS1 = function(secret, label, seed, length) {
  var rval = forge$8.util.createBuffer();
  var idx = secret.length >> 1;
  var slen = idx + (secret.length & 1);
  var s1 = secret.substr(0, slen);
  var s2 = secret.substr(idx, slen);
  var ai = forge$8.util.createBuffer();
  var hmac2 = forge$8.hmac.create();
  seed = label + seed;
  var md5itr = Math.ceil(length / 16);
  var sha1itr = Math.ceil(length / 20);
  hmac2.start("MD5", s1);
  var md5bytes = forge$8.util.createBuffer();
  ai.putBytes(seed);
  for (var i = 0; i < md5itr; ++i) {
    hmac2.start(null, null);
    hmac2.update(ai.getBytes());
    ai.putBuffer(hmac2.digest());
    hmac2.start(null, null);
    hmac2.update(ai.bytes() + seed);
    md5bytes.putBuffer(hmac2.digest());
  }
  hmac2.start("SHA1", s2);
  var sha1bytes = forge$8.util.createBuffer();
  ai.clear();
  ai.putBytes(seed);
  for (var i = 0; i < sha1itr; ++i) {
    hmac2.start(null, null);
    hmac2.update(ai.getBytes());
    ai.putBuffer(hmac2.digest());
    hmac2.start(null, null);
    hmac2.update(ai.bytes() + seed);
    sha1bytes.putBuffer(hmac2.digest());
  }
  rval.putBytes(forge$8.util.xorBytes(
    md5bytes.getBytes(),
    sha1bytes.getBytes(),
    length
  ));
  return rval;
};
var hmac_sha1 = function(key, seqNum, record) {
  var hmac2 = forge$8.hmac.create();
  hmac2.start("SHA1", key);
  var b = forge$8.util.createBuffer();
  b.putInt32(seqNum[0]);
  b.putInt32(seqNum[1]);
  b.putByte(record.type);
  b.putByte(record.version.major);
  b.putByte(record.version.minor);
  b.putInt16(record.length);
  b.putBytes(record.fragment.bytes());
  hmac2.update(b.getBytes());
  return hmac2.digest().getBytes();
};
var deflate = function(c, record, s2) {
  var rval = false;
  try {
    var bytes2 = c.deflate(record.fragment.getBytes());
    record.fragment = forge$8.util.createBuffer(bytes2);
    record.length = bytes2.length;
    rval = true;
  } catch (ex) {
  }
  return rval;
};
var inflate = function(c, record, s2) {
  var rval = false;
  try {
    var bytes2 = c.inflate(record.fragment.getBytes());
    record.fragment = forge$8.util.createBuffer(bytes2);
    record.length = bytes2.length;
    rval = true;
  } catch (ex) {
  }
  return rval;
};
var readVector = function(b, lenBytes) {
  var len = 0;
  switch (lenBytes) {
    case 1:
      len = b.getByte();
      break;
    case 2:
      len = b.getInt16();
      break;
    case 3:
      len = b.getInt24();
      break;
    case 4:
      len = b.getInt32();
      break;
  }
  return forge$8.util.createBuffer(b.getBytes(len));
};
var writeVector = function(b, lenBytes, v) {
  b.putInt(v.length(), lenBytes << 3);
  b.putBuffer(v);
};
var tls$1 = {};
tls$1.Versions = {
  TLS_1_0: { major: 3, minor: 1 },
  TLS_1_1: { major: 3, minor: 2 },
  TLS_1_2: { major: 3, minor: 3 }
};
tls$1.SupportedVersions = [
  tls$1.Versions.TLS_1_1,
  tls$1.Versions.TLS_1_0
];
tls$1.Version = tls$1.SupportedVersions[0];
tls$1.MaxFragment = 16384 - 1024;
tls$1.ConnectionEnd = {
  server: 0,
  client: 1
};
tls$1.PRFAlgorithm = {
  tls_prf_sha256: 0
};
tls$1.BulkCipherAlgorithm = {
  none: null,
  rc4: 0,
  des3: 1,
  aes: 2
};
tls$1.CipherType = {
  stream: 0,
  block: 1,
  aead: 2
};
tls$1.MACAlgorithm = {
  none: null,
  hmac_md5: 0,
  hmac_sha1: 1,
  hmac_sha256: 2,
  hmac_sha384: 3,
  hmac_sha512: 4
};
tls$1.CompressionMethod = {
  none: 0,
  deflate: 1
};
tls$1.ContentType = {
  change_cipher_spec: 20,
  alert: 21,
  handshake: 22,
  application_data: 23,
  heartbeat: 24
};
tls$1.HandshakeType = {
  hello_request: 0,
  client_hello: 1,
  server_hello: 2,
  certificate: 11,
  server_key_exchange: 12,
  certificate_request: 13,
  server_hello_done: 14,
  certificate_verify: 15,
  client_key_exchange: 16,
  finished: 20
};
tls$1.Alert = {};
tls$1.Alert.Level = {
  warning: 1,
  fatal: 2
};
tls$1.Alert.Description = {
  close_notify: 0,
  unexpected_message: 10,
  bad_record_mac: 20,
  decryption_failed: 21,
  record_overflow: 22,
  decompression_failure: 30,
  handshake_failure: 40,
  bad_certificate: 42,
  unsupported_certificate: 43,
  certificate_revoked: 44,
  certificate_expired: 45,
  certificate_unknown: 46,
  illegal_parameter: 47,
  unknown_ca: 48,
  access_denied: 49,
  decode_error: 50,
  decrypt_error: 51,
  export_restriction: 60,
  protocol_version: 70,
  insufficient_security: 71,
  internal_error: 80,
  user_canceled: 90,
  no_renegotiation: 100
};
tls$1.HeartbeatMessageType = {
  heartbeat_request: 1,
  heartbeat_response: 2
};
tls$1.CipherSuites = {};
tls$1.getCipherSuite = function(twoBytes) {
  var rval = null;
  for (var key in tls$1.CipherSuites) {
    var cs = tls$1.CipherSuites[key];
    if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
      rval = cs;
      break;
    }
  }
  return rval;
};
tls$1.handleUnexpected = function(c, record) {
  var ignore = !c.open && c.entity === tls$1.ConnectionEnd.client;
  if (!ignore) {
    c.error(c, {
      message: "Unexpected message. Received TLS record out of order.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.unexpected_message
      }
    });
  }
};
tls$1.handleHelloRequest = function(c, record, length) {
  if (!c.handshaking && c.handshakes > 0) {
    tls$1.queue(c, tls$1.createAlert(c, {
      level: tls$1.Alert.Level.warning,
      description: tls$1.Alert.Description.no_renegotiation
    }));
    tls$1.flush(c);
  }
  c.process();
};
tls$1.parseHelloMessage = function(c, record, length) {
  var msg = null;
  var client2 = c.entity === tls$1.ConnectionEnd.client;
  if (length < 38) {
    c.error(c, {
      message: client2 ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  } else {
    var b = record.fragment;
    var remaining = b.length();
    msg = {
      version: {
        major: b.getByte(),
        minor: b.getByte()
      },
      random: forge$8.util.createBuffer(b.getBytes(32)),
      session_id: readVector(b, 1),
      extensions: []
    };
    if (client2) {
      msg.cipher_suite = b.getBytes(2);
      msg.compression_method = b.getByte();
    } else {
      msg.cipher_suites = readVector(b, 2);
      msg.compression_methods = readVector(b, 1);
    }
    remaining = length - (remaining - b.length());
    if (remaining > 0) {
      var exts = readVector(b, 2);
      while (exts.length() > 0) {
        msg.extensions.push({
          type: [exts.getByte(), exts.getByte()],
          data: readVector(exts, 2)
        });
      }
      if (!client2) {
        for (var i = 0; i < msg.extensions.length; ++i) {
          var ext = msg.extensions[i];
          if (ext.type[0] === 0 && ext.type[1] === 0) {
            var snl = readVector(ext.data, 2);
            while (snl.length() > 0) {
              var snType = snl.getByte();
              if (snType !== 0) {
                break;
              }
              c.session.extensions.server_name.serverNameList.push(
                readVector(snl, 2).getBytes()
              );
            }
          }
        }
      }
    }
    if (c.session.version) {
      if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
        return c.error(c, {
          message: "TLS version change is disallowed during renegotiation.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.protocol_version
          }
        });
      }
    }
    if (client2) {
      c.session.cipherSuite = tls$1.getCipherSuite(msg.cipher_suite);
    } else {
      var tmp = forge$8.util.createBuffer(msg.cipher_suites.bytes());
      while (tmp.length() > 0) {
        c.session.cipherSuite = tls$1.getCipherSuite(tmp.getBytes(2));
        if (c.session.cipherSuite !== null) {
          break;
        }
      }
    }
    if (c.session.cipherSuite === null) {
      return c.error(c, {
        message: "No cipher suites in common.",
        send: true,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.handshake_failure
        },
        cipherSuite: forge$8.util.bytesToHex(msg.cipher_suite)
      });
    }
    if (client2) {
      c.session.compressionMethod = msg.compression_method;
    } else {
      c.session.compressionMethod = tls$1.CompressionMethod.none;
    }
  }
  return msg;
};
tls$1.createSecurityParameters = function(c, msg) {
  var client2 = c.entity === tls$1.ConnectionEnd.client;
  var msgRandom = msg.random.bytes();
  var cRandom = client2 ? c.session.sp.client_random : msgRandom;
  var sRandom = client2 ? msgRandom : tls$1.createRandom().getBytes();
  c.session.sp = {
    entity: c.entity,
    prf_algorithm: tls$1.PRFAlgorithm.tls_prf_sha256,
    bulk_cipher_algorithm: null,
    cipher_type: null,
    enc_key_length: null,
    block_length: null,
    fixed_iv_length: null,
    record_iv_length: null,
    mac_algorithm: null,
    mac_length: null,
    mac_key_length: null,
    compression_algorithm: c.session.compressionMethod,
    pre_master_secret: null,
    master_secret: null,
    client_random: cRandom,
    server_random: sRandom
  };
};
tls$1.handleServerHello = function(c, record, length) {
  var msg = tls$1.parseHelloMessage(c, record, length);
  if (c.fail) {
    return;
  }
  if (msg.version.minor <= c.version.minor) {
    c.version.minor = msg.version.minor;
  } else {
    return c.error(c, {
      message: "Incompatible TLS version.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.protocol_version
      }
    });
  }
  c.session.version = c.version;
  var sessionId = msg.session_id.bytes();
  if (sessionId.length > 0 && sessionId === c.session.id) {
    c.expect = SCC;
    c.session.resuming = true;
    c.session.sp.server_random = msg.random.bytes();
  } else {
    c.expect = SCE;
    c.session.resuming = false;
    tls$1.createSecurityParameters(c, msg);
  }
  c.session.id = sessionId;
  c.process();
};
tls$1.handleClientHello = function(c, record, length) {
  var msg = tls$1.parseHelloMessage(c, record, length);
  if (c.fail) {
    return;
  }
  var sessionId = msg.session_id.bytes();
  var session = null;
  if (c.sessionCache) {
    session = c.sessionCache.getSession(sessionId);
    if (session === null) {
      sessionId = "";
    } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
      session = null;
      sessionId = "";
    }
  }
  if (sessionId.length === 0) {
    sessionId = forge$8.random.getBytes(32);
  }
  c.session.id = sessionId;
  c.session.clientHelloVersion = msg.version;
  c.session.sp = {};
  if (session) {
    c.version = c.session.version = session.version;
    c.session.sp = session.sp;
  } else {
    var version2;
    for (var i = 1; i < tls$1.SupportedVersions.length; ++i) {
      version2 = tls$1.SupportedVersions[i];
      if (version2.minor <= msg.version.minor) {
        break;
      }
    }
    c.version = { major: version2.major, minor: version2.minor };
    c.session.version = c.version;
  }
  if (session !== null) {
    c.expect = CCC;
    c.session.resuming = true;
    c.session.sp.client_random = msg.random.bytes();
  } else {
    c.expect = c.verifyClient !== false ? CCE : CKE;
    c.session.resuming = false;
    tls$1.createSecurityParameters(c, msg);
  }
  c.open = true;
  tls$1.queue(c, tls$1.createRecord(c, {
    type: tls$1.ContentType.handshake,
    data: tls$1.createServerHello(c)
  }));
  if (c.session.resuming) {
    tls$1.queue(c, tls$1.createRecord(c, {
      type: tls$1.ContentType.change_cipher_spec,
      data: tls$1.createChangeCipherSpec()
    }));
    c.state.pending = tls$1.createConnectionState(c);
    c.state.current.write = c.state.pending.write;
    tls$1.queue(c, tls$1.createRecord(c, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createFinished(c)
    }));
  } else {
    tls$1.queue(c, tls$1.createRecord(c, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createCertificate(c)
    }));
    if (!c.fail) {
      tls$1.queue(c, tls$1.createRecord(c, {
        type: tls$1.ContentType.handshake,
        data: tls$1.createServerKeyExchange(c)
      }));
      if (c.verifyClient !== false) {
        tls$1.queue(c, tls$1.createRecord(c, {
          type: tls$1.ContentType.handshake,
          data: tls$1.createCertificateRequest(c)
        }));
      }
      tls$1.queue(c, tls$1.createRecord(c, {
        type: tls$1.ContentType.handshake,
        data: tls$1.createServerHelloDone(c)
      }));
    }
  }
  tls$1.flush(c);
  c.process();
};
tls$1.handleCertificate = function(c, record, length) {
  if (length < 3) {
    return c.error(c, {
      message: "Invalid Certificate message. Message too short.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  }
  var b = record.fragment;
  var msg = {
    certificate_list: readVector(b, 3)
  };
  var cert, asn12;
  var certs = [];
  try {
    while (msg.certificate_list.length() > 0) {
      cert = readVector(msg.certificate_list, 3);
      asn12 = forge$8.asn1.fromDer(cert);
      cert = forge$8.pki.certificateFromAsn1(asn12, true);
      certs.push(cert);
    }
  } catch (ex) {
    return c.error(c, {
      message: "Could not parse certificate list.",
      cause: ex,
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.bad_certificate
      }
    });
  }
  var client2 = c.entity === tls$1.ConnectionEnd.client;
  if ((client2 || c.verifyClient === true) && certs.length === 0) {
    c.error(c, {
      message: client2 ? "No server certificate provided." : "No client certificate provided.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  } else if (certs.length === 0) {
    c.expect = client2 ? SKE : CKE;
  } else {
    if (client2) {
      c.session.serverCertificate = certs[0];
    } else {
      c.session.clientCertificate = certs[0];
    }
    if (tls$1.verifyCertificateChain(c, certs)) {
      c.expect = client2 ? SKE : CKE;
    }
  }
  c.process();
};
tls$1.handleServerKeyExchange = function(c, record, length) {
  if (length > 0) {
    return c.error(c, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.unsupported_certificate
      }
    });
  }
  c.expect = SCR;
  c.process();
};
tls$1.handleClientKeyExchange = function(c, record, length) {
  if (length < 48) {
    return c.error(c, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.unsupported_certificate
      }
    });
  }
  var b = record.fragment;
  var msg = {
    enc_pre_master_secret: readVector(b, 2).getBytes()
  };
  var privateKey = null;
  if (c.getPrivateKey) {
    try {
      privateKey = c.getPrivateKey(c, c.session.serverCertificate);
      privateKey = forge$8.pki.privateKeyFromPem(privateKey);
    } catch (ex) {
      c.error(c, {
        message: "Could not get private key.",
        cause: ex,
        send: true,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.internal_error
        }
      });
    }
  }
  if (privateKey === null) {
    return c.error(c, {
      message: "No private key set.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.internal_error
      }
    });
  }
  try {
    var sp = c.session.sp;
    sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
    var version2 = c.session.clientHelloVersion;
    if (version2.major !== sp.pre_master_secret.charCodeAt(0) || version2.minor !== sp.pre_master_secret.charCodeAt(1)) {
      throw new Error("TLS version rollback attack detected.");
    }
  } catch (ex) {
    sp.pre_master_secret = forge$8.random.getBytes(48);
  }
  c.expect = CCC;
  if (c.session.clientCertificate !== null) {
    c.expect = CCV;
  }
  c.process();
};
tls$1.handleCertificateRequest = function(c, record, length) {
  if (length < 3) {
    return c.error(c, {
      message: "Invalid CertificateRequest. Message too short.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  }
  var b = record.fragment;
  var msg = {
    certificate_types: readVector(b, 1),
    certificate_authorities: readVector(b, 2)
  };
  c.session.certificateRequest = msg;
  c.expect = SHD;
  c.process();
};
tls$1.handleCertificateVerify = function(c, record, length) {
  if (length < 2) {
    return c.error(c, {
      message: "Invalid CertificateVerify. Message too short.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  }
  var b = record.fragment;
  b.read -= 4;
  var msgBytes = b.bytes();
  b.read += 4;
  var msg = {
    signature: readVector(b, 2).getBytes()
  };
  var verify = forge$8.util.createBuffer();
  verify.putBuffer(c.session.md5.digest());
  verify.putBuffer(c.session.sha1.digest());
  verify = verify.getBytes();
  try {
    var cert = c.session.clientCertificate;
    if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
      throw new Error("CertificateVerify signature does not match.");
    }
    c.session.md5.update(msgBytes);
    c.session.sha1.update(msgBytes);
  } catch (ex) {
    return c.error(c, {
      message: "Bad signature in CertificateVerify.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.handshake_failure
      }
    });
  }
  c.expect = CCC;
  c.process();
};
tls$1.handleServerHelloDone = function(c, record, length) {
  if (length > 0) {
    return c.error(c, {
      message: "Invalid ServerHelloDone message. Invalid length.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.record_overflow
      }
    });
  }
  if (c.serverCertificate === null) {
    var error2 = {
      message: "No server certificate provided. Not enough security.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.insufficient_security
      }
    };
    var depth = 0;
    var ret = c.verify(c, error2.alert.description, depth, []);
    if (ret !== true) {
      if (ret || ret === 0) {
        if (typeof ret === "object" && !forge$8.util.isArray(ret)) {
          if (ret.message) {
            error2.message = ret.message;
          }
          if (ret.alert) {
            error2.alert.description = ret.alert;
          }
        } else if (typeof ret === "number") {
          error2.alert.description = ret;
        }
      }
      return c.error(c, error2);
    }
  }
  if (c.session.certificateRequest !== null) {
    record = tls$1.createRecord(c, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createCertificate(c)
    });
    tls$1.queue(c, record);
  }
  record = tls$1.createRecord(c, {
    type: tls$1.ContentType.handshake,
    data: tls$1.createClientKeyExchange(c)
  });
  tls$1.queue(c, record);
  c.expect = SER;
  var callback = function(c2, signature) {
    if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
      tls$1.queue(c2, tls$1.createRecord(c2, {
        type: tls$1.ContentType.handshake,
        data: tls$1.createCertificateVerify(c2, signature)
      }));
    }
    tls$1.queue(c2, tls$1.createRecord(c2, {
      type: tls$1.ContentType.change_cipher_spec,
      data: tls$1.createChangeCipherSpec()
    }));
    c2.state.pending = tls$1.createConnectionState(c2);
    c2.state.current.write = c2.state.pending.write;
    tls$1.queue(c2, tls$1.createRecord(c2, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createFinished(c2)
    }));
    c2.expect = SCC;
    tls$1.flush(c2);
    c2.process();
  };
  if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
    return callback(c, null);
  }
  tls$1.getClientSignature(c, callback);
};
tls$1.handleChangeCipherSpec = function(c, record) {
  if (record.fragment.getByte() !== 1) {
    return c.error(c, {
      message: "Invalid ChangeCipherSpec message received.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.illegal_parameter
      }
    });
  }
  var client2 = c.entity === tls$1.ConnectionEnd.client;
  if (c.session.resuming && client2 || !c.session.resuming && !client2) {
    c.state.pending = tls$1.createConnectionState(c);
  }
  c.state.current.read = c.state.pending.read;
  if (!c.session.resuming && client2 || c.session.resuming && !client2) {
    c.state.pending = null;
  }
  c.expect = client2 ? SFI : CFI;
  c.process();
};
tls$1.handleFinished = function(c, record, length) {
  var b = record.fragment;
  b.read -= 4;
  var msgBytes = b.bytes();
  b.read += 4;
  var vd = record.fragment.getBytes();
  b = forge$8.util.createBuffer();
  b.putBuffer(c.session.md5.digest());
  b.putBuffer(c.session.sha1.digest());
  var client2 = c.entity === tls$1.ConnectionEnd.client;
  var label = client2 ? "server finished" : "client finished";
  var sp = c.session.sp;
  var vdl = 12;
  var prf = prf_TLS1;
  b = prf(sp.master_secret, label, b.getBytes(), vdl);
  if (b.getBytes() !== vd) {
    return c.error(c, {
      message: "Invalid verify_data in Finished message.",
      send: true,
      alert: {
        level: tls$1.Alert.Level.fatal,
        description: tls$1.Alert.Description.decrypt_error
      }
    });
  }
  c.session.md5.update(msgBytes);
  c.session.sha1.update(msgBytes);
  if (c.session.resuming && client2 || !c.session.resuming && !client2) {
    tls$1.queue(c, tls$1.createRecord(c, {
      type: tls$1.ContentType.change_cipher_spec,
      data: tls$1.createChangeCipherSpec()
    }));
    c.state.current.write = c.state.pending.write;
    c.state.pending = null;
    tls$1.queue(c, tls$1.createRecord(c, {
      type: tls$1.ContentType.handshake,
      data: tls$1.createFinished(c)
    }));
  }
  c.expect = client2 ? SAD : CAD;
  c.handshaking = false;
  ++c.handshakes;
  c.peerCertificate = client2 ? c.session.serverCertificate : c.session.clientCertificate;
  tls$1.flush(c);
  c.isConnected = true;
  c.connected(c);
  c.process();
};
tls$1.handleAlert = function(c, record) {
  var b = record.fragment;
  var alert = {
    level: b.getByte(),
    description: b.getByte()
  };
  var msg;
  switch (alert.description) {
    case tls$1.Alert.Description.close_notify:
      msg = "Connection closed.";
      break;
    case tls$1.Alert.Description.unexpected_message:
      msg = "Unexpected message.";
      break;
    case tls$1.Alert.Description.bad_record_mac:
      msg = "Bad record MAC.";
      break;
    case tls$1.Alert.Description.decryption_failed:
      msg = "Decryption failed.";
      break;
    case tls$1.Alert.Description.record_overflow:
      msg = "Record overflow.";
      break;
    case tls$1.Alert.Description.decompression_failure:
      msg = "Decompression failed.";
      break;
    case tls$1.Alert.Description.handshake_failure:
      msg = "Handshake failure.";
      break;
    case tls$1.Alert.Description.bad_certificate:
      msg = "Bad certificate.";
      break;
    case tls$1.Alert.Description.unsupported_certificate:
      msg = "Unsupported certificate.";
      break;
    case tls$1.Alert.Description.certificate_revoked:
      msg = "Certificate revoked.";
      break;
    case tls$1.Alert.Description.certificate_expired:
      msg = "Certificate expired.";
      break;
    case tls$1.Alert.Description.certificate_unknown:
      msg = "Certificate unknown.";
      break;
    case tls$1.Alert.Description.illegal_parameter:
      msg = "Illegal parameter.";
      break;
    case tls$1.Alert.Description.unknown_ca:
      msg = "Unknown certificate authority.";
      break;
    case tls$1.Alert.Description.access_denied:
      msg = "Access denied.";
      break;
    case tls$1.Alert.Description.decode_error:
      msg = "Decode error.";
      break;
    case tls$1.Alert.Description.decrypt_error:
      msg = "Decrypt error.";
      break;
    case tls$1.Alert.Description.export_restriction:
      msg = "Export restriction.";
      break;
    case tls$1.Alert.Description.protocol_version:
      msg = "Unsupported protocol version.";
      break;
    case tls$1.Alert.Description.insufficient_security:
      msg = "Insufficient security.";
      break;
    case tls$1.Alert.Description.internal_error:
      msg = "Internal error.";
      break;
    case tls$1.Alert.Description.user_canceled:
      msg = "User canceled.";
      break;
    case tls$1.Alert.Description.no_renegotiation:
      msg = "Renegotiation not supported.";
      break;
    default:
      msg = "Unknown error.";
      break;
  }
  if (alert.description === tls$1.Alert.Description.close_notify) {
    return c.close();
  }
  c.error(c, {
    message: msg,
    send: false,
    // origin is the opposite end
    origin: c.entity === tls$1.ConnectionEnd.client ? "server" : "client",
    alert
  });
  c.process();
};
tls$1.handleHandshake = function(c, record) {
  var b = record.fragment;
  var type3 = b.getByte();
  var length = b.getInt24();
  if (length > b.length()) {
    c.fragmented = record;
    record.fragment = forge$8.util.createBuffer();
    b.read -= 4;
    return c.process();
  }
  c.fragmented = null;
  b.read -= 4;
  var bytes2 = b.bytes(length + 4);
  b.read += 4;
  if (type3 in hsTable[c.entity][c.expect]) {
    if (c.entity === tls$1.ConnectionEnd.server && !c.open && !c.fail) {
      c.handshaking = true;
      c.session = {
        version: null,
        extensions: {
          server_name: {
            serverNameList: []
          }
        },
        cipherSuite: null,
        compressionMethod: null,
        serverCertificate: null,
        clientCertificate: null,
        md5: forge$8.md.md5.create(),
        sha1: forge$8.md.sha1.create()
      };
    }
    if (type3 !== tls$1.HandshakeType.hello_request && type3 !== tls$1.HandshakeType.certificate_verify && type3 !== tls$1.HandshakeType.finished) {
      c.session.md5.update(bytes2);
      c.session.sha1.update(bytes2);
    }
    hsTable[c.entity][c.expect][type3](c, record, length);
  } else {
    tls$1.handleUnexpected(c, record);
  }
};
tls$1.handleApplicationData = function(c, record) {
  c.data.putBuffer(record.fragment);
  c.dataReady(c);
  c.process();
};
tls$1.handleHeartbeat = function(c, record) {
  var b = record.fragment;
  var type3 = b.getByte();
  var length = b.getInt16();
  var payload = b.getBytes(length);
  if (type3 === tls$1.HeartbeatMessageType.heartbeat_request) {
    if (c.handshaking || length > payload.length) {
      return c.process();
    }
    tls$1.queue(c, tls$1.createRecord(c, {
      type: tls$1.ContentType.heartbeat,
      data: tls$1.createHeartbeat(
        tls$1.HeartbeatMessageType.heartbeat_response,
        payload
      )
    }));
    tls$1.flush(c);
  } else if (type3 === tls$1.HeartbeatMessageType.heartbeat_response) {
    if (payload !== c.expectedHeartbeatPayload) {
      return c.process();
    }
    if (c.heartbeatReceived) {
      c.heartbeatReceived(c, forge$8.util.createBuffer(payload));
    }
  }
  c.process();
};
var SHE = 0;
var SCE = 1;
var SKE = 2;
var SCR = 3;
var SHD = 4;
var SCC = 5;
var SFI = 6;
var SAD = 7;
var SER = 8;
var CHE = 0;
var CCE = 1;
var CKE = 2;
var CCV = 3;
var CCC = 4;
var CFI = 5;
var CAD = 6;
var __ = tls$1.handleUnexpected;
var R0 = tls$1.handleChangeCipherSpec;
var R1 = tls$1.handleAlert;
var R2 = tls$1.handleHandshake;
var R3 = tls$1.handleApplicationData;
var R4 = tls$1.handleHeartbeat;
var ctTable = [];
ctTable[tls$1.ConnectionEnd.client] = [
  //      CC,AL,HS,AD,HB
  /*SHE*/
  [__, R1, R2, __, R4],
  /*SCE*/
  [__, R1, R2, __, R4],
  /*SKE*/
  [__, R1, R2, __, R4],
  /*SCR*/
  [__, R1, R2, __, R4],
  /*SHD*/
  [__, R1, R2, __, R4],
  /*SCC*/
  [R0, R1, __, __, R4],
  /*SFI*/
  [__, R1, R2, __, R4],
  /*SAD*/
  [__, R1, R2, R3, R4],
  /*SER*/
  [__, R1, R2, __, R4]
];
ctTable[tls$1.ConnectionEnd.server] = [
  //      CC,AL,HS,AD
  /*CHE*/
  [__, R1, R2, __, R4],
  /*CCE*/
  [__, R1, R2, __, R4],
  /*CKE*/
  [__, R1, R2, __, R4],
  /*CCV*/
  [__, R1, R2, __, R4],
  /*CCC*/
  [R0, R1, __, __, R4],
  /*CFI*/
  [__, R1, R2, __, R4],
  /*CAD*/
  [__, R1, R2, R3, R4],
  /*CER*/
  [__, R1, R2, __, R4]
];
var H0 = tls$1.handleHelloRequest;
var H1 = tls$1.handleServerHello;
var H2 = tls$1.handleCertificate;
var H3 = tls$1.handleServerKeyExchange;
var H4 = tls$1.handleCertificateRequest;
var H5 = tls$1.handleServerHelloDone;
var H6 = tls$1.handleFinished;
var hsTable = [];
hsTable[tls$1.ConnectionEnd.client] = [
  //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
  /*SHE*/
  [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*SCE*/
  [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
  /*SKE*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
  /*SCR*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
  /*SHD*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
  /*SCC*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*SFI*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
  /*SAD*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*SER*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
];
var H7 = tls$1.handleClientHello;
var H8 = tls$1.handleClientKeyExchange;
var H9 = tls$1.handleCertificateVerify;
hsTable[tls$1.ConnectionEnd.server] = [
  //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
  /*CHE*/
  [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*CCE*/
  [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
  /*CKE*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
  /*CCV*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
  /*CCC*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*CFI*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
  /*CAD*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*CER*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
];
tls$1.generateKeys = function(c, sp) {
  var prf = prf_TLS1;
  var random = sp.client_random + sp.server_random;
  if (!c.session.resuming) {
    sp.master_secret = prf(
      sp.pre_master_secret,
      "master secret",
      random,
      48
    ).bytes();
    sp.pre_master_secret = null;
  }
  random = sp.server_random + sp.client_random;
  var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
  var tls10 = c.version.major === tls$1.Versions.TLS_1_0.major && c.version.minor === tls$1.Versions.TLS_1_0.minor;
  if (tls10) {
    length += 2 * sp.fixed_iv_length;
  }
  var km = prf(sp.master_secret, "key expansion", random, length);
  var rval = {
    client_write_MAC_key: km.getBytes(sp.mac_key_length),
    server_write_MAC_key: km.getBytes(sp.mac_key_length),
    client_write_key: km.getBytes(sp.enc_key_length),
    server_write_key: km.getBytes(sp.enc_key_length)
  };
  if (tls10) {
    rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
    rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
  }
  return rval;
};
tls$1.createConnectionState = function(c) {
  var client2 = c.entity === tls$1.ConnectionEnd.client;
  var createMode = function() {
    var mode = {
      // two 32-bit numbers, first is most significant
      sequenceNumber: [0, 0],
      macKey: null,
      macLength: 0,
      macFunction: null,
      cipherState: null,
      cipherFunction: function(record) {
        return true;
      },
      compressionState: null,
      compressFunction: function(record) {
        return true;
      },
      updateSequenceNumber: function() {
        if (mode.sequenceNumber[1] === 4294967295) {
          mode.sequenceNumber[1] = 0;
          ++mode.sequenceNumber[0];
        } else {
          ++mode.sequenceNumber[1];
        }
      }
    };
    return mode;
  };
  var state = {
    read: createMode(),
    write: createMode()
  };
  state.read.update = function(c2, record) {
    if (!state.read.cipherFunction(record, state.read)) {
      c2.error(c2, {
        message: "Could not decrypt record or bad MAC.",
        send: true,
        alert: {
          level: tls$1.Alert.Level.fatal,
          // doesn't matter if decryption failed or MAC was
          // invalid, return the same error so as not to reveal
          // which one occurred
          description: tls$1.Alert.Description.bad_record_mac
        }
      });
    } else if (!state.read.compressFunction(c2, record, state.read)) {
      c2.error(c2, {
        message: "Could not decompress record.",
        send: true,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.decompression_failure
        }
      });
    }
    return !c2.fail;
  };
  state.write.update = function(c2, record) {
    if (!state.write.compressFunction(c2, record, state.write)) {
      c2.error(c2, {
        message: "Could not compress record.",
        send: false,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.internal_error
        }
      });
    } else if (!state.write.cipherFunction(record, state.write)) {
      c2.error(c2, {
        message: "Could not encrypt record.",
        send: false,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.internal_error
        }
      });
    }
    return !c2.fail;
  };
  if (c.session) {
    var sp = c.session.sp;
    c.session.cipherSuite.initSecurityParameters(sp);
    sp.keys = tls$1.generateKeys(c, sp);
    state.read.macKey = client2 ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
    state.write.macKey = client2 ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
    c.session.cipherSuite.initConnectionState(state, c, sp);
    switch (sp.compression_algorithm) {
      case tls$1.CompressionMethod.none:
        break;
      case tls$1.CompressionMethod.deflate:
        state.read.compressFunction = inflate;
        state.write.compressFunction = deflate;
        break;
      default:
        throw new Error("Unsupported compression algorithm.");
    }
  }
  return state;
};
tls$1.createRandom = function() {
  var d2 = /* @__PURE__ */ new Date();
  var utc = +d2 + d2.getTimezoneOffset() * 6e4;
  var rval = forge$8.util.createBuffer();
  rval.putInt32(utc);
  rval.putBytes(forge$8.random.getBytes(28));
  return rval;
};
tls$1.createRecord = function(c, options2) {
  if (!options2.data) {
    return null;
  }
  var record = {
    type: options2.type,
    version: {
      major: c.version.major,
      minor: c.version.minor
    },
    length: options2.data.length(),
    fragment: options2.data
  };
  return record;
};
tls$1.createAlert = function(c, alert) {
  var b = forge$8.util.createBuffer();
  b.putByte(alert.level);
  b.putByte(alert.description);
  return tls$1.createRecord(c, {
    type: tls$1.ContentType.alert,
    data: b
  });
};
tls$1.createClientHello = function(c) {
  c.session.clientHelloVersion = {
    major: c.version.major,
    minor: c.version.minor
  };
  var cipherSuites = forge$8.util.createBuffer();
  for (var i = 0; i < c.cipherSuites.length; ++i) {
    var cs = c.cipherSuites[i];
    cipherSuites.putByte(cs.id[0]);
    cipherSuites.putByte(cs.id[1]);
  }
  var cSuites = cipherSuites.length();
  var compressionMethods = forge$8.util.createBuffer();
  compressionMethods.putByte(tls$1.CompressionMethod.none);
  var cMethods = compressionMethods.length();
  var extensions = forge$8.util.createBuffer();
  if (c.virtualHost) {
    var ext = forge$8.util.createBuffer();
    ext.putByte(0);
    ext.putByte(0);
    var serverName = forge$8.util.createBuffer();
    serverName.putByte(0);
    writeVector(serverName, 2, forge$8.util.createBuffer(c.virtualHost));
    var snList = forge$8.util.createBuffer();
    writeVector(snList, 2, serverName);
    writeVector(ext, 2, snList);
    extensions.putBuffer(ext);
  }
  var extLength = extensions.length();
  if (extLength > 0) {
    extLength += 2;
  }
  var sessionId = c.session.id;
  var length = sessionId.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + cSuites + // cipher suites vector
  1 + cMethods + // compression methods vector
  extLength;
  var rval = forge$8.util.createBuffer();
  rval.putByte(tls$1.HandshakeType.client_hello);
  rval.putInt24(length);
  rval.putByte(c.version.major);
  rval.putByte(c.version.minor);
  rval.putBytes(c.session.sp.client_random);
  writeVector(rval, 1, forge$8.util.createBuffer(sessionId));
  writeVector(rval, 2, cipherSuites);
  writeVector(rval, 1, compressionMethods);
  if (extLength > 0) {
    writeVector(rval, 2, extensions);
  }
  return rval;
};
tls$1.createServerHello = function(c) {
  var sessionId = c.session.id;
  var length = sessionId.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + // chosen cipher suite
  1;
  var rval = forge$8.util.createBuffer();
  rval.putByte(tls$1.HandshakeType.server_hello);
  rval.putInt24(length);
  rval.putByte(c.version.major);
  rval.putByte(c.version.minor);
  rval.putBytes(c.session.sp.server_random);
  writeVector(rval, 1, forge$8.util.createBuffer(sessionId));
  rval.putByte(c.session.cipherSuite.id[0]);
  rval.putByte(c.session.cipherSuite.id[1]);
  rval.putByte(c.session.compressionMethod);
  return rval;
};
tls$1.createCertificate = function(c) {
  var client2 = c.entity === tls$1.ConnectionEnd.client;
  var cert = null;
  if (c.getCertificate) {
    var hint;
    if (client2) {
      hint = c.session.certificateRequest;
    } else {
      hint = c.session.extensions.server_name.serverNameList;
    }
    cert = c.getCertificate(c, hint);
  }
  var certList = forge$8.util.createBuffer();
  if (cert !== null) {
    try {
      if (!forge$8.util.isArray(cert)) {
        cert = [cert];
      }
      var asn12 = null;
      for (var i = 0; i < cert.length; ++i) {
        var msg = forge$8.pem.decode(cert[i])[0];
        if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
          var error2 = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
          error2.headerType = msg.type;
          throw error2;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
        }
        var der = forge$8.util.createBuffer(msg.body);
        if (asn12 === null) {
          asn12 = forge$8.asn1.fromDer(der.bytes(), false);
        }
        var certBuffer = forge$8.util.createBuffer();
        writeVector(certBuffer, 3, der);
        certList.putBuffer(certBuffer);
      }
      cert = forge$8.pki.certificateFromAsn1(asn12);
      if (client2) {
        c.session.clientCertificate = cert;
      } else {
        c.session.serverCertificate = cert;
      }
    } catch (ex) {
      return c.error(c, {
        message: "Could not send certificate list.",
        cause: ex,
        send: true,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.bad_certificate
        }
      });
    }
  }
  var length = 3 + certList.length();
  var rval = forge$8.util.createBuffer();
  rval.putByte(tls$1.HandshakeType.certificate);
  rval.putInt24(length);
  writeVector(rval, 3, certList);
  return rval;
};
tls$1.createClientKeyExchange = function(c) {
  var b = forge$8.util.createBuffer();
  b.putByte(c.session.clientHelloVersion.major);
  b.putByte(c.session.clientHelloVersion.minor);
  b.putBytes(forge$8.random.getBytes(46));
  var sp = c.session.sp;
  sp.pre_master_secret = b.getBytes();
  var key = c.session.serverCertificate.publicKey;
  b = key.encrypt(sp.pre_master_secret);
  var length = b.length + 2;
  var rval = forge$8.util.createBuffer();
  rval.putByte(tls$1.HandshakeType.client_key_exchange);
  rval.putInt24(length);
  rval.putInt16(b.length);
  rval.putBytes(b);
  return rval;
};
tls$1.createServerKeyExchange = function(c) {
  var rval = forge$8.util.createBuffer();
  return rval;
};
tls$1.getClientSignature = function(c, callback) {
  var b = forge$8.util.createBuffer();
  b.putBuffer(c.session.md5.digest());
  b.putBuffer(c.session.sha1.digest());
  b = b.getBytes();
  c.getSignature = c.getSignature || function(c2, b2, callback2) {
    var privateKey = null;
    if (c2.getPrivateKey) {
      try {
        privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
        privateKey = forge$8.pki.privateKeyFromPem(privateKey);
      } catch (ex) {
        c2.error(c2, {
          message: "Could not get private key.",
          cause: ex,
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.internal_error
          }
        });
      }
    }
    if (privateKey === null) {
      c2.error(c2, {
        message: "No private key set.",
        send: true,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: tls$1.Alert.Description.internal_error
        }
      });
    } else {
      b2 = privateKey.sign(b2, null);
    }
    callback2(c2, b2);
  };
  c.getSignature(c, b, callback);
};
tls$1.createCertificateVerify = function(c, signature) {
  var length = signature.length + 2;
  var rval = forge$8.util.createBuffer();
  rval.putByte(tls$1.HandshakeType.certificate_verify);
  rval.putInt24(length);
  rval.putInt16(signature.length);
  rval.putBytes(signature);
  return rval;
};
tls$1.createCertificateRequest = function(c) {
  var certTypes = forge$8.util.createBuffer();
  certTypes.putByte(1);
  var cAs = forge$8.util.createBuffer();
  for (var key in c.caStore.certs) {
    var cert = c.caStore.certs[key];
    var dn = forge$8.pki.distinguishedNameToAsn1(cert.subject);
    var byteBuffer = forge$8.asn1.toDer(dn);
    cAs.putInt16(byteBuffer.length());
    cAs.putBuffer(byteBuffer);
  }
  var length = 1 + certTypes.length() + 2 + cAs.length();
  var rval = forge$8.util.createBuffer();
  rval.putByte(tls$1.HandshakeType.certificate_request);
  rval.putInt24(length);
  writeVector(rval, 1, certTypes);
  writeVector(rval, 2, cAs);
  return rval;
};
tls$1.createServerHelloDone = function(c) {
  var rval = forge$8.util.createBuffer();
  rval.putByte(tls$1.HandshakeType.server_hello_done);
  rval.putInt24(0);
  return rval;
};
tls$1.createChangeCipherSpec = function() {
  var rval = forge$8.util.createBuffer();
  rval.putByte(1);
  return rval;
};
tls$1.createFinished = function(c) {
  var b = forge$8.util.createBuffer();
  b.putBuffer(c.session.md5.digest());
  b.putBuffer(c.session.sha1.digest());
  var client2 = c.entity === tls$1.ConnectionEnd.client;
  var sp = c.session.sp;
  var vdl = 12;
  var prf = prf_TLS1;
  var label = client2 ? "client finished" : "server finished";
  b = prf(sp.master_secret, label, b.getBytes(), vdl);
  var rval = forge$8.util.createBuffer();
  rval.putByte(tls$1.HandshakeType.finished);
  rval.putInt24(b.length());
  rval.putBuffer(b);
  return rval;
};
tls$1.createHeartbeat = function(type3, payload, payloadLength) {
  if (typeof payloadLength === "undefined") {
    payloadLength = payload.length;
  }
  var rval = forge$8.util.createBuffer();
  rval.putByte(type3);
  rval.putInt16(payloadLength);
  rval.putBytes(payload);
  var plaintextLength = rval.length();
  var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
  rval.putBytes(forge$8.random.getBytes(paddingLength));
  return rval;
};
tls$1.queue = function(c, record) {
  if (!record) {
    return;
  }
  if (record.fragment.length() === 0) {
    if (record.type === tls$1.ContentType.handshake || record.type === tls$1.ContentType.alert || record.type === tls$1.ContentType.change_cipher_spec) {
      return;
    }
  }
  if (record.type === tls$1.ContentType.handshake) {
    var bytes2 = record.fragment.bytes();
    c.session.md5.update(bytes2);
    c.session.sha1.update(bytes2);
    bytes2 = null;
  }
  var records;
  if (record.fragment.length() <= tls$1.MaxFragment) {
    records = [record];
  } else {
    records = [];
    var data = record.fragment.bytes();
    while (data.length > tls$1.MaxFragment) {
      records.push(tls$1.createRecord(c, {
        type: record.type,
        data: forge$8.util.createBuffer(data.slice(0, tls$1.MaxFragment))
      }));
      data = data.slice(tls$1.MaxFragment);
    }
    if (data.length > 0) {
      records.push(tls$1.createRecord(c, {
        type: record.type,
        data: forge$8.util.createBuffer(data)
      }));
    }
  }
  for (var i = 0; i < records.length && !c.fail; ++i) {
    var rec = records[i];
    var s2 = c.state.current.write;
    if (s2.update(c, rec)) {
      c.records.push(rec);
    }
  }
};
tls$1.flush = function(c) {
  for (var i = 0; i < c.records.length; ++i) {
    var record = c.records[i];
    c.tlsData.putByte(record.type);
    c.tlsData.putByte(record.version.major);
    c.tlsData.putByte(record.version.minor);
    c.tlsData.putInt16(record.fragment.length());
    c.tlsData.putBuffer(c.records[i].fragment);
  }
  c.records = [];
  return c.tlsDataReady(c);
};
var _certErrorToAlertDesc = function(error2) {
  switch (error2) {
    case true:
      return true;
    case forge$8.pki.certificateError.bad_certificate:
      return tls$1.Alert.Description.bad_certificate;
    case forge$8.pki.certificateError.unsupported_certificate:
      return tls$1.Alert.Description.unsupported_certificate;
    case forge$8.pki.certificateError.certificate_revoked:
      return tls$1.Alert.Description.certificate_revoked;
    case forge$8.pki.certificateError.certificate_expired:
      return tls$1.Alert.Description.certificate_expired;
    case forge$8.pki.certificateError.certificate_unknown:
      return tls$1.Alert.Description.certificate_unknown;
    case forge$8.pki.certificateError.unknown_ca:
      return tls$1.Alert.Description.unknown_ca;
    default:
      return tls$1.Alert.Description.bad_certificate;
  }
};
var _alertDescToCertError = function(desc) {
  switch (desc) {
    case true:
      return true;
    case tls$1.Alert.Description.bad_certificate:
      return forge$8.pki.certificateError.bad_certificate;
    case tls$1.Alert.Description.unsupported_certificate:
      return forge$8.pki.certificateError.unsupported_certificate;
    case tls$1.Alert.Description.certificate_revoked:
      return forge$8.pki.certificateError.certificate_revoked;
    case tls$1.Alert.Description.certificate_expired:
      return forge$8.pki.certificateError.certificate_expired;
    case tls$1.Alert.Description.certificate_unknown:
      return forge$8.pki.certificateError.certificate_unknown;
    case tls$1.Alert.Description.unknown_ca:
      return forge$8.pki.certificateError.unknown_ca;
    default:
      return forge$8.pki.certificateError.bad_certificate;
  }
};
tls$1.verifyCertificateChain = function(c, chain) {
  try {
    var options2 = {};
    for (var key in c.verifyOptions) {
      options2[key] = c.verifyOptions[key];
    }
    options2.verify = function(vfd, depth, chain2) {
      var desc = _certErrorToAlertDesc(vfd);
      var ret = c.verify(c, vfd, depth, chain2);
      if (ret !== true) {
        if (typeof ret === "object" && !forge$8.util.isArray(ret)) {
          var error2 = new Error("The application rejected the certificate.");
          error2.send = true;
          error2.alert = {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.bad_certificate
          };
          if (ret.message) {
            error2.message = ret.message;
          }
          if (ret.alert) {
            error2.alert.description = ret.alert;
          }
          throw error2;
        }
        if (ret !== vfd) {
          ret = _alertDescToCertError(ret);
        }
      }
      return ret;
    };
    forge$8.pki.verifyCertificateChain(c.caStore, chain, options2);
  } catch (ex) {
    var err = ex;
    if (typeof err !== "object" || forge$8.util.isArray(err)) {
      err = {
        send: true,
        alert: {
          level: tls$1.Alert.Level.fatal,
          description: _certErrorToAlertDesc(ex)
        }
      };
    }
    if (!("send" in err)) {
      err.send = true;
    }
    if (!("alert" in err)) {
      err.alert = {
        level: tls$1.Alert.Level.fatal,
        description: _certErrorToAlertDesc(err.error)
      };
    }
    c.error(c, err);
  }
  return !c.fail;
};
tls$1.createSessionCache = function(cache, capacity) {
  var rval = null;
  if (cache && cache.getSession && cache.setSession && cache.order) {
    rval = cache;
  } else {
    rval = {};
    rval.cache = cache || {};
    rval.capacity = Math.max(capacity || 100, 1);
    rval.order = [];
    for (var key in cache) {
      if (rval.order.length <= capacity) {
        rval.order.push(key);
      } else {
        delete cache[key];
      }
    }
    rval.getSession = function(sessionId) {
      var session = null;
      var key2 = null;
      if (sessionId) {
        key2 = forge$8.util.bytesToHex(sessionId);
      } else if (rval.order.length > 0) {
        key2 = rval.order[0];
      }
      if (key2 !== null && key2 in rval.cache) {
        session = rval.cache[key2];
        delete rval.cache[key2];
        for (var i in rval.order) {
          if (rval.order[i] === key2) {
            rval.order.splice(i, 1);
            break;
          }
        }
      }
      return session;
    };
    rval.setSession = function(sessionId, session) {
      if (rval.order.length === rval.capacity) {
        var key2 = rval.order.shift();
        delete rval.cache[key2];
      }
      var key2 = forge$8.util.bytesToHex(sessionId);
      rval.order.push(key2);
      rval.cache[key2] = session;
    };
  }
  return rval;
};
tls$1.createConnection = function(options2) {
  var caStore = null;
  if (options2.caStore) {
    if (forge$8.util.isArray(options2.caStore)) {
      caStore = forge$8.pki.createCaStore(options2.caStore);
    } else {
      caStore = options2.caStore;
    }
  } else {
    caStore = forge$8.pki.createCaStore();
  }
  var cipherSuites = options2.cipherSuites || null;
  if (cipherSuites === null) {
    cipherSuites = [];
    for (var key in tls$1.CipherSuites) {
      cipherSuites.push(tls$1.CipherSuites[key]);
    }
  }
  var entity = options2.server || false ? tls$1.ConnectionEnd.server : tls$1.ConnectionEnd.client;
  var sessionCache = options2.sessionCache ? tls$1.createSessionCache(options2.sessionCache) : null;
  var c = {
    version: { major: tls$1.Version.major, minor: tls$1.Version.minor },
    entity,
    sessionId: options2.sessionId,
    caStore,
    sessionCache,
    cipherSuites,
    connected: options2.connected,
    virtualHost: options2.virtualHost || null,
    verifyClient: options2.verifyClient || false,
    verify: options2.verify || function(cn, vfd, dpth, cts) {
      return vfd;
    },
    verifyOptions: options2.verifyOptions || {},
    getCertificate: options2.getCertificate || null,
    getPrivateKey: options2.getPrivateKey || null,
    getSignature: options2.getSignature || null,
    input: forge$8.util.createBuffer(),
    tlsData: forge$8.util.createBuffer(),
    data: forge$8.util.createBuffer(),
    tlsDataReady: options2.tlsDataReady,
    dataReady: options2.dataReady,
    heartbeatReceived: options2.heartbeatReceived,
    closed: options2.closed,
    error: function(c2, ex) {
      ex.origin = ex.origin || (c2.entity === tls$1.ConnectionEnd.client ? "client" : "server");
      if (ex.send) {
        tls$1.queue(c2, tls$1.createAlert(c2, ex.alert));
        tls$1.flush(c2);
      }
      var fatal = ex.fatal !== false;
      if (fatal) {
        c2.fail = true;
      }
      options2.error(c2, ex);
      if (fatal) {
        c2.close(false);
      }
    },
    deflate: options2.deflate || null,
    inflate: options2.inflate || null
  };
  c.reset = function(clearFail) {
    c.version = { major: tls$1.Version.major, minor: tls$1.Version.minor };
    c.record = null;
    c.session = null;
    c.peerCertificate = null;
    c.state = {
      pending: null,
      current: null
    };
    c.expect = c.entity === tls$1.ConnectionEnd.client ? SHE : CHE;
    c.fragmented = null;
    c.records = [];
    c.open = false;
    c.handshakes = 0;
    c.handshaking = false;
    c.isConnected = false;
    c.fail = !(clearFail || typeof clearFail === "undefined");
    c.input.clear();
    c.tlsData.clear();
    c.data.clear();
    c.state.current = tls$1.createConnectionState(c);
  };
  c.reset();
  var _update2 = function(c2, record) {
    var aligned = record.type - tls$1.ContentType.change_cipher_spec;
    var handlers = ctTable[c2.entity][c2.expect];
    if (aligned in handlers) {
      handlers[aligned](c2, record);
    } else {
      tls$1.handleUnexpected(c2, record);
    }
  };
  var _readRecordHeader = function(c2) {
    var rval = 0;
    var b = c2.input;
    var len = b.length();
    if (len < 5) {
      rval = 5 - len;
    } else {
      c2.record = {
        type: b.getByte(),
        version: {
          major: b.getByte(),
          minor: b.getByte()
        },
        length: b.getInt16(),
        fragment: forge$8.util.createBuffer(),
        ready: false
      };
      var compatibleVersion = c2.record.version.major === c2.version.major;
      if (compatibleVersion && c2.session && c2.session.version) {
        compatibleVersion = c2.record.version.minor === c2.version.minor;
      }
      if (!compatibleVersion) {
        c2.error(c2, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.protocol_version
          }
        });
      }
    }
    return rval;
  };
  var _readRecord = function(c2) {
    var rval = 0;
    var b = c2.input;
    var len = b.length();
    if (len < c2.record.length) {
      rval = c2.record.length - len;
    } else {
      c2.record.fragment.putBytes(b.getBytes(c2.record.length));
      b.compact();
      var s2 = c2.state.current.read;
      if (s2.update(c2, c2.record)) {
        if (c2.fragmented !== null) {
          if (c2.fragmented.type === c2.record.type) {
            c2.fragmented.fragment.putBuffer(c2.record.fragment);
            c2.record = c2.fragmented;
          } else {
            c2.error(c2, {
              message: "Invalid fragmented record.",
              send: true,
              alert: {
                level: tls$1.Alert.Level.fatal,
                description: tls$1.Alert.Description.unexpected_message
              }
            });
          }
        }
        c2.record.ready = true;
      }
    }
    return rval;
  };
  c.handshake = function(sessionId) {
    if (c.entity !== tls$1.ConnectionEnd.client) {
      c.error(c, {
        message: "Cannot initiate handshake as a server.",
        fatal: false
      });
    } else if (c.handshaking) {
      c.error(c, {
        message: "Handshake already in progress.",
        fatal: false
      });
    } else {
      if (c.fail && !c.open && c.handshakes === 0) {
        c.fail = false;
      }
      c.handshaking = true;
      sessionId = sessionId || "";
      var session = null;
      if (sessionId.length > 0) {
        if (c.sessionCache) {
          session = c.sessionCache.getSession(sessionId);
        }
        if (session === null) {
          sessionId = "";
        }
      }
      if (sessionId.length === 0 && c.sessionCache) {
        session = c.sessionCache.getSession();
        if (session !== null) {
          sessionId = session.id;
        }
      }
      c.session = {
        id: sessionId,
        version: null,
        cipherSuite: null,
        compressionMethod: null,
        serverCertificate: null,
        certificateRequest: null,
        clientCertificate: null,
        sp: {},
        md5: forge$8.md.md5.create(),
        sha1: forge$8.md.sha1.create()
      };
      if (session) {
        c.version = session.version;
        c.session.sp = session.sp;
      }
      c.session.sp.client_random = tls$1.createRandom().getBytes();
      c.open = true;
      tls$1.queue(c, tls$1.createRecord(c, {
        type: tls$1.ContentType.handshake,
        data: tls$1.createClientHello(c)
      }));
      tls$1.flush(c);
    }
  };
  c.process = function(data) {
    var rval = 0;
    if (data) {
      c.input.putBytes(data);
    }
    if (!c.fail) {
      if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
        c.record = null;
      }
      if (c.record === null) {
        rval = _readRecordHeader(c);
      }
      if (!c.fail && c.record !== null && !c.record.ready) {
        rval = _readRecord(c);
      }
      if (!c.fail && c.record !== null && c.record.ready) {
        _update2(c, c.record);
      }
    }
    return rval;
  };
  c.prepare = function(data) {
    tls$1.queue(c, tls$1.createRecord(c, {
      type: tls$1.ContentType.application_data,
      data: forge$8.util.createBuffer(data)
    }));
    return tls$1.flush(c);
  };
  c.prepareHeartbeatRequest = function(payload, payloadLength) {
    if (payload instanceof forge$8.util.ByteBuffer) {
      payload = payload.bytes();
    }
    if (typeof payloadLength === "undefined") {
      payloadLength = payload.length;
    }
    c.expectedHeartbeatPayload = payload;
    tls$1.queue(c, tls$1.createRecord(c, {
      type: tls$1.ContentType.heartbeat,
      data: tls$1.createHeartbeat(
        tls$1.HeartbeatMessageType.heartbeat_request,
        payload,
        payloadLength
      )
    }));
    return tls$1.flush(c);
  };
  c.close = function(clearFail) {
    if (!c.fail && c.sessionCache && c.session) {
      var session = {
        id: c.session.id,
        version: c.session.version,
        sp: c.session.sp
      };
      session.sp.keys = null;
      c.sessionCache.setSession(session.id, session);
    }
    if (c.open) {
      c.open = false;
      c.input.clear();
      if (c.isConnected || c.handshaking) {
        c.isConnected = c.handshaking = false;
        tls$1.queue(c, tls$1.createAlert(c, {
          level: tls$1.Alert.Level.warning,
          description: tls$1.Alert.Description.close_notify
        }));
        tls$1.flush(c);
      }
      c.closed(c);
    }
    c.reset(clearFail);
  };
  return c;
};
forge$8.tls = forge$8.tls || {};
for (var key in tls$1) {
  if (typeof tls$1[key] !== "function") {
    forge$8.tls[key] = tls$1[key];
  }
}
forge$8.tls.prf_tls1 = prf_TLS1;
forge$8.tls.hmac_sha1 = hmac_sha1;
forge$8.tls.createSessionCache = tls$1.createSessionCache;
forge$8.tls.createConnection = tls$1.createConnection;
var forge$7 = forge$C;
var tls = forge$7.tls;
tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
  id: [0, 47],
  name: "TLS_RSA_WITH_AES_128_CBC_SHA",
  initSecurityParameters: function(sp) {
    sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
    sp.cipher_type = tls.CipherType.block;
    sp.enc_key_length = 16;
    sp.block_length = 16;
    sp.fixed_iv_length = 16;
    sp.record_iv_length = 16;
    sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
    sp.mac_length = 20;
    sp.mac_key_length = 20;
  },
  initConnectionState
};
tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
  id: [0, 53],
  name: "TLS_RSA_WITH_AES_256_CBC_SHA",
  initSecurityParameters: function(sp) {
    sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
    sp.cipher_type = tls.CipherType.block;
    sp.enc_key_length = 32;
    sp.block_length = 16;
    sp.fixed_iv_length = 16;
    sp.record_iv_length = 16;
    sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
    sp.mac_length = 20;
    sp.mac_key_length = 20;
  },
  initConnectionState
};
function initConnectionState(state, c, sp) {
  var client2 = c.entity === forge$7.tls.ConnectionEnd.client;
  state.read.cipherState = {
    init: false,
    cipher: forge$7.cipher.createDecipher("AES-CBC", client2 ? sp.keys.server_write_key : sp.keys.client_write_key),
    iv: client2 ? sp.keys.server_write_IV : sp.keys.client_write_IV
  };
  state.write.cipherState = {
    init: false,
    cipher: forge$7.cipher.createCipher("AES-CBC", client2 ? sp.keys.client_write_key : sp.keys.server_write_key),
    iv: client2 ? sp.keys.client_write_IV : sp.keys.server_write_IV
  };
  state.read.cipherFunction = decrypt_aes_cbc_sha1;
  state.write.cipherFunction = encrypt_aes_cbc_sha1;
  state.read.macLength = state.write.macLength = sp.mac_length;
  state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
}
function encrypt_aes_cbc_sha1(record, s2) {
  var rval = false;
  var mac = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
  record.fragment.putBytes(mac);
  s2.updateSequenceNumber();
  var iv;
  if (record.version.minor === tls.Versions.TLS_1_0.minor) {
    iv = s2.cipherState.init ? null : s2.cipherState.iv;
  } else {
    iv = forge$7.random.getBytesSync(16);
  }
  s2.cipherState.init = true;
  var cipher = s2.cipherState.cipher;
  cipher.start({ iv });
  if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
    cipher.output.putBytes(iv);
  }
  cipher.update(record.fragment);
  if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
    record.fragment = cipher.output;
    record.length = record.fragment.length();
    rval = true;
  }
  return rval;
}
function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt2) {
  if (!decrypt2) {
    var padding = blockSize - input.length() % blockSize;
    input.fillWithByte(padding - 1, padding);
  }
  return true;
}
function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt2) {
  var rval = true;
  if (decrypt2) {
    var len = output.length();
    var paddingLength = output.last();
    for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
      rval = rval && output.at(i) == paddingLength;
    }
    if (rval) {
      output.truncate(paddingLength + 1);
    }
  }
  return rval;
}
function decrypt_aes_cbc_sha1(record, s2) {
  var rval = false;
  var iv;
  if (record.version.minor === tls.Versions.TLS_1_0.minor) {
    iv = s2.cipherState.init ? null : s2.cipherState.iv;
  } else {
    iv = record.fragment.getBytes(16);
  }
  s2.cipherState.init = true;
  var cipher = s2.cipherState.cipher;
  cipher.start({ iv });
  cipher.update(record.fragment);
  rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
  var macLen = s2.macLength;
  var mac = forge$7.random.getBytesSync(macLen);
  var len = cipher.output.length();
  if (len >= macLen) {
    record.fragment = cipher.output.getBytes(len - macLen);
    mac = cipher.output.getBytes(macLen);
  } else {
    record.fragment = cipher.output.getBytes();
  }
  record.fragment = forge$7.util.createBuffer(record.fragment);
  record.length = record.fragment.length();
  var mac2 = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
  s2.updateSequenceNumber();
  rval = compareMacs(s2.macKey, mac, mac2) && rval;
  return rval;
}
function compareMacs(key, mac1, mac2) {
  var hmac2 = forge$7.hmac.create();
  hmac2.start("SHA1", key);
  hmac2.update(mac1);
  mac1 = hmac2.digest().getBytes();
  hmac2.start(null, null);
  hmac2.update(mac2);
  mac2 = hmac2.digest().getBytes();
  return mac1 === mac2;
}
var forge$6 = forge$C;
var sha512$1 = forge$6.sha512 = forge$6.sha512 || {};
forge$6.md.sha512 = forge$6.md.algorithms.sha512 = sha512$1;
var sha384 = forge$6.sha384 = forge$6.sha512.sha384 = forge$6.sha512.sha384 || {};
sha384.create = function() {
  return sha512$1.create("SHA-384");
};
forge$6.md.sha384 = forge$6.md.algorithms.sha384 = sha384;
forge$6.sha512.sha256 = forge$6.sha512.sha256 || {
  create: function() {
    return sha512$1.create("SHA-512/256");
  }
};
forge$6.md["sha512/256"] = forge$6.md.algorithms["sha512/256"] = forge$6.sha512.sha256;
forge$6.sha512.sha224 = forge$6.sha512.sha224 || {
  create: function() {
    return sha512$1.create("SHA-512/224");
  }
};
forge$6.md["sha512/224"] = forge$6.md.algorithms["sha512/224"] = forge$6.sha512.sha224;
sha512$1.create = function(algorithm) {
  if (!_initialized) {
    _init();
  }
  if (typeof algorithm === "undefined") {
    algorithm = "SHA-512";
  }
  if (!(algorithm in _states)) {
    throw new Error("Invalid SHA-512 algorithm: " + algorithm);
  }
  var _state2 = _states[algorithm];
  var _h = null;
  var _input = forge$6.util.createBuffer();
  var _w = new Array(80);
  for (var wi = 0; wi < 80; ++wi) {
    _w[wi] = new Array(2);
  }
  var digestLength = 64;
  switch (algorithm) {
    case "SHA-384":
      digestLength = 48;
      break;
    case "SHA-512/256":
      digestLength = 32;
      break;
    case "SHA-512/224":
      digestLength = 28;
      break;
  }
  var md = {
    // SHA-512 => sha512
    algorithm: algorithm.replace("-", "").toLowerCase(),
    blockLength: 128,
    digestLength,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength128 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge$6.util.createBuffer();
    _h = new Array(_state2.length);
    for (var i = 0; i < _state2.length; ++i) {
      _h[i] = _state2[i].slice(0);
    }
    return md;
  };
  md.start();
  md.update = function(msg, encoding3) {
    if (encoding3 === "utf8") {
      msg = forge$6.util.encodeUtf8(msg);
    }
    var len = msg.length;
    md.messageLength += len;
    len = [len / 4294967296 >>> 0, len >>> 0];
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update(_h, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$6.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var h2 = new Array(_h.length);
    for (var i = 0; i < _h.length; ++i) {
      h2[i] = _h[i].slice(0);
    }
    _update(h2, _w, finalBlock);
    var rval = forge$6.util.createBuffer();
    var hlen;
    if (algorithm === "SHA-512") {
      hlen = h2.length;
    } else if (algorithm === "SHA-384") {
      hlen = h2.length - 2;
    } else {
      hlen = h2.length - 4;
    }
    for (var i = 0; i < hlen; ++i) {
      rval.putInt32(h2[i][0]);
      if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
        rval.putInt32(h2[i][1]);
      }
    }
    return rval;
  };
  return md;
};
var _padding = null;
var _initialized = false;
var _k = null;
var _states = null;
function _init() {
  _padding = String.fromCharCode(128);
  _padding += forge$6.util.fillString(String.fromCharCode(0), 128);
  _k = [
    [1116352408, 3609767458],
    [1899447441, 602891725],
    [3049323471, 3964484399],
    [3921009573, 2173295548],
    [961987163, 4081628472],
    [1508970993, 3053834265],
    [2453635748, 2937671579],
    [2870763221, 3664609560],
    [3624381080, 2734883394],
    [310598401, 1164996542],
    [607225278, 1323610764],
    [1426881987, 3590304994],
    [1925078388, 4068182383],
    [2162078206, 991336113],
    [2614888103, 633803317],
    [3248222580, 3479774868],
    [3835390401, 2666613458],
    [4022224774, 944711139],
    [264347078, 2341262773],
    [604807628, 2007800933],
    [770255983, 1495990901],
    [1249150122, 1856431235],
    [1555081692, 3175218132],
    [1996064986, 2198950837],
    [2554220882, 3999719339],
    [2821834349, 766784016],
    [2952996808, 2566594879],
    [3210313671, 3203337956],
    [3336571891, 1034457026],
    [3584528711, 2466948901],
    [113926993, 3758326383],
    [338241895, 168717936],
    [666307205, 1188179964],
    [773529912, 1546045734],
    [1294757372, 1522805485],
    [1396182291, 2643833823],
    [1695183700, 2343527390],
    [1986661051, 1014477480],
    [2177026350, 1206759142],
    [2456956037, 344077627],
    [2730485921, 1290863460],
    [2820302411, 3158454273],
    [3259730800, 3505952657],
    [3345764771, 106217008],
    [3516065817, 3606008344],
    [3600352804, 1432725776],
    [4094571909, 1467031594],
    [275423344, 851169720],
    [430227734, 3100823752],
    [506948616, 1363258195],
    [659060556, 3750685593],
    [883997877, 3785050280],
    [958139571, 3318307427],
    [1322822218, 3812723403],
    [1537002063, 2003034995],
    [1747873779, 3602036899],
    [1955562222, 1575990012],
    [2024104815, 1125592928],
    [2227730452, 2716904306],
    [2361852424, 442776044],
    [2428436474, 593698344],
    [2756734187, 3733110249],
    [3204031479, 2999351573],
    [3329325298, 3815920427],
    [3391569614, 3928383900],
    [3515267271, 566280711],
    [3940187606, 3454069534],
    [4118630271, 4000239992],
    [116418474, 1914138554],
    [174292421, 2731055270],
    [289380356, 3203993006],
    [460393269, 320620315],
    [685471733, 587496836],
    [852142971, 1086792851],
    [1017036298, 365543100],
    [1126000580, 2618297676],
    [1288033470, 3409855158],
    [1501505948, 4234509866],
    [1607167915, 987167468],
    [1816402316, 1246189591]
  ];
  _states = {};
  _states["SHA-512"] = [
    [1779033703, 4089235720],
    [3144134277, 2227873595],
    [1013904242, 4271175723],
    [2773480762, 1595750129],
    [1359893119, 2917565137],
    [2600822924, 725511199],
    [528734635, 4215389547],
    [1541459225, 327033209]
  ];
  _states["SHA-384"] = [
    [3418070365, 3238371032],
    [1654270250, 914150663],
    [2438529370, 812702999],
    [355462360, 4144912697],
    [1731405415, 4290775857],
    [2394180231, 1750603025],
    [3675008525, 1694076839],
    [1203062813, 3204075428]
  ];
  _states["SHA-512/256"] = [
    [573645204, 4230739756],
    [2673172387, 3360449730],
    [596883563, 1867755857],
    [2520282905, 1497426621],
    [2519219938, 2827943907],
    [3193839141, 1401305490],
    [721525244, 746961066],
    [246885852, 2177182882]
  ];
  _states["SHA-512/224"] = [
    [2352822216, 424955298],
    [1944164710, 2312950998],
    [502970286, 855612546],
    [1738396948, 1479516111],
    [258812777, 2077511080],
    [2011393907, 79989058],
    [1067287976, 1780299464],
    [286451373, 2446758561]
  ];
  _initialized = true;
}
function _update(s2, w2, bytes2) {
  var t1_hi, t1_lo;
  var t2_hi, t2_lo;
  var s0_hi, s0_lo;
  var s1_hi, s1_lo;
  var ch_hi, ch_lo;
  var maj_hi, maj_lo;
  var a_hi, a_lo;
  var b_hi, b_lo;
  var c_hi, c_lo;
  var d_hi, d_lo;
  var e_hi, e_lo;
  var f_hi, f_lo;
  var g_hi, g_lo;
  var h_hi, h_lo;
  var i, hi, lo, w22, w7, w15, w16;
  var len = bytes2.length();
  while (len >= 128) {
    for (i = 0; i < 16; ++i) {
      w2[i][0] = bytes2.getInt32() >>> 0;
      w2[i][1] = bytes2.getInt32() >>> 0;
    }
    for (; i < 80; ++i) {
      w22 = w2[i - 2];
      hi = w22[0];
      lo = w22[1];
      t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
      (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
      hi >>> 6) >>> 0;
      t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
      (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
      (hi << 26 | lo >>> 6)) >>> 0;
      w15 = w2[i - 15];
      hi = w15[0];
      lo = w15[1];
      t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
      (hi >>> 8 | lo << 24) ^ // ROTR 8
      hi >>> 7) >>> 0;
      t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
      (hi << 24 | lo >>> 8) ^ // ROTR 8
      (hi << 25 | lo >>> 7)) >>> 0;
      w7 = w2[i - 7];
      w16 = w2[i - 16];
      lo = t1_lo + w7[1] + t2_lo + w16[1];
      w2[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
      w2[i][1] = lo >>> 0;
    }
    a_hi = s2[0][0];
    a_lo = s2[0][1];
    b_hi = s2[1][0];
    b_lo = s2[1][1];
    c_hi = s2[2][0];
    c_lo = s2[2][1];
    d_hi = s2[3][0];
    d_lo = s2[3][1];
    e_hi = s2[4][0];
    e_lo = s2[4][1];
    f_hi = s2[5][0];
    f_lo = s2[5][1];
    g_hi = s2[6][0];
    g_lo = s2[6][1];
    h_hi = s2[7][0];
    h_lo = s2[7][1];
    for (i = 0; i < 80; ++i) {
      s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
      (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
      (e_lo >>> 9 | e_hi << 23)) >>> 0;
      s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
      (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
      (e_lo << 23 | e_hi >>> 9)) >>> 0;
      ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
      ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
      s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
      (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
      (a_lo >>> 7 | a_hi << 25)) >>> 0;
      s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
      (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
      (a_lo << 25 | a_hi >>> 7)) >>> 0;
      maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
      maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
      lo = h_lo + s1_lo + ch_lo + _k[i][1] + w2[i][1];
      t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w2[i][0] + (lo / 4294967296 >>> 0) >>> 0;
      t1_lo = lo >>> 0;
      lo = s0_lo + maj_lo;
      t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
      t2_lo = lo >>> 0;
      h_hi = g_hi;
      h_lo = g_lo;
      g_hi = f_hi;
      g_lo = f_lo;
      f_hi = e_hi;
      f_lo = e_lo;
      lo = d_lo + t1_lo;
      e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
      e_lo = lo >>> 0;
      d_hi = c_hi;
      d_lo = c_lo;
      c_hi = b_hi;
      c_lo = b_lo;
      b_hi = a_hi;
      b_lo = a_lo;
      lo = t1_lo + t2_lo;
      a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
      a_lo = lo >>> 0;
    }
    lo = s2[0][1] + a_lo;
    s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[0][1] = lo >>> 0;
    lo = s2[1][1] + b_lo;
    s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[1][1] = lo >>> 0;
    lo = s2[2][1] + c_lo;
    s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[2][1] = lo >>> 0;
    lo = s2[3][1] + d_lo;
    s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[3][1] = lo >>> 0;
    lo = s2[4][1] + e_lo;
    s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[4][1] = lo >>> 0;
    lo = s2[5][1] + f_lo;
    s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[5][1] = lo >>> 0;
    lo = s2[6][1] + g_lo;
    s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[6][1] = lo >>> 0;
    lo = s2[7][1] + h_lo;
    s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[7][1] = lo >>> 0;
    len -= 128;
  }
}
var asn1Validator$1 = {};
var forge$5 = forge$C;
var asn1$1 = forge$5.asn1;
asn1Validator$1.privateKeyValidator = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.OID,
      constructed: false,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.OCTETSTRING,
    constructed: false,
    capture: "privateKey"
  }]
};
asn1Validator$1.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "subjectPublicKeyInfo",
  value: [
    {
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "publicKeyOid"
      }]
    },
    // capture group for ed25519PublicKey
    {
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.BITSTRING,
      constructed: false,
      composed: true,
      captureBitStringValue: "ed25519PublicKey"
    }
    // FIXME: this is capture group for rsaPublicKey, use it in this API or
    // discard?
    /* {
      // subjectPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      value: [{
        // RSAPublicKey
        name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: 'rsaPublicKey'
      }]
    } */
  ]
};
var forge$4 = forge$C;
var asn1Validator = asn1Validator$1;
var publicKeyValidator = asn1Validator.publicKeyValidator;
var privateKeyValidator = asn1Validator.privateKeyValidator;
if (typeof BigInteger$2 === "undefined") {
  var BigInteger$2 = forge$4.jsbn.BigInteger;
}
var ByteBuffer = forge$4.util.ByteBuffer;
var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
forge$4.pki = forge$4.pki || {};
forge$4.pki.ed25519 = forge$4.ed25519 = forge$4.ed25519 || {};
var ed25519 = forge$4.ed25519;
ed25519.constants = {};
ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
ed25519.constants.SEED_BYTE_LENGTH = 32;
ed25519.constants.SIGN_BYTE_LENGTH = 64;
ed25519.constants.HASH_BYTE_LENGTH = 64;
ed25519.generateKeyPair = function(options2) {
  options2 = options2 || {};
  var seed = options2.seed;
  if (seed === void 0) {
    seed = forge$4.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
  } else if (typeof seed === "string") {
    if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
      throw new TypeError(
        '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
      );
    }
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError(
      '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
    );
  }
  seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
  var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
  for (var i = 0; i < 32; ++i) {
    sk[i] = seed[i];
  }
  crypto_sign_keypair(pk, sk);
  return { publicKey: pk, privateKey: sk };
};
ed25519.privateKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  var valid2 = forge$4.asn1.validate(obj, privateKeyValidator, capture, errors2);
  if (!valid2) {
    var error2 = new Error("Invalid Key.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = forge$4.asn1.derToOid(capture.privateKeyOid);
  var ed25519Oid = forge$4.oids.EdDSA25519;
  if (oid !== ed25519Oid) {
    throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
  }
  var privateKey = capture.privateKey;
  var privateKeyBytes = messageToNativeBuffer({
    message: forge$4.asn1.fromDer(privateKey).value,
    encoding: "binary"
  });
  return { privateKeyBytes };
};
ed25519.publicKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  var valid2 = forge$4.asn1.validate(obj, publicKeyValidator, capture, errors2);
  if (!valid2) {
    var error2 = new Error("Invalid Key.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = forge$4.asn1.derToOid(capture.publicKeyOid);
  var ed25519Oid = forge$4.oids.EdDSA25519;
  if (oid !== ed25519Oid) {
    throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
  }
  var publicKeyBytes = capture.ed25519PublicKey;
  if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
    throw new Error("Key length is invalid.");
  }
  return messageToNativeBuffer({
    message: publicKeyBytes,
    encoding: "binary"
  });
};
ed25519.publicKeyFromPrivateKey = function(options2) {
  options2 = options2 || {};
  var privateKey = messageToNativeBuffer({
    message: options2.privateKey,
    encoding: "binary"
  });
  if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  }
  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
  for (var i = 0; i < pk.length; ++i) {
    pk[i] = privateKey[32 + i];
  }
  return pk;
};
ed25519.sign = function(options2) {
  options2 = options2 || {};
  var msg = messageToNativeBuffer(options2);
  var privateKey = messageToNativeBuffer({
    message: options2.privateKey,
    encoding: "binary"
  });
  if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
    var keyPair = ed25519.generateKeyPair({ seed: privateKey });
    privateKey = keyPair.privateKey;
  } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  }
  var signedMsg = new NativeBuffer(
    ed25519.constants.SIGN_BYTE_LENGTH + msg.length
  );
  crypto_sign(signedMsg, msg, msg.length, privateKey);
  var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
  for (var i = 0; i < sig.length; ++i) {
    sig[i] = signedMsg[i];
  }
  return sig;
};
ed25519.verify = function(options2) {
  options2 = options2 || {};
  var msg = messageToNativeBuffer(options2);
  if (options2.signature === void 0) {
    throw new TypeError(
      '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
    );
  }
  var sig = messageToNativeBuffer({
    message: options2.signature,
    encoding: "binary"
  });
  if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
    throw new TypeError(
      '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
    );
  }
  var publicKey = messageToNativeBuffer({
    message: options2.publicKey,
    encoding: "binary"
  });
  if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
    throw new TypeError(
      '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
    );
  }
  var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
  var m2 = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
  var i;
  for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
    sm[i] = sig[i];
  }
  for (i = 0; i < msg.length; ++i) {
    sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
  }
  return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
};
function messageToNativeBuffer(options2) {
  var message = options2.message;
  if (message instanceof Uint8Array || message instanceof NativeBuffer) {
    return message;
  }
  var encoding3 = options2.encoding;
  if (message === void 0) {
    if (options2.md) {
      message = options2.md.digest().getBytes();
      encoding3 = "binary";
    } else {
      throw new TypeError('"options.message" or "options.md" not specified.');
    }
  }
  if (typeof message === "string" && !encoding3) {
    throw new TypeError('"options.encoding" must be "binary" or "utf8".');
  }
  if (typeof message === "string") {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(message, encoding3);
    }
    message = new ByteBuffer(message, encoding3);
  } else if (!(message instanceof ByteBuffer)) {
    throw new TypeError(
      '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
    );
  }
  var buffer2 = new NativeBuffer(message.length());
  for (var i = 0; i < buffer2.length; ++i) {
    buffer2[i] = message.at(i);
  }
  return buffer2;
}
var gf0 = gf();
var gf1 = gf([1]);
var D = gf([
  30883,
  4953,
  19914,
  30187,
  55467,
  16705,
  2637,
  112,
  59544,
  30585,
  16505,
  36039,
  65139,
  11119,
  27886,
  20995
]);
var D2 = gf([
  61785,
  9906,
  39828,
  60374,
  45398,
  33411,
  5274,
  224,
  53552,
  61171,
  33010,
  6542,
  64743,
  22239,
  55772,
  9222
]);
var X = gf([
  54554,
  36645,
  11616,
  51542,
  42930,
  38181,
  51040,
  26924,
  56412,
  64982,
  57905,
  49316,
  21502,
  52590,
  14035,
  8553
]);
var Y = gf([
  26200,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214
]);
var L = new Float64Array([
  237,
  211,
  245,
  92,
  26,
  99,
  18,
  88,
  214,
  156,
  247,
  162,
  222,
  249,
  222,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16
]);
var I = gf([
  41136,
  18958,
  6951,
  50414,
  58488,
  44335,
  6150,
  12099,
  55207,
  15867,
  153,
  11085,
  57099,
  20417,
  9344,
  11139
]);
function sha512(msg, msgLen) {
  var md = forge$4.md.sha512.create();
  var buffer2 = new ByteBuffer(msg);
  md.update(buffer2.getBytes(msgLen), "binary");
  var hash2 = md.digest().getBytes();
  if (typeof Buffer !== "undefined") {
    return Buffer.from(hash2, "binary");
  }
  var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
  for (var i = 0; i < 64; ++i) {
    out[i] = hash2.charCodeAt(i);
  }
  return out;
}
function crypto_sign_keypair(pk, sk) {
  var p = [gf(), gf(), gf(), gf()];
  var i;
  var d2 = sha512(sk, 32);
  d2[0] &= 248;
  d2[31] &= 127;
  d2[31] |= 64;
  scalarbase(p, d2);
  pack(pk, p);
  for (i = 0; i < 32; ++i) {
    sk[i + 32] = pk[i];
  }
  return 0;
}
function crypto_sign(sm, m2, n, sk) {
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var d2 = sha512(sk, 32);
  d2[0] &= 248;
  d2[31] &= 127;
  d2[31] |= 64;
  var smlen = n + 64;
  for (i = 0; i < n; ++i) {
    sm[64 + i] = m2[i];
  }
  for (i = 0; i < 32; ++i) {
    sm[32 + i] = d2[32 + i];
  }
  var r = sha512(sm.subarray(32), n + 32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);
  for (i = 32; i < 64; ++i) {
    sm[i] = sk[i];
  }
  var h2 = sha512(sm, n + 64);
  reduce(h2);
  for (i = 32; i < 64; ++i) {
    x[i] = 0;
  }
  for (i = 0; i < 32; ++i) {
    x[i] = r[i];
  }
  for (i = 0; i < 32; ++i) {
    for (j = 0; j < 32; j++) {
      x[i + j] += h2[i] * d2[j];
    }
  }
  modL(sm.subarray(32), x);
  return smlen;
}
function crypto_sign_open(m2, sm, n, pk) {
  var i, mlen;
  var t2 = new NativeBuffer(32);
  var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
  mlen = -1;
  if (n < 64) {
    return -1;
  }
  if (unpackneg(q, pk)) {
    return -1;
  }
  for (i = 0; i < n; ++i) {
    m2[i] = sm[i];
  }
  for (i = 0; i < 32; ++i) {
    m2[i + 32] = pk[i];
  }
  var h2 = sha512(m2, n);
  reduce(h2);
  scalarmult(p, q, h2);
  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t2, p);
  n -= 64;
  if (crypto_verify_32(sm, 0, t2, 0)) {
    for (i = 0; i < n; ++i) {
      m2[i] = 0;
    }
    return -1;
  }
  for (i = 0; i < n; ++i) {
    m2[i] = sm[i + 64];
  }
  mlen = n;
  return mlen;
}
function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = x[j] + 128 >> 8;
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; ++j) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; ++j) {
    x[j] -= carry * L[j];
  }
  for (i = 0; i < 32; ++i) {
    x[i + 1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}
function reduce(r) {
  var x = new Float64Array(64);
  for (var i = 0; i < 64; ++i) {
    x[i] = r[i];
    r[i] = 0;
  }
  modL(r, x);
}
function add(p, q) {
  var a = gf(), b = gf(), c = gf(), d2 = gf(), e = gf(), f = gf(), g = gf(), h2 = gf(), t2 = gf();
  Z(a, p[1], p[0]);
  Z(t2, q[1], q[0]);
  M(a, a, t2);
  A(b, p[0], p[1]);
  A(t2, q[0], q[1]);
  M(b, b, t2);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d2, p[2], q[2]);
  A(d2, d2, d2);
  Z(e, b, a);
  Z(f, d2, c);
  A(g, d2, c);
  A(h2, b, a);
  M(p[0], e, f);
  M(p[1], h2, g);
  M(p[2], g, f);
  M(p[3], e, h2);
}
function cswap(p, q, b) {
  for (var i = 0; i < 4; ++i) {
    sel25519(p[i], q[i], b);
  }
}
function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}
function pack25519(o, n) {
  var i, j, b;
  var m2 = gf(), t2 = gf();
  for (i = 0; i < 16; ++i) {
    t2[i] = n[i];
  }
  car25519(t2);
  car25519(t2);
  car25519(t2);
  for (j = 0; j < 2; ++j) {
    m2[0] = t2[0] - 65517;
    for (i = 1; i < 15; ++i) {
      m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1);
      m2[i - 1] &= 65535;
    }
    m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
    b = m2[15] >> 16 & 1;
    m2[14] &= 65535;
    sel25519(t2, m2, 1 - b);
  }
  for (i = 0; i < 16; i++) {
    o[2 * i] = t2[i] & 255;
    o[2 * i + 1] = t2[i] >> 8;
  }
}
function unpackneg(r, p) {
  var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);
  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t2, den6, num);
  M(t2, t2, den);
  pow2523(t2, t2);
  M(t2, t2, num);
  M(t2, t2, den);
  M(t2, t2, den);
  M(r[0], t2, den);
  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) {
    M(r[0], r[0], I);
  }
  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) {
    return -1;
  }
  if (par25519(r[0]) === p[31] >> 7) {
    Z(r[0], gf0, r[0]);
  }
  M(r[3], r[0], r[1]);
  return 0;
}
function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; ++i) {
    o[i] = n[2 * i] + (n[2 * i + 1] << 8);
  }
  o[15] &= 32767;
}
function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; ++a) {
    c[a] = i[a];
  }
  for (a = 250; a >= 0; --a) {
    S(c, c);
    if (a !== 1) {
      M(c, c, i);
    }
  }
  for (a = 0; a < 16; ++a) {
    o[a] = c[a];
  }
}
function neq25519(a, b) {
  var c = new NativeBuffer(32);
  var d2 = new NativeBuffer(32);
  pack25519(c, a);
  pack25519(d2, b);
  return crypto_verify_32(c, 0, d2, 0);
}
function crypto_verify_32(x, xi, y2, yi) {
  return vn(x, xi, y2, yi, 32);
}
function vn(x, xi, y2, yi, n) {
  var i, d2 = 0;
  for (i = 0; i < n; ++i) {
    d2 |= x[xi + i] ^ y2[yi + i];
  }
  return (1 & d2 - 1 >>> 8) - 1;
}
function par25519(a) {
  var d2 = new NativeBuffer(32);
  pack25519(d2, a);
  return d2[0] & 1;
}
function scalarmult(p, q, s2) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = s2[i / 8 | 0] >> (i & 7) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}
function scalarbase(p, s2) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s2);
}
function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) {
    r[i] = a[i] | 0;
  }
}
function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; ++a) {
    c[a] = i[a];
  }
  for (a = 253; a >= 0; --a) {
    S(c, c);
    if (a !== 2 && a !== 4) {
      M(c, c, i);
    }
  }
  for (a = 0; a < 16; ++a) {
    o[a] = c[a];
  }
}
function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; ++i) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
  var t2, c = ~(b - 1);
  for (var i = 0; i < 16; ++i) {
    t2 = c & (p[i] ^ q[i]);
    p[i] ^= t2;
    q[i] ^= t2;
  }
}
function gf(init2) {
  var i, r = new Float64Array(16);
  if (init2) {
    for (i = 0; i < init2.length; ++i) {
      r[i] = init2[i];
    }
  }
  return r;
}
function A(o, a, b) {
  for (var i = 0; i < 16; ++i) {
    o[i] = a[i] + b[i];
  }
}
function Z(o, a, b) {
  for (var i = 0; i < 16; ++i) {
    o[i] = a[i] - b[i];
  }
}
function S(o, a) {
  M(o, a, a);
}
function M(o, a, b) {
  var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;
  t0 += 38 * t16;
  t1 += 38 * t17;
  t2 += 38 * t18;
  t3 += 38 * t19;
  t4 += 38 * t20;
  t5 += 38 * t21;
  t6 += 38 * t22;
  t7 += 38 * t23;
  t8 += 38 * t24;
  t9 += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  c = 1;
  v = t0 + c + 65535;
  c = Math.floor(v / 65536);
  t0 = v - c * 65536;
  v = t1 + c + 65535;
  c = Math.floor(v / 65536);
  t1 = v - c * 65536;
  v = t2 + c + 65535;
  c = Math.floor(v / 65536);
  t2 = v - c * 65536;
  v = t3 + c + 65535;
  c = Math.floor(v / 65536);
  t3 = v - c * 65536;
  v = t4 + c + 65535;
  c = Math.floor(v / 65536);
  t4 = v - c * 65536;
  v = t5 + c + 65535;
  c = Math.floor(v / 65536);
  t5 = v - c * 65536;
  v = t6 + c + 65535;
  c = Math.floor(v / 65536);
  t6 = v - c * 65536;
  v = t7 + c + 65535;
  c = Math.floor(v / 65536);
  t7 = v - c * 65536;
  v = t8 + c + 65535;
  c = Math.floor(v / 65536);
  t8 = v - c * 65536;
  v = t9 + c + 65535;
  c = Math.floor(v / 65536);
  t9 = v - c * 65536;
  v = t10 + c + 65535;
  c = Math.floor(v / 65536);
  t10 = v - c * 65536;
  v = t11 + c + 65535;
  c = Math.floor(v / 65536);
  t11 = v - c * 65536;
  v = t12 + c + 65535;
  c = Math.floor(v / 65536);
  t12 = v - c * 65536;
  v = t13 + c + 65535;
  c = Math.floor(v / 65536);
  t13 = v - c * 65536;
  v = t14 + c + 65535;
  c = Math.floor(v / 65536);
  t14 = v - c * 65536;
  v = t15 + c + 65535;
  c = Math.floor(v / 65536);
  t15 = v - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  c = 1;
  v = t0 + c + 65535;
  c = Math.floor(v / 65536);
  t0 = v - c * 65536;
  v = t1 + c + 65535;
  c = Math.floor(v / 65536);
  t1 = v - c * 65536;
  v = t2 + c + 65535;
  c = Math.floor(v / 65536);
  t2 = v - c * 65536;
  v = t3 + c + 65535;
  c = Math.floor(v / 65536);
  t3 = v - c * 65536;
  v = t4 + c + 65535;
  c = Math.floor(v / 65536);
  t4 = v - c * 65536;
  v = t5 + c + 65535;
  c = Math.floor(v / 65536);
  t5 = v - c * 65536;
  v = t6 + c + 65535;
  c = Math.floor(v / 65536);
  t6 = v - c * 65536;
  v = t7 + c + 65535;
  c = Math.floor(v / 65536);
  t7 = v - c * 65536;
  v = t8 + c + 65535;
  c = Math.floor(v / 65536);
  t8 = v - c * 65536;
  v = t9 + c + 65535;
  c = Math.floor(v / 65536);
  t9 = v - c * 65536;
  v = t10 + c + 65535;
  c = Math.floor(v / 65536);
  t10 = v - c * 65536;
  v = t11 + c + 65535;
  c = Math.floor(v / 65536);
  t11 = v - c * 65536;
  v = t12 + c + 65535;
  c = Math.floor(v / 65536);
  t12 = v - c * 65536;
  v = t13 + c + 65535;
  c = Math.floor(v / 65536);
  t13 = v - c * 65536;
  v = t14 + c + 65535;
  c = Math.floor(v / 65536);
  t14 = v - c * 65536;
  v = t15 + c + 65535;
  c = Math.floor(v / 65536);
  t15 = v - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  o[0] = t0;
  o[1] = t1;
  o[2] = t2;
  o[3] = t3;
  o[4] = t4;
  o[5] = t5;
  o[6] = t6;
  o[7] = t7;
  o[8] = t8;
  o[9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}
var forge$3 = forge$C;
forge$3.kem = forge$3.kem || {};
var BigInteger$1 = forge$3.jsbn.BigInteger;
forge$3.kem.rsa = {};
forge$3.kem.rsa.create = function(kdf, options2) {
  options2 = options2 || {};
  var prng2 = options2.prng || forge$3.random;
  var kem = {};
  kem.encrypt = function(publicKey, keyLength) {
    var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
    var r;
    do {
      r = new BigInteger$1(
        forge$3.util.bytesToHex(prng2.getBytesSync(byteLength)),
        16
      ).mod(publicKey.n);
    } while (r.compareTo(BigInteger$1.ONE) <= 0);
    r = forge$3.util.hexToBytes(r.toString(16));
    var zeros = byteLength - r.length;
    if (zeros > 0) {
      r = forge$3.util.fillString(String.fromCharCode(0), zeros) + r;
    }
    var encapsulation = publicKey.encrypt(r, "NONE");
    var key = kdf.generate(r, keyLength);
    return { encapsulation, key };
  };
  kem.decrypt = function(privateKey, encapsulation, keyLength) {
    var r = privateKey.decrypt(encapsulation, "NONE");
    return kdf.generate(r, keyLength);
  };
  return kem;
};
forge$3.kem.kdf1 = function(md, digestLength) {
  _createKDF(this, md, 0, digestLength || md.digestLength);
};
forge$3.kem.kdf2 = function(md, digestLength) {
  _createKDF(this, md, 1, digestLength || md.digestLength);
};
function _createKDF(kdf, md, counterStart, digestLength) {
  kdf.generate = function(x, length) {
    var key = new forge$3.util.ByteBuffer();
    var k = Math.ceil(length / digestLength) + counterStart;
    var c = new forge$3.util.ByteBuffer();
    for (var i = counterStart; i < k; ++i) {
      c.putInt32(i);
      md.start();
      md.update(x + c.getBytes());
      var hash2 = md.digest();
      key.putBytes(hash2.getBytes(digestLength));
    }
    key.truncate(key.length() - length);
    return key.getBytes();
  };
}
var forge$2 = forge$C;
forge$2.log = forge$2.log || {};
forge$2.log.levels = [
  "none",
  "error",
  "warning",
  "info",
  "debug",
  "verbose",
  "max"
];
var sLevelInfo = {};
var sLoggers = [];
var sConsoleLogger = null;
forge$2.log.LEVEL_LOCKED = 1 << 1;
forge$2.log.NO_LEVEL_CHECK = 1 << 2;
forge$2.log.INTERPOLATE = 1 << 3;
for (var i = 0; i < forge$2.log.levels.length; ++i) {
  var level = forge$2.log.levels[i];
  sLevelInfo[level] = {
    index: i,
    name: level.toUpperCase()
  };
}
forge$2.log.logMessage = function(message) {
  var messageLevelIndex = sLevelInfo[message.level].index;
  for (var i = 0; i < sLoggers.length; ++i) {
    var logger = sLoggers[i];
    if (logger.flags & forge$2.log.NO_LEVEL_CHECK) {
      logger.f(message);
    } else {
      var loggerLevelIndex = sLevelInfo[logger.level].index;
      if (messageLevelIndex <= loggerLevelIndex) {
        logger.f(logger, message);
      }
    }
  }
};
forge$2.log.prepareStandard = function(message) {
  if (!("standard" in message)) {
    message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +
    " [" + message.category + "] " + message.message;
  }
};
forge$2.log.prepareFull = function(message) {
  if (!("full" in message)) {
    var args = [message.message];
    args = args.concat([]);
    message.full = forge$2.util.format.apply(this, args);
  }
};
forge$2.log.prepareStandardFull = function(message) {
  if (!("standardFull" in message)) {
    forge$2.log.prepareStandard(message);
    message.standardFull = message.standard;
  }
};
{
  var levels = ["error", "warning", "info", "debug", "verbose"];
  for (var i = 0; i < levels.length; ++i) {
    (function(level) {
      forge$2.log[level] = function(category, message) {
        var args = Array.prototype.slice.call(arguments).slice(2);
        var msg = {
          timestamp: /* @__PURE__ */ new Date(),
          level,
          category,
          message,
          "arguments": args
          /*standard*/
          /*full*/
          /*fullMessage*/
        };
        forge$2.log.logMessage(msg);
      };
    })(levels[i]);
  }
}
forge$2.log.makeLogger = function(logFunction) {
  var logger = {
    flags: 0,
    f: logFunction
  };
  forge$2.log.setLevel(logger, "none");
  return logger;
};
forge$2.log.setLevel = function(logger, level) {
  var rval = false;
  if (logger && !(logger.flags & forge$2.log.LEVEL_LOCKED)) {
    for (var i = 0; i < forge$2.log.levels.length; ++i) {
      var aValidLevel = forge$2.log.levels[i];
      if (level == aValidLevel) {
        logger.level = level;
        rval = true;
        break;
      }
    }
  }
  return rval;
};
forge$2.log.lock = function(logger, lock) {
  if (typeof lock === "undefined" || lock) {
    logger.flags |= forge$2.log.LEVEL_LOCKED;
  } else {
    logger.flags &= ~forge$2.log.LEVEL_LOCKED;
  }
};
forge$2.log.addLogger = function(logger) {
  sLoggers.push(logger);
};
if (typeof console !== "undefined" && "log" in console) {
  var logger;
  if (console.error && console.warn && console.info && console.debug) {
    var levelHandlers = {
      error: console.error,
      warning: console.warn,
      info: console.info,
      debug: console.debug,
      verbose: console.debug
    };
    var f = function(logger2, message) {
      forge$2.log.prepareStandard(message);
      var handler = levelHandlers[message.level];
      var args = [message.standard];
      args = args.concat(message["arguments"].slice());
      handler.apply(console, args);
    };
    logger = forge$2.log.makeLogger(f);
  } else {
    var f = function(logger2, message) {
      forge$2.log.prepareStandardFull(message);
      console.log(message.standardFull);
    };
    logger = forge$2.log.makeLogger(f);
  }
  forge$2.log.setLevel(logger, "debug");
  forge$2.log.addLogger(logger);
  sConsoleLogger = logger;
} else {
  console = {
    log: function() {
    }
  };
}
if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
  var query = new URL(window.location.href).searchParams;
  if (query.has("console.level")) {
    forge$2.log.setLevel(
      sConsoleLogger,
      query.get("console.level").slice(-1)[0]
    );
  }
  if (query.has("console.lock")) {
    var lock = query.get("console.lock").slice(-1)[0];
    if (lock == "true") {
      forge$2.log.lock(sConsoleLogger);
    }
  }
}
forge$2.log.consoleLogger = sConsoleLogger;
var forge$1 = forge$C;
var asn1 = forge$1.asn1;
var p7 = forge$1.pkcs7 = forge$1.pkcs7 || {};
p7.messageFromPem = function(pem2) {
  var msg = forge$1.pem.decode(pem2)[0];
  if (msg.type !== "PKCS7") {
    var error2 = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
  }
  var obj = asn1.fromDer(msg.body);
  return p7.messageFromAsn1(obj);
};
p7.messageToPem = function(msg, maxline) {
  var pemObj = {
    type: "PKCS7",
    body: asn1.toDer(msg.toAsn1()).getBytes()
  };
  return forge$1.pem.encode(pemObj, { maxline });
};
p7.messageFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var contentType3 = asn1.derToOid(capture.contentType);
  var msg;
  switch (contentType3) {
    case forge$1.pki.oids.envelopedData:
      msg = p7.createEnvelopedData();
      break;
    case forge$1.pki.oids.encryptedData:
      msg = p7.createEncryptedData();
      break;
    case forge$1.pki.oids.signedData:
      msg = p7.createSignedData();
      break;
    default:
      throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType3 + " is not (yet) supported.");
  }
  msg.fromAsn1(capture.content.value[0]);
  return msg;
};
p7.createSignedData = function() {
  var msg = null;
  msg = {
    type: forge$1.pki.oids.signedData,
    version: 1,
    certificates: [],
    crls: [],
    // TODO: add json-formatted signer stuff here?
    signers: [],
    // populated during sign()
    digestAlgorithmIdentifiers: [],
    contentInfo: null,
    signerInfos: [],
    fromAsn1: function(obj) {
      _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
      msg.certificates = [];
      msg.crls = [];
      msg.digestAlgorithmIdentifiers = [];
      msg.contentInfo = null;
      msg.signerInfos = [];
      if (msg.rawCapture.certificates) {
        var certs = msg.rawCapture.certificates.value;
        for (var i = 0; i < certs.length; ++i) {
          msg.certificates.push(forge$1.pki.certificateFromAsn1(certs[i]));
        }
      }
    },
    toAsn1: function() {
      if (!msg.contentInfo) {
        msg.sign();
      }
      var certs = [];
      for (var i = 0; i < msg.certificates.length; ++i) {
        certs.push(forge$1.pki.certificateToAsn1(msg.certificates[i]));
      }
      var crls = [];
      var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Version
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(msg.version).getBytes()
          ),
          // DigestAlgorithmIdentifiers
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SET,
            true,
            msg.digestAlgorithmIdentifiers
          ),
          // ContentInfo
          msg.contentInfo
        ])
      ]);
      if (certs.length > 0) {
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
        );
      }
      if (crls.length > 0) {
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
        );
      }
      signedData.value[0].value.push(
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SET,
          true,
          msg.signerInfos
        )
      );
      return asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        [
          // ContentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(msg.type).getBytes()
          ),
          // [0] SignedData
          signedData
        ]
      );
    },
    /**
     * Add (another) entity to list of signers.
     *
     * Note: If authenticatedAttributes are provided, then, per RFC 2315,
     * they must include at least two attributes: content type and
     * message digest. The message digest attribute value will be
     * auto-calculated during signing and will be ignored if provided.
     *
     * Here's an example of providing these two attributes:
     *
     * forge.pkcs7.createSignedData();
     * p7.addSigner({
     *   issuer: cert.issuer.attributes,
     *   serialNumber: cert.serialNumber,
     *   key: privateKey,
     *   digestAlgorithm: forge.pki.oids.sha1,
     *   authenticatedAttributes: [{
     *     type: forge.pki.oids.contentType,
     *     value: forge.pki.oids.data
     *   }, {
     *     type: forge.pki.oids.messageDigest
     *   }]
     * });
     *
     * TODO: Support [subjectKeyIdentifier] as signer's ID.
     *
     * @param signer the signer information:
     *          key the signer's private key.
     *          [certificate] a certificate containing the public key
     *            associated with the signer's private key; use this option as
     *            an alternative to specifying signer.issuer and
     *            signer.serialNumber.
     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
     *          [serialNumber] the signer's certificate's serial number in
     *           hexadecimal (eg: cert.serialNumber).
     *          [digestAlgorithm] the message digest OID, as a string, to use
     *            (eg: forge.pki.oids.sha1).
     *          [authenticatedAttributes] an optional array of attributes
     *            to also sign along with the content.
     */
    addSigner: function(signer) {
      var issuer = signer.issuer;
      var serialNumber = signer.serialNumber;
      if (signer.certificate) {
        var cert = signer.certificate;
        if (typeof cert === "string") {
          cert = forge$1.pki.certificateFromPem(cert);
        }
        issuer = cert.issuer.attributes;
        serialNumber = cert.serialNumber;
      }
      var key = signer.key;
      if (!key) {
        throw new Error(
          "Could not add PKCS#7 signer; no private key specified."
        );
      }
      if (typeof key === "string") {
        key = forge$1.pki.privateKeyFromPem(key);
      }
      var digestAlgorithm = signer.digestAlgorithm || forge$1.pki.oids.sha1;
      switch (digestAlgorithm) {
        case forge$1.pki.oids.sha1:
        case forge$1.pki.oids.sha256:
        case forge$1.pki.oids.sha384:
        case forge$1.pki.oids.sha512:
        case forge$1.pki.oids.md5:
          break;
        default:
          throw new Error(
            "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
          );
      }
      var authenticatedAttributes = signer.authenticatedAttributes || [];
      if (authenticatedAttributes.length > 0) {
        var contentType3 = false;
        var messageDigest = false;
        for (var i = 0; i < authenticatedAttributes.length; ++i) {
          var attr = authenticatedAttributes[i];
          if (!contentType3 && attr.type === forge$1.pki.oids.contentType) {
            contentType3 = true;
            if (messageDigest) {
              break;
            }
            continue;
          }
          if (!messageDigest && attr.type === forge$1.pki.oids.messageDigest) {
            messageDigest = true;
            if (contentType3) {
              break;
            }
            continue;
          }
        }
        if (!contentType3 || !messageDigest) {
          throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
        }
      }
      msg.signers.push({
        key,
        version: 1,
        issuer,
        serialNumber,
        digestAlgorithm,
        signatureAlgorithm: forge$1.pki.oids.rsaEncryption,
        signature: null,
        authenticatedAttributes,
        unauthenticatedAttributes: []
      });
    },
    /**
     * Signs the content.
     * @param options Options to apply when signing:
     *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
     */
    sign: function(options2) {
      options2 = options2 || {};
      if (typeof msg.content !== "object" || msg.contentInfo === null) {
        msg.contentInfo = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(forge$1.pki.oids.data).getBytes()
            )
          ]
        );
        if ("content" in msg) {
          var content;
          if (msg.content instanceof forge$1.util.ByteBuffer) {
            content = msg.content.bytes();
          } else if (typeof msg.content === "string") {
            content = forge$1.util.encodeUtf8(msg.content);
          }
          if (options2.detached) {
            msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
          } else {
            msg.contentInfo.value.push(
              // [0] EXPLICIT content
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  content
                )
              ])
            );
          }
        }
      }
      if (msg.signers.length === 0) {
        return;
      }
      var mds = addDigestAlgorithmIds();
      addSignerInfos(mds);
    },
    verify: function() {
      throw new Error("PKCS#7 signature verification not yet implemented.");
    },
    /**
     * Add a certificate.
     *
     * @param cert the certificate to add.
     */
    addCertificate: function(cert) {
      if (typeof cert === "string") {
        cert = forge$1.pki.certificateFromPem(cert);
      }
      msg.certificates.push(cert);
    },
    /**
     * Add a certificate revokation list.
     *
     * @param crl the certificate revokation list to add.
     */
    addCertificateRevokationList: function(crl) {
      throw new Error("PKCS#7 CRL support not yet implemented.");
    }
  };
  return msg;
  function addDigestAlgorithmIds() {
    var mds = {};
    for (var i = 0; i < msg.signers.length; ++i) {
      var signer = msg.signers[i];
      var oid = signer.digestAlgorithm;
      if (!(oid in mds)) {
        mds[oid] = forge$1.md[forge$1.pki.oids[oid]].create();
      }
      if (signer.authenticatedAttributes.length === 0) {
        signer.md = mds[oid];
      } else {
        signer.md = forge$1.md[forge$1.pki.oids[oid]].create();
      }
    }
    msg.digestAlgorithmIdentifiers = [];
    for (var oid in mds) {
      msg.digestAlgorithmIdentifiers.push(
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(oid).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      );
    }
    return mds;
  }
  function addSignerInfos(mds) {
    var content;
    if (msg.detachedContent) {
      content = msg.detachedContent;
    } else {
      content = msg.contentInfo.value[1];
      content = content.value[0];
    }
    if (!content) {
      throw new Error(
        "Could not sign PKCS#7 message; there is no content to sign."
      );
    }
    var contentType3 = asn1.derToOid(msg.contentInfo.value[0].value);
    var bytes2 = asn1.toDer(content);
    bytes2.getByte();
    asn1.getBerValueLength(bytes2);
    bytes2 = bytes2.getBytes();
    for (var oid in mds) {
      mds[oid].start().update(bytes2);
    }
    var signingTime = /* @__PURE__ */ new Date();
    for (var i = 0; i < msg.signers.length; ++i) {
      var signer = msg.signers[i];
      if (signer.authenticatedAttributes.length === 0) {
        if (contentType3 !== forge$1.pki.oids.data) {
          throw new Error(
            "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
          );
        }
      } else {
        signer.authenticatedAttributesAsn1 = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var attrsAsn1 = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SET,
          true,
          []
        );
        for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
          var attr = signer.authenticatedAttributes[ai];
          if (attr.type === forge$1.pki.oids.messageDigest) {
            attr.value = mds[signer.digestAlgorithm].digest();
          } else if (attr.type === forge$1.pki.oids.signingTime) {
            if (!attr.value) {
              attr.value = signingTime;
            }
          }
          attrsAsn1.value.push(_attributeToAsn1(attr));
          signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
        }
        bytes2 = asn1.toDer(attrsAsn1).getBytes();
        signer.md.start().update(bytes2);
      }
      signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
    }
    msg.signerInfos = _signersToAsn1(msg.signers);
  }
};
p7.createEncryptedData = function() {
  var msg = null;
  msg = {
    type: forge$1.pki.oids.encryptedData,
    version: 0,
    encryptedContent: {
      algorithm: forge$1.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EncryptedData content block (in ASN.1 format)
     *
     * @param obj The ASN.1 representation of the EncryptedData content block
     */
    fromAsn1: function(obj) {
      _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
    },
    /**
     * Decrypt encrypted content
     *
     * @param key The (symmetric) key as a byte buffer
     */
    decrypt: function(key) {
      if (key !== void 0) {
        msg.encryptedContent.key = key;
      }
      _decryptContent(msg);
    }
  };
  return msg;
};
p7.createEnvelopedData = function() {
  var msg = null;
  msg = {
    type: forge$1.pki.oids.envelopedData,
    version: 0,
    recipients: [],
    encryptedContent: {
      algorithm: forge$1.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EnvelopedData content block (in ASN.1 format)
     *
     * @param obj the ASN.1 representation of the EnvelopedData content block.
     */
    fromAsn1: function(obj) {
      var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
      msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
    },
    toAsn1: function() {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // ContentType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(msg.type).getBytes()
        ),
        // [0] EnvelopedData
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // Version
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              asn1.integerToDer(msg.version).getBytes()
            ),
            // RecipientInfos
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              _recipientsToAsn1(msg.recipients)
            ),
            // EncryptedContentInfo
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              _encryptedContentToAsn1(msg.encryptedContent)
            )
          ])
        ])
      ]);
    },
    /**
     * Find recipient by X.509 certificate's issuer.
     *
     * @param cert the certificate with the issuer to look for.
     *
     * @return the recipient object.
     */
    findRecipient: function(cert) {
      var sAttr = cert.issuer.attributes;
      for (var i = 0; i < msg.recipients.length; ++i) {
        var r = msg.recipients[i];
        var rAttr = r.issuer;
        if (r.serialNumber !== cert.serialNumber) {
          continue;
        }
        if (rAttr.length !== sAttr.length) {
          continue;
        }
        var match2 = true;
        for (var j = 0; j < sAttr.length; ++j) {
          if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
            match2 = false;
            break;
          }
        }
        if (match2) {
          return r;
        }
      }
      return null;
    },
    /**
     * Decrypt enveloped content
     *
     * @param recipient The recipient object related to the private key
     * @param privKey The (RSA) private key object
     */
    decrypt: function(recipient, privKey) {
      if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
        switch (recipient.encryptedContent.algorithm) {
          case forge$1.pki.oids.rsaEncryption:
          case forge$1.pki.oids.desCBC:
            var key = privKey.decrypt(recipient.encryptedContent.content);
            msg.encryptedContent.key = forge$1.util.createBuffer(key);
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
        }
      }
      _decryptContent(msg);
    },
    /**
     * Add (another) entity to list of recipients.
     *
     * @param cert The certificate of the entity to add.
     */
    addRecipient: function(cert) {
      msg.recipients.push({
        version: 0,
        issuer: cert.issuer.attributes,
        serialNumber: cert.serialNumber,
        encryptedContent: {
          // We simply assume rsaEncryption here, since forge.pki only
          // supports RSA so far.  If the PKI module supports other
          // ciphers one day, we need to modify this one as well.
          algorithm: forge$1.pki.oids.rsaEncryption,
          key: cert.publicKey
        }
      });
    },
    /**
     * Encrypt enveloped content.
     *
     * This function supports two optional arguments, cipher and key, which
     * can be used to influence symmetric encryption.  Unless cipher is
     * provided, the cipher specified in encryptedContent.algorithm is used
     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
     * is (re-)used.  If that one's not set, a random key will be generated
     * automatically.
     *
     * @param [key] The key to be used for symmetric encryption.
     * @param [cipher] The OID of the symmetric cipher to use.
     */
    encrypt: function(key, cipher) {
      if (msg.encryptedContent.content === void 0) {
        cipher = cipher || msg.encryptedContent.algorithm;
        key = key || msg.encryptedContent.key;
        var keyLen, ivLen, ciphFn;
        switch (cipher) {
          case forge$1.pki.oids["aes128-CBC"]:
            keyLen = 16;
            ivLen = 16;
            ciphFn = forge$1.aes.createEncryptionCipher;
            break;
          case forge$1.pki.oids["aes192-CBC"]:
            keyLen = 24;
            ivLen = 16;
            ciphFn = forge$1.aes.createEncryptionCipher;
            break;
          case forge$1.pki.oids["aes256-CBC"]:
            keyLen = 32;
            ivLen = 16;
            ciphFn = forge$1.aes.createEncryptionCipher;
            break;
          case forge$1.pki.oids["des-EDE3-CBC"]:
            keyLen = 24;
            ivLen = 8;
            ciphFn = forge$1.des.createEncryptionCipher;
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + cipher);
        }
        if (key === void 0) {
          key = forge$1.util.createBuffer(forge$1.random.getBytes(keyLen));
        } else if (key.length() != keyLen) {
          throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
        }
        msg.encryptedContent.algorithm = cipher;
        msg.encryptedContent.key = key;
        msg.encryptedContent.parameter = forge$1.util.createBuffer(
          forge$1.random.getBytes(ivLen)
        );
        var ciph = ciphFn(key);
        ciph.start(msg.encryptedContent.parameter.copy());
        ciph.update(msg.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric encryption failed.");
        }
        msg.encryptedContent.content = ciph.output;
      }
      for (var i = 0; i < msg.recipients.length; ++i) {
        var recipient = msg.recipients[i];
        if (recipient.encryptedContent.content !== void 0) {
          continue;
        }
        switch (recipient.encryptedContent.algorithm) {
          case forge$1.pki.oids.rsaEncryption:
            recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
              msg.encryptedContent.key.data
            );
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
        }
      }
    }
  };
  return msg;
};
function _recipientFromAsn1(obj) {
  var capture = {};
  var errors2 = [];
  if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
    error2.errors = errors2;
    throw error2;
  }
  return {
    version: capture.version.charCodeAt(0),
    issuer: forge$1.pki.RDNAttributesAsArray(capture.issuer),
    serialNumber: forge$1.util.createBuffer(capture.serial).toHex(),
    encryptedContent: {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: capture.encParameter ? capture.encParameter.value : void 0,
      content: capture.encKey
    }
  };
}
function _recipientToAsn1(obj) {
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // Version
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      false,
      asn1.integerToDer(obj.version).getBytes()
    ),
    // IssuerAndSerialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // Name
      forge$1.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
      // Serial
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.INTEGER,
        false,
        forge$1.util.hexToBytes(obj.serialNumber)
      )
    ]),
    // KeyEncryptionAlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // Algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
      ),
      // Parameter, force NULL, only RSA supported for now.
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
    ]),
    // EncryptedKey
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      false,
      obj.encryptedContent.content
    )
  ]);
}
function _recipientsFromAsn1(infos) {
  var ret = [];
  for (var i = 0; i < infos.length; ++i) {
    ret.push(_recipientFromAsn1(infos[i]));
  }
  return ret;
}
function _recipientsToAsn1(recipients) {
  var ret = [];
  for (var i = 0; i < recipients.length; ++i) {
    ret.push(_recipientToAsn1(recipients[i]));
  }
  return ret;
}
function _signerToAsn1(obj) {
  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      false,
      asn1.integerToDer(obj.version).getBytes()
    ),
    // issuerAndSerialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // name
      forge$1.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
      // serial
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.INTEGER,
        false,
        forge$1.util.hexToBytes(obj.serialNumber)
      )
    ]),
    // digestAlgorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(obj.digestAlgorithm).getBytes()
      ),
      // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
    ])
  ]);
  if (obj.authenticatedAttributesAsn1) {
    rval.value.push(obj.authenticatedAttributesAsn1);
  }
  rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // algorithm
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(obj.signatureAlgorithm).getBytes()
    ),
    // parameters (null)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
  ]));
  rval.value.push(asn1.create(
    asn1.Class.UNIVERSAL,
    asn1.Type.OCTETSTRING,
    false,
    obj.signature
  ));
  if (obj.unauthenticatedAttributes.length > 0) {
    var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
    for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
      var attr = obj.unauthenticatedAttributes[i];
      attrsAsn1.values.push(_attributeToAsn1(attr));
    }
    rval.value.push(attrsAsn1);
  }
  return rval;
}
function _signersToAsn1(signers) {
  var ret = [];
  for (var i = 0; i < signers.length; ++i) {
    ret.push(_signerToAsn1(signers[i]));
  }
  return ret;
}
function _attributeToAsn1(attr) {
  var value;
  if (attr.type === forge$1.pki.oids.contentType) {
    value = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(attr.value).getBytes()
    );
  } else if (attr.type === forge$1.pki.oids.messageDigest) {
    value = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      false,
      attr.value.bytes()
    );
  } else if (attr.type === forge$1.pki.oids.signingTime) {
    var jan_1_19502 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
    var jan_1_20502 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
    var date = attr.value;
    if (typeof date === "string") {
      var timestamp2 = Date.parse(date);
      if (!isNaN(timestamp2)) {
        date = new Date(timestamp2);
      } else if (date.length === 13) {
        date = asn1.utcTimeToDate(date);
      } else {
        date = asn1.generalizedTimeToDate(date);
      }
    }
    if (date >= jan_1_19502 && date < jan_1_20502) {
      value = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.UTCTIME,
        false,
        asn1.dateToUtcTime(date)
      );
    } else {
      value = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.GENERALIZEDTIME,
        false,
        asn1.dateToGeneralizedTime(date)
      );
    }
  }
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // AttributeType
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(attr.type).getBytes()
    ),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
      // AttributeValue
      value
    ])
  ]);
}
function _encryptedContentToAsn1(ec) {
  return [
    // ContentType, always Data for the moment
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(forge$1.pki.oids.data).getBytes()
    ),
    // ContentEncryptionAlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // Algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ec.algorithm).getBytes()
      ),
      // Parameters (IV)
      !ec.parameter ? void 0 : asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        ec.parameter.getBytes()
      )
    ]),
    // [0] EncryptedContent
    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        ec.content.getBytes()
      )
    ])
  ];
}
function _fromAsn1(msg, obj, validator) {
  var capture = {};
  var errors2 = [];
  if (!asn1.validate(obj, validator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
    error2.errors = error2;
    throw error2;
  }
  var contentType3 = asn1.derToOid(capture.contentType);
  if (contentType3 !== forge$1.pki.oids.data) {
    throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
  }
  if (capture.encryptedContent) {
    var content = "";
    if (forge$1.util.isArray(capture.encryptedContent)) {
      for (var i = 0; i < capture.encryptedContent.length; ++i) {
        if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
          throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
        }
        content += capture.encryptedContent[i].value;
      }
    } else {
      content = capture.encryptedContent;
    }
    msg.encryptedContent = {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: forge$1.util.createBuffer(capture.encParameter.value),
      content: forge$1.util.createBuffer(content)
    };
  }
  if (capture.content) {
    var content = "";
    if (forge$1.util.isArray(capture.content)) {
      for (var i = 0; i < capture.content.length; ++i) {
        if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
          throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
        }
        content += capture.content[i].value;
      }
    } else {
      content = capture.content;
    }
    msg.content = forge$1.util.createBuffer(content);
  }
  msg.version = capture.version.charCodeAt(0);
  msg.rawCapture = capture;
  return capture;
}
function _decryptContent(msg) {
  if (msg.encryptedContent.key === void 0) {
    throw new Error("Symmetric key not available.");
  }
  if (msg.content === void 0) {
    var ciph;
    switch (msg.encryptedContent.algorithm) {
      case forge$1.pki.oids["aes128-CBC"]:
      case forge$1.pki.oids["aes192-CBC"]:
      case forge$1.pki.oids["aes256-CBC"]:
        ciph = forge$1.aes.createDecryptionCipher(msg.encryptedContent.key);
        break;
      case forge$1.pki.oids["desCBC"]:
      case forge$1.pki.oids["des-EDE3-CBC"]:
        ciph = forge$1.des.createDecryptionCipher(msg.encryptedContent.key);
        break;
      default:
        throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
    }
    ciph.start(msg.encryptedContent.parameter);
    ciph.update(msg.encryptedContent.content);
    if (!ciph.finish()) {
      throw new Error("Symmetric decryption failed.");
    }
    msg.content = ciph.output;
  }
}
var forge = forge$C;
var ssh = forge.ssh = forge.ssh || {};
ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
  comment = comment || "";
  passphrase = passphrase || "";
  var algorithm = "ssh-rsa";
  var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
  var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
  ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
  ppk += "Comment: " + comment + "\r\n";
  var pubbuffer = forge.util.createBuffer();
  _addStringToBuffer(pubbuffer, algorithm);
  _addBigIntegerToBuffer(pubbuffer, privateKey.e);
  _addBigIntegerToBuffer(pubbuffer, privateKey.n);
  var pub = forge.util.encode64(pubbuffer.bytes(), 64);
  var length = Math.floor(pub.length / 66) + 1;
  ppk += "Public-Lines: " + length + "\r\n";
  ppk += pub;
  var privbuffer = forge.util.createBuffer();
  _addBigIntegerToBuffer(privbuffer, privateKey.d);
  _addBigIntegerToBuffer(privbuffer, privateKey.p);
  _addBigIntegerToBuffer(privbuffer, privateKey.q);
  _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
  var priv;
  if (!passphrase) {
    priv = forge.util.encode64(privbuffer.bytes(), 64);
  } else {
    var encLen = privbuffer.length() + 16 - 1;
    encLen -= encLen % 16;
    var padding = _sha1(privbuffer.bytes());
    padding.truncate(padding.length() - encLen + privbuffer.length());
    privbuffer.putBuffer(padding);
    var aeskey = forge.util.createBuffer();
    aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
    aeskey.putBuffer(_sha1("\0\0\0", passphrase));
    var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
    cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
    cipher.update(privbuffer.copy());
    cipher.finish();
    var encrypted = cipher.output;
    encrypted.truncate(16);
    priv = forge.util.encode64(encrypted.bytes(), 64);
  }
  length = Math.floor(priv.length / 66) + 1;
  ppk += "\r\nPrivate-Lines: " + length + "\r\n";
  ppk += priv;
  var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
  var macbuffer = forge.util.createBuffer();
  _addStringToBuffer(macbuffer, algorithm);
  _addStringToBuffer(macbuffer, encryptionAlgorithm);
  _addStringToBuffer(macbuffer, comment);
  macbuffer.putInt32(pubbuffer.length());
  macbuffer.putBuffer(pubbuffer);
  macbuffer.putInt32(privbuffer.length());
  macbuffer.putBuffer(privbuffer);
  var hmac2 = forge.hmac.create();
  hmac2.start("sha1", mackey);
  hmac2.update(macbuffer.bytes());
  ppk += "\r\nPrivate-MAC: " + hmac2.digest().toHex() + "\r\n";
  return ppk;
};
ssh.publicKeyToOpenSSH = function(key, comment) {
  var type3 = "ssh-rsa";
  comment = comment || "";
  var buffer2 = forge.util.createBuffer();
  _addStringToBuffer(buffer2, type3);
  _addBigIntegerToBuffer(buffer2, key.e);
  _addBigIntegerToBuffer(buffer2, key.n);
  return type3 + " " + forge.util.encode64(buffer2.bytes()) + " " + comment;
};
ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
  if (!passphrase) {
    return forge.pki.privateKeyToPem(privateKey);
  }
  return forge.pki.encryptRsaPrivateKey(
    privateKey,
    passphrase,
    { legacy: true, algorithm: "aes128" }
  );
};
ssh.getPublicKeyFingerprint = function(key, options2) {
  options2 = options2 || {};
  var md = options2.md || forge.md.md5.create();
  var type3 = "ssh-rsa";
  var buffer2 = forge.util.createBuffer();
  _addStringToBuffer(buffer2, type3);
  _addBigIntegerToBuffer(buffer2, key.e);
  _addBigIntegerToBuffer(buffer2, key.n);
  md.start();
  md.update(buffer2.getBytes());
  var digest = md.digest();
  if (options2.encoding === "hex") {
    var hex = digest.toHex();
    if (options2.delimiter) {
      return hex.match(/.{2}/g).join(options2.delimiter);
    }
    return hex;
  } else if (options2.encoding === "binary") {
    return digest.getBytes();
  } else if (options2.encoding) {
    throw new Error('Unknown encoding "' + options2.encoding + '".');
  }
  return digest;
};
function _addBigIntegerToBuffer(buffer2, val) {
  var hexVal = val.toString(16);
  if (hexVal[0] >= "8") {
    hexVal = "00" + hexVal;
  }
  var bytes2 = forge.util.hexToBytes(hexVal);
  buffer2.putInt32(bytes2.length);
  buffer2.putBytes(bytes2);
}
function _addStringToBuffer(buffer2, val) {
  buffer2.putInt32(val.length);
  buffer2.putString(val);
}
function _sha1() {
  var sha = forge.md.sha1.create();
  var num = arguments.length;
  for (var i = 0; i < num; ++i) {
    sha.update(arguments[i]);
  }
  return sha.digest();
}
var lib = forge$C;
var __importDefault$P = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(auth, "__esModule", { value: true });
const node_forge_1 = __importDefault$P(lib);
const bluebird_1$7 = __importDefault$P(bluebird_1$b);
const BigInteger = node_forge_1.default.jsbn.BigInteger;
class Auth {
  static parsePublicKey(buffer2) {
    return new bluebird_1$7.default(function(resolve3, reject) {
      const match2 = Auth.RE.exec(buffer2);
      if (match2) {
        const struct2 = Buffer.from(match2[1], "base64");
        const comment = match2[2].trim();
        return resolve3(Auth.readPublicKeyFromStruct(struct2, comment));
      } else {
        return reject(new Error("Unrecognizable public key format"));
      }
    });
  }
  static readPublicKeyFromStruct(struct2, comment) {
    if (!struct2.length) {
      throw new Error("Invalid public key");
    }
    let offset = 0;
    const len = struct2.readUInt32LE(offset) * 4;
    offset += 4;
    if (struct2.length !== 4 + 4 + len + len + 4) {
      throw new Error("Invalid public key");
    }
    offset += 4;
    const n = Buffer.alloc(len);
    struct2.copy(n, 0, offset, offset + len);
    [].reverse.call(n);
    offset += len;
    offset += len;
    const e = struct2.readUInt32LE(offset);
    if (!(e === 3 || e === 65537)) {
      throw new Error(`Invalid exponent ${e}, only 3 and 65537 are supported`);
    }
    const modulus = new BigInteger(n.toString("hex"), 16);
    const exponent = new BigInteger(e.toString(), 10);
    const key = node_forge_1.default.pki.rsa.setPublicKey(modulus, exponent);
    const md = node_forge_1.default.md.md5.create();
    md.update(struct2.toString("binary"));
    const extendedKey = key;
    extendedKey.fingerprint = md.digest().toHex().match(/../g).join(":");
    extendedKey.comment = comment;
    return extendedKey;
  }
}
Auth.RE = /^((?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?)\0?( .*|)\s*$/;
auth.default = Auth;
var servicemap = {};
Object.defineProperty(servicemap, "__esModule", { value: true });
class ServiceMap {
  constructor() {
    this.remotes = /* @__PURE__ */ Object.create(null);
    this.count = 0;
  }
  end() {
    const ref2 = this.remotes;
    for (const remoteId in ref2) {
      const remote = ref2[remoteId];
      remote.end();
    }
    this.remotes = /* @__PURE__ */ Object.create(null);
    this.count = 0;
  }
  insert(remoteId, socket2) {
    if (this.remotes[remoteId]) {
      throw new Error(`Remote ID ${remoteId} is already being used`);
    } else {
      this.count += 1;
      return this.remotes[remoteId] = socket2;
    }
  }
  get(remoteId) {
    return this.remotes[remoteId] || null;
  }
  remove(remoteId) {
    let remote;
    if (remote = this.remotes[remoteId]) {
      delete this.remotes[remoteId];
      this.count -= 1;
      return remote;
    } else {
      return null;
    }
  }
}
servicemap.default = ServiceMap;
var service = {};
var __importDefault$O = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(service, "__esModule", { value: true });
const debug_1$4 = __importDefault$O(srcExports);
const events_1$9 = require$$0$9;
const packet_1$1 = __importDefault$O(packet);
const bluebird_1$6 = __importDefault$O(bluebird_1$b);
const protocol_1$y = __importDefault$O(protocol2);
const debug$4 = (0, debug_1$4.default)("adb:tcpusb:service");
class PrematurePacketError extends Error {
  constructor(packet2) {
    super();
    this.packet = packet2;
    Object.setPrototypeOf(this, PrematurePacketError.prototype);
    this.name = "PrematurePacketError";
    this.message = "Premature packet";
    Error.captureStackTrace(this, Service2.PrematurePacketError);
  }
}
class LateTransportError extends Error {
  constructor() {
    super();
    Object.setPrototypeOf(this, LateTransportError.prototype);
    this.name = "LateTransportError";
    this.message = "Late transport";
    Error.captureStackTrace(this, Service2.LateTransportError);
  }
}
class Service2 extends events_1$9.EventEmitter {
  constructor(client2, serial, localId, remoteId, socket2) {
    super();
    this.client = client2;
    this.serial = serial;
    this.localId = localId;
    this.remoteId = remoteId;
    this.socket = socket2;
    this.opened = false;
    this.ended = false;
    this.needAck = false;
  }
  end() {
    if (this.transport) {
      this.transport.end();
    }
    if (this.ended) {
      return this;
    }
    debug$4("O:A_CLSE");
    const localId = this.opened ? this.localId : 0;
    try {
      this.socket.write(packet_1$1.default.assemble(packet_1$1.default.A_CLSE, localId, this.remoteId, null));
    } catch (error2) {
    }
    this.transport = null;
    this.ended = true;
    this.emit("end");
    return this;
  }
  handle(packet2) {
    return bluebird_1$6.default.try(() => {
      switch (packet2.command) {
        case packet_1$1.default.A_OPEN:
          return this._handleOpenPacket(packet2);
        case packet_1$1.default.A_OKAY:
          return this._handleOkayPacket(packet2);
        case packet_1$1.default.A_WRTE:
          return this._handleWritePacket(packet2);
        case packet_1$1.default.A_CLSE:
          return this._handleClosePacket(packet2);
        default:
          throw new Error(`Unexpected packet ${packet2.command}`);
      }
    }).catch((err) => {
      this.emit("error", err);
      return this.end();
    });
  }
  _handleOpenPacket(packet2) {
    debug$4("I:A_OPEN", packet2);
    return this.client.getDevice(this.serial).transport().then((transport2) => {
      this.transport = transport2;
      if (this.ended) {
        throw new LateTransportError();
      }
      this.transport.write(protocol_1$y.default.encodeData(packet2.data.slice(0, -1)));
      return this.transport.parser.readAscii(4).then((reply2) => {
        switch (reply2) {
          case protocol_1$y.default.OKAY:
            debug$4("O:A_OKAY");
            this.socket.write(packet_1$1.default.assemble(packet_1$1.default.A_OKAY, this.localId, this.remoteId, null));
            return this.opened = true;
          case protocol_1$y.default.FAIL:
            return this.transport.parser.readError();
          default:
            return this.transport.parser.unexpected(reply2, "OKAY or FAIL");
        }
      });
    }).then(() => {
      return new bluebird_1$6.default((resolve3, reject) => {
        this.transport.socket.on("readable", () => this._tryPush()).on("end", resolve3).on("error", reject);
        return this._tryPush();
      });
    }).finally(() => {
      return this.end();
    });
  }
  _handleOkayPacket(packet2) {
    debug$4("I:A_OKAY", packet2);
    if (this.ended) {
      return;
    }
    if (!this.transport) {
      throw new Service2.PrematurePacketError(packet2);
    }
    this.needAck = false;
    return this._tryPush();
  }
  _handleWritePacket(packet2) {
    debug$4("I:A_WRTE", packet2);
    if (this.ended) {
      return;
    }
    if (!this.transport) {
      throw new Service2.PrematurePacketError(packet2);
    }
    if (this.transport && packet2.data) {
      this.transport.write(packet2.data);
    }
    debug$4("O:A_OKAY");
    return this.socket.write(packet_1$1.default.assemble(packet_1$1.default.A_OKAY, this.localId, this.remoteId, null));
  }
  _handleClosePacket(packet2) {
    debug$4("I:A_CLSE", packet2);
    if (this.ended) {
      return;
    }
    if (!this.transport) {
      throw new Service2.PrematurePacketError(packet2);
    }
    return this.end();
  }
  _tryPush() {
    if (this.needAck || this.ended) {
      return;
    }
    const chunk = this._readChunk(this.transport.socket);
    if (chunk) {
      debug$4("O:A_WRTE");
      this.socket.write(packet_1$1.default.assemble(packet_1$1.default.A_WRTE, this.localId, this.remoteId, chunk));
      return this.needAck = true;
    }
  }
  _readChunk(stream2) {
    return stream2.read(this.socket.maxPayload) || stream2.read();
  }
}
Service2.PrematurePacketError = PrematurePacketError;
Service2.LateTransportError = LateTransportError;
service.default = Service2;
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
  }
  __setModuleDefault$3(result, mod);
  return result;
};
var __importDefault$N = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(socket, "__esModule", { value: true });
const events_1$8 = require$$0$9;
const crypto$1 = __importStar$3(require$$0$6);
const debug_1$3 = __importDefault$N(srcExports);
const bluebird_1$5 = __importDefault$N(bluebird_1$b);
const packetreader_1 = __importDefault$N(packetreader);
const rollingcounter_1 = __importDefault$N(rollingcounter);
const packet_1 = __importDefault$N(packet);
const auth_1$1 = __importDefault$N(auth);
const servicemap_1 = __importDefault$N(servicemap);
const service_1 = __importDefault$N(service);
const debug$3 = (0, debug_1$3.default)("adb:tcpusb:socket");
const UINT32_MAX = 4294967295;
const UINT16_MAX = 65535;
const AUTH_TOKEN = 1;
const AUTH_SIGNATURE = 2;
const AUTH_RSAPUBLICKEY = 3;
const TOKEN_LENGTH = 20;
class AuthError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, AuthError.prototype);
    this.name = "AuthError";
    Error.captureStackTrace(this, Socket.AuthError);
  }
}
class UnauthorizedError extends Error {
  constructor() {
    super("Unauthorized access");
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
    this.name = "UnauthorizedError";
    Error.captureStackTrace(this, Socket.UnauthorizedError);
  }
}
class Socket extends events_1$8.EventEmitter {
  constructor(client2, serial, socket2, options2 = {}) {
    super();
    this.client = client2;
    this.serial = serial;
    this.socket = socket2;
    this.options = options2;
    this.ended = false;
    this.authorized = false;
    this.syncToken = new rollingcounter_1.default(UINT32_MAX);
    this.remoteId = new rollingcounter_1.default(UINT32_MAX);
    this.services = new servicemap_1.default();
    this.version = 1;
    this.maxPayload = 4096;
    let base;
    (base = this.options).auth || (base.auth = () => bluebird_1$5.default.resolve(true));
    this.socket.setNoDelay(true);
    this.reader = new packetreader_1.default(this.socket).on("packet", this._handle.bind(this)).on("error", (err) => {
      debug$3(`PacketReader error: ${err.message}`);
      return this.end();
    }).on("end", this.end.bind(this));
    this.remoteAddress = this.socket.remoteAddress;
    this.token = void 0;
    this.signature = void 0;
  }
  end() {
    if (this.ended) {
      return this;
    }
    this.services.end();
    this.socket.end();
    this.ended = true;
    this.emit("end");
    return this;
  }
  _error(err) {
    this.emit("error", err);
    return this.end();
  }
  _handle(packet2) {
    if (this.ended) {
      return bluebird_1$5.default.resolve(false);
    }
    this.emit("userActivity", packet2);
    return bluebird_1$5.default.try(() => {
      switch (packet2.command) {
        case packet_1.default.A_SYNC:
          return bluebird_1$5.default.resolve(this._handleSyncPacket());
        case packet_1.default.A_CNXN:
          return this._handleConnectionPacket(packet2);
        case packet_1.default.A_OPEN:
          return this._handleOpenPacket(packet2).then((r) => !!r);
        case packet_1.default.A_OKAY:
        case packet_1.default.A_WRTE:
        case packet_1.default.A_CLSE:
          return this._forwardServicePacket(packet2).then((r) => !!r);
        case packet_1.default.A_AUTH:
          return this._handleAuthPacket(packet2);
        default:
          throw new Error(`Unknown command ${packet2.command}`);
      }
    }).catch(Socket.AuthError, () => {
      this.end();
      return false;
    }).catch(Socket.UnauthorizedError, () => {
      this.end();
      return false;
    }).catch((err) => {
      this._error(err);
      return false;
    });
  }
  _handleSyncPacket() {
    debug$3("I:A_SYNC");
    debug$3("O:A_SYNC");
    return this.write(packet_1.default.assemble(packet_1.default.A_SYNC, 1, this.syncToken.next()));
  }
  _handleConnectionPacket(packet2) {
    debug$3("I:A_CNXN", packet2);
    this.version = packet_1.default.swap32(packet2.arg0);
    this.maxPayload = Math.min(UINT16_MAX, packet2.arg1);
    return this._createToken().then((token) => {
      this.token = token;
      debug$3(`Created challenge '${this.token.toString("base64")}'`);
      debug$3("O:A_AUTH");
      return this.write(packet_1.default.assemble(packet_1.default.A_AUTH, AUTH_TOKEN, 0, this.token));
    });
  }
  _handleAuthPacket(packet2) {
    debug$3("I:A_AUTH", packet2);
    switch (packet2.arg0) {
      case AUTH_SIGNATURE:
        if (packet2.data)
          debug$3(`Received signature '${packet2.data.toString("base64")}'`);
        if (!this.signature) {
          this.signature = packet2.data;
        }
        const digest = this.token.toString("binary");
        const sig = this.signature.toString("binary");
        for (const key of this.options.knownPublicKeys ?? []) {
          if (key.verify(digest, sig))
            return this._acceptConnection();
        }
        debug$3("O:A_AUTH");
        const b = this.write(packet_1.default.assemble(packet_1.default.A_AUTH, AUTH_TOKEN, 0, this.token));
        return bluebird_1$5.default.resolve(b);
      case AUTH_RSAPUBLICKEY:
        if (!this.signature) {
          throw new Socket.AuthError("Public key sent before signature");
        }
        if (!packet2.data || packet2.data.length < 2) {
          throw new Socket.AuthError("Empty RSA public key");
        }
        debug$3(`Received RSA public key '${packet2.data.toString("base64")}'`);
        return auth_1$1.default.parsePublicKey(this._skipNull(packet2.data).toString()).then((key) => {
          const digest2 = this.token.toString("binary");
          const sig2 = this.signature.toString("binary");
          if (!key.verify(digest2, sig2)) {
            debug$3("Signature mismatch");
            throw new Socket.AuthError("Signature mismatch");
          }
          debug$3("Signature verified");
          return key;
        }).then((key) => {
          if (!this.options.auth)
            return;
          return this.options.auth(key).catch(() => {
            debug$3("Connection rejected by user-defined auth handler");
            throw new Socket.AuthError("Rejected by user-defined handler");
          });
        }).then(() => {
          return this._acceptConnection();
        });
      default:
        throw new Error(`Unknown authentication method ${packet2.arg0}`);
    }
  }
  /**
   * Mark the incoming connection as authorized
   * and send the connection packet
   */
  _acceptConnection() {
    return this._deviceId().then((id) => {
      this.authorized = true;
      debug$3("O:A_CNXN");
      return this.write(packet_1.default.assemble(packet_1.default.A_CNXN, packet_1.default.swap32(this.version), this.maxPayload, id));
    });
  }
  _handleOpenPacket(packet2) {
    if (!this.authorized) {
      throw new Socket.UnauthorizedError();
    }
    const remoteId = packet2.arg0;
    const localId = this.remoteId.next();
    if (!(packet2.data && packet2.data.length >= 2)) {
      throw new Error("Empty service name");
    }
    const name = this._skipNull(packet2.data);
    debug$3(`Calling ${name}`);
    const service2 = new service_1.default(this.client, this.serial, localId, remoteId, this);
    return new bluebird_1$5.default((resolve3, reject) => {
      service2.on("error", reject);
      service2.on("end", resolve3);
      this.services.insert(localId, service2);
      debug$3(`Handling ${this.services.count} services simultaneously`);
      return service2.handle(packet2);
    }).catch(() => true).finally(() => {
      this.services.remove(localId);
      debug$3(`Handling ${this.services.count} services simultaneously`);
      return service2.end();
    });
  }
  _forwardServicePacket(packet2) {
    if (!this.authorized) {
      throw new Socket.UnauthorizedError();
    }
    const localId = packet2.arg1;
    const service2 = this.services.get(localId);
    if (service2) {
      return service2.handle(packet2);
    } else {
      debug$3("Received a packet to a service that may have been closed already");
      return Promise.resolve(false);
    }
  }
  write(chunk) {
    if (this.ended) {
      return false;
    }
    return this.socket.write(chunk);
  }
  _createToken() {
    return bluebird_1$5.default.promisify(crypto$1.randomBytes)(TOKEN_LENGTH);
  }
  _skipNull(data) {
    return data.slice(0, -1);
  }
  _deviceId() {
    debug$3("Loading device properties to form a standard device ID");
    return this.client.getDevice(this.serial).getProperties().then(function(properties) {
      const id = function() {
        const ref2 = ["ro.product.name", "ro.product.model", "ro.product.device"];
        const results = [];
        for (let i = 0, len = ref2.length; i < len; i++) {
          const prop = ref2[i];
          results.push(`${prop}=${properties[prop]};`);
        }
        return results;
      }().join("");
      return Buffer.from(`device::${id}\0`);
    });
  }
}
Socket.AuthError = AuthError;
Socket.UnauthorizedError = UnauthorizedError;
socket.default = Socket;
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
var __importDefault$M = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(server, "__esModule", { value: true });
const Net = __importStar$2(require$$0$7);
const socket_1 = __importDefault$M(socket);
const events_1$7 = require$$0$9;
class Server extends events_1$7.EventEmitter {
  constructor(client2, serial, options2) {
    super();
    this.client = client2;
    this.serial = serial;
    this.options = options2;
    this.connections = [];
    this.server = Net.createServer({
      allowHalfOpen: true
    });
    this.server.on("error", (err) => this.emit("error", err));
    this.server.on("listening", () => this.emit("listening"));
    this.server.on("close", () => this.emit("close"));
    this.server.on("connection", (conn) => {
      const socket2 = new socket_1.default(this.client, this.serial, conn, this.options);
      this.connections.push(socket2);
      socket2.on("error", (err) => {
        return this.emit("error", err);
      });
      socket2.once("end", () => {
        return this.connections = this.connections.filter(function(val) {
          return val !== socket2;
        });
      });
      return this.emit("connection", socket2);
    });
  }
  listen(...args) {
    this.server.listen(...args);
    return this;
  }
  close() {
    this.server.close();
    return this;
  }
  end() {
    const ref2 = this.connections;
    for (let i = 0, len = ref2.length; i < len; i++) {
      ref2[i].end();
    }
    return this;
  }
}
server.default = Server;
var DeviceClient$1 = {};
var monkey$1 = { exports: {} };
var client = { exports: {} };
var api = { exports: {} };
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi) return api.exports;
  hasRequiredApi = 1;
  (function() {
    var Api, EventEmitter2, _ref, __hasProp = {}.hasOwnProperty, __extends2 = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    EventEmitter2 = require$$0$9.EventEmitter;
    Api = function(_super) {
      __extends2(Api2, _super);
      function Api2() {
        _ref = Api2.__super__.constructor.apply(this, arguments);
        return _ref;
      }
      Api2.prototype.send = function() {
        throw new Error("send is not implemented");
      };
      Api2.prototype.keyDown = function(keyCode, callback) {
        this.send("key down " + keyCode, callback);
        return this;
      };
      Api2.prototype.keyUp = function(keyCode, callback) {
        this.send("key up " + keyCode, callback);
        return this;
      };
      Api2.prototype.touchDown = function(x, y2, callback) {
        this.send("touch down " + x + " " + y2, callback);
        return this;
      };
      Api2.prototype.touchUp = function(x, y2, callback) {
        this.send("touch up " + x + " " + y2, callback);
        return this;
      };
      Api2.prototype.touchMove = function(x, y2, callback) {
        this.send("touch move " + x + " " + y2, callback);
        return this;
      };
      Api2.prototype.trackball = function(dx, dy, callback) {
        this.send("trackball " + dx + " " + dy, callback);
        return this;
      };
      Api2.prototype.flipOpen = function(callback) {
        this.send("flip open", callback);
        return this;
      };
      Api2.prototype.flipClose = function(callback) {
        this.send("flip close", callback);
        return this;
      };
      Api2.prototype.wake = function(callback) {
        this.send("wake", callback);
        return this;
      };
      Api2.prototype.tap = function(x, y2, callback) {
        this.send("tap " + x + " " + y2, callback);
        return this;
      };
      Api2.prototype.press = function(keyCode, callback) {
        this.send("press " + keyCode, callback);
        return this;
      };
      Api2.prototype.type = function(str2, callback) {
        str2 = str2.replace(/"/g, '\\"');
        if (str2.indexOf(" ") === -1) {
          this.send("type " + str2, callback);
        } else {
          this.send('type "' + str2 + '"', callback);
        }
        return this;
      };
      Api2.prototype.list = function(callback) {
        var _this = this;
        this.send("listvar", function(err, vars) {
          if (err) {
            return _this(callback(err));
          }
          if (err) {
            return callback(err);
          } else {
            return callback(null, vars.split(/\s+/g));
          }
        });
        return this;
      };
      Api2.prototype.get = function(name, callback) {
        this.send("getvar " + name, callback);
        return this;
      };
      Api2.prototype.quit = function(callback) {
        this.send("quit", callback);
        return this;
      };
      Api2.prototype.done = function(callback) {
        this.send("done", callback);
        return this;
      };
      Api2.prototype.sleep = function(ms2, callback) {
        this.send("sleep " + ms2, callback);
        return this;
      };
      Api2.prototype.getAmCurrentAction = function(callback) {
        this.get("am.current.action", callback);
        return this;
      };
      Api2.prototype.getAmCurrentCategories = function(callback) {
        this.get("am.current.categories", callback);
        return this;
      };
      Api2.prototype.getAmCurrentCompClass = function(callback) {
        this.get("am.current.comp.class", callback);
        return this;
      };
      Api2.prototype.getAmCurrentCompPackage = function(callback) {
        this.get("am.current.comp.package", callback);
        return this;
      };
      Api2.prototype.getAmCurrentData = function(callback) {
        this.get("am.current.data", callback);
        return this;
      };
      Api2.prototype.getAmCurrentPackage = function(callback) {
        this.get("am.current.package", callback);
        return this;
      };
      Api2.prototype.getBuildBoard = function(callback) {
        this.get("build.board", callback);
        return this;
      };
      Api2.prototype.getBuildBrand = function(callback) {
        this.get("build.brand", callback);
        return this;
      };
      Api2.prototype.getBuildCpuAbi = function(callback) {
        this.get("build.cpu_abi", callback);
        return this;
      };
      Api2.prototype.getBuildDevice = function(callback) {
        this.get("build.device", callback);
        return this;
      };
      Api2.prototype.getBuildDisplay = function(callback) {
        this.get("build.display", callback);
        return this;
      };
      Api2.prototype.getBuildFingerprint = function(callback) {
        this.get("build.fingerprint", callback);
        return this;
      };
      Api2.prototype.getBuildHost = function(callback) {
        this.get("build.host", callback);
        return this;
      };
      Api2.prototype.getBuildId = function(callback) {
        this.get("build.id", callback);
        return this;
      };
      Api2.prototype.getBuildManufacturer = function(callback) {
        this.get("build.manufacturer", callback);
        return this;
      };
      Api2.prototype.getBuildModel = function(callback) {
        this.get("build.model", callback);
        return this;
      };
      Api2.prototype.getBuildProduct = function(callback) {
        this.get("build.product", callback);
        return this;
      };
      Api2.prototype.getBuildTags = function(callback) {
        this.get("build.tags", callback);
        return this;
      };
      Api2.prototype.getBuildType = function(callback) {
        this.get("build.type", callback);
        return this;
      };
      Api2.prototype.getBuildUser = function(callback) {
        this.get("build.user", callback);
        return this;
      };
      Api2.prototype.getBuildVersionCodename = function(callback) {
        this.get("build.version.codename", callback);
        return this;
      };
      Api2.prototype.getBuildVersionIncremental = function(callback) {
        this.get("build.version.incremental", callback);
        return this;
      };
      Api2.prototype.getBuildVersionRelease = function(callback) {
        this.get("build.version.release", callback);
        return this;
      };
      Api2.prototype.getBuildVersionSdk = function(callback) {
        this.get("build.version.sdk", callback);
        return this;
      };
      Api2.prototype.getClockMillis = function(callback) {
        this.get("clock.millis", callback);
        return this;
      };
      Api2.prototype.getClockRealtime = function(callback) {
        this.get("clock.realtime", callback);
        return this;
      };
      Api2.prototype.getClockUptime = function(callback) {
        this.get("clock.uptime", callback);
        return this;
      };
      Api2.prototype.getDisplayDensity = function(callback) {
        this.get("display.density", callback);
        return this;
      };
      Api2.prototype.getDisplayHeight = function(callback) {
        this.get("display.height", callback);
        return this;
      };
      Api2.prototype.getDisplayWidth = function(callback) {
        this.get("display.width", callback);
        return this;
      };
      return Api2;
    }(EventEmitter2);
    api.exports = Api;
  }).call(commonjsGlobal);
  return api.exports;
}
var command = { exports: {} };
var hasRequiredCommand;
function requireCommand() {
  if (hasRequiredCommand) return command.exports;
  hasRequiredCommand = 1;
  (function() {
    var Command2;
    Command2 = /* @__PURE__ */ function() {
      function Command3(command2, callback) {
        this.command = command2;
        this.callback = callback;
        this.next = null;
      }
      return Command3;
    }();
    command.exports = Command2;
  }).call(commonjsGlobal);
  return command.exports;
}
var reply = { exports: {} };
var hasRequiredReply;
function requireReply() {
  if (hasRequiredReply) return reply.exports;
  hasRequiredReply = 1;
  (function() {
    var Reply;
    Reply = function() {
      Reply2.ERROR = "ERROR";
      Reply2.OK = "OK";
      function Reply2(type3, value) {
        this.type = type3;
        this.value = value;
      }
      Reply2.prototype.isError = function() {
        return this.type === Reply2.ERROR;
      };
      Reply2.prototype.toError = function() {
        if (!this.isError()) {
          throw new Error("toError() cannot be called for non-errors");
        }
        return new Error(this.value);
      };
      return Reply2;
    }();
    reply.exports = Reply;
  }).call(commonjsGlobal);
  return reply.exports;
}
var queue = { exports: {} };
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue.exports;
  hasRequiredQueue = 1;
  (function() {
    var Queue;
    Queue = function() {
      function Queue2() {
        this.head = null;
        this.tail = null;
      }
      Queue2.prototype.enqueue = function(item) {
        if (this.tail) {
          this.tail.next = item;
        } else {
          this.head = item;
        }
        this.tail = item;
      };
      Queue2.prototype.dequeue = function() {
        var item;
        item = this.head;
        if (item) {
          if (item === this.tail) {
            this.tail = null;
          }
          this.head = item.next;
          item.next = null;
        }
        return item;
      };
      return Queue2;
    }();
    queue.exports = Queue;
  }).call(commonjsGlobal);
  return queue.exports;
}
var multi = { exports: {} };
var hasRequiredMulti;
function requireMulti() {
  if (hasRequiredMulti) return multi.exports;
  hasRequiredMulti = 1;
  (function() {
    var Api, Command2, Multi, __hasProp = {}.hasOwnProperty, __extends2 = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    Api = requireApi();
    Command2 = requireCommand();
    Multi = function(_super) {
      __extends2(Multi2, _super);
      function Multi2(monkey2) {
        var _this = this;
        this.monkey = monkey2;
        this.commands = [];
        this.replies = [];
        this.errors = [];
        this.counter = 0;
        this.sent = false;
        this.callback = null;
        this.collector = function(err, result, cmd) {
          if (err) {
            _this.errors.push("" + cmd + ": " + err.message);
          }
          _this.replies.push(result);
          _this.counter -= 1;
          return _this._maybeFinish();
        };
      }
      Multi2.prototype._maybeFinish = function() {
        var _this = this;
        if (this.counter === 0) {
          if (this.errors.length) {
            setImmediate(function() {
              return _this.callback(new Error(_this.errors.join(", ")));
            });
          } else {
            setImmediate(function() {
              return _this.callback(null, _this.replies);
            });
          }
        }
      };
      Multi2.prototype._forbidReuse = function() {
        if (this.sent) {
          throw new Error("Reuse not supported");
        }
      };
      Multi2.prototype.send = function(command2) {
        this._forbidReuse();
        this.commands.push(new Command2(command2, this.collector));
      };
      Multi2.prototype.execute = function(callback) {
        var command2, parts, _i, _len, _ref;
        this._forbidReuse();
        this.counter = this.commands.length;
        this.sent = true;
        this.callback = callback;
        if (this.counter === 0) {
          return;
        }
        parts = [];
        _ref = this.commands;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          command2 = _ref[_i];
          this.monkey.commandQueue.enqueue(command2);
          parts.push(command2.command);
        }
        parts.push("");
        this.commands = [];
        this.monkey.stream.write(parts.join("\n"));
      };
      return Multi2;
    }(Api);
    multi.exports = Multi;
  }).call(commonjsGlobal);
  return multi.exports;
}
var parser = { exports: {} };
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser.exports;
  hasRequiredParser = 1;
  (function() {
    var EventEmitter2, Parser2, Reply, __hasProp = {}.hasOwnProperty, __extends2 = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    EventEmitter2 = require$$0$9.EventEmitter;
    Reply = requireReply();
    Parser2 = function(_super) {
      __extends2(Parser3, _super);
      function Parser3(options2) {
        this.column = 0;
        this.buffer = new Buffer("");
      }
      Parser3.prototype.parse = function(chunk) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
        while (this.column < this.buffer.length) {
          if (this.buffer[this.column] === 10) {
            this._parseLine(this.buffer.slice(0, this.column));
            this.buffer = this.buffer.slice(this.column + 1);
            this.column = 0;
          }
          this.column += 1;
        }
        if (this.buffer.length) {
          this.emit("wait");
        } else {
          this.emit("drain");
        }
      };
      Parser3.prototype._parseLine = function(line) {
        switch (line[0]) {
          case 79:
            if (line.length === 2) {
              this.emit("reply", new Reply(Reply.OK, null));
            } else {
              this.emit("reply", new Reply(Reply.OK, line.toString("ascii", 3)));
            }
            break;
          case 69:
            if (line.length === 5) {
              this.emit("reply", new Reply(Reply.ERROR, null));
            } else {
              this.emit("reply", new Reply(Reply.ERROR, line.toString("ascii", 6)));
            }
            break;
          default:
            this._complain(line);
        }
      };
      Parser3.prototype._complain = function(line) {
        this.emit("error", new SyntaxError("Unparseable line '" + line + "'"));
      };
      return Parser3;
    }(EventEmitter2);
    parser.exports = Parser2;
  }).call(commonjsGlobal);
  return parser.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client.exports;
  hasRequiredClient = 1;
  (function() {
    var Api, Client2, Command2, Multi, Parser2, Queue, __hasProp = {}.hasOwnProperty, __extends2 = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    Api = requireApi();
    Command2 = requireCommand();
    requireReply();
    Queue = requireQueue();
    Multi = requireMulti();
    Parser2 = requireParser();
    Client2 = function(_super) {
      __extends2(Client3, _super);
      function Client3() {
        this.commandQueue = new Queue();
        this.parser = new Parser2();
        this.stream = null;
      }
      Client3.prototype._hook = function() {
        var _this = this;
        this.stream.on("data", function(data) {
          return _this.parser.parse(data);
        });
        this.stream.on("error", function(err) {
          return _this.emit("error", err);
        });
        this.stream.on("end", function() {
          return _this.emit("end");
        });
        this.stream.on("finish", function() {
          return _this.emit("finish");
        });
        this.parser.on("reply", function(reply2) {
          return _this._consume(reply2);
        });
        this.parser.on("error", function(err) {
          return _this.emit("error", err);
        });
      };
      Client3.prototype._consume = function(reply2) {
        var command2;
        if (command2 = this.commandQueue.dequeue()) {
          if (reply2.isError()) {
            command2.callback(reply2.toError(), null, command2.command);
          } else {
            command2.callback(null, reply2.value, command2.command);
          }
        } else {
          throw new Error("Command queue depleted, but replies still coming in");
        }
      };
      Client3.prototype.connect = function(stream2) {
        this.stream = stream2;
        this._hook();
        return this;
      };
      Client3.prototype.end = function() {
        this.stream.end();
        return this;
      };
      Client3.prototype.send = function(commands, callback) {
        var command2, _i, _len;
        if (Array.isArray(commands)) {
          for (_i = 0, _len = commands.length; _i < _len; _i++) {
            command2 = commands[_i];
            this.commandQueue.enqueue(new Command2(command2, callback));
          }
          this.stream.write("" + commands.join("\n") + "\n");
        } else {
          this.commandQueue.enqueue(new Command2(commands, callback));
          this.stream.write("" + commands + "\n");
        }
        return this;
      };
      Client3.prototype.multi = function() {
        return new Multi(this);
      };
      return Client3;
    }(Api);
    client.exports = Client2;
  }).call(commonjsGlobal);
  return client.exports;
}
var connection = { exports: {} };
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection) return connection.exports;
  hasRequiredConnection = 1;
  (function() {
    var Client2, Connection2, Net2, _ref, __hasProp = {}.hasOwnProperty, __extends2 = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    Net2 = require$$0$7;
    Client2 = requireClient();
    Connection2 = function(_super) {
      __extends2(Connection3, _super);
      function Connection3() {
        _ref = Connection3.__super__.constructor.apply(this, arguments);
        return _ref;
      }
      Connection3.prototype.connect = function(options2) {
        var stream2;
        stream2 = Net2.connect(options2);
        stream2.setNoDelay(true);
        return Connection3.__super__.connect.call(this, stream2);
      };
      Connection3.prototype._hook = function() {
        var _this = this;
        this.stream.on("connect", function() {
          return _this.emit("connect");
        });
        this.stream.on("close", function(hadError) {
          return _this.emit("close", hadError);
        });
        return Connection3.__super__._hook.call(this);
      };
      return Connection3;
    }(Client2);
    connection.exports = Connection2;
  }).call(commonjsGlobal);
  return connection.exports;
}
(function() {
  var Client2, Connection2, Monkey;
  Client2 = requireClient();
  Connection2 = requireConnection();
  Monkey = function() {
    function Monkey2() {
    }
    Monkey2.connect = function(options2) {
      return new Connection2().connect(options2);
    };
    Monkey2.connectStream = function(stream2) {
      return new Client2().connect(stream2);
    };
    return Monkey2;
  }();
  Monkey.Connection = Connection2;
  Monkey.Client = Client2;
  monkey$1.exports = Monkey;
}).call(commonjsGlobal);
var monkeyExports = monkey$1.exports;
var Entry$1 = (
  /** @class */
  function() {
    function Entry3() {
      this.date = null;
      this.pid = -1;
      this.tid = -1;
      this.priority = null;
      this.tag = null;
      this.message = null;
    }
    Entry3.prototype.setDate = function(date) {
      this.date = date;
    };
    Entry3.prototype.setPid = function(pid) {
      this.pid = pid;
    };
    Entry3.prototype.setTid = function(tid) {
      this.tid = tid;
    };
    Entry3.prototype.setPriority = function(priority2) {
      this.priority = priority2;
    };
    Entry3.prototype.setTag = function(tag) {
      this.tag = tag;
    };
    Entry3.prototype.setMessage = function(message) {
      this.message = message;
    };
    Entry3.prototype.toBinary = function() {
      var length = 20;
      length += 1;
      length += this.tag.length;
      length += 1;
      length += this.message.length;
      length += 1;
      var buffer2 = new Buffer(length);
      var cursor = 0;
      buffer2.writeUInt16LE(length - 20, cursor);
      cursor += 4;
      buffer2.writeInt32LE(this.pid, cursor);
      cursor += 4;
      buffer2.writeInt32LE(this.tid, cursor);
      cursor += 4;
      buffer2.writeInt32LE(Math.floor(this.date.getTime() / 1e3), cursor);
      cursor += 4;
      buffer2.writeInt32LE(this.date.getTime() % 1e3 * 1e6, cursor);
      cursor += 4;
      buffer2[cursor] = this.priority;
      cursor += 1;
      buffer2.write(this.tag, cursor, this.tag.length);
      cursor += this.tag.length;
      buffer2[cursor] = 0;
      cursor += 1;
      buffer2.write(this.message, cursor, this.message.length);
      cursor += this.message.length;
      buffer2[cursor] = 0;
      return buffer2;
    };
    return Entry3;
  }()
);
var entry$1 = Entry$1;
var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d3[p] = b2[p];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __2() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
  };
}();
var __importDefault$L = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
var events_1$6 = require$$0$9;
var entry_1$1 = __importDefault$L(entry$1);
var HEADER_SIZE_V1 = 20;
var HEADER_SIZE_MAX = 100;
var Binary = (
  /** @class */
  function(_super) {
    __extends$2(Binary2, _super);
    function Binary2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buffer = new Buffer(0);
      return _this;
    }
    Binary2.prototype.parse = function(chunk) {
      this.buffer = Buffer.concat([this.buffer, chunk]);
      while (this.buffer.length > 4) {
        var cursor = 0;
        var length = this.buffer.readUInt16LE(cursor);
        cursor += 2;
        var headerSize = this.buffer.readUInt16LE(cursor);
        if (headerSize < HEADER_SIZE_V1 || headerSize > HEADER_SIZE_MAX) {
          headerSize = HEADER_SIZE_V1;
        }
        cursor += 2;
        if (this.buffer.length < headerSize + length) {
          break;
        }
        var entry2 = new entry_1$1.default();
        entry2.setPid(this.buffer.readInt32LE(cursor));
        cursor += 4;
        entry2.setTid(this.buffer.readInt32LE(cursor));
        cursor += 4;
        var sec = this.buffer.readInt32LE(cursor);
        cursor += 4;
        var nsec = this.buffer.readInt32LE(cursor);
        entry2.setDate(new Date(sec * 1e3 + nsec / 1e6));
        cursor += 4;
        cursor = headerSize;
        var data = this.buffer.slice(cursor, cursor + length);
        cursor += length;
        this.buffer = this.buffer.slice(cursor);
        this._processEntry(entry2, data);
      }
      if (this.buffer.length) {
        this.emit("wait");
      } else {
        this.emit("drain");
      }
    };
    Binary2.prototype._processEntry = function(entry2, data) {
      entry2.setPriority(data[0]);
      var cursor = 1;
      while (cursor < data.length) {
        if (data[cursor] === 0) {
          entry2.setTag(data.slice(1, cursor).toString());
          entry2.setMessage(data.slice(cursor + 1, data.length - 1).toString());
          this.emit("entry", entry2);
          return;
        }
        cursor += 1;
      }
      this.emit("error", new Error("Unprocessable entry data '".concat(data, "'")));
    };
    return Binary2;
  }(events_1$6.EventEmitter)
);
var binary = Binary;
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d3[p] = b2[p];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __2() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
  };
}();
var stream_1$3 = require$$1$3;
var Transform = (
  /** @class */
  function(_super) {
    __extends$1(Transform2, _super);
    function Transform2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.savedR = null;
      return _this;
    }
    Transform2.prototype._transform = function(chunk, encoding3, done) {
      var lo = 0;
      var hi = 0;
      if (this.savedR) {
        if (chunk[0] !== 10) {
          this.push(this.savedR);
        }
        this.savedR = null;
      }
      var last = chunk.length - 1;
      while (hi <= last) {
        if (chunk[hi] === 13) {
          if (hi === last) {
            this.savedR = chunk.slice(last);
            break;
          } else if (chunk[hi + 1] === 10) {
            this.push(chunk.slice(lo, hi));
            lo = hi + 1;
          }
        }
        hi += 1;
      }
      if (hi !== lo) {
        this.push(chunk.slice(lo, hi));
      }
      done();
    };
    return Transform2;
  }(stream_1$3.Transform)
);
var transform = Transform;
var codes = {
  UNKNOWN: 0,
  DEFAULT: 1,
  VERBOSE: 2,
  DEBUG: 3,
  INFO: 4,
  WARN: 5,
  ERROR: 6,
  FATAL: 7,
  SILENT: 8
};
var names = {
  0: "UNKNOWN",
  1: "DEFAULT",
  2: "VERBOSE",
  3: "DEBUG",
  4: "INFO",
  5: "WARN",
  6: "ERROR",
  7: "FATAL",
  8: "SILENT"
};
var letters = {
  "?": codes.UNKNOWN,
  V: codes.VERBOSE,
  D: codes.DEBUG,
  I: codes.INFO,
  W: codes.WARN,
  E: codes.ERROR,
  F: codes.FATAL,
  S: codes.SILENT
};
var letterNames = {
  0: "?",
  1: "?",
  2: "V",
  3: "D",
  4: "I",
  5: "W",
  6: "E",
  7: "F",
  8: "S"
};
var Priority = (
  /** @class */
  function() {
    function Priority2() {
    }
    Priority2.fromName = function(name) {
      var value = codes[name.toUpperCase()];
      if (value || value === 0) {
        return value;
      }
      return Priority2.fromLetter(name);
    };
    Priority2.toName = function(value) {
      return names[value];
    };
    Priority2.fromLetter = function(letter) {
      return letters[letter.toUpperCase()];
    };
    Priority2.toLetter = function(value) {
      return letterNames[value];
    };
    Priority2.UNKNOWN = codes.UNKNOWN;
    Priority2.DEFAULT = codes.DEFAULT;
    Priority2.VERBOSE = codes.VERBOSE;
    Priority2.DEBUG = codes.DEBUG;
    Priority2.INFO = codes.INFO;
    Priority2.WARN = codes.WARN;
    Priority2.ERROR = codes.ERROR;
    Priority2.FATAL = codes.FATAL;
    Priority2.SILENT = codes.SILENT;
    return Priority2;
  }()
);
var priority = Priority;
var __extends = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d3[p] = b2[p];
    };
    return extendStatics(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __2() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
  };
}();
var __importDefault$K = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
var events_1$5 = require$$0$9;
var binary_1 = __importDefault$K(binary);
var transform_1 = __importDefault$K(transform);
var priority_1$1 = __importDefault$K(priority);
var Reader = (
  /** @class */
  function(_super) {
    __extends(Reader2, _super);
    function Reader2(options2) {
      var _this = _super.call(this, options2) || this;
      _this.options = options2;
      _this.parser = new binary_1.default();
      _this.stream = null;
      var defaults2 = {
        format: "binary",
        fixLineFeeds: true,
        priority: priority_1$1.default.DEBUG
      };
      _this.options = Object.assign({}, defaults2, options2);
      _this.filters = {
        all: -1,
        tags: {}
      };
      if (_this.options.format !== "binary") {
        throw new Error("Unsupported format '".concat(_this.options.format, "'"));
      }
      return _this;
    }
    Reader2.prototype.exclude = function(tag) {
      if (tag === Reader2.ANY) {
        return this.excludeAll();
      }
      this.filters.tags[tag] = priority_1$1.default.SILENT;
      return this;
    };
    Reader2.prototype.excludeAll = function() {
      this.filters.all = priority_1$1.default.SILENT;
      return this;
    };
    Reader2.prototype.include = function(tag, priority2) {
      if (priority2 === void 0) {
        priority2 = this.options.priority;
      }
      if (tag === Reader2.ANY) {
        return this.includeAll(priority2);
      }
      this.filters.tags[tag] = this._priority(priority2);
      return this;
    };
    Reader2.prototype.includeAll = function(priority2) {
      if (priority2 === void 0) {
        priority2 = this.options.priority;
      }
      this.filters.all = this._priority(priority2);
      return this;
    };
    Reader2.prototype.resetFilters = function() {
      this.filters.all = -1;
      this.filters.tags = {};
      return this;
    };
    Reader2.prototype._hook = function() {
      var _this = this;
      if (this.options.fixLineFeeds) {
        var transform2 = this.stream.pipe(new transform_1.default());
        transform2.on("data", function(data) {
          _this.parser.parse(data);
        });
      } else {
        this.stream.on("data", function(data) {
          _this.parser.parse(data);
        });
      }
      this.stream.on("error", function(err) {
        _this.emit("error", err);
      });
      this.stream.on("end", function() {
        _this.emit("end");
      });
      this.stream.on("finish", function() {
        _this.emit("finish");
      });
      this.parser.on("entry", function(entry2) {
        if (_this._filter(entry2)) {
          _this.emit("entry", entry2);
        }
      });
      this.parser.on("error", function(err) {
        _this.emit("error", err);
      });
    };
    Reader2.prototype._filter = function(entry2) {
      var wanted = entry2.tag in this.filters.tags ? this.filters.tags[entry2.tag] : this.filters.all;
      return entry2.priority >= wanted;
    };
    Reader2.prototype._priority = function(priority2) {
      return typeof priority2 === "number" ? priority2 : priority_1$1.default.fromName(priority2);
    };
    Reader2.prototype.connect = function(stream2) {
      this.stream = stream2;
      this._hook();
      return this;
    };
    Reader2.prototype.end = function() {
      this.stream.end();
      return this;
    };
    Reader2.ANY = "*";
    return Reader2;
  }(events_1$5.EventEmitter)
);
var reader = Reader;
var __importDefault$J = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
var reader_1 = __importDefault$J(reader);
var priority_1 = __importDefault$J(priority);
var Logcat = (
  /** @class */
  function() {
    function Logcat2() {
    }
    Logcat2.readStream = function(stream2, options2) {
      return new reader_1.default(options2).connect(stream2);
    };
    Logcat2.Reader = reader_1.default;
    Logcat2.Priority = priority_1.default;
    return Logcat2;
  }()
);
var logcat$1 = Logcat;
var __importDefault$I = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
var logcat_1 = __importDefault$I(logcat$1);
var adbkitLogcat = logcat_1.default;
var sync$1 = {};
var stats = {};
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
  }
  __setModuleDefault$1(result, mod);
  return result;
};
Object.defineProperty(stats, "__esModule", { value: true });
const Fs$1 = __importStar$1(require$$0$8);
class Stats extends Fs$1.Stats {
  constructor(mode, sizeBig, mtime) {
    super();
    this.mode = Number(mode);
    this.size = Number(sizeBig);
    this.sizeBig = sizeBig;
    this.mtimeMs = mtime * 1e3;
  }
}
Stats.S_IFMT = 61440;
Stats.S_IFSOCK = 49152;
Stats.S_IFLNK = 40960;
Stats.S_IFREG = 32768;
Stats.S_IFBLK = 24576;
Stats.S_IFDIR = 16384;
Stats.S_IFCHR = 8192;
Stats.S_IFIFO = 4096;
Stats.S_ISUID = 2048;
Stats.S_ISGID = 1024;
Stats.S_ISVTX = 512;
Stats.S_IRWXU = 448;
Stats.S_IRUSR = 256;
Stats.S_IWUSR = 128;
Stats.S_IXUSR = 64;
Stats.S_IRWXG = 56;
Stats.S_IRGRP = 32;
stats.default = Stats;
var __importDefault$H = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
const stats_1$1 = __importDefault$H(stats);
class Entry2 extends stats_1$1.default {
  constructor(name, mode, size, mtime) {
    super(mode, BigInt(size), mtime);
    this.name = name;
  }
  toString() {
    return this.name;
  }
}
var entry = Entry2;
var pushtransfer = {};
Object.defineProperty(pushtransfer, "__esModule", { value: true });
const events_1$4 = require$$0$9;
class PushTransfer extends events_1$4.EventEmitter {
  constructor() {
    super(...arguments);
    this._stack = [];
    this.stats = {
      bytesTransferred: 0
    };
  }
  cancel() {
    return this.emit("cancel");
  }
  push(byteCount) {
    return this._stack.push(byteCount);
  }
  pop() {
    const byteCount = this._stack.pop();
    if (byteCount) {
      this.stats.bytesTransferred += byteCount;
    }
    return this.emit("progress", this.stats);
  }
  end() {
    return this.emit("end");
  }
}
pushtransfer.default = PushTransfer;
var pulltransfer = {};
Object.defineProperty(pulltransfer, "__esModule", { value: true });
const stream_1$2 = require$$1$3;
class PullTransfer extends stream_1$2.Stream.PassThrough {
  constructor() {
    super(...arguments);
    this.stats = {
      bytesTransferred: 0
    };
  }
  cancel() {
    return this.emit("cancel");
  }
  write(chunk, encoding3, callback) {
    this.stats.bytesTransferred += chunk.length;
    this.emit("progress", this.stats);
    if (typeof encoding3 === "function") {
      return super.write(chunk, encoding3);
    }
    return super.write(chunk, encoding3, callback);
  }
}
pulltransfer.default = PullTransfer;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault$G = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(sync$1, "__esModule", { value: true });
const Fs = __importStar(require$$0$8);
const Path = __importStar(require$$1$2);
const bluebird_1$4 = __importDefault$G(bluebird_1$b);
const events_1$3 = require$$0$9;
const debug_1$2 = __importDefault$G(srcExports);
const parser_1$7 = __importDefault$G(parser$1);
const protocol_1$x = __importDefault$G(protocol2);
const stats_1 = __importDefault$G(stats);
const entry_1 = __importDefault$G(entry);
const pushtransfer_1 = __importDefault$G(pushtransfer);
const pulltransfer_1 = __importDefault$G(pulltransfer);
const TEMP_PATH = "/data/local/tmp";
const DEFAULT_CHMOD = 420;
const DATA_MAX_LENGTH = 65536;
const debug$2 = (0, debug_1$2.default)("adb:sync");
class Sync extends events_1$3.EventEmitter {
  static temp(path3) {
    return `${TEMP_PATH}/${Path.basename(path3)}`;
  }
  constructor(connection2) {
    super();
    this.connection = connection2;
    this.parser = this.connection.parser;
  }
  stat(path3, callback) {
    this._sendCommandWithArg(protocol_1$x.default.STAT, path3);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$x.default.STAT:
          return this.parser.readBytes(12).then((stat2) => {
            const mode = stat2.readUInt32LE(0);
            const size = stat2.readUInt32LE(4);
            const mtime = stat2.readUInt32LE(8);
            if (mode === 0) {
              return this._enoent(path3);
            } else {
              return new stats_1.default(mode, BigInt(size), mtime);
            }
          });
        case protocol_1$x.default.FAIL:
          return this._readError();
        default:
          return this.parser.unexpected(reply2, "STAT or FAIL");
      }
    }).nodeify(callback);
  }
  sta2(path3, callback) {
    this._sendCommandWithArg(protocol_1$x.default.STA2, path3);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$x.default.STA2:
          return this.parser.readBytes(68).then((stat2) => {
            const mode = stat2.readUInt32LE(20);
            const size = stat2.readBigUInt64LE(36);
            const mtime = stat2.readBigUInt64LE(52);
            if (mode === 0) {
              return this._enoent(path3);
            } else {
              return new stats_1.default(mode, size, Number(mtime));
            }
          });
        case protocol_1$x.default.FAIL:
          return this._readError();
        default:
          return this.parser.unexpected(reply2, "STA2 or FAIL");
      }
    }).nodeify(callback);
  }
  readdir(path3, callback) {
    const files = [];
    const readNext = () => {
      return this.parser.readAscii(4).then((reply2) => {
        switch (reply2) {
          case protocol_1$x.default.DENT:
            return this.parser.readBytes(16).then((stat2) => {
              const mode = stat2.readUInt32LE(0);
              const size = stat2.readUInt32LE(4);
              const mtime = stat2.readUInt32LE(8);
              const namelen = stat2.readUInt32LE(12);
              return this.parser.readBytes(namelen).then(function(name) {
                const nameString = name.toString();
                if (!(nameString === "." || nameString === "..")) {
                  files.push(new entry_1.default(nameString, mode, size, mtime));
                }
                return readNext();
              });
            });
          case protocol_1$x.default.DONE:
            return this.parser.readBytes(16).then(function() {
              return files;
            });
          case protocol_1$x.default.FAIL:
            return this._readError();
          default:
            return this.parser.unexpected(reply2, "DENT, DONE or FAIL");
        }
      });
    };
    this._sendCommandWithArg(protocol_1$x.default.LIST, path3);
    return readNext().nodeify(callback);
  }
  push(contents, path3, mode) {
    if (typeof contents === "string") {
      return this.pushFile(contents, path3, mode);
    } else {
      return this.pushStream(contents, path3, mode);
    }
  }
  pushFile(file, path3, mode = DEFAULT_CHMOD) {
    mode || (mode = DEFAULT_CHMOD);
    return this.pushStream(Fs.createReadStream(file), path3, mode);
  }
  pushStream(stream2, path3, mode = DEFAULT_CHMOD) {
    mode |= stats_1.default.S_IFREG;
    this._sendCommandWithArg(protocol_1$x.default.SEND, `${path3},${mode}`);
    return this._writeData(stream2, Math.floor(Date.now() / 1e3));
  }
  pull(path3) {
    this._sendCommandWithArg(protocol_1$x.default.RECV, `${path3}`);
    return this._readData();
  }
  end() {
    this.connection.end();
    return this;
  }
  tempFile(path3) {
    return Sync.temp(path3);
  }
  _writeData(stream2, timeStamp) {
    const transfer = new pushtransfer_1.default();
    const writeData = () => {
      let readableListener;
      let connErrorListener;
      let endListener;
      let errorListener;
      let resolver = bluebird_1$4.default.defer();
      const writer2 = bluebird_1$4.default.resolve();
      endListener = () => {
        writer2.then(() => {
          this._sendCommandWithLength(protocol_1$x.default.DONE, timeStamp);
          return resolver.resolve();
        });
      };
      stream2.on("end", endListener);
      const waitForDrain = () => {
        resolver = bluebird_1$4.default.defer();
        const drainListener = () => {
          resolver.resolve();
        };
        this.connection.on("drain", drainListener);
        return resolver.promise.finally(() => {
          return this.connection.removeListener("drain", drainListener);
        });
      };
      const track = () => transfer.pop();
      const writeNext = () => {
        let chunk;
        if (chunk = stream2.read(DATA_MAX_LENGTH) || stream2.read()) {
          this._sendCommandWithLength(protocol_1$x.default.DATA, chunk.length);
          transfer.push(chunk.length);
          if (this.connection.write(chunk, track)) {
            return writeNext();
          } else {
            return waitForDrain().then(writeNext);
          }
        } else {
          return bluebird_1$4.default.resolve();
        }
      };
      readableListener = () => writer2.then(writeNext);
      stream2.on("readable", readableListener);
      errorListener = (err) => resolver.reject(err);
      stream2.on("error", errorListener);
      connErrorListener = (err) => {
        stream2.destroy(err);
        this.connection.end();
        resolver.reject(err);
      };
      this.connection.on("error", connErrorListener);
      return resolver.promise.finally(() => {
        stream2.removeListener("end", endListener);
        stream2.removeListener("readable", readableListener);
        stream2.removeListener("error", errorListener);
        this.connection.removeListener("error", connErrorListener);
        return writer2.cancel();
      });
    };
    const readReply = () => {
      return this.parser.readAscii(4).then((reply2) => {
        switch (reply2) {
          case protocol_1$x.default.OKAY:
            return this.parser.readBytes(4).then(function() {
              return true;
            });
          case protocol_1$x.default.FAIL:
            return this._readError();
          default:
            return this.parser.unexpected(reply2, "OKAY or FAIL");
        }
      });
    };
    const writer = writeData().catch(bluebird_1$4.default.CancellationError, () => {
      return this.connection.end();
    }).catch(function(err) {
      transfer.emit("error", err);
      return reader2.cancel();
    });
    const reader2 = readReply().catch(bluebird_1$4.default.CancellationError, () => true).catch((err) => {
      transfer.emit("error", err);
      return writer.cancel();
    }).finally(() => {
      return transfer.end();
    });
    transfer.on("cancel", () => {
      writer.cancel();
      reader2.cancel();
    });
    return transfer;
  }
  _readData() {
    const transfer = new pulltransfer_1.default();
    const readEnd = (afterEnd) => {
      transfer.removeListener("cancel", cancelListener);
      let retEnd = transfer.end();
      if (afterEnd) {
        return afterEnd();
      } else {
        return retEnd;
      }
    };
    const readNext = () => {
      return this.parser.readAscii(4).then((reply2) => {
        switch (reply2) {
          case protocol_1$x.default.DATA:
            return this.parser.readBytes(4).then((lengthData) => {
              const length = lengthData.readUInt32LE(0);
              return this.parser.readByteFlow(length, transfer).then(() => {
                return readNext();
              });
            });
          case protocol_1$x.default.DONE:
            return this.parser.readBytes(4).then(function() {
              return readEnd();
            });
          case protocol_1$x.default.FAIL:
            return readEnd(() => {
              return this._readError();
            });
          default:
            return readEnd(() => {
              return this.parser.unexpected(reply2, "DATA, DONE or FAIL");
            });
        }
      });
    };
    const reader2 = readNext().catch(bluebird_1$4.default.CancellationError, () => this.connection.end()).catch((err) => transfer.emit("error", err));
    const cancelListener = () => reader2.cancel();
    transfer.on("cancel", cancelListener);
    return transfer;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _readError() {
    return this.parser.readBytes(4).then((length) => {
      return this.parser.readBytes(length.readUInt32LE(0)).then((buf) => {
        return bluebird_1$4.default.reject(new parser_1$7.default.FailError(buf.toString()));
      });
    }).finally(() => {
      return this.parser.end();
    });
  }
  _sendCommandWithLength(cmd, length) {
    if (cmd !== protocol_1$x.default.DATA) {
      debug$2(cmd);
    }
    const payload = Buffer.alloc(cmd.length + 4);
    payload.write(cmd, 0, cmd.length);
    payload.writeUInt32LE(length, cmd.length);
    return this.connection.write(payload);
  }
  _sendCommandWithArg(cmd, arg) {
    debug$2(`${cmd} ${arg}`);
    const arglen = Buffer.byteLength(arg, "utf-8");
    const payload = Buffer.alloc(cmd.length + 4 + arglen);
    let pos = 0;
    payload.write(cmd, pos, cmd.length);
    pos += cmd.length;
    payload.writeUInt32LE(arglen, pos);
    pos += 4;
    payload.write(arg, pos);
    return this.connection.write(payload);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _enoent(path3) {
    const err = new Error(`ENOENT, no such file or directory '${path3}'`);
    err.errno = 34;
    err.code = "ENOENT";
    err.path = path3;
    return bluebird_1$4.default.reject(err);
  }
}
sync$1.default = Sync;
var __importDefault$F = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
const events_1$2 = require$$0$9;
const parser_1$6 = __importDefault$F(parser$1);
const bluebird_1$3 = __importDefault$F(bluebird_1$b);
const RE_CPULINE = /^cpu[0-9]+ .*$/gm;
const RE_COLSEP = /\ +/g;
class ProcStat extends events_1$2.EventEmitter {
  constructor(sync2) {
    super();
    this.sync = sync2;
    this.interval = 1e3;
    this.stats = this._emptyStats();
    this._ignore = {};
    this._timer = setInterval(() => {
      return this.update();
    }, this.interval);
    this.update();
  }
  end() {
    clearInterval(this._timer);
    if (this.sync) {
      this.sync.end();
      this.sync = void 0;
    }
  }
  update() {
    if (!this.sync) {
      throw Error("Closed");
    }
    return new parser_1$6.default(this.sync.pull("/proc/stat")).readAll().then((out) => {
      return this._parse(out.toString());
    }).catch((err) => {
      this._error(err);
      return bluebird_1$3.default.reject(err);
    });
  }
  _parse(out) {
    let match2, val;
    const stats2 = this._emptyStats();
    while (match2 = RE_CPULINE.exec(out)) {
      const line = match2[0];
      const cols = line.split(RE_COLSEP);
      const type3 = cols.shift();
      if (this._ignore[type3] === line) {
        continue;
      }
      let total = 0;
      for (let i = 0, len = cols.length; i < len; i++) {
        val = cols[i];
        total += +val;
      }
      stats2.cpus[type3] = {
        line,
        user: +cols[0] || 0,
        nice: +cols[1] || 0,
        system: +cols[2] || 0,
        idle: +cols[3] || 0,
        iowait: +cols[4] || 0,
        irq: +cols[5] || 0,
        softirq: +cols[6] || 0,
        steal: +cols[7] || 0,
        guest: +cols[8] || 0,
        guestnice: +cols[9] || 0,
        total
      };
    }
    return this._set(stats2);
  }
  _set(stats2) {
    const loads = {};
    let found = false;
    const ref2 = stats2.cpus;
    for (const id in ref2) {
      const cur = ref2[id];
      const old2 = this.stats.cpus[id];
      if (!old2) {
        continue;
      }
      const ticks = cur.total - old2.total;
      if (ticks > 0) {
        found = true;
        const m2 = 100 / ticks;
        loads[id] = {
          user: Math.floor(m2 * (cur.user - old2.user)),
          nice: Math.floor(m2 * (cur.nice - old2.nice)),
          system: Math.floor(m2 * (cur.system - old2.system)),
          idle: Math.floor(m2 * (cur.idle - old2.idle)),
          iowait: Math.floor(m2 * (cur.iowait - old2.iowait)),
          irq: Math.floor(m2 * (cur.irq - old2.irq)),
          softirq: Math.floor(m2 * (cur.softirq - old2.softirq)),
          steal: Math.floor(m2 * (cur.steal - old2.steal)),
          guest: Math.floor(m2 * (cur.guest - old2.guest)),
          guestnice: Math.floor(m2 * (cur.guestnice - old2.guestnice)),
          total: 100
        };
      } else {
        this._ignore[id] = cur.line;
        delete stats2.cpus[id];
      }
    }
    if (found) {
      this.emit("load", loads);
    }
    return this.stats = stats2;
  }
  _error(err) {
    return this.emit("error", err);
  }
  _emptyStats() {
    return {
      cpus: {}
    };
  }
}
var stat = ProcStat;
var hostTransport = {};
var clear = {};
var __importDefault$E = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(clear, "__esModule", { value: true });
const protocol_1$w = __importDefault$E(protocol2);
const command_1$w = __importDefault$E(command$1);
class ClearCommand extends command_1$w.default {
  execute(pkg) {
    this._send(`shell:pm clear ${pkg}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$w.default.OKAY:
          return this.parser.searchLine(/^(Success|Failed)$/).finally(() => {
            return this.parser.end();
          }).then(function(result) {
            switch (result[0]) {
              case "Success":
                return true;
              case "Failed":
                throw new Error(`Package '${pkg}' could not be cleared`);
            }
            return false;
          });
        case protocol_1$w.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
clear.default = ClearCommand;
var framebuffer = {};
var __importDefault$D = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
const assert_1 = __importDefault$D(require$$0$d);
const stream_1$1 = require$$1$3;
class RgbTransform extends stream_1$1.Stream.Transform {
  constructor(meta, options2) {
    super(options2);
    this.meta = meta;
    this._buffer = Buffer.from("");
    assert_1.default.ok(this.meta.bpp === 24 || this.meta.bpp === 32, "Only 24-bit and 32-bit raw images with 8-bits per color are supported");
    this._r_pos = this.meta.red_offset / 8;
    this._g_pos = this.meta.green_offset / 8;
    this._b_pos = this.meta.blue_offset / 8;
    this._a_pos = this.meta.alpha_offset / 8;
    this._pixel_bytes = this.meta.bpp / 8;
  }
  _transform(chunk, encoding3, done) {
    if (this._buffer.length) {
      this._buffer = Buffer.concat([this._buffer, chunk], this._buffer.length + chunk.length);
    } else {
      this._buffer = chunk;
    }
    let sourceCursor = 0;
    let targetCursor = 0;
    const target = this._pixel_bytes === 3 ? this._buffer : Buffer.alloc(Math.max(4, chunk.length / this._pixel_bytes * 3));
    while (this._buffer.length - sourceCursor >= this._pixel_bytes) {
      const r = this._buffer[sourceCursor + this._r_pos];
      const g = this._buffer[sourceCursor + this._g_pos];
      const b = this._buffer[sourceCursor + this._b_pos];
      target[targetCursor + 0] = r;
      target[targetCursor + 1] = g;
      target[targetCursor + 2] = b;
      sourceCursor += this._pixel_bytes;
      targetCursor += 3;
    }
    if (targetCursor) {
      this.push(target.slice(0, targetCursor));
      this._buffer = this._buffer.slice(sourceCursor);
    }
    done();
  }
}
var rgbtransform = RgbTransform;
var __importDefault$C = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(framebuffer, "__esModule", { value: true });
const child_process_1 = require$$0$c;
const debug_1$1 = __importDefault$C(srcExports);
const rgbtransform_1 = __importDefault$C(rgbtransform);
const protocol_1$v = __importDefault$C(protocol2);
const command_1$v = __importDefault$C(command$1);
const debug$1 = (0, debug_1$1.default)("adb:command:framebuffer");
class FrameBufferCommand extends command_1$v.default {
  execute(format2) {
    this._send("framebuffer:");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$v.default.OKAY:
          return this.parser.readBytes(52).then((header3) => {
            let stream2;
            const meta = this._parseHeader(header3);
            switch (format2) {
              case "raw":
                stream2 = this.parser.raw();
                stream2.meta = meta;
                return stream2;
              default:
                stream2 = this._convert(meta, format2);
                stream2.meta = meta;
                return stream2;
            }
          });
        case protocol_1$v.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
  _convert(meta, format2, raw) {
    debug$1(`Converting raw framebuffer stream into ${format2.toUpperCase()}`);
    switch (meta.format) {
      case "rgb":
      case "rgba":
        break;
      default:
        debug$1(`Silently transforming '${meta.format}' into 'rgb' for \`gm\``);
        const transform2 = new rgbtransform_1.default(meta);
        meta.format = "rgb";
        raw = this.parser.raw().pipe(transform2);
    }
    const proc = (0, child_process_1.spawn)("gm", ["convert", "-size", `${meta.width}x${meta.height}`, `${meta.format}:-`, `${format2}:-`]);
    if (raw) {
      raw.pipe(proc.stdin);
    }
    return proc.stdout;
  }
  _parseHeader(header3) {
    let offset = 0;
    const version2 = header3.readUInt32LE(offset);
    if (version2 === 16) {
      throw new Error("Old-style raw images are not supported");
    }
    offset += 4;
    const bpp = header3.readUInt32LE(offset);
    offset += 4;
    const size = header3.readUInt32LE(offset);
    offset += 4;
    const width = header3.readUInt32LE(offset);
    offset += 4;
    const height = header3.readUInt32LE(offset);
    offset += 4;
    const red_offset = header3.readUInt32LE(offset);
    offset += 4;
    const red_length = header3.readUInt32LE(offset);
    offset += 4;
    const blue_offset = header3.readUInt32LE(offset);
    offset += 4;
    const blue_length = header3.readUInt32LE(offset);
    offset += 4;
    const green_offset = header3.readUInt32LE(offset);
    offset += 4;
    const green_length = header3.readUInt32LE(offset);
    offset += 4;
    const alpha_offset = header3.readUInt32LE(offset);
    offset += 4;
    const alpha_length = header3.readUInt32LE(offset);
    let format2 = blue_offset === 0 ? "bgr" : "rgb";
    if (bpp === 32 || alpha_length) {
      format2 += "a";
    }
    return {
      version: version2,
      bpp,
      size,
      width,
      height,
      red_offset,
      red_length,
      blue_offset,
      blue_length,
      green_offset,
      green_length,
      alpha_offset,
      alpha_length,
      format: format2
    };
  }
}
framebuffer.default = FrameBufferCommand;
var getfeatures = {};
var __importDefault$B = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(getfeatures, "__esModule", { value: true });
const command_1$u = __importDefault$B(command$1);
const protocol_1$u = __importDefault$B(protocol2);
const RE_FEATURE = /^feature:(.*?)(?:=(.*?))?\r?$/gm;
class GetFeaturesCommand extends command_1$u.default {
  execute() {
    this._send("shell:pm list features 2>/dev/null");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$u.default.OKAY:
          return this.parser.readAll().then((data) => {
            return this._parseFeatures(data.toString());
          });
        case protocol_1$u.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
  _parseFeatures(value) {
    const features = {};
    let match2;
    while (match2 = RE_FEATURE.exec(value)) {
      features[match2[1]] = match2[2] || true;
    }
    return features;
  }
}
getfeatures.default = GetFeaturesCommand;
var getpackages = {};
var __importDefault$A = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(getpackages, "__esModule", { value: true });
const command_1$t = __importDefault$A(command$1);
const protocol_1$t = __importDefault$A(protocol2);
class GetPackagesCommand extends command_1$t.default {
  execute(flags) {
    if (flags) {
      this._send(`shell:pm list packages ${flags} 2>/dev/null`);
    } else {
      this._send("shell:pm list packages 2>/dev/null");
    }
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$t.default.OKAY:
          return this.parser.readAll().then((data) => {
            return this._parsePackages(data.toString());
          });
        case protocol_1$t.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
  _parsePackages(value) {
    const packages = [];
    const RE_PACKAGE = /^package:(.*?)\r?$/gm;
    while (true) {
      const match2 = RE_PACKAGE.exec(value);
      if (match2) {
        packages.push(match2[1]);
      } else {
        break;
      }
    }
    return packages;
  }
}
getpackages.default = GetPackagesCommand;
var getproperties = {};
var __importDefault$z = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(getproperties, "__esModule", { value: true });
const protocol_1$s = __importDefault$z(protocol2);
const command_1$s = __importDefault$z(command$1);
const RE_KEYVAL = /^\[([\s\S]*?)\]: \[([\s\S]*?)\]\r?$/gm;
class GetPropertiesCommand extends command_1$s.default {
  execute() {
    this._send("shell:getprop");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$s.default.OKAY:
          return this.parser.readAll().then((data) => {
            return this._parseProperties(data.toString());
          });
        case protocol_1$s.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
  _parseProperties(value) {
    const properties = {};
    let match2;
    while (match2 = RE_KEYVAL.exec(value)) {
      properties[match2[1]] = match2[2];
    }
    return properties;
  }
}
getproperties.default = GetPropertiesCommand;
var install = {};
var __importDefault$y = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(install, "__esModule", { value: true });
const protocol_1$r = __importDefault$y(protocol2);
const command_1$r = __importDefault$y(command$1);
const OKAY_OUTPUT_REGEXP = /^(Success|Failure \[(.*?)\]|Exception)(.*)$/;
const INSTALL_EXCEPTION_CODE = "INSTALL_EXCEPTION";
class InstallError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}
class InstallCommand extends command_1$r.default {
  execute(apk) {
    this._send(`shell:pm install -r ${this._escapeCompat(apk)}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$r.default.OKAY:
          return this.parser.searchLine(OKAY_OUTPUT_REGEXP).then((match2) => {
            if (match2[1] === "Success") {
              return true;
            } else if (match2[1] === "Exception") {
              return this.parser.readLine().then((buffer2) => {
                throw new InstallError(buffer2.toString(), INSTALL_EXCEPTION_CODE);
              });
            } else {
              const code = match2[2];
              throw new InstallError(`${apk} could not be installed [${code}]`, code);
            }
          }).finally(() => {
            return this.parser.readAll();
          });
        case protocol_1$r.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
install.default = InstallCommand;
var isinstalled = {};
var __importDefault$x = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(isinstalled, "__esModule", { value: true });
const protocol_1$q = __importDefault$x(protocol2);
const parser_1$5 = __importDefault$x(parser$1);
const command_1$q = __importDefault$x(command$1);
class IsInstalledCommand extends command_1$q.default {
  execute(pkg) {
    this._send(`shell:pm path ${pkg} 2>/dev/null`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$q.default.OKAY:
          return this.parser.readAscii(8).then((reply3) => {
            switch (reply3) {
              case "package:":
                return true;
              default:
                return this.parser.unexpected(reply3, "'package:'");
            }
          }).catch(parser_1$5.default.PrematureEOFError, function() {
            return false;
          });
        case protocol_1$q.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
isinstalled.default = IsInstalledCommand;
var listreverses = {};
var __importDefault$w = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(listreverses, "__esModule", { value: true });
const protocol_1$p = __importDefault$w(protocol2);
const command_1$p = __importDefault$w(command$1);
class ListReversesCommand extends command_1$p.default {
  execute() {
    this._send("reverse:list-forward");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$p.default.OKAY:
          return this.parser.readValue().then((value) => {
            return this._parseReverses(value);
          });
        case protocol_1$p.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
  _parseReverses(value) {
    const reverses = [];
    const ref2 = value.toString().split("\n");
    for (let i = 0, len = ref2.length; i < len; i++) {
      const reverse2 = ref2[i];
      if (reverse2) {
        const [, remote, local2] = reverse2.split(/\s+/);
        reverses.push({ remote, local: local2 });
      }
    }
    return reverses;
  }
}
listreverses.default = ListReversesCommand;
var local = {};
var __importDefault$v = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(local, "__esModule", { value: true });
const protocol_1$o = __importDefault$v(protocol2);
const command_1$o = __importDefault$v(command$1);
class LocalCommand extends command_1$o.default {
  execute(path3) {
    this._send(/:/.test(path3) ? path3 : `localfilesystem:${path3}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$o.default.OKAY:
          return this.parser.raw();
        case protocol_1$o.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
local.default = LocalCommand;
var log = {};
var __importDefault$u = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(log, "__esModule", { value: true });
const protocol_1$n = __importDefault$u(protocol2);
const command_1$n = __importDefault$u(command$1);
class LogCommand extends command_1$n.default {
  execute(name) {
    this._send(`log:${name}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$n.default.OKAY:
          return this.parser.raw();
        case protocol_1$n.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
log.default = LogCommand;
var logcat = {};
var linetransform = {};
var __importDefault$t = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(linetransform, "__esModule", { value: true });
const stream_1 = __importDefault$t(require$$1$3);
class LineTransform extends stream_1.default.Transform {
  constructor(options2 = {}) {
    super(options2);
    this.autoDetect = options2.autoDetect || false;
    this.transformNeeded = true;
    this.skipBytes = 0;
  }
  _nullTransform(chunk, encoding3, done) {
    this.push(chunk);
    done();
  }
  // Sadly, the ADB shell is not very smart. It automatically converts every
  // 0x0a ('\n') it can find to 0x0d 0x0a ('\r\n'). This also applies to binary
  // content. We could get rid of this behavior by setting `stty raw`, but
  // unfortunately it's not available by default (you'd have to install busybox)
  // or something similar. On the up side, it really does do this for all line
  // feeds, so a simple transform works fine.
  _transform(chunk, encoding3, done) {
    if (this.autoDetect) {
      if (chunk[0] === 10) {
        this.transformNeeded = false;
        this.skipBytes = 1;
      } else {
        this.skipBytes = 2;
      }
      this.autoDetect = false;
    }
    if (this.skipBytes) {
      const skip = Math.min(chunk.length, this.skipBytes);
      chunk = chunk.slice(skip);
      this.skipBytes -= skip;
    }
    if (!chunk.length) {
      return done();
    }
    if (!this.transformNeeded) {
      return this._nullTransform(chunk, encoding3, done);
    }
    let lo = 0;
    let hi = 0;
    if (this.savedR) {
      if (chunk[0] !== 10) {
        this.push(this.savedR);
      }
      this.savedR = void 0;
    }
    const last = chunk.length - 1;
    while (hi <= last) {
      if (chunk[hi] === 13) {
        if (hi === last) {
          this.savedR = chunk.slice(last);
          break;
        } else if (chunk[hi + 1] === 10) {
          this.push(chunk.slice(lo, hi));
          lo = hi + 1;
        }
      }
      hi += 1;
    }
    if (hi !== lo) {
      this.push(chunk.slice(lo, hi));
    }
    done();
  }
  // When the stream ends on an '\r', output it as-is (assume binary data).
  _flush(done) {
    if (this.savedR) {
      this.push(this.savedR);
    }
    done();
  }
}
linetransform.default = LineTransform;
var __importDefault$s = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(logcat, "__esModule", { value: true });
const linetransform_1$1 = __importDefault$s(linetransform);
const protocol_1$m = __importDefault$s(protocol2);
const command_1$m = __importDefault$s(command$1);
class LogcatCommand extends command_1$m.default {
  execute(options2 = {}) {
    let cmd;
    cmd = "logcat -B *:I 2>/dev/null";
    if (options2.clear) {
      cmd = `logcat -c 2>/dev/null && ${cmd}`;
    }
    this._send(`shell:echo && ${cmd}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$m.default.OKAY:
          return this.parser.raw().pipe(new linetransform_1$1.default({
            autoDetect: true
          }));
        case protocol_1$m.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
logcat.default = LogcatCommand;
var monkey = {};
var __importDefault$r = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(monkey, "__esModule", { value: true });
const bluebird_1$2 = __importDefault$r(bluebird_1$b);
const protocol_1$l = __importDefault$r(protocol2);
const command_1$l = __importDefault$r(command$1);
class MonkeyCommand extends command_1$l.default {
  execute(port) {
    this._send(`shell:EXTERNAL_STORAGE=/data/local/tmp monkey --port ${port} -v`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$l.default.OKAY:
          return this.parser.searchLine(/^:Monkey:/).timeout(1e3).then(() => {
            return this.parser.raw();
          }).catch(bluebird_1$2.default.TimeoutError, () => {
            return this.parser.raw();
          });
        case protocol_1$l.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
monkey.default = MonkeyCommand;
var reboot = {};
var __importDefault$q = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(reboot, "__esModule", { value: true });
const protocol_1$k = __importDefault$q(protocol2);
const command_1$k = __importDefault$q(command$1);
class RebootCommand extends command_1$k.default {
  execute() {
    this._send("reboot:");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$k.default.OKAY:
          return this.parser.readAll().return(true);
        case protocol_1$k.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
reboot.default = RebootCommand;
var remount = {};
var __importDefault$p = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(remount, "__esModule", { value: true });
const protocol_1$j = __importDefault$p(protocol2);
const command_1$j = __importDefault$p(command$1);
class RemountCommand extends command_1$j.default {
  execute() {
    this._send("remount:");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$j.default.OKAY:
          return true;
        case protocol_1$j.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
remount.default = RemountCommand;
var reverse = {};
var __importDefault$o = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(reverse, "__esModule", { value: true });
const protocol_1$i = __importDefault$o(protocol2);
const command_1$i = __importDefault$o(command$1);
class ReverseCommand extends command_1$i.default {
  execute(remote, local2) {
    this._send(`reverse:forward:${remote};${local2}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$i.default.OKAY:
          return this.parser.readAscii(4).then((reply3) => {
            switch (reply3) {
              case protocol_1$i.default.OKAY:
                return true;
              case protocol_1$i.default.FAIL:
                return this.parser.readError();
              default:
                return this.parser.unexpected(reply3, "OKAY or FAIL");
            }
          });
        case protocol_1$i.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
reverse.default = ReverseCommand;
var root2 = {};
var __importDefault$n = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(root2, "__esModule", { value: true });
const protocol_1$h = __importDefault$n(protocol2);
const command_1$h = __importDefault$n(command$1);
const RE_OK$2 = /restarting adbd as root/;
class RootCommand extends command_1$h.default {
  execute() {
    this._send("root:");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$h.default.OKAY:
          return this.parser.readAll().then(function(value) {
            if (RE_OK$2.test(value.toString())) {
              return true;
            } else {
              throw new Error(value.toString().trim());
            }
          });
        case protocol_1$h.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
root2.default = RootCommand;
var screencap = {};
var __importDefault$m = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(screencap, "__esModule", { value: true });
const linetransform_1 = __importDefault$m(linetransform);
const protocol_1$g = __importDefault$m(protocol2);
const parser_1$4 = __importDefault$m(parser$1);
const command_1$g = __importDefault$m(command$1);
class ScreencapCommand extends command_1$g.default {
  execute() {
    this._send("shell:echo && screencap -p 2>/dev/null");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$g.default.OKAY:
          let transform2 = new linetransform_1.default();
          return this.parser.readBytes(1).then((chunk) => {
            transform2 = new linetransform_1.default({ autoDetect: true });
            transform2.write(chunk);
            return this.parser.raw().pipe(transform2);
          }).catch(parser_1$4.default.PrematureEOFError, () => {
            throw Error("No support for the screencap command");
          });
        case protocol_1$g.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
screencap.default = ScreencapCommand;
var shell = {};
var __importDefault$l = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(shell, "__esModule", { value: true });
const protocol_1$f = __importDefault$l(protocol2);
const command_1$f = __importDefault$l(command$1);
class ShellCommand extends command_1$f.default {
  execute(command2) {
    if (Array.isArray(command2)) {
      command2 = command2.map(this._escape).join(" ");
    }
    this._send(`shell:${command2}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$f.default.OKAY:
          return this.parser.raw();
        case protocol_1$f.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
shell.default = ShellCommand;
var __importDefault$k = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
const protocol_1$e = __importDefault$k(protocol2);
const parser_1$3 = __importDefault$k(parser$1);
const command_1$e = __importDefault$k(command$1);
const RE_ERROR = /^Error: (.*)$/;
const EXTRA_TYPES = {
  string: "s",
  null: "sn",
  bool: "z",
  int: "i",
  long: "l",
  float: "f",
  uri: "u",
  component: "cn"
};
class StartActivityCommand extends command_1$e.default {
  execute(options2) {
    const args = this._intentArgs(options2);
    if (options2.debug) {
      args.push("-D");
    }
    if (options2.wait) {
      args.push("-W");
    }
    if (options2.user || options2.user === 0) {
      args.push("--user", this._escape(options2.user));
    }
    return this._run("start", args);
  }
  _run(command2, args) {
    this._send(`shell:am ${command2} ${args.join(" ")}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$e.default.OKAY:
          return this.parser.searchLine(RE_ERROR).finally(() => {
            return this.parser.end();
          }).then(function(match2) {
            throw new Error(match2[1]);
          }).catch(parser_1$3.default.PrematureEOFError, function() {
            return true;
          });
        case protocol_1$e.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
  _intentArgs(options2) {
    const args = [];
    if (options2.extras) {
      args.push(...this._formatExtras(options2.extras));
    }
    if (options2.action) {
      args.push("-a", this._escape(options2.action));
    }
    if (options2.data) {
      args.push("-d", this._escape(options2.data));
    }
    if (options2.mimeType) {
      args.push("-t", this._escape(options2.mimeType));
    }
    if (options2.category) {
      if (Array.isArray(options2.category)) {
        options2.category.forEach((category) => {
          return args.push("-c", this._escape(category));
        });
      } else {
        args.push("-c", this._escape(options2.category));
      }
    }
    if (options2.component) {
      args.push("-n", this._escape(options2.component));
    }
    if (options2.flags) {
      args.push("-f", this._escape(options2.flags));
    }
    return args;
  }
  // StartActivityOptions['extras']
  _formatExtras(extras) {
    if (!extras) {
      return [];
    }
    if (Array.isArray(extras)) {
      return extras.reduce((all2, extra) => {
        return all2.concat(this._formatLongExtra(extra));
      }, []);
    } else {
      return Object.keys(extras).reduce((all2, key) => {
        return all2.concat(this._formatShortExtra(key, extras[key]));
      }, []);
    }
  }
  _formatShortExtra(key, value) {
    let sugared = {
      key,
      type: "",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      value: void 0
    };
    if (value === null) {
      sugared.type = "null";
    } else if (Array.isArray(value)) {
      throw new Error(`Refusing to format array value '${key}' using short syntax; empty array would cause unpredictable results due to unknown type. Please use long syntax instead.`);
    } else {
      switch (typeof value) {
        case "string":
          sugared.type = "string";
          sugared.value = value;
          break;
        case "boolean":
          sugared.type = "bool";
          sugared.value = value;
          break;
        case "number":
          sugared.type = "int";
          sugared.value = value;
          break;
        case "object":
          sugared = value;
          sugared.key = key;
      }
    }
    return this._formatLongExtra(sugared);
  }
  _formatLongExtra(extra) {
    const args = [];
    if (!extra.type) {
      extra.type = "string";
    }
    const type3 = EXTRA_TYPES[extra.type];
    if (!type3) {
      throw new Error(`Unsupported type '${extra.type}' for extra '${extra.key}'`);
    }
    if (extra.type === "null") {
      args.push(`--e${type3}`);
      args.push(this._escape(extra.key));
    } else if (Array.isArray(extra.value)) {
      args.push(`--e${type3}a`);
      args.push(this._escape(extra.key));
      args.push(this._escape(extra.value.join(",")));
    } else {
      args.push(`--e${type3}`);
      args.push(this._escape(extra.key));
      args.push(this._escape(extra.value));
    }
    return args;
  }
}
var startactivity = StartActivityCommand;
var startservice = {};
var __importDefault$j = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(startservice, "__esModule", { value: true });
const startactivity_1 = __importDefault$j(startactivity);
class StartServiceCommand extends startactivity_1.default {
  execute(options2) {
    const args = this._intentArgs(options2);
    if (options2.user || options2.user === 0) {
      args.push("--user", this._escape(options2.user));
    }
    return this._run("startservice", args);
  }
}
startservice.default = StartServiceCommand;
var sync = {};
var __importDefault$i = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(sync, "__esModule", { value: true });
const protocol_1$d = __importDefault$i(protocol2);
const sync_1$1 = __importDefault$i(sync$1);
const command_1$d = __importDefault$i(command$1);
class SyncCommand extends command_1$d.default {
  execute() {
    this._send("sync:");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$d.default.OKAY:
          return new sync_1$1.default(this.connection);
        case protocol_1$d.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
sync.default = SyncCommand;
var tcp = {};
var __importDefault$h = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(tcp, "__esModule", { value: true });
const protocol_1$c = __importDefault$h(protocol2);
const command_1$c = __importDefault$h(command$1);
class TcpCommand extends command_1$c.default {
  execute(port, host3) {
    this._send(`tcp:${port}` + (host3 ? `:${host3}` : ""));
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$c.default.OKAY:
          return this.parser.raw();
        case protocol_1$c.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
tcp.default = TcpCommand;
var tcpip = {};
var __importDefault$g = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(tcpip, "__esModule", { value: true });
const protocol_1$b = __importDefault$g(protocol2);
const command_1$b = __importDefault$g(command$1);
const RE_OK$1 = /restarting in/;
class TcpIpCommand extends command_1$b.default {
  execute(port) {
    this._send(`tcpip:${port}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$b.default.OKAY:
          return this.parser.readAll().then(function(value) {
            if (RE_OK$1.test(value.toString())) {
              return port;
            } else {
              throw new Error(value.toString().trim());
            }
          });
        case protocol_1$b.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
tcpip.default = TcpIpCommand;
var trackjdwp = {};
var jdwptracker = {};
var __importDefault$f = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(jdwptracker, "__esModule", { value: true });
const events_1$1 = require$$0$9;
const bluebird_1$1 = __importDefault$f(bluebird_1$b);
const parser_1$2 = __importDefault$f(parser$1);
class JdwpTracker extends events_1$1.EventEmitter {
  constructor(command2) {
    super();
    this.command = command2;
    this.pids = [];
    this.pidMap = /* @__PURE__ */ Object.create(null);
    this.command = command2;
    this.pids = [];
    this.pidMap = /* @__PURE__ */ Object.create(null);
    this.reader = this.read().catch(parser_1$2.default.PrematureEOFError, () => {
      return this.emit("end");
    }).catch(bluebird_1$1.default.CancellationError, () => {
      this.command.connection.end();
      return this.emit("end");
    }).catch((err) => {
      this.command.connection.end();
      this.emit("error", err);
      return this.emit("end");
    });
  }
  on(event, listener2) {
    return super.on(event, listener2);
  }
  once(event, listener2) {
    return super.once(event, listener2);
  }
  emit(event, ...args) {
    return super.emit(event, ...args);
  }
  read() {
    return this.command.parser.readValue().then((list) => {
      const pids = list.toString().split("\n");
      const maybeEmpty = pids.pop();
      if (maybeEmpty) {
        pids.push(maybeEmpty);
      }
      return this.update(pids);
    });
  }
  update(newList) {
    const changeSet = {
      removed: [],
      added: []
    };
    const newMap = /* @__PURE__ */ Object.create(null);
    for (let i = 0, len = newList.length; i < len; i++) {
      const pid = newList[i];
      if (!this.pidMap[pid]) {
        changeSet.added.push(pid);
        this.emit("add", pid);
        newMap[pid] = pid;
      }
    }
    const ref2 = this.pids;
    for (let j = 0, len1 = ref2.length; j < len1; j++) {
      const pid = ref2[j];
      if (!newMap[pid]) {
        changeSet.removed.push(pid);
        this.emit("remove", pid);
      }
    }
    this.pids = newList;
    this.pidMap = newMap;
    this.emit("changeSet", changeSet, newList);
    return this;
  }
  end() {
    this.reader.cancel();
    return this;
  }
}
jdwptracker.default = JdwpTracker;
var __importDefault$e = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(trackjdwp, "__esModule", { value: true });
const protocol_1$a = __importDefault$e(protocol2);
const command_1$a = __importDefault$e(command$1);
const jdwptracker_1 = __importDefault$e(jdwptracker);
class TrackJdwpCommand extends command_1$a.default {
  execute() {
    this._send("track-jdwp");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$a.default.OKAY:
          return new jdwptracker_1.default(this);
        case protocol_1$a.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
trackjdwp.default = TrackJdwpCommand;
var uninstall = {};
var __importDefault$d = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(uninstall, "__esModule", { value: true });
const protocol_1$9 = __importDefault$d(protocol2);
const command_1$9 = __importDefault$d(command$1);
class UninstallError extends Error {
  constructor(message) {
    super(message);
  }
}
class UninstallCommand extends command_1$9.default {
  execute(pkg) {
    this._send(`shell:pm uninstall ${pkg}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$9.default.OKAY:
          return this.parser.searchLine(/^(Success|Failure.*|.*Unknown package:.*)$/).then(function(match2) {
            if (match2[1] === "Success") {
              return true;
            } else if (match2[1].includes("DELETE_FAILED_DEVICE_POLICY_MANAGER")) {
              const reason = match2[1];
              throw new UninstallError(`${pkg} could not be uninstalled [${reason}]`);
            } else {
              return true;
            }
          }).finally(() => {
            return this.parser.readAll();
          });
        case protocol_1$9.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
uninstall.default = UninstallCommand;
var usb = {};
var __importDefault$c = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(usb, "__esModule", { value: true });
const protocol_1$8 = __importDefault$c(protocol2);
const command_1$8 = __importDefault$c(command$1);
const RE_OK = /restarting in/;
class UsbCommand extends command_1$8.default {
  execute() {
    this._send("usb:");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$8.default.OKAY:
          return this.parser.readAll().then(function(value) {
            if (RE_OK.test(value.toString())) {
              return true;
            } else {
              throw new Error(value.toString().trim());
            }
          });
        case protocol_1$8.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
usb.default = UsbCommand;
var waitbootcomplete = {};
var __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(waitbootcomplete, "__esModule", { value: true });
const protocol_1$7 = __importDefault$b(protocol2);
const command_1$7 = __importDefault$b(command$1);
class WaitBootCompleteCommand extends command_1$7.default {
  execute() {
    this._send("shell:while getprop sys.boot_completed 2>/dev/null; do sleep 1; done");
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$7.default.OKAY:
          return this.parser.searchLine(/^1$/).finally(() => this.parser.end()).then(() => true);
        case protocol_1$7.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
waitbootcomplete.default = WaitBootCompleteCommand;
(function(exports$1) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.WaitBootCompleteCommand = exports$1.UsbCommand = exports$1.UninstallCommand = exports$1.TrackJdwpCommand = exports$1.TcpIpCommand = exports$1.TcpCommand = exports$1.SyncCommand = exports$1.StartServiceCommand = exports$1.StartActivityCommand = exports$1.ShellCommand = exports$1.ScreencapCommand = exports$1.RootCommand = exports$1.ReverseCommand = exports$1.RemountCommand = exports$1.RebootCommand = exports$1.MonkeyCommand = exports$1.LogcatCommand = exports$1.LogCommand = exports$1.LocalCommand = exports$1.ListReversesCommand = exports$1.IsInstalledCommand = exports$1.InstallCommand = exports$1.GetPropertiesCommand = exports$1.GetPackagesCommand = exports$1.GetFeaturesCommand = exports$1.FrameBufferCommand = exports$1.ClearCommand = void 0;
  var clear_1 = clear;
  Object.defineProperty(exports$1, "ClearCommand", { enumerable: true, get: function() {
    return __importDefault2(clear_1).default;
  } });
  var framebuffer_1 = framebuffer;
  Object.defineProperty(exports$1, "FrameBufferCommand", { enumerable: true, get: function() {
    return __importDefault2(framebuffer_1).default;
  } });
  var getfeatures_1 = getfeatures;
  Object.defineProperty(exports$1, "GetFeaturesCommand", { enumerable: true, get: function() {
    return __importDefault2(getfeatures_1).default;
  } });
  var getpackages_1 = getpackages;
  Object.defineProperty(exports$1, "GetPackagesCommand", { enumerable: true, get: function() {
    return __importDefault2(getpackages_1).default;
  } });
  var getproperties_1 = getproperties;
  Object.defineProperty(exports$1, "GetPropertiesCommand", { enumerable: true, get: function() {
    return __importDefault2(getproperties_1).default;
  } });
  var install_1 = install;
  Object.defineProperty(exports$1, "InstallCommand", { enumerable: true, get: function() {
    return __importDefault2(install_1).default;
  } });
  var isinstalled_1 = isinstalled;
  Object.defineProperty(exports$1, "IsInstalledCommand", { enumerable: true, get: function() {
    return __importDefault2(isinstalled_1).default;
  } });
  var listreverses_1 = listreverses;
  Object.defineProperty(exports$1, "ListReversesCommand", { enumerable: true, get: function() {
    return __importDefault2(listreverses_1).default;
  } });
  var local_1 = local;
  Object.defineProperty(exports$1, "LocalCommand", { enumerable: true, get: function() {
    return __importDefault2(local_1).default;
  } });
  var log_1 = log;
  Object.defineProperty(exports$1, "LogCommand", { enumerable: true, get: function() {
    return __importDefault2(log_1).default;
  } });
  var logcat_12 = logcat;
  Object.defineProperty(exports$1, "LogcatCommand", { enumerable: true, get: function() {
    return __importDefault2(logcat_12).default;
  } });
  var monkey_1 = monkey;
  Object.defineProperty(exports$1, "MonkeyCommand", { enumerable: true, get: function() {
    return __importDefault2(monkey_1).default;
  } });
  var reboot_1 = reboot;
  Object.defineProperty(exports$1, "RebootCommand", { enumerable: true, get: function() {
    return __importDefault2(reboot_1).default;
  } });
  var remount_1 = remount;
  Object.defineProperty(exports$1, "RemountCommand", { enumerable: true, get: function() {
    return __importDefault2(remount_1).default;
  } });
  var reverse_1 = reverse;
  Object.defineProperty(exports$1, "ReverseCommand", { enumerable: true, get: function() {
    return __importDefault2(reverse_1).default;
  } });
  var root_1 = root2;
  Object.defineProperty(exports$1, "RootCommand", { enumerable: true, get: function() {
    return __importDefault2(root_1).default;
  } });
  var screencap_1 = screencap;
  Object.defineProperty(exports$1, "ScreencapCommand", { enumerable: true, get: function() {
    return __importDefault2(screencap_1).default;
  } });
  var shell_1 = shell;
  Object.defineProperty(exports$1, "ShellCommand", { enumerable: true, get: function() {
    return __importDefault2(shell_1).default;
  } });
  var startactivity_12 = startactivity;
  Object.defineProperty(exports$1, "StartActivityCommand", { enumerable: true, get: function() {
    return __importDefault2(startactivity_12).default;
  } });
  var startservice_1 = startservice;
  Object.defineProperty(exports$1, "StartServiceCommand", { enumerable: true, get: function() {
    return __importDefault2(startservice_1).default;
  } });
  var sync_12 = sync;
  Object.defineProperty(exports$1, "SyncCommand", { enumerable: true, get: function() {
    return __importDefault2(sync_12).default;
  } });
  var tcp_1 = tcp;
  Object.defineProperty(exports$1, "TcpCommand", { enumerable: true, get: function() {
    return __importDefault2(tcp_1).default;
  } });
  var tcpip_1 = tcpip;
  Object.defineProperty(exports$1, "TcpIpCommand", { enumerable: true, get: function() {
    return __importDefault2(tcpip_1).default;
  } });
  var trackjdwp_1 = trackjdwp;
  Object.defineProperty(exports$1, "TrackJdwpCommand", { enumerable: true, get: function() {
    return __importDefault2(trackjdwp_1).default;
  } });
  var uninstall_1 = uninstall;
  Object.defineProperty(exports$1, "UninstallCommand", { enumerable: true, get: function() {
    return __importDefault2(uninstall_1).default;
  } });
  var usb_1 = usb;
  Object.defineProperty(exports$1, "UsbCommand", { enumerable: true, get: function() {
    return __importDefault2(usb_1).default;
  } });
  var waitbootcomplete_1 = waitbootcomplete;
  Object.defineProperty(exports$1, "WaitBootCompleteCommand", { enumerable: true, get: function() {
    return __importDefault2(waitbootcomplete_1).default;
  } });
})(hostTransport);
var hostSerial = {};
var attach = {};
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(attach, "__esModule", { value: true });
const command_1$6 = __importDefault$a(command$1);
const protocol_1$6 = __importDefault$a(protocol2);
class AttachCommand extends command_1$6.default {
  execute(serial) {
    this._send(`host-serial:${serial}:attach`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$6.default.OKAY:
          return true;
        case protocol_1$6.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
attach.default = AttachCommand;
var detach = {};
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(detach, "__esModule", { value: true });
const command_1$5 = __importDefault$9(command$1);
const protocol_1$5 = __importDefault$9(protocol2);
class DetachCommand extends command_1$5.default {
  execute(serial) {
    this._send(`host-serial:${serial}:detach`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$5.default.OKAY:
          return true;
        case protocol_1$5.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
detach.default = DetachCommand;
var forward = {};
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(forward, "__esModule", { value: true });
const command_1$4 = __importDefault$8(command$1);
const protocol_1$4 = __importDefault$8(protocol2);
class ForwardCommand extends command_1$4.default {
  execute(serial, local2, remote) {
    this._send(`host-serial:${serial}:forward:${local2};${remote}`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$4.default.OKAY:
          return this.parser.readAscii(4).then((reply3) => {
            switch (reply3) {
              case protocol_1$4.default.OKAY:
                return true;
              case protocol_1$4.default.FAIL:
                return this.parser.readError();
              default:
                return this.parser.unexpected(reply3, "OKAY or FAIL");
            }
          });
        case protocol_1$4.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
forward.default = ForwardCommand;
var getdevicepath = {};
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(getdevicepath, "__esModule", { value: true });
const protocol_1$3 = __importDefault$7(protocol2);
const command_1$3 = __importDefault$7(command$1);
class GetDevicePathCommand extends command_1$3.default {
  execute(serial) {
    this._send(`host-serial:${serial}:get-devpath`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$3.default.OKAY:
          return this.parser.readValue().then((value) => {
            return value.toString();
          });
        case protocol_1$3.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
getdevicepath.default = GetDevicePathCommand;
var getstate = {};
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(getstate, "__esModule", { value: true });
const command_1$2 = __importDefault$6(command$1);
const protocol_1$2 = __importDefault$6(protocol2);
class GetStateCommand extends command_1$2.default {
  execute(serial) {
    this._send(`host-serial:${serial}:get-state`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$2.default.OKAY:
          return this.parser.readValue().then((value) => value.toString());
        case protocol_1$2.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
getstate.default = GetStateCommand;
var listforwards = {};
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(listforwards, "__esModule", { value: true });
const command_1$1 = __importDefault$5(command$1);
const protocol_1$1 = __importDefault$5(protocol2);
class ListForwardsCommand extends command_1$1.default {
  execute(serial) {
    this._send(`host-serial:${serial}:list-forward`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1$1.default.OKAY:
          return this.parser.readValue().then(this._parseForwards);
        case protocol_1$1.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
  _parseForwards(value) {
    return value.toString().split("\n").filter((e) => e).map((forward2) => {
      const [serial, local2, remote] = forward2.split(/\s+/);
      return { serial, local: local2, remote };
    });
  }
}
listforwards.default = ListForwardsCommand;
var waitfordevice = {};
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(waitfordevice, "__esModule", { value: true });
const protocol_1 = __importDefault$4(protocol2);
const command_1 = __importDefault$4(command$1);
class WaitForDeviceCommand extends command_1.default {
  execute(serial) {
    this._send(`host-serial:${serial}:wait-for-any-device`);
    return this.parser.readAscii(4).then((reply2) => {
      switch (reply2) {
        case protocol_1.default.OKAY:
          return this.parser.readAscii(4).then((reply3) => {
            switch (reply3) {
              case protocol_1.default.OKAY:
                return serial;
              case protocol_1.default.FAIL:
                return this.parser.readError();
              default:
                return this.parser.unexpected(reply3, "OKAY or FAIL");
            }
          });
        case protocol_1.default.FAIL:
          return this.parser.readError();
        default:
          return this.parser.unexpected(reply2, "OKAY or FAIL");
      }
    });
  }
}
waitfordevice.default = WaitForDeviceCommand;
(function(exports$1) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.WaitForDeviceCommand = exports$1.ListForwardsCommand = exports$1.GetStateCommand = exports$1.GetSerialNoCommand = exports$1.GetDevicePathCommand = exports$1.ForwardCommand = exports$1.DetachCommand = exports$1.AttachCommand = void 0;
  var attach_1 = attach;
  Object.defineProperty(exports$1, "AttachCommand", { enumerable: true, get: function() {
    return __importDefault2(attach_1).default;
  } });
  var detach_1 = detach;
  Object.defineProperty(exports$1, "DetachCommand", { enumerable: true, get: function() {
    return __importDefault2(detach_1).default;
  } });
  var forward_1 = forward;
  Object.defineProperty(exports$1, "ForwardCommand", { enumerable: true, get: function() {
    return __importDefault2(forward_1).default;
  } });
  var getdevicepath_1 = getdevicepath;
  Object.defineProperty(exports$1, "GetDevicePathCommand", { enumerable: true, get: function() {
    return __importDefault2(getdevicepath_1).default;
  } });
  var getdevicepath_2 = getdevicepath;
  Object.defineProperty(exports$1, "GetSerialNoCommand", { enumerable: true, get: function() {
    return __importDefault2(getdevicepath_2).default;
  } });
  var getstate_1 = getstate;
  Object.defineProperty(exports$1, "GetStateCommand", { enumerable: true, get: function() {
    return __importDefault2(getstate_1).default;
  } });
  var listforwards_1 = listforwards;
  Object.defineProperty(exports$1, "ListForwardsCommand", { enumerable: true, get: function() {
    return __importDefault2(listforwards_1).default;
  } });
  var waitfordevice_1 = waitfordevice;
  Object.defineProperty(exports$1, "WaitForDeviceCommand", { enumerable: true, get: function() {
    return __importDefault2(waitfordevice_1).default;
  } });
})(hostSerial);
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(DeviceClient$1, "__esModule", { value: true });
const adbkit_monkey_1 = __importDefault$3(monkeyExports);
const adbkit_logcat_1 = __importDefault$3(adbkitLogcat);
const sync_1 = __importDefault$3(sync$1);
const parser_1$1 = __importDefault$3(parser$1);
const stat_1 = __importDefault$3(stat);
const host_1$1 = host2;
const host_transport_1 = hostTransport;
const host_serial_1 = hostSerial;
const debug_1 = __importDefault$3(srcExports);
const bluebird_1 = __importDefault$3(bluebird_1$b);
const debug = (0, debug_1.default)("adb:client");
const NoUserOptionError = (err) => err.message.indexOf("--user") !== -1;
class DeviceClient {
  constructor(client2, serial) {
    this.client = client2;
    this.serial = serial;
  }
  /**
   * Gets the serial number of the device identified by the given serial number. With our API this doesn't really make much sense, but it has been implemented for completeness. _FYI: in the raw ADB protocol you can specify a device in other ways, too._
   *
   * @returns The serial number of the device.
   */
  getSerialNo() {
    return this.connection().then((conn) => new host_serial_1.GetSerialNoCommand(conn).execute(this.serial));
  }
  /**
   * Gets the device path of the device identified by the given serial number.
   * @returns The device path. This corresponds to the device path in `client.listDevicesWithPaths()`.
   */
  getDevicePath() {
    return this.connection().then((conn) => new host_serial_1.GetDevicePathCommand(conn).execute(this.serial));
  }
  /**
   * Gets the state of the device identified by the given serial number.
   *
   * @returns The device state. This corresponds to the device type in `client.listDevices()`.
   */
  getState() {
    return this.connection().then((conn) => new host_serial_1.GetStateCommand(conn).execute(this.serial));
  }
  /**
   * Retrieves the properties of the device identified by the given serial number. This is analogous to `adb shell getprop`.
   *
   * @returns An object of device properties. Each key corresponds to a device property. Convenient for accessing things like `'ro.product.model'`.
   */
  getProperties() {
    return this.transport().then((transport2) => new host_transport_1.GetPropertiesCommand(transport2).execute());
  }
  /**
   * Retrieves the features of the device identified by the given serial number. This is analogous to `adb shell pm list features`. Useful for checking whether hardware features such as NFC are available (you'd check for `'android.hardware.nfc'`).
   * @param [flags] Flags to pass to the `pm list packages` command to filter the list
   * ```
   * -d: filter to only show disabled packages
   * -e: filter to only show enabled packages
   * -s: filter to only show system packages
   * -3: filter to only show third party packages
   * ```
   * @returns An object of device features. Each key corresponds to a device feature, with the value being either `true` for a boolean feature, or the feature value as a string (e.g. `'0x20000'` for `reqGlEsVersion`).
   */
  getFeatures() {
    return this.transport().then((transport2) => new host_transport_1.GetFeaturesCommand(transport2).execute());
  }
  /**
   * Retrieves the list of packages present on the device. This is analogous to `adb shell pm list packages`. If you just want to see if something's installed, consider using `client.isInstalled()` instead.
   *
   * @param flags TODO
   * @returns An object of device features. Each key corresponds to a device feature, with the value being either `true` for a boolean feature, or the feature value as a string (e.g. `'0x20000'` for `reqGlEsVersion`)
   */
  getPackages(flags) {
    return this.transport().then((transport2) => new host_transport_1.GetPackagesCommand(transport2).execute(flags));
  }
  /**
   * Attemps to retrieve the IP address of the device. Roughly analogous to `adb shell getprop dhcp.<iface>.ipaddress`.
   *
   * @param [iface] The network interface. Defaults to `'wlan0'`.
   *
   * @returns The IP address as a `String`.
   */
  getDHCPIpAddress(iface = "wlan0") {
    return this.getProperties().then((properties) => {
      const ip2 = properties[`dhcp.${iface}.ipaddress`];
      if (ip2) {
        return ip2;
      }
      throw Error(`Unable to find ipaddress for '${iface}'`);
    });
  }
  /**
   * Forwards socket connections from the ADB server host (local) to the device (remote). This is analogous to `adb forward <local> <remote>`. It's important to note that if you are connected to a remote ADB server, the forward will be created on that host.
   *
   * @param local A string representing the local endpoint on the ADB host. At time of writing, can be one of:
   * -   `tcp:<port>`
   * -   `localabstract:<unix domain socket name>`
   * -   `localreserved:<unix domain socket name>`
   * -   `localfilesystem:<unix domain socket name>`
   * -   `dev:<character device name>`
   * @param remote A string representing the remote endpoint on the device. At time of writing, can be one of:
   *   Any value accepted by the `local` argument
   *   `jdwp:<process pid>`
   * @returns true
   */
  forward(local2, remote) {
    return this.connection().then((conn) => new host_serial_1.ForwardCommand(conn).execute(this.serial, local2, remote));
  }
  /**
   * Lists forwarded connections on the device. This is analogous to `adb forward --list`.
   *
   * @returns An array of forward objects with the following properties:
   *   -   **serial** The device serial.
   *   -   **local** The local endpoint. Same format as `client.forward()`'s `local` argument.
   *   -   **remote** The remote endpoint on the device. Same format as `client.forward()`'s `remote` argument.
   */
  listForwards() {
    return this.connection().then((conn) => new host_serial_1.ListForwardsCommand(conn).execute(this.serial));
  }
  /**
   * Reverses socket connections from the device (remote) to the ADB server host (local). This is analogous to `adb reverse <remote> <local>`. It's important to note that if you are connected to a remote ADB server, the reverse will be created on that host.
   * @param remote A string representing the remote endpoint on the device. At time of writing, can be one of:
   * -   `tcp:<port>`
   * -   `localabstract:<unix domain socket name>`
   * -   `localreserved:<unix domain socket name>`
   * -   `localfilesystem:<unix domain socket name>`
   * @param local A string representing the local endpoint on the ADB host. At time of writing, can be any value accepted by the `remote` argument.
   */
  reverse(remote, local2) {
    return this.transport().then((transport2) => new host_transport_1.ReverseCommand(transport2).execute(remote, local2));
  }
  /**
   * Lists forwarded connections on the device. This is analogous to `adb reverse --list`.
   *
   * @returns An array of Reverse objects with the following properties:
   *  -   **remote** The remote endpoint on the device. Same format as `client.reverse()`'s `remote` argument.
   *  -   **local** The local endpoint on the host. Same format as `client.reverse()`'s `local` argument.
   */
  listReverses() {
    return this.transport().then((transport2) => new host_transport_1.ListReversesCommand(transport2).execute());
  }
  /**
   * return a new connection to ADB.
   */
  connection() {
    return this.client.connection();
  }
  /**
   * return a new connextion to the current Host devices
   */
  transport() {
    return this.connection().then((conn) => new host_1$1.HostTransportCommand(conn).execute(this.serial).return(conn));
  }
  /**
   * Runs a shell command on the device. Note that you'll be limited to the permissions of the `shell` user, which ADB uses.
   *
   * @param command The shell command to execute. When `String`, the command is run as-is. When `Array`, the elements will be rudimentarily escaped (for convenience, not security) and joined to form a command.
   *
   * @returns A readable stream (`Socket` actually) containing the progressive `stdout` of the command. Use with `adb.util.readAll` to get a readable String from it.
   */
  shell(command2) {
    return this.transport().then((transport2) => new host_transport_1.ShellCommand(transport2).execute(command2));
  }
  /**
   * Puts the device into root mode which may be needed by certain shell commands. A remount is generally required after a successful root call. **Note that this will only work if your device supports this feature. Production devices almost never do.**
   *
   * @return true
   */
  reboot() {
    return this.transport().then((transport2) => new host_transport_1.RebootCommand(transport2).execute());
  }
  /**
   * Attempts to remount the `/system` partition in read-write mode. This will usually only work on emulators and developer devices.
   *
   * @returns true
   */
  remount() {
    return this.transport().then((transport2) => new host_transport_1.RemountCommand(transport2).execute());
  }
  /**
   * Puts the device into root mode which may be needed by certain shell commands. A remount is generally required after a successful root call. **Note that this will only work if your device supports this feature. Production devices almost never do.**
   *
   * @return true
   */
  root() {
    return this.transport().then((transport2) => new host_transport_1.RootCommand(transport2).execute());
  }
  /**
   * Starts a JDWP tracker for the given device.
   *
   * Note that as the tracker will keep a connection open, you must call `tracker.end()` if you wish to stop tracking JDWP processes.
   *
   * @returns The JDWP tracker, which is an [`EventEmitter`][node-events]. The following events are available:
   *  -   **add** **(pid)** Emitted when a new JDWP process becomes available, once per pid.
   *  -   **remove** **(pid)** Emitted when a JDWP process becomes unavailable, once per pid.
   *  -   **changeSet** **(changes, pids)** All changes in a single event.
   *    -   **changes** An object with the following properties always present:
   *      -   **added** An array of pids that were added. Empty if none.
   *      -   **removed** An array of pids that were removed. Empty if none.
   *    -   **pids** All currently active pids (including pids from previous runs).
   *  -   **end** Emitted when the underlying connection ends.
   *  -   **error** **(err)** Emitted if there's an error.
   */
  trackJdwp() {
    return this.transport().then((transport2) => new host_transport_1.TrackJdwpCommand(transport2).execute());
  }
  /**
   * Fetches the current **raw** framebuffer (i.e. what is visible on the screen) from the device, and optionally converts it into something more usable by using [GraphicsMagick][graphicsmagick]'s `gm` command, which must be available in `$PATH` if conversion is desired. Note that we don't bother supporting really old framebuffer formats such as RGB_565. If for some mysterious reason you happen to run into a `>=2.3` device that uses RGB_565, let us know.
   *
   * Note that high-resolution devices can have quite massive framebuffers. For example, a device with a resolution of 1920x1080 and 32 bit colors would have a roughly 8MB (`1920*1080*4` byte) RGBA framebuffer. Empirical tests point to about 5MB/s bandwidth limit for the ADB USB connection, which means that it can take ~1.6 seconds for the raw data to arrive, or even more if the USB connection is already congested. Using a conversion will further slow down completion.
   *
   * @param format The desired output format. Any output format supported by [GraphicsMagick][graphicsmagick] (such as `'png'`) is supported. Defaults to `'raw'` for raw framebuffer data.
   *
   * @returns The possibly converted framebuffer stream. The stream also has a `meta`.:
   */
  framebuffer(format2 = "raw") {
    return this.transport().then((transport2) => new host_transport_1.FrameBufferCommand(transport2).execute(format2));
  }
  /**
   * Takes a screenshot in PNG format using the built-in `screencap` utility. This is analogous to `adb shell screencap -p`. Sadly, the utility is not available on most Android `<=2.3` devices, but a silent fallback to the `client.framebuffer()` command in PNG mode is attempted, so you should have its dependencies installed just in case.
   *
   * Generating the PNG on the device naturally requires considerably more processing time on that side. However, as the data transferred over USB easily decreases by ~95%, and no conversion being required on the host, this method is usually several times faster than using the framebuffer. Naturally, this benefit does not apply if we're forced to fall back to the framebuffer.
   *
   * For convenience purposes, if the screencap command fails (e.g. because it doesn't exist on older Androids), we fall back to `client.framebuffer(serial, 'png')`, which is slower and has additional installation requirements.
   *
   * @return The PNG stream.
   */
  screencap() {
    return this.transport().then((transport2) => new host_transport_1.ScreencapCommand(transport2).execute().catch((err) => {
      debug(`Emulating screencap command due to '${err}'`);
      return this.framebuffer("png");
    }));
  }
  /**
   * Opens a direct connection to a unix domain socket in the given path.
   *
   * @param path The path to the socket. Prefixed with `'localfilesystem:'` by default, include another prefix (e.g. `'localabstract:'`) in the path to override.
   *
   * @returns The connection (i.e. [`net.Socket`][node-net]). Read and write as you please. Call `conn.end()` to end the connection.
   */
  openLocal(path3) {
    return this.transport().then((transport2) => new host_transport_1.LocalCommand(transport2).execute(path3));
  }
  /**
   * Opens a direct connection to a binary log file, providing access to the raw log data. Note that it is usually much more convenient to use the `client.openLogcat()` method, described separately.
   *
   * @param name The name of the log. Available logs include `'main'`, `'system'`, `'radio'` and `'events'`.
   *
   * @returns The binary log stream. Call `log.end()` when you wish to stop receiving data.
   */
  openLog(name) {
    return this.transport().then((transport2) => new host_transport_1.LogCommand(transport2).execute(name));
  }
  /**
       * Opens a direct TCP connection to a port on the device, without any port forwarding required.
  
       * @param port The port number to connect to.
       * @param host Optional. The host to connect to. Allegedly this is supposed to establish a connection to the given host from the device, but we have not been able to get it to work at all. Skip the host and everything works great.
       *
       * @returns The TCP connection (i.e. [`net.Socket`][node-net]). Read and write as you please. Call `conn.end()` to end the connection.
       */
  openTcp(port, host3) {
    return this.transport().then((transport2) => new host_transport_1.TcpCommand(transport2).execute(port, host3));
  }
  /**
   * Starts the built-in `monkey` utility on the device, connects to it using `client.openTcp()` and hands the connection to [adbkit-monkey][adbkit-monkey], a pure Node.js Monkey client. This allows you to create touch and key events, among other things.
   *
   * For more information, check out the [adbkit-monkey][adbkit-monkey] documentation.
   *
   * @param port Optional. The device port where you'd like Monkey to run at. Defaults to `1080`.
   *
   * @returns The Monkey client. Please see the [adbkit-monkey][adbkit-monkey] documentation for details.
   */
  openMonkey(port = 1080) {
    const tryConnect = (times) => {
      return this.openTcp(port).then((stream2) => adbkit_monkey_1.default.connectStream(stream2)).catch((err) => {
        if (times -= 1) {
          debug(`Monkey can't be reached, trying ${times} more times`);
          return bluebird_1.default.delay(100).then(() => tryConnect(times));
        } else {
          throw err;
        }
      });
    };
    return tryConnect(1).catch(() => {
      return this.transport().then((transport2) => new host_transport_1.MonkeyCommand(transport2).execute(port)).then((out) => tryConnect(20).then((monkey2) => monkey2.once("end", () => out.end())));
    });
  }
  /**
   * Calls the `logcat` utility on the device and hands off the connection to [adbkit-logcat][adbkit-logcat], a pure Node.js Logcat client. This is analogous to `adb logcat -B`, but the event stream will be parsed for you and a separate event will be emitted for every log entry, allowing for easy processing.
   *
   * For more information, check out the [adbkit-logcat][adbkit-logcat] documentation.
   *
   * @param options Optional. The following options are supported:
   * -   **clear** When `true`, clears logcat before opening the reader. Not set by default.
   *
   * @returns The Logcat client. Please see the [adbkit-logcat][adbkit-logcat] documentation for details.
   */
  openLogcat(options2 = {}) {
    return this.transport().then((transport2) => new host_transport_1.LogcatCommand(transport2).execute(options2)).then((stream2) => adbkit_logcat_1.default.readStream(stream2, { fixLineFeeds: false }));
  }
  /**
   * Tracks `/proc/stat` and emits useful information, such as CPU load. A single sync service instance is used to download the `/proc/stat` file for processing. While doing this does consume some resources, it is very light and should not be a problem.
   *
   * @returns The `/proc/stat` tracker, which is an [`EventEmitter`][node-events]. Call `stat.end()` to stop tracking. The following events are available:
   *   -   **load** **(loads)** Emitted when a CPU load calculation is available.
   *   -   **loads** CPU loads of **online** CPUs. Each key is a CPU id (e.g. `'cpu0'`, `'cpu1'`) and the value an object with the following properties:
   *     -   **user** Percentage (0-100) of ticks spent on user programs.
   *     -   **nice** Percentage (0-100) of ticks spent on `nice`d user programs.
   *     -   **system** Percentage (0-100) of ticks spent on system programs.
   *     -   **idle** Percentage (0-100) of ticks spent idling.
   *     -   **iowait** Percentage (0-100) of ticks spent waiting for IO.
   *     -   **irq** Percentage (0-100) of ticks spent on hardware interrupts.
   *     -   **softirq** Percentage (0-100) of ticks spent on software interrupts.
   *     -   **steal** Percentage (0-100) of ticks stolen by others.
   *     -   **guest** Percentage (0-100) of ticks spent by a guest.
   *     -   **guestnice** Percentage (0-100) of ticks spent by a `nice`d guest.
   *     -   **total** Total. Always 100.
   */
  openProcStat() {
    return this.syncService().then((sync2) => new stat_1.default(sync2));
  }
  /**
   * Deletes all data associated with a package from the device. This is roughly analogous to `adb shell pm clear <pkg>`.
   *
   * @param pkg The package name. This is NOT the APK.
   *
   * @returns true
   */
  clear(pkg) {
    return this.transport().then((transport2) => new host_transport_1.ClearCommand(transport2).execute(pkg));
  }
  /**
   * Installs the APK on the device, replacing any previously installed version. This is roughly analogous to `adb install -r <apk>`.
   *
   * Note that if the call seems to stall, you may have to accept a dialog on the phone first.
   *
   * @param apk When `String`, interpreted as a path to an APK file. When [`Stream`][node-stream], installs directly from the stream, which must be a valid APK.
   * @returns true
   */
  install(apk) {
    const temp = sync_1.default.temp(typeof apk === "string" ? apk : "_stream.apk");
    return this.push(apk, temp).then((transfer) => {
      let endListener;
      let errorListener;
      return new bluebird_1.default((resolve3, reject) => {
        errorListener = (err) => reject(err);
        endListener = () => this.installRemote(temp).then((value) => resolve3(value)).catch(reject);
        transfer.on("error", errorListener);
        transfer.on("end", endListener);
      }).finally(() => {
        transfer.removeListener("error", errorListener);
        transfer.removeListener("end", endListener);
      });
    });
  }
  /**
   * Installs an APK file which must already be located on the device file system, and replaces any previously installed version. Useful if you've previously pushed the file to the device for some reason (perhaps to have direct access to `client.push()`'s transfer stats). This is roughly analogous to `adb shell pm install -r <apk>` followed by `adb shell rm -f <apk>`.
   *
   * Note that if the call seems to stall, you may have to accept a dialog on the phone first.
   *
   * @param apk The path to the APK file on the device. The file will be removed when the command completes.
   * @returns true
   */
  installRemote(apk) {
    return this.transport().then((transport2) => {
      return new host_transport_1.InstallCommand(transport2).execute(apk).finally(() => {
        return this.shell(["rm", "-f", apk]).then((stream2) => new parser_1$1.default(stream2).readAll());
      }).then(() => true);
    });
  }
  /**
   * Uninstalls the package from the device. This is roughly analogous to `adb uninstall <pkg>`.
   *
   * @param pkg The package name. This is NOT the APK.
   * @returns true
   */
  uninstall(pkg) {
    return this.transport().then((transport2) => new host_transport_1.UninstallCommand(transport2).execute(pkg));
  }
  /**
   * Tells you if the specific package is installed or not. This is analogous to `adb shell pm path <pkg>` and some output parsing.
   *
   * @param pkg The package name. This is NOT the APK.
   *
   * @returns `true` if the package is installed, `false` otherwise.
   */
  isInstalled(pkg) {
    return this.transport().then((transport2) => new host_transport_1.IsInstalledCommand(transport2).execute(pkg));
  }
  /**
   * Starts the configured activity on the device. Roughly analogous to `adb shell am start <options>`.
   *
   * @param options The activity configuration.
   */
  startActivity(options2) {
    return this.transport().then((transport2) => new host_transport_1.StartActivityCommand(transport2).execute(options2)).catch(NoUserOptionError, () => {
      options2.user = void 0;
      return this.startActivity(options2);
    });
  }
  /**
   * Starts the configured service on the device. Roughly analogous to `adb shell am startservice <options>`.
   * @param options The activity configuration.
   */
  startService(options2) {
    return this.transport().then((transport2) => {
      if (!(options2.user || options2.user === null)) {
        options2.user = 0;
      }
      return new host_transport_1.StartServiceCommand(transport2).execute(options2);
    }).catch(NoUserOptionError, () => {
      options2.user = void 0;
      return this.startService(options2);
    });
  }
  /**
   * Establishes a new Sync connection that can be used to push and pull files. This method provides the most freedom and the best performance for repeated use, but can be a bit cumbersome to use. For simple use cases, consider using `client.stat()`, `client.push()` and `client.pull()`.
   *
   * @returns The Sync client. See below for details. Call `sync.end()` when done.
   */
  syncService() {
    return this.transport().then((transport2) => new host_transport_1.SyncCommand(transport2).execute());
  }
  /**
     * Retrieves information about the given path.
     *
     * @param path The path.
     *
     * @returns An [`fs.Stats`][node-fs-stats] instance. While the `stats.is*` methods are available, only the following properties are supported:
        -   **mode** The raw mode.
        -   **size** The file size.
        -   **mtime** The time of last modification as a `Date`.
     */
  stat(path3) {
    return this.syncService().then((sync2) => sync2.stat(path3).finally(() => sync2.end()));
  }
  /**
   * A convenience shortcut for `sync.readdir()`, mainly for one-off use cases. The connection cannot be reused, resulting in poorer performance over multiple calls. However, the Sync client will be closed automatically for you, so that's one less thing to worry about.
   *
   * @param path See `sync.readdir()` for details.
   * @returns Files Lists
   */
  readdir(path3) {
    return this.syncService().then((sync2) => sync2.readdir(path3).finally(() => sync2.end()));
  }
  /**
   * A convenience shortcut for `sync.pull()`, mainly for one-off use cases. The connection cannot be reused, resulting in poorer performance over multiple calls. However, the Sync client will be closed automatically for you, so that's one less thing to worry about.
   *
   * @param path See `sync.pull()` for details.
   *
   * @returns A `PullTransfer` instance.
   */
  pull(path3) {
    return this.syncService().then((sync2) => sync2.pull(path3).on("end", () => sync2.end()));
  }
  /**
   * A convenience shortcut for `sync.push()`, mainly for one-off use cases. The connection cannot be reused, resulting in poorer performance over multiple calls. However, the Sync client will be closed automatically for you, so that's one less thing to worry about.
   *
   * @param contents See `sync.push()` for details.
   * @param path See `sync.push()` for details.
   * @param mode See `sync.push()` for details.
   */
  push(contents, path3, mode) {
    return this.syncService().then((sync2) => sync2.push(contents, path3, mode).on("end", () => sync2.end()));
  }
  /**
   * Puts the device's ADB daemon into tcp mode, allowing you to use `adb connect` or `client.connect()` to connect to it. Note that the device will still be visible to ADB as a regular USB-connected device until you unplug it. Same as `adb tcpip <port>`.
   *
   * @param port Optional. The port the device should listen on. Defaults to `5555`.
   * @returns The port the device started listening on.
   */
  tcpip(port = 5555) {
    return this.transport().then((transport2) => new host_transport_1.TcpIpCommand(transport2).execute(port));
  }
  /**
   * Puts the device's ADB daemon back into USB mode. Reverses `client.tcpip()`. Same as `adb usb`.
   *
   * @returns true
   */
  usb() {
    return this.transport().then((transport2) => new host_transport_1.UsbCommand(transport2).execute());
  }
  /**
   * Waits until the device has finished booting. Note that the device must already be seen by ADB. This is roughly analogous to periodically checking `adb shell getprop sys.boot_completed`.
   *
   * @returns true
   */
  waitBootComplete() {
    return this.transport().then((transport2) => new host_transport_1.WaitBootCompleteCommand(transport2).execute());
  }
  /**
   * Waits until ADB can see the device. Note that you must know the serial in advance. Other than that, works like `adb -s serial wait-for-device`. If you're planning on reacting to random devices being plugged in and out, consider using `client.trackDevices()` instead.
   *
   * @returns The device ID. Can be useful for chaining.
   */
  waitForDevice() {
    return this.connection().then((conn) => new host_serial_1.WaitForDeviceCommand(conn).execute(this.serial));
  }
  /**
   * Reattaches ADB to the device's ADB USB interface. This re-enables communication between ADB and device, reversing `client.detach()`.
   *
   * @returns true
   */
  attach() {
    return this.connection().then((conn) => new host_serial_1.AttachCommand(conn).execute(this.serial));
  }
  /**
   * Detaches ADB's USB interface from ADB. This releases the device from ADB control, allowing other processes to use it.
   *
   * @returns true
   */
  detach() {
    return this.connection().then((conn) => new host_serial_1.DetachCommand(conn).execute(this.serial));
  }
}
DeviceClient$1.default = DeviceClient;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(client$1, "__esModule", { value: true });
const events_1 = require$$0$9;
const connection_1 = __importDefault$2(connection$1);
const host_1 = host2;
const server_1 = __importDefault$2(server);
const DeviceClient_1 = __importDefault$2(DeviceClient$1);
class Client extends events_1.EventEmitter {
  constructor({ host: host3 = "127.0.0.1", port = 5037, bin = "adb", timeout: timeout2 = 0 } = { port: 5037 }) {
    super();
    this.host = host3;
    this.port = port;
    this.bin = bin;
    this.timeout = timeout2;
    this.options = { host: host3, port, bin, timeout: timeout2 };
  }
  createTcpUsbBridge(serial, options2) {
    return new server_1.default(this, serial, options2);
  }
  connection() {
    const connection2 = new connection_1.default(this.options);
    connection2.on("error", (err) => this.emit("error", err));
    return connection2.connect();
  }
  version() {
    return this.connection().then((conn) => new host_1.HostVersionCommand(conn).execute());
  }
  connect(host3, port = 5555) {
    if (host3.indexOf(":") !== -1) {
      const [h2, portString] = host3.split(":", 2);
      host3 = h2;
      const parsed = parseInt(portString, 10);
      if (!isNaN(parsed)) {
        port = parsed;
      }
    }
    return this.connection().then((conn) => new host_1.HostConnectCommand(conn).execute(host3, port));
  }
  disconnect(host3, port = 5555) {
    if (host3.indexOf(":") !== -1) {
      const [h2, portString] = host3.split(":", 2);
      host3 = h2;
      const parsed = parseInt(portString, 10);
      if (!isNaN(parsed)) {
        port = parsed;
      }
    }
    return this.connection().then((conn) => new host_1.HostDisconnectCommand(conn).execute(host3, port)).then((deviceId) => new DeviceClient_1.default(this, deviceId));
  }
  listDevices() {
    return this.connection().then((conn) => new host_1.HostDevicesCommand(conn).execute());
  }
  listDevicesWithPaths() {
    return this.connection().then((conn) => new host_1.HostDevicesWithPathsCommand(conn).execute());
  }
  trackDevices() {
    return this.connection().then((conn) => new host_1.HostTrackDevicesCommand(conn).execute());
  }
  kill() {
    return this.connection().then((conn) => new host_1.HostKillCommand(conn).execute());
  }
  getDevice(serial) {
    return new DeviceClient_1.default(this, serial);
  }
}
client$1.default = Client;
var util = {};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(util, "__esModule", { value: true });
const parser_1 = __importDefault$1(parser$1);
const auth_1 = __importDefault$1(auth);
class Util {
  static readAll(stream2, callback) {
    return new parser_1.default(stream2).readAll().nodeify(callback);
  }
  static parsePublicKey(keyString, callback) {
    return auth_1.default.parsePublicKey(keyString).nodeify(callback);
  }
}
util.default = Util;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(adb, "__esModule", { value: true });
const client_1 = __importDefault(client$1);
const util_1 = __importDefault(util);
let Adb$1 = class Adb {
  static createClient(options2 = {}) {
    const opts = {
      bin: options2.bin,
      host: options2.host || process.env.ADB_HOST,
      port: options2.port || 5037,
      timeout: options2.timeout || 0
    };
    if (!opts.port) {
      const port = parseInt(process.env.ADB_PORT || "5037", 10);
      if (!isNaN(port)) {
        opts.port = port;
      }
    }
    return new client_1.default(opts);
  }
};
Adb$1.util = util_1.default;
adb.default = Adb$1;
var keycode = {};
Object.defineProperty(keycode, "__esModule", { value: true });
keycode.KeyCodes = void 0;
var KeyCodes;
(function(KeyCodes2) {
  KeyCodes2[KeyCodes2["KEYCODE_UNKNOWN"] = 0] = "KEYCODE_UNKNOWN";
  KeyCodes2[KeyCodes2["KEYCODE_SOFT_LEFT"] = 1] = "KEYCODE_SOFT_LEFT";
  KeyCodes2[KeyCodes2["KEYCODE_SOFT_RIGHT"] = 2] = "KEYCODE_SOFT_RIGHT";
  KeyCodes2[KeyCodes2["KEYCODE_HOME"] = 3] = "KEYCODE_HOME";
  KeyCodes2[KeyCodes2["KEYCODE_BACK"] = 4] = "KEYCODE_BACK";
  KeyCodes2[KeyCodes2["KEYCODE_CALL"] = 5] = "KEYCODE_CALL";
  KeyCodes2[KeyCodes2["KEYCODE_ENDCALL"] = 6] = "KEYCODE_ENDCALL";
  KeyCodes2[KeyCodes2["KEYCODE_0"] = 7] = "KEYCODE_0";
  KeyCodes2[KeyCodes2["KEYCODE_1"] = 8] = "KEYCODE_1";
  KeyCodes2[KeyCodes2["KEYCODE_2"] = 9] = "KEYCODE_2";
  KeyCodes2[KeyCodes2["KEYCODE_3"] = 10] = "KEYCODE_3";
  KeyCodes2[KeyCodes2["KEYCODE_4"] = 11] = "KEYCODE_4";
  KeyCodes2[KeyCodes2["KEYCODE_5"] = 12] = "KEYCODE_5";
  KeyCodes2[KeyCodes2["KEYCODE_6"] = 13] = "KEYCODE_6";
  KeyCodes2[KeyCodes2["KEYCODE_7"] = 14] = "KEYCODE_7";
  KeyCodes2[KeyCodes2["KEYCODE_8"] = 15] = "KEYCODE_8";
  KeyCodes2[KeyCodes2["KEYCODE_9"] = 16] = "KEYCODE_9";
  KeyCodes2[KeyCodes2["KEYCODE_STAR"] = 17] = "KEYCODE_STAR";
  KeyCodes2[KeyCodes2["KEYCODE_POUND"] = 18] = "KEYCODE_POUND";
  KeyCodes2[KeyCodes2["KEYCODE_DPAD_UP"] = 19] = "KEYCODE_DPAD_UP";
  KeyCodes2[KeyCodes2["KEYCODE_DPAD_DOWN"] = 20] = "KEYCODE_DPAD_DOWN";
  KeyCodes2[KeyCodes2["KEYCODE_DPAD_LEFT"] = 21] = "KEYCODE_DPAD_LEFT";
  KeyCodes2[KeyCodes2["KEYCODE_DPAD_RIGHT"] = 22] = "KEYCODE_DPAD_RIGHT";
  KeyCodes2[KeyCodes2["KEYCODE_DPAD_CENTER"] = 23] = "KEYCODE_DPAD_CENTER";
  KeyCodes2[KeyCodes2["KEYCODE_VOLUME_UP"] = 24] = "KEYCODE_VOLUME_UP";
  KeyCodes2[KeyCodes2["KEYCODE_VOLUME_DOWN"] = 25] = "KEYCODE_VOLUME_DOWN";
  KeyCodes2[KeyCodes2["KEYCODE_POWER"] = 26] = "KEYCODE_POWER";
  KeyCodes2[KeyCodes2["KEYCODE_CAMERA"] = 27] = "KEYCODE_CAMERA";
  KeyCodes2[KeyCodes2["KEYCODE_CLEAR"] = 28] = "KEYCODE_CLEAR";
  KeyCodes2[KeyCodes2["KEYCODE_A"] = 29] = "KEYCODE_A";
  KeyCodes2[KeyCodes2["KEYCODE_B"] = 30] = "KEYCODE_B";
  KeyCodes2[KeyCodes2["KEYCODE_C"] = 31] = "KEYCODE_C";
  KeyCodes2[KeyCodes2["KEYCODE_D"] = 32] = "KEYCODE_D";
  KeyCodes2[KeyCodes2["KEYCODE_E"] = 33] = "KEYCODE_E";
  KeyCodes2[KeyCodes2["KEYCODE_F"] = 34] = "KEYCODE_F";
  KeyCodes2[KeyCodes2["KEYCODE_G"] = 35] = "KEYCODE_G";
  KeyCodes2[KeyCodes2["KEYCODE_H"] = 36] = "KEYCODE_H";
  KeyCodes2[KeyCodes2["KEYCODE_I"] = 37] = "KEYCODE_I";
  KeyCodes2[KeyCodes2["KEYCODE_J"] = 38] = "KEYCODE_J";
  KeyCodes2[KeyCodes2["KEYCODE_K"] = 39] = "KEYCODE_K";
  KeyCodes2[KeyCodes2["KEYCODE_L"] = 40] = "KEYCODE_L";
  KeyCodes2[KeyCodes2["KEYCODE_M"] = 41] = "KEYCODE_M";
  KeyCodes2[KeyCodes2["KEYCODE_N"] = 42] = "KEYCODE_N";
  KeyCodes2[KeyCodes2["KEYCODE_O"] = 43] = "KEYCODE_O";
  KeyCodes2[KeyCodes2["KEYCODE_P"] = 44] = "KEYCODE_P";
  KeyCodes2[KeyCodes2["KEYCODE_Q"] = 45] = "KEYCODE_Q";
  KeyCodes2[KeyCodes2["KEYCODE_R"] = 46] = "KEYCODE_R";
  KeyCodes2[KeyCodes2["KEYCODE_S"] = 47] = "KEYCODE_S";
  KeyCodes2[KeyCodes2["KEYCODE_T"] = 48] = "KEYCODE_T";
  KeyCodes2[KeyCodes2["KEYCODE_U"] = 49] = "KEYCODE_U";
  KeyCodes2[KeyCodes2["KEYCODE_V"] = 50] = "KEYCODE_V";
  KeyCodes2[KeyCodes2["KEYCODE_W"] = 51] = "KEYCODE_W";
  KeyCodes2[KeyCodes2["KEYCODE_X"] = 52] = "KEYCODE_X";
  KeyCodes2[KeyCodes2["KEYCODE_Y"] = 53] = "KEYCODE_Y";
  KeyCodes2[KeyCodes2["KEYCODE_Z"] = 54] = "KEYCODE_Z";
  KeyCodes2[KeyCodes2["KEYCODE_COMMA"] = 55] = "KEYCODE_COMMA";
  KeyCodes2[KeyCodes2["KEYCODE_PERIOD"] = 56] = "KEYCODE_PERIOD";
  KeyCodes2[KeyCodes2["KEYCODE_ALT_LEFT"] = 57] = "KEYCODE_ALT_LEFT";
  KeyCodes2[KeyCodes2["KEYCODE_ALT_RIGHT"] = 58] = "KEYCODE_ALT_RIGHT";
  KeyCodes2[KeyCodes2["KEYCODE_SHIFT_LEFT"] = 59] = "KEYCODE_SHIFT_LEFT";
  KeyCodes2[KeyCodes2["KEYCODE_SHIFT_RIGHT"] = 60] = "KEYCODE_SHIFT_RIGHT";
  KeyCodes2[KeyCodes2["KEYCODE_TAB"] = 61] = "KEYCODE_TAB";
  KeyCodes2[KeyCodes2["KEYCODE_SPACE"] = 62] = "KEYCODE_SPACE";
  KeyCodes2[KeyCodes2["KEYCODE_SYM"] = 63] = "KEYCODE_SYM";
  KeyCodes2[KeyCodes2["KEYCODE_EXPLORER"] = 64] = "KEYCODE_EXPLORER";
  KeyCodes2[KeyCodes2["KEYCODE_ENVELOPE"] = 65] = "KEYCODE_ENVELOPE";
  KeyCodes2[KeyCodes2["KEYCODE_ENTER"] = 66] = "KEYCODE_ENTER";
  KeyCodes2[KeyCodes2["KEYCODE_DEL"] = 67] = "KEYCODE_DEL";
  KeyCodes2[KeyCodes2["KEYCODE_GRAVE"] = 68] = "KEYCODE_GRAVE";
  KeyCodes2[KeyCodes2["KEYCODE_MINUS"] = 69] = "KEYCODE_MINUS";
  KeyCodes2[KeyCodes2["KEYCODE_EQUALS"] = 70] = "KEYCODE_EQUALS";
  KeyCodes2[KeyCodes2["KEYCODE_LEFT_BRACKET"] = 71] = "KEYCODE_LEFT_BRACKET";
  KeyCodes2[KeyCodes2["KEYCODE_RIGHT_BRACKET"] = 72] = "KEYCODE_RIGHT_BRACKET";
  KeyCodes2[KeyCodes2["KEYCODE_BACKSLASH"] = 73] = "KEYCODE_BACKSLASH";
  KeyCodes2[KeyCodes2["KEYCODE_SEMICOLON"] = 74] = "KEYCODE_SEMICOLON";
  KeyCodes2[KeyCodes2["KEYCODE_APOSTROPHE"] = 75] = "KEYCODE_APOSTROPHE";
  KeyCodes2[KeyCodes2["KEYCODE_SLASH"] = 76] = "KEYCODE_SLASH";
  KeyCodes2[KeyCodes2["KEYCODE_AT"] = 77] = "KEYCODE_AT";
  KeyCodes2[KeyCodes2["KEYCODE_NUM"] = 78] = "KEYCODE_NUM";
  KeyCodes2[KeyCodes2["KEYCODE_HEADSETHOOK"] = 79] = "KEYCODE_HEADSETHOOK";
  KeyCodes2[KeyCodes2["KEYCODE_FOCUS"] = 80] = "KEYCODE_FOCUS";
  KeyCodes2[KeyCodes2["KEYCODE_PLUS"] = 81] = "KEYCODE_PLUS";
  KeyCodes2[KeyCodes2["KEYCODE_MENU"] = 82] = "KEYCODE_MENU";
  KeyCodes2[KeyCodes2["KEYCODE_NOTIFICATION"] = 83] = "KEYCODE_NOTIFICATION";
  KeyCodes2[KeyCodes2["KEYCODE_SEARCH"] = 84] = "KEYCODE_SEARCH";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_PLAY_PAUSE"] = 85] = "KEYCODE_MEDIA_PLAY_PAUSE";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_STOP"] = 86] = "KEYCODE_MEDIA_STOP";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_NEXT"] = 87] = "KEYCODE_MEDIA_NEXT";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_PREVIOUS"] = 88] = "KEYCODE_MEDIA_PREVIOUS";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_REWIND"] = 89] = "KEYCODE_MEDIA_REWIND";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_FAST_FORWARD"] = 90] = "KEYCODE_MEDIA_FAST_FORWARD";
  KeyCodes2[KeyCodes2["KEYCODE_MUTE"] = 91] = "KEYCODE_MUTE";
  KeyCodes2[KeyCodes2["KEYCODE_PAGE_UP"] = 92] = "KEYCODE_PAGE_UP";
  KeyCodes2[KeyCodes2["KEYCODE_PAGE_DOWN"] = 93] = "KEYCODE_PAGE_DOWN";
  KeyCodes2[KeyCodes2["KEYCODE_PICTSYMBOLS"] = 94] = "KEYCODE_PICTSYMBOLS";
  KeyCodes2[KeyCodes2["KEYCODE_SWITCH_CHARSET"] = 95] = "KEYCODE_SWITCH_CHARSET";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_A"] = 96] = "KEYCODE_BUTTON_A";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_B"] = 97] = "KEYCODE_BUTTON_B";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_C"] = 98] = "KEYCODE_BUTTON_C";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_X"] = 99] = "KEYCODE_BUTTON_X";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_Y"] = 100] = "KEYCODE_BUTTON_Y";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_Z"] = 101] = "KEYCODE_BUTTON_Z";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_L1"] = 102] = "KEYCODE_BUTTON_L1";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_R1"] = 103] = "KEYCODE_BUTTON_R1";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_L2"] = 104] = "KEYCODE_BUTTON_L2";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_R2"] = 105] = "KEYCODE_BUTTON_R2";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_THUMBL"] = 106] = "KEYCODE_BUTTON_THUMBL";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_THUMBR"] = 107] = "KEYCODE_BUTTON_THUMBR";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_START"] = 108] = "KEYCODE_BUTTON_START";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_SELECT"] = 109] = "KEYCODE_BUTTON_SELECT";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_MODE"] = 110] = "KEYCODE_BUTTON_MODE";
  KeyCodes2[KeyCodes2["KEYCODE_ESCAPE"] = 111] = "KEYCODE_ESCAPE";
  KeyCodes2[KeyCodes2["KEYCODE_FORWARD_DEL"] = 112] = "KEYCODE_FORWARD_DEL";
  KeyCodes2[KeyCodes2["KEYCODE_CTRL_LEFT"] = 113] = "KEYCODE_CTRL_LEFT";
  KeyCodes2[KeyCodes2["KEYCODE_CTRL_RIGHT"] = 114] = "KEYCODE_CTRL_RIGHT";
  KeyCodes2[KeyCodes2["KEYCODE_CAPS_LOCK"] = 115] = "KEYCODE_CAPS_LOCK";
  KeyCodes2[KeyCodes2["KEYCODE_SCROLL_LOCK"] = 116] = "KEYCODE_SCROLL_LOCK";
  KeyCodes2[KeyCodes2["KEYCODE_META_LEFT"] = 117] = "KEYCODE_META_LEFT";
  KeyCodes2[KeyCodes2["KEYCODE_META_RIGHT"] = 118] = "KEYCODE_META_RIGHT";
  KeyCodes2[KeyCodes2["KEYCODE_FUNCTION"] = 119] = "KEYCODE_FUNCTION";
  KeyCodes2[KeyCodes2["KEYCODE_SYSRQ"] = 120] = "KEYCODE_SYSRQ";
  KeyCodes2[KeyCodes2["KEYCODE_BREAK"] = 121] = "KEYCODE_BREAK";
  KeyCodes2[KeyCodes2["KEYCODE_MOVE_HOME"] = 122] = "KEYCODE_MOVE_HOME";
  KeyCodes2[KeyCodes2["KEYCODE_MOVE_END"] = 123] = "KEYCODE_MOVE_END";
  KeyCodes2[KeyCodes2["KEYCODE_INSERT"] = 124] = "KEYCODE_INSERT";
  KeyCodes2[KeyCodes2["KEYCODE_FORWARD"] = 125] = "KEYCODE_FORWARD";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_PLAY"] = 126] = "KEYCODE_MEDIA_PLAY";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_PAUSE"] = 127] = "KEYCODE_MEDIA_PAUSE";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_CLOSE"] = 128] = "KEYCODE_MEDIA_CLOSE";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_EJECT"] = 129] = "KEYCODE_MEDIA_EJECT";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_RECORD"] = 130] = "KEYCODE_MEDIA_RECORD";
  KeyCodes2[KeyCodes2["KEYCODE_F1"] = 131] = "KEYCODE_F1";
  KeyCodes2[KeyCodes2["KEYCODE_F2"] = 132] = "KEYCODE_F2";
  KeyCodes2[KeyCodes2["KEYCODE_F3"] = 133] = "KEYCODE_F3";
  KeyCodes2[KeyCodes2["KEYCODE_F4"] = 134] = "KEYCODE_F4";
  KeyCodes2[KeyCodes2["KEYCODE_F5"] = 135] = "KEYCODE_F5";
  KeyCodes2[KeyCodes2["KEYCODE_F6"] = 136] = "KEYCODE_F6";
  KeyCodes2[KeyCodes2["KEYCODE_F7"] = 137] = "KEYCODE_F7";
  KeyCodes2[KeyCodes2["KEYCODE_F8"] = 138] = "KEYCODE_F8";
  KeyCodes2[KeyCodes2["KEYCODE_F9"] = 139] = "KEYCODE_F9";
  KeyCodes2[KeyCodes2["KEYCODE_F10"] = 140] = "KEYCODE_F10";
  KeyCodes2[KeyCodes2["KEYCODE_F11"] = 141] = "KEYCODE_F11";
  KeyCodes2[KeyCodes2["KEYCODE_F12"] = 142] = "KEYCODE_F12";
  KeyCodes2[KeyCodes2["KEYCODE_NUM_LOCK"] = 143] = "KEYCODE_NUM_LOCK";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_0"] = 144] = "KEYCODE_NUMPAD_0";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_1"] = 145] = "KEYCODE_NUMPAD_1";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_2"] = 146] = "KEYCODE_NUMPAD_2";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_3"] = 147] = "KEYCODE_NUMPAD_3";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_4"] = 148] = "KEYCODE_NUMPAD_4";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_5"] = 149] = "KEYCODE_NUMPAD_5";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_6"] = 150] = "KEYCODE_NUMPAD_6";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_7"] = 151] = "KEYCODE_NUMPAD_7";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_8"] = 152] = "KEYCODE_NUMPAD_8";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_9"] = 153] = "KEYCODE_NUMPAD_9";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_DIVIDE"] = 154] = "KEYCODE_NUMPAD_DIVIDE";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_MULTIPLY"] = 155] = "KEYCODE_NUMPAD_MULTIPLY";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_SUBTRACT"] = 156] = "KEYCODE_NUMPAD_SUBTRACT";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_ADD"] = 157] = "KEYCODE_NUMPAD_ADD";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_DOT"] = 158] = "KEYCODE_NUMPAD_DOT";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_COMMA"] = 159] = "KEYCODE_NUMPAD_COMMA";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_ENTER"] = 160] = "KEYCODE_NUMPAD_ENTER";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_EQUALS"] = 161] = "KEYCODE_NUMPAD_EQUALS";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_LEFT_PAREN"] = 162] = "KEYCODE_NUMPAD_LEFT_PAREN";
  KeyCodes2[KeyCodes2["KEYCODE_NUMPAD_RIGHT_PAREN"] = 163] = "KEYCODE_NUMPAD_RIGHT_PAREN";
  KeyCodes2[KeyCodes2["KEYCODE_VOLUME_MUTE"] = 164] = "KEYCODE_VOLUME_MUTE";
  KeyCodes2[KeyCodes2["KEYCODE_INFO"] = 165] = "KEYCODE_INFO";
  KeyCodes2[KeyCodes2["KEYCODE_CHANNEL_UP"] = 166] = "KEYCODE_CHANNEL_UP";
  KeyCodes2[KeyCodes2["KEYCODE_CHANNEL_DOWN"] = 167] = "KEYCODE_CHANNEL_DOWN";
  KeyCodes2[KeyCodes2["KEYCODE_ZOOM_IN"] = 168] = "KEYCODE_ZOOM_IN";
  KeyCodes2[KeyCodes2["KEYCODE_ZOOM_OUT"] = 169] = "KEYCODE_ZOOM_OUT";
  KeyCodes2[KeyCodes2["KEYCODE_TV"] = 170] = "KEYCODE_TV";
  KeyCodes2[KeyCodes2["KEYCODE_WINDOW"] = 171] = "KEYCODE_WINDOW";
  KeyCodes2[KeyCodes2["KEYCODE_GUIDE"] = 172] = "KEYCODE_GUIDE";
  KeyCodes2[KeyCodes2["KEYCODE_DVR"] = 173] = "KEYCODE_DVR";
  KeyCodes2[KeyCodes2["KEYCODE_BOOKMARK"] = 174] = "KEYCODE_BOOKMARK";
  KeyCodes2[KeyCodes2["KEYCODE_CAPTIONS"] = 175] = "KEYCODE_CAPTIONS";
  KeyCodes2[KeyCodes2["KEYCODE_SETTINGS"] = 176] = "KEYCODE_SETTINGS";
  KeyCodes2[KeyCodes2["KEYCODE_TV_POWER"] = 177] = "KEYCODE_TV_POWER";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT"] = 178] = "KEYCODE_TV_INPUT";
  KeyCodes2[KeyCodes2["KEYCODE_STB_POWER"] = 179] = "KEYCODE_STB_POWER";
  KeyCodes2[KeyCodes2["KEYCODE_STB_INPUT"] = 180] = "KEYCODE_STB_INPUT";
  KeyCodes2[KeyCodes2["KEYCODE_AVR_POWER"] = 181] = "KEYCODE_AVR_POWER";
  KeyCodes2[KeyCodes2["KEYCODE_AVR_INPUT"] = 182] = "KEYCODE_AVR_INPUT";
  KeyCodes2[KeyCodes2["KEYCODE_PROG_RED"] = 183] = "KEYCODE_PROG_RED";
  KeyCodes2[KeyCodes2["KEYCODE_PROG_GREEN"] = 184] = "KEYCODE_PROG_GREEN";
  KeyCodes2[KeyCodes2["KEYCODE_PROG_YELLOW"] = 185] = "KEYCODE_PROG_YELLOW";
  KeyCodes2[KeyCodes2["KEYCODE_PROG_BLUE"] = 186] = "KEYCODE_PROG_BLUE";
  KeyCodes2[KeyCodes2["KEYCODE_APP_SWITCH"] = 187] = "KEYCODE_APP_SWITCH";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_1"] = 188] = "KEYCODE_BUTTON_1";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_2"] = 189] = "KEYCODE_BUTTON_2";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_3"] = 190] = "KEYCODE_BUTTON_3";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_4"] = 191] = "KEYCODE_BUTTON_4";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_5"] = 192] = "KEYCODE_BUTTON_5";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_6"] = 193] = "KEYCODE_BUTTON_6";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_7"] = 194] = "KEYCODE_BUTTON_7";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_8"] = 195] = "KEYCODE_BUTTON_8";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_9"] = 196] = "KEYCODE_BUTTON_9";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_10"] = 197] = "KEYCODE_BUTTON_10";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_11"] = 198] = "KEYCODE_BUTTON_11";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_12"] = 199] = "KEYCODE_BUTTON_12";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_13"] = 200] = "KEYCODE_BUTTON_13";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_14"] = 201] = "KEYCODE_BUTTON_14";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_15"] = 202] = "KEYCODE_BUTTON_15";
  KeyCodes2[KeyCodes2["KEYCODE_BUTTON_16"] = 203] = "KEYCODE_BUTTON_16";
  KeyCodes2[KeyCodes2["KEYCODE_LANGUAGE_SWITCH"] = 204] = "KEYCODE_LANGUAGE_SWITCH";
  KeyCodes2[KeyCodes2["KEYCODE_MANNER_MODE"] = 205] = "KEYCODE_MANNER_MODE";
  KeyCodes2[KeyCodes2["KEYCODE_3D_MODE"] = 206] = "KEYCODE_3D_MODE";
  KeyCodes2[KeyCodes2["KEYCODE_CONTACTS"] = 207] = "KEYCODE_CONTACTS";
  KeyCodes2[KeyCodes2["KEYCODE_CALENDAR"] = 208] = "KEYCODE_CALENDAR";
  KeyCodes2[KeyCodes2["KEYCODE_MUSIC"] = 209] = "KEYCODE_MUSIC";
  KeyCodes2[KeyCodes2["KEYCODE_CALCULATOR"] = 210] = "KEYCODE_CALCULATOR";
  KeyCodes2[KeyCodes2["KEYCODE_ZENKAKU_HANKAKU"] = 211] = "KEYCODE_ZENKAKU_HANKAKU";
  KeyCodes2[KeyCodes2["KEYCODE_EISU"] = 212] = "KEYCODE_EISU";
  KeyCodes2[KeyCodes2["KEYCODE_MUHENKAN"] = 213] = "KEYCODE_MUHENKAN";
  KeyCodes2[KeyCodes2["KEYCODE_HENKAN"] = 214] = "KEYCODE_HENKAN";
  KeyCodes2[KeyCodes2["KEYCODE_KATAKANA_HIRAGANA"] = 215] = "KEYCODE_KATAKANA_HIRAGANA";
  KeyCodes2[KeyCodes2["KEYCODE_YEN"] = 216] = "KEYCODE_YEN";
  KeyCodes2[KeyCodes2["KEYCODE_RO"] = 217] = "KEYCODE_RO";
  KeyCodes2[KeyCodes2["KEYCODE_KANA"] = 218] = "KEYCODE_KANA";
  KeyCodes2[KeyCodes2["KEYCODE_ASSIST"] = 219] = "KEYCODE_ASSIST";
  KeyCodes2[KeyCodes2["KEYCODE_BRIGHTNESS_DOWN"] = 220] = "KEYCODE_BRIGHTNESS_DOWN";
  KeyCodes2[KeyCodes2["KEYCODE_BRIGHTNESS_UP"] = 221] = "KEYCODE_BRIGHTNESS_UP";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_AUDIO_TRACK"] = 222] = "KEYCODE_MEDIA_AUDIO_TRACK";
  KeyCodes2[KeyCodes2["KEYCODE_SLEEP"] = 223] = "KEYCODE_SLEEP";
  KeyCodes2[KeyCodes2["KEYCODE_WAKEUP"] = 224] = "KEYCODE_WAKEUP";
  KeyCodes2[KeyCodes2["KEYCODE_PAIRING"] = 225] = "KEYCODE_PAIRING";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_TOP_MENU"] = 226] = "KEYCODE_MEDIA_TOP_MENU";
  KeyCodes2[KeyCodes2["KEYCODE_11"] = 227] = "KEYCODE_11";
  KeyCodes2[KeyCodes2["KEYCODE_12"] = 228] = "KEYCODE_12";
  KeyCodes2[KeyCodes2["KEYCODE_LAST_CHANNEL"] = 229] = "KEYCODE_LAST_CHANNEL";
  KeyCodes2[KeyCodes2["KEYCODE_TV_DATA_SERVICE"] = 230] = "KEYCODE_TV_DATA_SERVICE";
  KeyCodes2[KeyCodes2["KEYCODE_VOICE_ASSIST"] = 231] = "KEYCODE_VOICE_ASSIST";
  KeyCodes2[KeyCodes2["KEYCODE_TV_RADIO_SERVICE"] = 232] = "KEYCODE_TV_RADIO_SERVICE";
  KeyCodes2[KeyCodes2["KEYCODE_TV_TELETEXT"] = 233] = "KEYCODE_TV_TELETEXT";
  KeyCodes2[KeyCodes2["KEYCODE_TV_NUMBER_ENTRY"] = 234] = "KEYCODE_TV_NUMBER_ENTRY";
  KeyCodes2[KeyCodes2["KEYCODE_TV_TERRESTRIAL_ANALOG"] = 235] = "KEYCODE_TV_TERRESTRIAL_ANALOG";
  KeyCodes2[KeyCodes2["KEYCODE_TV_TERRESTRIAL_DIGITAL"] = 236] = "KEYCODE_TV_TERRESTRIAL_DIGITAL";
  KeyCodes2[KeyCodes2["KEYCODE_TV_SATELLITE"] = 237] = "KEYCODE_TV_SATELLITE";
  KeyCodes2[KeyCodes2["KEYCODE_TV_SATELLITE_BS"] = 238] = "KEYCODE_TV_SATELLITE_BS";
  KeyCodes2[KeyCodes2["KEYCODE_TV_SATELLITE_CS"] = 239] = "KEYCODE_TV_SATELLITE_CS";
  KeyCodes2[KeyCodes2["KEYCODE_TV_SATELLITE_SERVICE"] = 240] = "KEYCODE_TV_SATELLITE_SERVICE";
  KeyCodes2[KeyCodes2["KEYCODE_TV_NETWORK"] = 241] = "KEYCODE_TV_NETWORK";
  KeyCodes2[KeyCodes2["KEYCODE_TV_ANTENNA_CABLE"] = 242] = "KEYCODE_TV_ANTENNA_CABLE";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT_HDMI_1"] = 243] = "KEYCODE_TV_INPUT_HDMI_1";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT_HDMI_2"] = 244] = "KEYCODE_TV_INPUT_HDMI_2";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT_HDMI_3"] = 245] = "KEYCODE_TV_INPUT_HDMI_3";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT_HDMI_4"] = 246] = "KEYCODE_TV_INPUT_HDMI_4";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT_COMPOSITE_1"] = 247] = "KEYCODE_TV_INPUT_COMPOSITE_1";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT_COMPOSITE_2"] = 248] = "KEYCODE_TV_INPUT_COMPOSITE_2";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT_COMPONENT_1"] = 249] = "KEYCODE_TV_INPUT_COMPONENT_1";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT_COMPONENT_2"] = 250] = "KEYCODE_TV_INPUT_COMPONENT_2";
  KeyCodes2[KeyCodes2["KEYCODE_TV_INPUT_VGA_1"] = 251] = "KEYCODE_TV_INPUT_VGA_1";
  KeyCodes2[KeyCodes2["KEYCODE_TV_AUDIO_DESCRIPTION"] = 252] = "KEYCODE_TV_AUDIO_DESCRIPTION";
  KeyCodes2[KeyCodes2["KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP"] = 253] = "KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP";
  KeyCodes2[KeyCodes2["KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN"] = 254] = "KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN";
  KeyCodes2[KeyCodes2["KEYCODE_TV_ZOOM_MODE"] = 255] = "KEYCODE_TV_ZOOM_MODE";
  KeyCodes2[KeyCodes2["KEYCODE_TV_CONTENTS_MENU"] = 256] = "KEYCODE_TV_CONTENTS_MENU";
  KeyCodes2[KeyCodes2["KEYCODE_TV_MEDIA_CONTEXT_MENU"] = 257] = "KEYCODE_TV_MEDIA_CONTEXT_MENU";
  KeyCodes2[KeyCodes2["KEYCODE_TV_TIMER_PROGRAMMING"] = 258] = "KEYCODE_TV_TIMER_PROGRAMMING";
  KeyCodes2[KeyCodes2["KEYCODE_HELP"] = 259] = "KEYCODE_HELP";
  KeyCodes2[KeyCodes2["KEYCODE_NAVIGATE_PREVIOUS"] = 260] = "KEYCODE_NAVIGATE_PREVIOUS";
  KeyCodes2[KeyCodes2["KEYCODE_NAVIGATE_NEXT"] = 261] = "KEYCODE_NAVIGATE_NEXT";
  KeyCodes2[KeyCodes2["KEYCODE_NAVIGATE_IN"] = 262] = "KEYCODE_NAVIGATE_IN";
  KeyCodes2[KeyCodes2["KEYCODE_NAVIGATE_OUT"] = 263] = "KEYCODE_NAVIGATE_OUT";
  KeyCodes2[KeyCodes2["KEYCODE_STEM_PRIMARY"] = 264] = "KEYCODE_STEM_PRIMARY";
  KeyCodes2[KeyCodes2["KEYCODE_STEM_1"] = 265] = "KEYCODE_STEM_1";
  KeyCodes2[KeyCodes2["KEYCODE_STEM_2"] = 266] = "KEYCODE_STEM_2";
  KeyCodes2[KeyCodes2["KEYCODE_STEM_3"] = 267] = "KEYCODE_STEM_3";
  KeyCodes2[KeyCodes2["KEYCODE_DPAD_UP_LEFT"] = 268] = "KEYCODE_DPAD_UP_LEFT";
  KeyCodes2[KeyCodes2["KEYCODE_DPAD_DOWN_LEFT"] = 269] = "KEYCODE_DPAD_DOWN_LEFT";
  KeyCodes2[KeyCodes2["KEYCODE_DPAD_UP_RIGHT"] = 270] = "KEYCODE_DPAD_UP_RIGHT";
  KeyCodes2[KeyCodes2["KEYCODE_DPAD_DOWN_RIGHT"] = 271] = "KEYCODE_DPAD_DOWN_RIGHT";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_SKIP_FORWARD"] = 272] = "KEYCODE_MEDIA_SKIP_FORWARD";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_SKIP_BACKWARD"] = 273] = "KEYCODE_MEDIA_SKIP_BACKWARD";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_STEP_FORWARD"] = 274] = "KEYCODE_MEDIA_STEP_FORWARD";
  KeyCodes2[KeyCodes2["KEYCODE_MEDIA_STEP_BACKWARD"] = 275] = "KEYCODE_MEDIA_STEP_BACKWARD";
  KeyCodes2[KeyCodes2["KEYCODE_SOFT_SLEEP"] = 276] = "KEYCODE_SOFT_SLEEP";
  KeyCodes2[KeyCodes2["KEYCODE_CUT"] = 277] = "KEYCODE_CUT";
  KeyCodes2[KeyCodes2["KEYCODE_COPY"] = 278] = "KEYCODE_COPY";
  KeyCodes2[KeyCodes2["KEYCODE_PASTE"] = 279] = "KEYCODE_PASTE";
  KeyCodes2[KeyCodes2["KEYCODE_SYSTEM_NAVIGATION_UP"] = 280] = "KEYCODE_SYSTEM_NAVIGATION_UP";
  KeyCodes2[KeyCodes2["KEYCODE_SYSTEM_NAVIGATION_DOWN"] = 281] = "KEYCODE_SYSTEM_NAVIGATION_DOWN";
  KeyCodes2[KeyCodes2["KEYCODE_SYSTEM_NAVIGATION_LEFT"] = 282] = "KEYCODE_SYSTEM_NAVIGATION_LEFT";
  KeyCodes2[KeyCodes2["KEYCODE_SYSTEM_NAVIGATION_RIGHT"] = 283] = "KEYCODE_SYSTEM_NAVIGATION_RIGHT";
  KeyCodes2[KeyCodes2["KEYCODE_ALL_APPS"] = 284] = "KEYCODE_ALL_APPS";
  KeyCodes2[KeyCodes2["KEYCODE_REFRESH"] = 285] = "KEYCODE_REFRESH";
  KeyCodes2[KeyCodes2["KEYCODE_THUMBS_UP"] = 286] = "KEYCODE_THUMBS_UP";
  KeyCodes2[KeyCodes2["KEYCODE_THUMBS_DOWN"] = 287] = "KEYCODE_THUMBS_DOWN";
  KeyCodes2[KeyCodes2["KEYCODE_PROFILE_SWITCH"] = 288] = "KEYCODE_PROFILE_SWITCH";
})(KeyCodes || (keycode.KeyCodes = KeyCodes = {}));
(function(exports$1) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.KeyCodes = exports$1.ShellCommand = exports$1.DeviceClient = exports$1.Client = exports$1.Parser = exports$1.Adb = exports$1.default = void 0;
  var adb_1 = adb;
  Object.defineProperty(exports$1, "default", { enumerable: true, get: function() {
    return __importDefault2(adb_1).default;
  } });
  var adb_2 = adb;
  Object.defineProperty(exports$1, "Adb", { enumerable: true, get: function() {
    return __importDefault2(adb_2).default;
  } });
  var parser_12 = parser$1;
  Object.defineProperty(exports$1, "Parser", { enumerable: true, get: function() {
    return __importDefault2(parser_12).default;
  } });
  var client_12 = client$1;
  Object.defineProperty(exports$1, "Client", { enumerable: true, get: function() {
    return __importDefault2(client_12).default;
  } });
  var DeviceClient_12 = DeviceClient$1;
  Object.defineProperty(exports$1, "DeviceClient", { enumerable: true, get: function() {
    return __importDefault2(DeviceClient_12).default;
  } });
  var shell_1 = shell;
  Object.defineProperty(exports$1, "ShellCommand", { enumerable: true, get: function() {
    return __importDefault2(shell_1).default;
  } });
  var keycode_1 = keycode;
  Object.defineProperty(exports$1, "KeyCodes", { enumerable: true, get: function() {
    return keycode_1.KeyCodes;
  } });
})(dist);
const Adb2 = /* @__PURE__ */ getDefaultExportFromCjs(dist);
class Locked extends Error {
  constructor(port) {
    super(`${port} is locked`);
  }
}
const lockedPorts = {
  old: /* @__PURE__ */ new Set(),
  young: /* @__PURE__ */ new Set()
};
const releaseOldLockedPortsIntervalMs = 1e3 * 15;
let timeout;
const getLocalHosts = () => {
  const interfaces = os$1.networkInterfaces();
  const results = /* @__PURE__ */ new Set([void 0, "0.0.0.0"]);
  for (const _interface of Object.values(interfaces)) {
    for (const config2 of _interface) {
      results.add(config2.address);
    }
  }
  return results;
};
const checkAvailablePort = (options2) => new Promise((resolve3, reject) => {
  const server2 = net.createServer();
  server2.unref();
  server2.on("error", reject);
  server2.listen(options2, () => {
    const { port } = server2.address();
    server2.close(() => {
      resolve3(port);
    });
  });
});
const getAvailablePort = async (options2, hosts) => {
  if (options2.host || options2.port === 0) {
    return checkAvailablePort(options2);
  }
  for (const host3 of hosts) {
    try {
      await checkAvailablePort({ port: options2.port, host: host3 });
    } catch (error2) {
      if (!["EADDRNOTAVAIL", "EINVAL"].includes(error2.code)) {
        throw error2;
      }
    }
  }
  return options2.port;
};
const portCheckSequence = function* (ports) {
  yield 0;
};
async function getPorts(options2) {
  let exclude = /* @__PURE__ */ new Set();
  if (timeout === void 0) {
    timeout = setTimeout(() => {
      timeout = void 0;
      lockedPorts.old = lockedPorts.young;
      lockedPorts.young = /* @__PURE__ */ new Set();
    }, releaseOldLockedPortsIntervalMs);
    if (timeout.unref) {
      timeout.unref();
    }
  }
  const hosts = getLocalHosts();
  for (const port of portCheckSequence()) {
    try {
      if (exclude.has(port)) {
        continue;
      }
      let availablePort = await getAvailablePort({ ...options2, port }, hosts);
      while (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {
        if (port !== 0) {
          throw new Locked(port);
        }
        availablePort = await getAvailablePort({ ...options2, port }, hosts);
      }
      lockedPorts.young.add(availablePort);
      return availablePort;
    } catch (error2) {
      if (!["EADDRINUSE", "EACCES"].includes(error2.code) && !(error2 instanceof Locked)) {
        throw error2;
      }
    }
  }
  throw new Error("No available ports found");
}
class AdbClient {
  constructor() {
    __publicField(this, "client", Adb2.createClient());
  }
  async listDevices() {
    const devices2 = await this.client.listDevices();
    return devices2.map((d2) => ({
      id: d2.id,
      state: d2.type
    }));
  }
  async shell(deviceId, cmd) {
    const device = this.client.getDevice(deviceId);
    const socket2 = await device.shell(cmd);
    const output = await Adb2.util.readAll(socket2);
    return output.toString().trim();
  }
  async shellRaw(deviceId, cmd) {
    const device = this.client.getDevice(deviceId);
    const socket2 = await device.shell(cmd);
    const output = await Adb2.util.readAll(socket2);
    return Buffer.from(output);
  }
  async shellSocket(deviceId, cmd) {
    const device = this.client.getDevice(deviceId);
    return device.shell(cmd);
  }
  async reverseTcp(deviceId, remote) {
    const device = this.client.getDevice(deviceId);
    const reverses = await device.listReverses();
    for (const reverse2 of reverses) {
      if (reverse2.remote === remote) {
        return Number(reverse2.local.replace("tcp:", ""));
      }
    }
    const port = await getPorts();
    const local2 = `tcp:${port}`;
    await device.reverse(remote, local2);
    return port;
  }
  async push(deviceId, localPath, remotePath) {
    const device = this.client.getDevice(deviceId);
    const transfer = await device.push(localPath, remotePath);
    await new Promise((resolve3, reject) => {
      transfer.on("end", () => resolve3());
      transfer.on("error", (err) => reject(err));
    });
  }
}
const _ScrcpyAudioCodec = class _ScrcpyAudioCodec {
  constructor(optionValue, metadataValue, mimeType, webCodecId) {
    __publicField(this, "optionValue");
    __publicField(this, "metadataValue");
    __publicField(this, "mimeType");
    __publicField(this, "webCodecId");
    this.optionValue = optionValue;
    this.metadataValue = metadataValue;
    this.mimeType = mimeType;
    this.webCodecId = webCodecId;
  }
  toOptionValue() {
    return this.optionValue;
  }
};
__publicField(_ScrcpyAudioCodec, "Opus", /* @__PURE__ */ new _ScrcpyAudioCodec("opus", 1869641075, "audio/opus", "opus"));
__publicField(_ScrcpyAudioCodec, "Aac", /* @__PURE__ */ new _ScrcpyAudioCodec("aac", 6381923, "audio/aac", "mp4a.66"));
__publicField(_ScrcpyAudioCodec, "Flac", /* @__PURE__ */ new _ScrcpyAudioCodec("flac", 1718378851, "audio/flac", "flac"));
__publicField(_ScrcpyAudioCodec, "Raw", /* @__PURE__ */ new _ScrcpyAudioCodec("raw", 7496055, "audio/raw", ""));
let ScrcpyAudioCodec = _ScrcpyAudioCodec;
const ScrcpyControlMessageType = {
  InjectKeyCode: 0,
  InjectText: 1,
  InjectTouch: 2,
  InjectScroll: 3,
  BackOrScreenOn: 4,
  ExpandNotificationPanel: 5,
  ExpandSettingPanel: 6,
  CollapseNotificationPanel: 7,
  GetClipboard: 8,
  SetClipboard: 9,
  SetDisplayPower: 10,
  RotateDevice: 11,
  UHidCreate: 12,
  UHidInput: 13,
  UHidDestroy: 14,
  OpenHardKeyboardSettings: 15,
  StartApp: 16,
  ResetVideo: 17
};
class ScrcpyDeviceMessageParsers {
  constructor() {
    __privateAdd(this, _ScrcpyDeviceMessageParsers_instances);
    __privateAdd(this, _parsers, []);
  }
  get parsers() {
    return __privateGet(this, _parsers);
  }
  add(parser2) {
    if (Array.isArray(parser2.id)) {
      for (const id of parser2.id) {
        __privateMethod(this, _ScrcpyDeviceMessageParsers_instances, add_fn).call(this, id, parser2);
      }
    } else {
      __privateMethod(this, _ScrcpyDeviceMessageParsers_instances, add_fn).call(this, parser2.id, parser2);
    }
    return parser2;
  }
  async parse(id, stream2) {
    const parser2 = __privateGet(this, _parsers)[id];
    if (!parser2) {
      throw new Error(`Unknown device message id ${id}`);
    }
    return parser2.parse(id, stream2);
  }
  close() {
    for (const parser2 of __privateGet(this, _parsers)) {
      parser2.close();
    }
  }
  error(e) {
    for (const parser2 of __privateGet(this, _parsers)) {
      parser2.error(e);
    }
  }
}
_parsers = new WeakMap();
_ScrcpyDeviceMessageParsers_instances = new WeakSet();
add_fn = function(id, parser2) {
  if (__privateGet(this, _parsers)[id]) {
    throw new Error(`Duplicate parser for id ${id}`);
  }
  __privateGet(this, _parsers)[id] = parser2;
};
function isScrcpyOptionValue(value) {
  return typeof value === "object" && value !== null && "toOptionValue" in value && typeof value.toOptionValue === "function";
}
function toScrcpyOptionValue(value, empty) {
  if (isScrcpyOptionValue(value)) {
    value = value.toOptionValue();
  }
  if (value === void 0) {
    return empty;
  }
  if (typeof value !== "string" && typeof value !== "number" && typeof value !== "boolean") {
    throw new TypeError(`Invalid option value: ${JSON.stringify(value)}`);
  }
  return value.toString();
}
const ScrcpyVideoCodecId = {
  H264: 1748121140,
  H265: 1748121141,
  AV1: 6387249
};
const AndroidKeyEventAction = {
  Down: 0,
  Up: 1
};
const AndroidKeyCode = {
  AndroidBack: 4,
  Backspace: 67
};
const AndroidMotionEventAction = {
  Down: 0,
  Up: 1,
  Move: 2
};
const AndroidMotionEventButton = {
  Primary: 1
};
class PromiseResolver {
  constructor() {
    __privateAdd(this, _promise);
    __privateAdd(this, _resolve);
    __privateAdd(this, _reject);
    __privateAdd(this, _state, "running");
    __publicField(this, "resolve", (value) => {
      __privateGet(this, _resolve).call(this, value);
      __privateSet(this, _state, "resolved");
    });
    __publicField(this, "reject", (reason) => {
      __privateGet(this, _reject).call(this, reason);
      __privateSet(this, _state, "rejected");
    });
    __privateSet(this, _promise, new Promise((resolve3, reject) => {
      __privateSet(this, _resolve, resolve3);
      __privateSet(this, _reject, reject);
    }));
  }
  get promise() {
    return __privateGet(this, _promise);
  }
  get state() {
    return __privateGet(this, _state);
  }
}
_promise = new WeakMap();
_resolve = new WeakMap();
_reject = new WeakMap();
_state = new WeakMap();
function isPromiseLike(value) {
  return typeof value === "object" && value !== null && "then" in value;
}
function advance(iterator2, next) {
  while (true) {
    const { done, value } = iterator2.next(next);
    if (done) {
      return value;
    }
    if (isPromiseLike(value)) {
      return value.then((value2) => advance(iterator2, { resolved: value2 }), (error2) => advance(iterator2, { error: error2 }));
    }
    next = value;
  }
}
// @__NO_SIDE_EFFECTS__
function bipedal(fn, bindThis) {
  function result(...args) {
    const iterator2 = fn.call(this, function* (value) {
      if (isPromiseLike(value)) {
        const result2 = yield value;
        if ("resolved" in result2) {
          return result2.resolved;
        } else {
          throw result2.error;
        }
      }
      return value;
    }, ...args);
    return advance(iterator2, void 0);
  }
  {
    return result;
  }
}
function defaultFieldSerializer(serializer) {
  return (source, context2) => {
    if ("buffer" in context2) {
      const buffer2 = serializer(source, context2);
      context2.buffer.set(buffer2, context2.index);
      return buffer2.length;
    } else {
      return serializer(source, context2);
    }
  };
}
function byobFieldSerializer(size, serializer) {
  return (source, context2) => {
    if ("buffer" in context2) {
      context2.index ?? (context2.index = 0);
      serializer(source, context2);
      return size;
    } else {
      const buffer2 = new Uint8Array(size);
      serializer(source, {
        buffer: buffer2,
        index: 0,
        littleEndian: context2.littleEndian
      });
      return buffer2;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function _field(size, type3, serialize2, deserialize, options2) {
  const field2 = {
    size,
    type: type3,
    serialize: type3 === "default" ? defaultFieldSerializer(serialize2) : byobFieldSerializer(size, serialize2),
    deserialize: /* @__PURE__ */ bipedal(deserialize),
    omitInit: options2 == null ? void 0 : options2.omitInit
  };
  if (options2 == null ? void 0 : options2.init) {
    field2.init = options2.init;
  }
  return field2;
}
const field = _field;
const EmptyUint8Array = new Uint8Array(0);
function copyMaybeDifferentLength(dest, source, index2, length) {
  if (source.length < length) {
    dest.set(source, index2);
    dest.fill(0, index2 + source.length, index2 + length);
  } else if (source.length === length) {
    dest.set(source, index2);
  } else {
    dest.set(source.subarray(0, length), index2);
  }
}
// @__NO_SIDE_EFFECTS__
function buffer(lengthOrField, converter) {
  if (typeof lengthOrField === "number") {
    let serialize2;
    let deserialize2;
    let init3;
    if (lengthOrField === 0) {
      serialize2 = () => {
      };
      if (converter) {
        deserialize2 = function* () {
          return converter.convert(EmptyUint8Array);
        };
      } else {
        deserialize2 = function* () {
          return EmptyUint8Array;
        };
      }
    } else {
      serialize2 = (value, { buffer: buffer2, index: index2 }) => copyMaybeDifferentLength(buffer2, value, index2, lengthOrField);
      if (converter) {
        deserialize2 = function* (then, reader2) {
          const array = reader2.readExactly(lengthOrField);
          return converter.convert(yield* then(array));
        };
        init3 = (value) => converter.back(value);
      } else {
        deserialize2 = function* (_then, reader2) {
          const array = reader2.readExactly(lengthOrField);
          return array;
        };
      }
    }
    return field(lengthOrField, "byob", serialize2, deserialize2, { init: init3 });
  }
  if ((typeof lengthOrField === "object" || typeof lengthOrField === "function") && "serialize" in lengthOrField) {
    let deserialize2;
    let init3;
    if (converter) {
      deserialize2 = function* (then, reader2, context2) {
        const length = yield* then(lengthOrField.deserialize(reader2, context2));
        const array = length !== 0 ? reader2.readExactly(length) : EmptyUint8Array;
        return converter.convert(yield* then(array));
      };
      init3 = (value) => converter.back(value);
    } else {
      deserialize2 = function* (then, reader2, context2) {
        const length = yield* then(lengthOrField.deserialize(reader2, context2));
        const array = length !== 0 ? reader2.readExactly(length) : EmptyUint8Array;
        return array;
      };
    }
    return field(lengthOrField.size, "default", (value, { littleEndian }) => {
      if (lengthOrField.type === "default") {
        const lengthBuffer = lengthOrField.serialize(value.length, {
          littleEndian
        });
        if (value.length === 0) {
          return lengthBuffer;
        }
        const result = new Uint8Array(lengthBuffer.length + value.length);
        result.set(lengthBuffer, 0);
        result.set(value, lengthBuffer.length);
        return result;
      } else {
        const result = new Uint8Array(lengthOrField.size + value.length);
        lengthOrField.serialize(value.length, {
          buffer: result,
          index: 0,
          littleEndian
        });
        result.set(value, lengthOrField.size);
        return result;
      }
    }, deserialize2, { init: init3 });
  }
  if (typeof lengthOrField === "string") {
    let deserialize2;
    let init3;
    if (converter) {
      deserialize2 = function* (then, reader2, { dependencies }) {
        const length = dependencies[lengthOrField];
        const array = length !== 0 ? reader2.readExactly(length) : EmptyUint8Array;
        return converter.convert(yield* then(array));
      };
      init3 = (value, dependencies) => {
        const array = converter.back(value);
        dependencies[lengthOrField] = array.length;
        return array;
      };
    } else {
      deserialize2 = function* (_then, reader2, { dependencies }) {
        const length = dependencies[lengthOrField];
        const array = length !== 0 ? reader2.readExactly(length) : EmptyUint8Array;
        return array;
      };
      init3 = (value, dependencies) => {
        const array = value;
        dependencies[lengthOrField] = array.length;
        return array;
      };
    }
    return field(0, "default", (source) => source, deserialize2, { init: init3 });
  }
  let deserialize;
  let init2;
  if (converter) {
    deserialize = function* (then, reader2, { dependencies }) {
      const rawLength = dependencies[lengthOrField.field];
      const length = lengthOrField.convert(rawLength);
      const array = length !== 0 ? reader2.readExactly(length) : EmptyUint8Array;
      return converter.convert(yield* then(array));
    };
    init2 = (value, dependencies) => {
      const array = converter.back(value);
      dependencies[lengthOrField.field] = lengthOrField.back(array.length);
      return array;
    };
  } else {
    deserialize = function* (_then, reader2, { dependencies }) {
      const rawLength = dependencies[lengthOrField.field];
      const length = lengthOrField.convert(rawLength);
      const array = length !== 0 ? reader2.readExactly(length) : EmptyUint8Array;
      return array;
    };
    init2 = (value, dependencies) => {
      const array = value;
      dependencies[lengthOrField.field] = lengthOrField.back(array.length);
      return array;
    };
  }
  return field(0, "default", (source) => source, deserialize, { init: init2 });
}
class ExactReadableEndedError extends Error {
  constructor() {
    super("ExactReadable ended");
  }
}
class StructDeserializeError extends Error {
  constructor(message) {
    super(message);
  }
}
class StructNotEnoughDataError extends StructDeserializeError {
  constructor() {
    super("The underlying readable was ended before the struct was fully deserialized");
  }
}
class StructEmptyError extends StructDeserializeError {
  constructor() {
    super("The underlying readable doesn't contain any more struct");
  }
}
// @__NO_SIDE_EFFECTS__
function struct(fields, options2) {
  const fieldList = Object.entries(fields);
  let size = 0;
  let byob = true;
  for (const [, field2] of fieldList) {
    size += field2.size;
    if (byob && field2.type !== "byob") {
      byob = false;
    }
  }
  const littleEndian = options2.littleEndian;
  const extra = options2.extra ? Object.getOwnPropertyDescriptors(options2.extra) : void 0;
  return {
    littleEndian,
    fields,
    extra: options2.extra,
    type: byob ? "byob" : "default",
    size,
    serialize(source, bufferOrContext) {
      var _a3;
      const temp = { ...source };
      for (const [key, field2] of fieldList) {
        if (key in temp && "init" in field2) {
          const result = (_a3 = field2.init) == null ? void 0 : _a3.call(field2, temp[key], temp);
          temp[key] = result;
        }
      }
      const sizes = new Array(fieldList.length);
      const buffers = new Array(fieldList.length);
      {
        const context3 = { littleEndian };
        for (const [index3, [key, field2]] of fieldList.entries()) {
          if (field2.type === "byob") {
            sizes[index3] = field2.size;
          } else {
            buffers[index3] = field2.serialize(temp[key], context3);
            sizes[index3] = buffers[index3].length;
          }
        }
      }
      const size2 = sizes.reduce((sum, size3) => sum + size3, 0);
      let externalBuffer;
      let buffer2;
      let index2;
      if (bufferOrContext instanceof Uint8Array) {
        if (bufferOrContext.length < size2) {
          throw new Error("Buffer too small");
        }
        externalBuffer = true;
        buffer2 = bufferOrContext;
        index2 = 0;
      } else if (typeof bufferOrContext === "object" && "buffer" in bufferOrContext) {
        externalBuffer = true;
        buffer2 = bufferOrContext.buffer;
        index2 = bufferOrContext.index ?? 0;
        if (buffer2.length - index2 < size2) {
          throw new Error("Buffer too small");
        }
      } else {
        externalBuffer = false;
        buffer2 = new Uint8Array(size2);
        index2 = 0;
      }
      const context2 = {
        buffer: buffer2,
        index: index2,
        littleEndian
      };
      for (const [index3, [key, field2]] of fieldList.entries()) {
        if (buffers[index3]) {
          buffer2.set(buffers[index3], context2.index);
        } else {
          field2.serialize(temp[key], context2);
        }
        context2.index += sizes[index3];
      }
      if (externalBuffer) {
        return size2;
      } else {
        return buffer2;
      }
    },
    deserialize: /* @__PURE__ */ bipedal(function* (then, reader2) {
      const startPosition = reader2.position;
      const result = {};
      const context2 = {
        dependencies: result,
        littleEndian
      };
      try {
        for (const [key, field2] of fieldList) {
          result[key] = yield* then(field2.deserialize(reader2, context2));
        }
      } catch (e) {
        if (!(e instanceof ExactReadableEndedError)) {
          throw e;
        }
        if (reader2.position === startPosition) {
          throw new StructEmptyError();
        } else {
          throw new StructNotEnoughDataError();
        }
      }
      if (extra) {
        Object.defineProperties(result, extra);
      }
      if (options2.postDeserialize) {
        return options2.postDeserialize.call(result, result);
      } else {
        return result;
      }
    })
  };
}
// @__NO_SIDE_EFFECTS__
function extend2(base, fields, options2) {
  return /* @__PURE__ */ struct(Object.assign({}, base.fields, fields), {
    littleEndian: base.littleEndian,
    extra: base.extra,
    postDeserialize: options2 == null ? void 0 : options2.postDeserialize
  });
}
// @__NO_SIDE_EFFECTS__
function getInt16(buffer2, offset, littleEndian) {
  return littleEndian ? (buffer2[offset] | buffer2[offset + 1] << 8) << 16 >> 16 : (buffer2[offset] << 8 | buffer2[offset + 1]) << 16 >> 16;
}
function setInt16(buffer2, offset, value, littleEndian) {
  if (littleEndian) {
    buffer2[offset] = value;
    buffer2[offset + 1] = value >> 8;
  } else {
    buffer2[offset] = value >> 8;
    buffer2[offset + 1] = value;
  }
}
// @__NO_SIDE_EFFECTS__
function getUint16(buffer2, offset, littleEndian) {
  return littleEndian ? buffer2[offset] | buffer2[offset + 1] << 8 : buffer2[offset + 1] | buffer2[offset] << 8;
}
function setUint16(buffer2, offset, value, littleEndian) {
  if (littleEndian) {
    buffer2[offset] = value;
    buffer2[offset + 1] = value >> 8;
  } else {
    buffer2[offset] = value >> 8;
    buffer2[offset + 1] = value;
  }
}
// @__NO_SIDE_EFFECTS__
function getUint32BigEndian(buffer2, offset) {
  return (buffer2[offset] << 24 | buffer2[offset + 1] << 16 | buffer2[offset + 2] << 8 | buffer2[offset + 3]) >>> 0;
}
// @__NO_SIDE_EFFECTS__
function getUint32(buffer2, offset, littleEndian) {
  return littleEndian ? (buffer2[offset] | buffer2[offset + 1] << 8 | buffer2[offset + 2] << 16 | buffer2[offset + 3] << 24) >>> 0 : (buffer2[offset] << 24 | buffer2[offset + 1] << 16 | buffer2[offset + 2] << 8 | buffer2[offset + 3]) >>> 0;
}
function setUint32(buffer2, offset, value, littleEndian) {
  if (littleEndian) {
    buffer2[offset] = value;
    buffer2[offset + 1] = value >> 8;
    buffer2[offset + 2] = value >> 16;
    buffer2[offset + 3] = value >> 24;
  } else {
    buffer2[offset] = value >> 24;
    buffer2[offset + 1] = value >> 16;
    buffer2[offset + 2] = value >> 8;
    buffer2[offset + 3] = value;
  }
}
function getUint64(buffer2, offset, littleEndian) {
  return littleEndian ? BigInt(buffer2[offset]) | BigInt(buffer2[offset + 1]) << 8n | BigInt(buffer2[offset + 2]) << 16n | BigInt(buffer2[offset + 3]) << 24n | BigInt(buffer2[offset + 4]) << 32n | BigInt(buffer2[offset + 5]) << 40n | BigInt(buffer2[offset + 6]) << 48n | BigInt(buffer2[offset + 7]) << 56n : BigInt(buffer2[offset]) << 56n | BigInt(buffer2[offset + 1]) << 48n | BigInt(buffer2[offset + 2]) << 40n | BigInt(buffer2[offset + 3]) << 32n | BigInt(buffer2[offset + 4]) << 24n | BigInt(buffer2[offset + 5]) << 16n | BigInt(buffer2[offset + 6]) << 8n | BigInt(buffer2[offset + 7]);
}
function setUint64(buffer2, offset, value, littleEndian) {
  if (littleEndian) {
    buffer2[offset] = Number(value & 0xffn);
    buffer2[offset + 1] = Number(value >> 8n & 0xffn);
    buffer2[offset + 2] = Number(value >> 16n & 0xffn);
    buffer2[offset + 3] = Number(value >> 24n & 0xffn);
    buffer2[offset + 4] = Number(value >> 32n & 0xffn);
    buffer2[offset + 5] = Number(value >> 40n & 0xffn);
    buffer2[offset + 6] = Number(value >> 48n & 0xffn);
    buffer2[offset + 7] = Number(value >> 56n & 0xffn);
  } else {
    buffer2[offset] = Number(value >> 56n & 0xffn);
    buffer2[offset + 1] = Number(value >> 48n & 0xffn);
    buffer2[offset + 2] = Number(value >> 40n & 0xffn);
    buffer2[offset + 3] = Number(value >> 32n & 0xffn);
    buffer2[offset + 4] = Number(value >> 24n & 0xffn);
    buffer2[offset + 5] = Number(value >> 16n & 0xffn);
    buffer2[offset + 6] = Number(value >> 8n & 0xffn);
    buffer2[offset + 7] = Number(value & 0xffn);
  }
}
// @__NO_SIDE_EFFECTS__
function number(size, serialize2, deserialize) {
  const fn = () => fn;
  Object.assign(fn, field(size, "byob", serialize2, deserialize));
  return fn;
}
const u8 = /* @__PURE__ */ number(1, (value, { buffer: buffer2, index: index2 }) => {
  buffer2[index2] = value;
}, function* (then, reader2) {
  const data = yield* then(reader2.readExactly(1));
  return data[0];
});
const u16 = /* @__PURE__ */ number(2, (value, { buffer: buffer2, index: index2, littleEndian }) => {
  setUint16(buffer2, index2, value, littleEndian);
}, function* (then, reader2, { littleEndian }) {
  const data = yield* then(reader2.readExactly(2));
  return /* @__PURE__ */ getUint16(data, 0, littleEndian);
});
const u32 = /* @__PURE__ */ number(4, (value, { buffer: buffer2, index: index2, littleEndian }) => {
  setUint32(buffer2, index2, value, littleEndian);
}, function* (then, reader2, { littleEndian }) {
  const data = yield* then(reader2.readExactly(4));
  return /* @__PURE__ */ getUint32(data, 0, littleEndian);
});
const u64 = /* @__PURE__ */ number(8, (value, { buffer: buffer2, index: index2, littleEndian }) => {
  setUint64(buffer2, index2, value, littleEndian);
}, function* (then, reader2, { littleEndian }) {
  const data = yield* then(reader2.readExactly(8));
  return getUint64(data, 0, littleEndian);
});
const { TextEncoder: TextEncoder$1, TextDecoder: TextDecoder$1 } = globalThis;
const SharedEncoder = /* @__PURE__ */ new TextEncoder$1();
const SharedDecoder = /* @__PURE__ */ new TextDecoder$1();
// @__NO_SIDE_EFFECTS__
function encodeUtf8(input) {
  return SharedEncoder.encode(input);
}
// @__NO_SIDE_EFFECTS__
function decodeUtf8(buffer2) {
  return SharedDecoder.decode(buffer2);
}
const string = /* @__NO_SIDE_EFFECTS__ */ (lengthOrField) => {
  const field2 = /* @__PURE__ */ buffer(lengthOrField, {
    convert: decodeUtf8,
    back: encodeUtf8
  });
  field2.as = () => field2;
  return field2;
};
const EmptyControlMessage = /* @__PURE__ */ struct({ type: u8 }, { littleEndian: false });
const ScrcpyInjectKeyCodeControlMessage = /* @__PURE__ */ (() => /* @__PURE__ */ struct({
  type: u8(ScrcpyControlMessageType.InjectKeyCode),
  action: u8(),
  keyCode: u32(),
  repeat: u32,
  metaState: u32()
}, { littleEndian: false }))();
const ScrcpyInjectTextControlMessage = /* @__PURE__ */ struct({ type: u8, text: /* @__PURE__ */ string(u32) }, { littleEndian: false });
class ScrcpyControlMessageTypeMap {
  constructor(options2) {
    __privateAdd(this, _types);
    __privateSet(this, _types, options2.controlMessageTypes);
  }
  get(type3) {
    const value = __privateGet(this, _types).indexOf(type3);
    if (value === -1) {
      throw new TypeError("Invalid or unsupported control message type");
    }
    return value;
  }
  fillMessageType(message, type3) {
    message.type = this.get(type3);
    return message;
  }
}
_types = new WeakMap();
const ScrcpySetDisplayPowerControlMessage = /* @__PURE__ */ struct({ type: u8, mode: u8() }, { littleEndian: false });
const ScrcpyStartAppControlMessage = /* @__PURE__ */ struct({
  type: u8,
  name: /* @__PURE__ */ string(u8)
}, { littleEndian: false });
const ScrcpyUHidInputControlMessage = /* @__PURE__ */ (() => /* @__PURE__ */ struct({
  type: u8(ScrcpyControlMessageType.UHidInput),
  id: u16,
  data: /* @__PURE__ */ buffer(u16)
}, { littleEndian: false }))();
const ScrcpyUHidDestroyControlMessage = /* @__PURE__ */ struct({ type: u8, id: u16 }, { littleEndian: false });
class ScrcpyControlMessageSerializer {
  constructor(options2) {
    __privateAdd(this, _options2);
    __privateAdd(this, _typeMap);
    __privateAdd(this, _scrollController);
    __privateSet(this, _options2, options2);
    __privateSet(this, _typeMap, new ScrcpyControlMessageTypeMap(options2));
    __privateSet(this, _scrollController, options2.createScrollController());
  }
  injectKeyCode(message) {
    return ScrcpyInjectKeyCodeControlMessage.serialize(__privateGet(this, _typeMap).fillMessageType(message, ScrcpyControlMessageType.InjectKeyCode));
  }
  injectText(text) {
    return ScrcpyInjectTextControlMessage.serialize({
      text,
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.InjectText)
    });
  }
  /**
   * `pressure` is a float value between 0 and 1.
   */
  injectTouch(message) {
    return __privateGet(this, _options2).serializeInjectTouchControlMessage(__privateGet(this, _typeMap).fillMessageType(message, ScrcpyControlMessageType.InjectTouch));
  }
  /**
   * `scrollX` and `scrollY` are float values between 0 and 1.
   */
  injectScroll(message) {
    return __privateGet(this, _scrollController).serializeScrollMessage(__privateGet(this, _typeMap).fillMessageType(message, ScrcpyControlMessageType.InjectScroll));
  }
  backOrScreenOn(action) {
    return __privateGet(this, _options2).serializeBackOrScreenOnControlMessage({
      action,
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.BackOrScreenOn)
    });
  }
  setDisplayPower(mode) {
    return ScrcpySetDisplayPowerControlMessage.serialize({
      mode,
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.SetDisplayPower)
    });
  }
  expandNotificationPanel() {
    return EmptyControlMessage.serialize({
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.ExpandNotificationPanel)
    });
  }
  expandSettingPanel() {
    return EmptyControlMessage.serialize({
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.ExpandSettingPanel)
    });
  }
  collapseNotificationPanel() {
    return EmptyControlMessage.serialize({
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.CollapseNotificationPanel)
    });
  }
  rotateDevice() {
    return EmptyControlMessage.serialize({
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.RotateDevice)
    });
  }
  setClipboard(message) {
    return __privateGet(this, _options2).serializeSetClipboardControlMessage({
      ...message,
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.SetClipboard)
    });
  }
  uHidCreate(message) {
    if (!__privateGet(this, _options2).serializeUHidCreateControlMessage) {
      throw new Error("UHid not supported");
    }
    return __privateGet(this, _options2).serializeUHidCreateControlMessage(__privateGet(this, _typeMap).fillMessageType(message, ScrcpyControlMessageType.UHidCreate));
  }
  uHidInput(message) {
    return ScrcpyUHidInputControlMessage.serialize(__privateGet(this, _typeMap).fillMessageType(message, ScrcpyControlMessageType.UHidInput));
  }
  uHidDestroy(id) {
    return ScrcpyUHidDestroyControlMessage.serialize({
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.UHidDestroy),
      id
    });
  }
  startApp(name, options2) {
    if (options2 == null ? void 0 : options2.searchByName) {
      name = "?" + name;
    }
    if (options2 == null ? void 0 : options2.forceStop) {
      name = "+" + name;
    }
    return ScrcpyStartAppControlMessage.serialize({
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.StartApp),
      name
    });
  }
  resetVideo() {
    return EmptyControlMessage.serialize({
      type: __privateGet(this, _typeMap).get(ScrcpyControlMessageType.ResetVideo)
    });
  }
}
_options2 = new WeakMap();
_typeMap = new WeakMap();
_scrollController = new WeakMap();
const { AbortController: AbortController$1 } = globalThis;
const ReadableStream = /* @__PURE__ */ (() => {
  const { ReadableStream: ReadableStream2 } = globalThis;
  if (!ReadableStream2.from) {
    ReadableStream2.from = function(iterable) {
      const iterator2 = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
      return new ReadableStream2({
        async pull(controller) {
          const result = await iterator2.next();
          if (result.done) {
            controller.close();
            return;
          }
          controller.enqueue(result.value);
        },
        async cancel(reason) {
          var _a3;
          await ((_a3 = iterator2.return) == null ? void 0 : _a3.call(iterator2, reason));
        }
      });
    };
  }
  if (!ReadableStream2.prototype[Symbol.asyncIterator] || !ReadableStream2.prototype.values) {
    ReadableStream2.prototype.values = async function* (options2) {
      const reader2 = this.getReader();
      try {
        while (true) {
          const { done, value } = await reader2.read();
          if (done) {
            return;
          }
          yield value;
        }
      } finally {
        if (!(options2 == null ? void 0 : options2.preventCancel)) {
          await reader2.cancel();
        }
        reader2.releaseLock();
      }
    };
    ReadableStream2.prototype[Symbol.asyncIterator] = // eslint-disable-next-line @typescript-eslint/unbound-method
    ReadableStream2.prototype.values;
  }
  return ReadableStream2;
})();
const { WritableStream, TransformStream } = globalThis;
class PushReadableStream extends ReadableStream {
  /**
   * Create a new `PushReadableStream` from a source.
   *
   * @param source If `source` returns a `Promise`, the stream will be closed
   * when the `Promise` is resolved, and be errored when the `Promise` is rejected.
   * @param strategy
   */
  constructor(source, strategy, logger) {
    let waterMarkLow;
    let zeroHighWaterMarkAllowEnqueue = false;
    const abortController = new AbortController$1();
    super({
      start: (controller) => {
        const result = source({
          abortSignal: abortController.signal,
          enqueue: async (chunk) => {
            logger == null ? void 0 : logger({
              source: "producer",
              operation: "enqueue",
              value: chunk,
              phase: "start"
            });
            if (abortController.signal.aborted) {
              logger == null ? void 0 : logger({
                source: "producer",
                operation: "enqueue",
                value: chunk,
                phase: "ignored"
              });
              return;
            }
            if (controller.desiredSize === null) {
              controller.enqueue(chunk);
              return;
            }
            if (zeroHighWaterMarkAllowEnqueue) {
              zeroHighWaterMarkAllowEnqueue = false;
              controller.enqueue(chunk);
              logger == null ? void 0 : logger({
                source: "producer",
                operation: "enqueue",
                value: chunk,
                phase: "complete"
              });
              return;
            }
            if (controller.desiredSize <= 0) {
              logger == null ? void 0 : logger({
                source: "producer",
                operation: "enqueue",
                value: chunk,
                phase: "waiting"
              });
              waterMarkLow = new PromiseResolver();
              await waterMarkLow.promise;
              if (abortController.signal.aborted) {
                logger == null ? void 0 : logger({
                  source: "producer",
                  operation: "enqueue",
                  value: chunk,
                  phase: "ignored"
                });
                return;
              }
            }
            controller.enqueue(chunk);
            logger == null ? void 0 : logger({
              source: "producer",
              operation: "enqueue",
              value: chunk,
              phase: "complete"
            });
          },
          close() {
            logger == null ? void 0 : logger({
              source: "producer",
              operation: "close",
              explicit: true,
              phase: "start"
            });
            if (abortController.signal.aborted) {
              logger == null ? void 0 : logger({
                source: "producer",
                operation: "close",
                explicit: true,
                phase: "ignored"
              });
              return;
            }
            controller.close();
            logger == null ? void 0 : logger({
              source: "producer",
              operation: "close",
              explicit: true,
              phase: "complete"
            });
          },
          error(e) {
            logger == null ? void 0 : logger({
              source: "producer",
              operation: "error",
              explicit: true,
              phase: "start"
            });
            controller.error(e);
            logger == null ? void 0 : logger({
              source: "producer",
              operation: "error",
              explicit: true,
              phase: "complete"
            });
          }
        });
        if (result && "then" in result) {
          result.then(() => {
            logger == null ? void 0 : logger({
              source: "producer",
              operation: "close",
              explicit: false,
              phase: "start"
            });
            try {
              controller.close();
              logger == null ? void 0 : logger({
                source: "producer",
                operation: "close",
                explicit: false,
                phase: "complete"
              });
            } catch {
              logger == null ? void 0 : logger({
                source: "producer",
                operation: "close",
                explicit: false,
                phase: "ignored"
              });
            }
          }, (e) => {
            logger == null ? void 0 : logger({
              source: "producer",
              operation: "error",
              explicit: false,
              phase: "start"
            });
            controller.error(e);
            logger == null ? void 0 : logger({
              source: "producer",
              operation: "error",
              explicit: false,
              phase: "complete"
            });
          });
        }
      },
      pull: () => {
        logger == null ? void 0 : logger({
          source: "consumer",
          operation: "pull",
          phase: "start"
        });
        if (waterMarkLow) {
          waterMarkLow.resolve();
        } else if ((strategy == null ? void 0 : strategy.highWaterMark) === 0) {
          zeroHighWaterMarkAllowEnqueue = true;
        }
        logger == null ? void 0 : logger({
          source: "consumer",
          operation: "pull",
          phase: "complete"
        });
      },
      cancel: (reason) => {
        logger == null ? void 0 : logger({
          source: "consumer",
          operation: "cancel",
          phase: "start"
        });
        abortController.abort(reason);
        waterMarkLow == null ? void 0 : waterMarkLow.resolve();
        logger == null ? void 0 : logger({
          source: "consumer",
          operation: "cancel",
          phase: "complete"
        });
      }
    }, strategy);
  }
}
async function tryCancel(stream2) {
  try {
    await stream2.cancel();
    return true;
  } catch {
    return false;
  }
}
class BufferedReadableStream {
  constructor(stream2) {
    __privateAdd(this, _BufferedReadableStream_instances);
    __privateAdd(this, _buffered);
    // PERF: `subarray` is slow
    // don't use it until absolutely necessary
    __privateAdd(this, _bufferedOffset, 0);
    __privateAdd(this, _bufferedLength, 0);
    __privateAdd(this, _position, 0);
    __publicField(this, "stream");
    __publicField(this, "reader");
    __publicField(this, "readExactly", /* @__PURE__ */ bipedal(function* (then, length) {
      let result;
      let index2 = 0;
      const initial = __privateMethod(this, _BufferedReadableStream_instances, readBuffered_fn).call(this, length);
      if (initial) {
        if (initial.length === length) {
          return initial;
        }
        result = new Uint8Array(length);
        result.set(initial, index2);
        index2 += initial.length;
        length -= initial.length;
      } else {
        result = new Uint8Array(length);
      }
      while (length > 0) {
        const value = yield* then(__privateMethod(this, _BufferedReadableStream_instances, readSource_fn).call(this, length));
        result.set(value, index2);
        index2 += value.length;
        length -= value.length;
      }
      return result;
    }));
    this.stream = stream2;
    this.reader = stream2.getReader();
  }
  get position() {
    return __privateGet(this, _position);
  }
  iterateExactly(length) {
    let state = __privateGet(this, _buffered) ? 0 : 1;
    return {
      next: () => {
        switch (state) {
          case 0: {
            const value = __privateMethod(this, _BufferedReadableStream_instances, readBuffered_fn).call(this, length);
            if (value.length === length) {
              state = 2;
            } else {
              length -= value.length;
              state = 1;
            }
            return { done: false, value };
          }
          case 1:
            state = 3;
            return {
              done: false,
              value: __privateMethod(this, _BufferedReadableStream_instances, readSource_fn).call(this, length).then((value) => {
                if (value.length === length) {
                  state = 2;
                } else {
                  length -= value.length;
                  state = 1;
                }
                return value;
              })
            };
          case 2:
            return { done: true, value: void 0 };
          case 3:
            throw new Error("Can't call `next` before previous Promise resolves");
          default:
            throw new Error("unreachable");
        }
      }
    };
  }
  /**
   * Return a readable stream with unconsumed data (if any) and
   * all data from the wrapped stream.
   * @returns A `ReadableStream`
   */
  release() {
    if (__privateGet(this, _bufferedLength) > 0) {
      return new PushReadableStream(async (controller) => {
        const buffered = __privateGet(this, _buffered).subarray(__privateGet(this, _bufferedOffset));
        await controller.enqueue(buffered);
        controller.abortSignal.addEventListener("abort", () => {
          void tryCancel(this.reader);
        });
        while (true) {
          const { done, value } = await this.reader.read();
          if (done) {
            return;
          }
          await controller.enqueue(value);
        }
      });
    } else {
      this.reader.releaseLock();
      return this.stream;
    }
  }
  async cancel(reason) {
    await this.reader.cancel(reason);
  }
}
_buffered = new WeakMap();
_bufferedOffset = new WeakMap();
_bufferedLength = new WeakMap();
_position = new WeakMap();
_BufferedReadableStream_instances = new WeakSet();
readBuffered_fn = function(length) {
  if (!__privateGet(this, _buffered)) {
    return void 0;
  }
  const value = __privateGet(this, _buffered).subarray(__privateGet(this, _bufferedOffset), __privateGet(this, _bufferedOffset) + length);
  if (__privateGet(this, _bufferedLength) > length) {
    __privateSet(this, _position, __privateGet(this, _position) + length);
    __privateSet(this, _bufferedOffset, __privateGet(this, _bufferedOffset) + length);
    __privateSet(this, _bufferedLength, __privateGet(this, _bufferedLength) - length);
    return value;
  }
  __privateSet(this, _position, __privateGet(this, _position) + __privateGet(this, _bufferedLength));
  __privateSet(this, _buffered, void 0);
  __privateSet(this, _bufferedOffset, 0);
  __privateSet(this, _bufferedLength, 0);
  return value;
};
readSource_fn = async function(length) {
  const { done, value } = await this.reader.read();
  if (done) {
    throw new ExactReadableEndedError();
  }
  if (value.length > length) {
    __privateSet(this, _buffered, value);
    __privateSet(this, _bufferedOffset, length);
    __privateSet(this, _bufferedLength, value.length - length);
    __privateSet(this, _position, __privateGet(this, _position) + length);
    return value.subarray(0, length);
  }
  __privateSet(this, _position, __privateGet(this, _position) + value.length);
  return value;
};
class BufferedTransformStream {
  constructor(transform2) {
    __privateAdd(this, _readable);
    __privateAdd(this, _writable);
    let bufferedStreamController;
    let writableStreamController;
    const buffered = new BufferedReadableStream(new PushReadableStream((controller) => {
      bufferedStreamController = controller;
    }));
    __privateSet(this, _readable, new ReadableStream({
      async pull(controller) {
        try {
          const value = await transform2(buffered);
          controller.enqueue(value);
        } catch (e) {
          if (e instanceof StructEmptyError) {
            controller.close();
            return;
          }
          throw e;
        }
      },
      cancel: (reason) => {
        return writableStreamController.error(reason);
      }
    }));
    __privateSet(this, _writable, new WritableStream({
      start(controller) {
        writableStreamController = controller;
      },
      async write(chunk) {
        await bufferedStreamController.enqueue(chunk);
      },
      abort() {
        bufferedStreamController.close();
      },
      close() {
        bufferedStreamController.close();
      }
    }));
  }
  get readable() {
    return __privateGet(this, _readable);
  }
  get writable() {
    return __privateGet(this, _writable);
  }
}
_readable = new WeakMap();
_writable = new WeakMap();
class ConsumableReadableStream extends ReadableStream {
  static async enqueue(controller, chunk) {
    const output = new Consumable(chunk);
    controller.enqueue(output);
    await output.consumed;
  }
  constructor(source, strategy) {
    let wrappedController;
    let wrappedStrategy;
    if (strategy) {
      wrappedStrategy = {};
      if ("highWaterMark" in strategy) {
        wrappedStrategy.highWaterMark = strategy.highWaterMark;
      }
      if ("size" in strategy) {
        wrappedStrategy.size = (chunk) => {
          return strategy.size(chunk.value);
        };
      }
    }
    super({
      start(controller) {
        var _a3;
        wrappedController = {
          enqueue(chunk) {
            return ConsumableReadableStream.enqueue(controller, chunk);
          },
          close() {
            controller.close();
          },
          error(reason) {
            controller.error(reason);
          }
        };
        return (_a3 = source.start) == null ? void 0 : _a3.call(source, wrappedController);
      },
      pull() {
        var _a3;
        return (_a3 = source.pull) == null ? void 0 : _a3.call(source, wrappedController);
      },
      cancel(reason) {
        var _a3;
        return (_a3 = source.cancel) == null ? void 0 : _a3.call(source, reason);
      }
    }, wrappedStrategy);
  }
}
class ConsumableWrapByteReadableStream extends ReadableStream {
  constructor(stream2, chunkSize, min2) {
    const reader2 = stream2.getReader({ mode: "byob" });
    let array = new Uint8Array(chunkSize);
    super({
      async pull(controller) {
        const { done, value } = await reader2.read(array, { min: min2 });
        if (done) {
          controller.close();
          return;
        }
        await ConsumableReadableStream.enqueue(controller, value);
        array = new Uint8Array(value.buffer);
      },
      cancel(reason) {
        return reader2.cancel(reason);
      }
    });
  }
}
class ConsumableWrapWritableStream extends WritableStream {
  constructor(stream2) {
    const writer = stream2.getWriter();
    super({
      write(chunk) {
        return chunk.tryConsume((chunk2) => writer.write(chunk2));
      },
      abort(reason) {
        return writer.abort(reason);
      },
      close() {
        return writer.close();
      }
    });
  }
}
class ConsumableWritableStream extends WritableStream {
  static async write(writer, value) {
    const consumable = new Consumable(value);
    await writer.write(consumable);
    await consumable.consumed;
  }
  constructor(sink, strategy) {
    let wrappedStrategy;
    if (strategy) {
      wrappedStrategy = {};
      if ("highWaterMark" in strategy) {
        wrappedStrategy.highWaterMark = strategy.highWaterMark;
      }
      if ("size" in strategy) {
        wrappedStrategy.size = (chunk) => {
          return strategy.size(chunk instanceof Consumable ? chunk.value : chunk);
        };
      }
    }
    super({
      start(controller) {
        var _a3;
        return (_a3 = sink.start) == null ? void 0 : _a3.call(sink, controller);
      },
      write(chunk, controller) {
        return chunk.tryConsume((chunk2) => {
          var _a3;
          return (_a3 = sink.write) == null ? void 0 : _a3.call(sink, chunk2, controller);
        });
      },
      abort(reason) {
        var _a3;
        return (_a3 = sink.abort) == null ? void 0 : _a3.call(sink, reason);
      },
      close() {
        var _a3;
        return (_a3 = sink.close) == null ? void 0 : _a3.call(sink);
      }
    }, wrappedStrategy);
  }
}
const { console: console$1 } = globalThis;
const createTask = /* @__PURE__ */ (() => {
  var _a3;
  return ((_a3 = console$1 == null ? void 0 : console$1.createTask) == null ? void 0 : _a3.bind(console$1)) ?? (() => ({
    run(callback) {
      return callback();
    }
  }));
})();
class Consumable {
  constructor(value) {
    __privateAdd(this, _task);
    __privateAdd(this, _resolver);
    __publicField(this, "value");
    __publicField(this, "consumed");
    __privateSet(this, _task, createTask("Consumable"));
    this.value = value;
    __privateSet(this, _resolver, new PromiseResolver());
    this.consumed = __privateGet(this, _resolver).promise;
  }
  consume() {
    __privateGet(this, _resolver).resolve();
  }
  error(error2) {
    __privateGet(this, _resolver).reject(error2);
  }
  tryConsume(callback) {
    try {
      let result = __privateGet(this, _task).run(() => callback(this.value));
      if (isPromiseLike(result)) {
        result = result.then((value) => {
          __privateGet(this, _resolver).resolve();
          return value;
        }, (e) => {
          __privateGet(this, _resolver).reject(e);
          throw e;
        });
      } else {
        __privateGet(this, _resolver).resolve();
      }
      return result;
    } catch (e) {
      __privateGet(this, _resolver).reject(e);
      throw e;
    }
  }
}
_task = new WeakMap();
_resolver = new WeakMap();
__publicField(Consumable, "WritableStream", ConsumableWritableStream);
__publicField(Consumable, "WrapWritableStream", ConsumableWrapWritableStream);
__publicField(Consumable, "ReadableStream", ConsumableReadableStream);
__publicField(Consumable, "WrapByteReadableStream", ConsumableWrapByteReadableStream);
class StructDeserializeStream extends BufferedTransformStream {
  constructor(struct2) {
    super((stream2) => {
      return struct2.deserialize(stream2);
    });
  }
}
class ScrcpyControlMessageWriter {
  constructor(writer, options2) {
    __privateAdd(this, _writer);
    __privateAdd(this, _serializer);
    __privateSet(this, _writer, writer);
    __privateSet(this, _serializer, new ScrcpyControlMessageSerializer(options2));
  }
  write(message) {
    return Consumable.WritableStream.write(__privateGet(this, _writer), message);
  }
  injectKeyCode(message) {
    return this.write(__privateGet(this, _serializer).injectKeyCode(message));
  }
  injectText(text) {
    return this.write(__privateGet(this, _serializer).injectText(text));
  }
  /**
   * `pressure` is a float value between 0 and 1.
   */
  injectTouch(message) {
    return this.write(__privateGet(this, _serializer).injectTouch(message));
  }
  /**
   * `scrollX` and `scrollY` are float values between 0 and 1.
   */
  async injectScroll(message) {
    const data = __privateGet(this, _serializer).injectScroll(message);
    if (data) {
      await this.write(data);
    }
  }
  async backOrScreenOn(action) {
    const data = __privateGet(this, _serializer).backOrScreenOn(action);
    if (data) {
      await this.write(data);
    }
  }
  setScreenPowerMode(mode) {
    return this.write(__privateGet(this, _serializer).setDisplayPower(mode));
  }
  expandNotificationPanel() {
    return this.write(__privateGet(this, _serializer).expandNotificationPanel());
  }
  expandSettingPanel() {
    return this.write(__privateGet(this, _serializer).expandSettingPanel());
  }
  collapseNotificationPanel() {
    return this.write(__privateGet(this, _serializer).collapseNotificationPanel());
  }
  rotateDevice() {
    return this.write(__privateGet(this, _serializer).rotateDevice());
  }
  async setClipboard(message) {
    const result = __privateGet(this, _serializer).setClipboard(message);
    if (result instanceof Uint8Array) {
      await this.write(result);
    } else {
      await this.write(result[0]);
      await result[1];
    }
  }
  uHidCreate(message) {
    return this.write(__privateGet(this, _serializer).uHidCreate(message));
  }
  uHidInput(message) {
    return this.write(__privateGet(this, _serializer).uHidInput(message));
  }
  uHidDestroy(id) {
    return this.write(__privateGet(this, _serializer).uHidDestroy(id));
  }
  startApp(name, options2) {
    return this.write(__privateGet(this, _serializer).startApp(name, options2));
  }
  resetVideo() {
    return this.write(__privateGet(this, _serializer).resetVideo());
  }
  releaseLock() {
    __privateGet(this, _writer).releaseLock();
  }
  async close() {
    await __privateGet(this, _writer).close();
  }
}
_writer = new WeakMap();
_serializer = new WeakMap();
const BackOrScreenOnControlMessage$1 = EmptyControlMessage;
const ClipboardDeviceMessage = /* @__PURE__ */ struct({ content: /* @__PURE__ */ string(u32) }, { littleEndian: false });
class ClipboardStream extends PushReadableStream {
  constructor() {
    let controller;
    super((controller_) => {
      controller = controller_;
    });
    __privateAdd(this, _controller);
    __publicField(this, "id", 0);
    __privateSet(this, _controller, controller);
  }
  async parse(_id, stream2) {
    const message = await ClipboardDeviceMessage.deserialize(stream2);
    await __privateGet(this, _controller).enqueue(message.content);
  }
  close() {
    __privateGet(this, _controller).close();
  }
  error(e) {
    __privateGet(this, _controller).error(e);
  }
}
_controller = new WeakMap();
const ControlMessageTypes$4 = /* @__PURE__ */ (() => [
  /*  0 */
  ScrcpyControlMessageType.InjectKeyCode,
  /*  1 */
  ScrcpyControlMessageType.InjectText,
  /*  2 */
  ScrcpyControlMessageType.InjectTouch,
  /*  3 */
  ScrcpyControlMessageType.InjectScroll,
  /*  4 */
  ScrcpyControlMessageType.BackOrScreenOn,
  /*  5 */
  ScrcpyControlMessageType.ExpandNotificationPanel,
  /*  6 */
  ScrcpyControlMessageType.CollapseNotificationPanel,
  /*  7 */
  ScrcpyControlMessageType.GetClipboard,
  /*  8 */
  ScrcpyControlMessageType.SetClipboard,
  /*  9 */
  ScrcpyControlMessageType.SetDisplayPower,
  /* 10 */
  ScrcpyControlMessageType.RotateDevice
])();
const VideoOrientation$1 = {
  Unlocked: -1
};
const Defaults$c = {
  logLevel: "debug",
  maxSize: 0,
  bitRate: 8e6,
  maxFps: 0,
  lockVideoOrientation: VideoOrientation$1.Unlocked,
  tunnelForward: false,
  crop: void 0,
  sendFrameMeta: true,
  control: true,
  displayId: 0,
  showTouches: false,
  stayAwake: false,
  codecOptions: void 0
};
function clamp(value, min2, max2) {
  if (value < min2) {
    return min2;
  }
  if (value > max2) {
    return max2;
  }
  return value;
}
// @__NO_SIDE_EFFECTS__
function omit(value, ...keys) {
  return Object.fromEntries(Object.entries(value).filter(([key]) => !keys.includes(key)));
}
const UnsignedFloat = field(2, "byob", (source, { buffer: buffer2, index: index2, littleEndian }) => {
  source = clamp(source, -1, 1);
  source = source === 1 ? 65535 : source * 65536;
  setUint16(buffer2, index2, source, littleEndian);
}, function* (then, reader2, { littleEndian }) {
  const data = yield* then(reader2.readExactly(2));
  const value = /* @__PURE__ */ getUint16(data, 0, littleEndian);
  return value === 65535 ? 1 : value / 65536;
});
const MediaStreamRawPacket = /* @__PURE__ */ struct({ pts: u64, data: /* @__PURE__ */ buffer(u32) }, { littleEndian: false });
const PtsConfig = 1n << 63n;
async function readString(stream2, maxLength) {
  const buffer2 = await stream2.readExactly(maxLength);
  return /* @__PURE__ */ decodeUtf8(buffer2.subarray(0, buffer2.indexOf(0)));
}
async function readU32(stream2) {
  const buffer2 = await stream2.readExactly(4);
  return /* @__PURE__ */ getUint32BigEndian(buffer2, 0);
}
const Defaults$b = /* @__PURE__ */ (() => ({
  ...Defaults$c,
  encoderName: void 0
}))();
const BackOrScreenOnControlMessage = /* @__PURE__ */ extend2(BackOrScreenOnControlMessage$1, { action: u8() });
function serializeBackOrScreenOnControlMessage(message) {
  return BackOrScreenOnControlMessage.serialize(message);
}
const ControlMessageTypes$3 = /* @__PURE__ */ (() => {
  const result = ControlMessageTypes$4.slice();
  result.splice(6, 0, ScrcpyControlMessageType.ExpandSettingPanel);
  return result;
})();
const VideoOrientation = {
  Unlocked: -1
};
const Defaults$a = /* @__PURE__ */ (() => ({
  ...Defaults$b,
  logLevel: "debug",
  lockVideoOrientation: VideoOrientation.Unlocked,
  powerOffOnClose: false
}))();
const Defaults$9 = /* @__PURE__ */ (() => ({
  ...Defaults$a,
  clipboardAutosync: true
}))();
function toSnakeCase(input) {
  return input.replace(/([A-Z])/g, "_$1").toLowerCase();
}
function serialize(options2, defaults2) {
  const result = [];
  for (const [key, value] of Object.entries(options2)) {
    const serializedValue = toScrcpyOptionValue(value, void 0);
    if (serializedValue === void 0) {
      continue;
    }
    const defaultValue = toScrcpyOptionValue(defaults2[key], void 0);
    if (serializedValue === defaultValue) {
      continue;
    }
    result.push(`${toSnakeCase(key)}=${serializedValue}`);
  }
  return result;
}
const AckClipboardDeviceMessage = /* @__PURE__ */ struct({ sequence: u64 }, { littleEndian: false });
const SetClipboardControlMessage = /* @__PURE__ */ struct({
  type: u8,
  sequence: u64,
  paste: u8(),
  content: /* @__PURE__ */ string(u32)
}, { littleEndian: false });
class AckClipboardHandler {
  constructor() {
    __privateAdd(this, _resolvers, /* @__PURE__ */ new Map());
    __privateAdd(this, _closed, false);
    __publicField(this, "id", 1);
  }
  async parse(_id, stream2) {
    const message = await AckClipboardDeviceMessage.deserialize(stream2);
    const resolver = __privateGet(this, _resolvers).get(message.sequence);
    if (resolver) {
      resolver.resolve();
      __privateGet(this, _resolvers).delete(message.sequence);
    }
  }
  close() {
    for (const resolver of __privateGet(this, _resolvers).values()) {
      resolver.reject();
    }
    __privateGet(this, _resolvers).clear();
    __privateSet(this, _closed, true);
  }
  error(e) {
    for (const resolver of __privateGet(this, _resolvers).values()) {
      resolver.reject(e);
    }
    __privateGet(this, _resolvers).clear();
    __privateSet(this, _closed, true);
  }
  serializeSetClipboardControlMessage(message) {
    if (message.sequence === 0n) {
      return SetClipboardControlMessage.serialize(message);
    }
    if (__privateGet(this, _closed)) {
      throw new Error();
    }
    const resolver = new PromiseResolver();
    __privateGet(this, _resolvers).set(message.sequence, resolver);
    return [
      SetClipboardControlMessage.serialize(message),
      resolver.promise
    ];
  }
}
_resolvers = new WeakMap();
_closed = new WeakMap();
const Defaults$8 = /* @__PURE__ */ (() => ({
  ...Defaults$9,
  downsizeOnError: true,
  sendDeviceMeta: true,
  sendDummyByte: true
}))();
const Defaults$7 = /* @__PURE__ */ (() => ({
  ...Defaults$8,
  cleanup: true
}))();
const PtsKeyframe = 1n << 62n;
function createMediaStreamTransformer(options2) {
  if (!options2.sendFrameMeta) {
    return new TransformStream({
      transform(chunk, controller) {
        controller.enqueue({
          type: "data",
          data: chunk
        });
      }
    });
  }
  const deserializeStream = new StructDeserializeStream(MediaStreamRawPacket);
  return {
    writable: deserializeStream.writable,
    readable: deserializeStream.readable.pipeThrough(new TransformStream({
      transform(packet2, controller) {
        if (packet2.pts === PtsConfig) {
          controller.enqueue({
            type: "configuration",
            data: packet2.data
          });
          return;
        }
        if (packet2.pts & PtsKeyframe) {
          controller.enqueue({
            type: "data",
            keyframe: true,
            pts: packet2.pts & ~PtsKeyframe,
            data: packet2.data
          });
          return;
        }
        controller.enqueue({
          type: "data",
          keyframe: false,
          pts: packet2.pts,
          data: packet2.data
        });
      }
    }))
  };
}
const Defaults$6 = /* @__PURE__ */ (() => ({
  ...Defaults$7,
  powerOn: true
}))();
const SignedFloat = field(2, "byob", (value, { buffer: buffer2, index: index2, littleEndian }) => {
  value = clamp(value, -1, 1);
  value = value === 1 ? 32767 : value * 32768;
  setInt16(buffer2, index2, value, littleEndian);
}, function* (then, reader2, { littleEndian }) {
  const data = yield* then(reader2.readExactly(2));
  const value = /* @__PURE__ */ getInt16(data, 0, littleEndian);
  return value === 32767 ? 1 : value / 32768;
});
const InjectScrollControlMessage = /* @__PURE__ */ (() => /* @__PURE__ */ struct({
  type: u8(ScrcpyControlMessageType.InjectScroll),
  pointerX: u32,
  pointerY: u32,
  videoWidth: u16,
  videoHeight: u16,
  scrollX: SignedFloat,
  scrollY: SignedFloat,
  buttons: u32
}, { littleEndian: false }))();
class ScrollController {
  serializeScrollMessage(message) {
    return InjectScrollControlMessage.serialize(message);
  }
}
function createScrollController() {
  return new ScrollController();
}
const Defaults$5 = /* @__PURE__ */ (() => ({
  .../* @__PURE__ */ omit(Defaults$6, "bitRate", "codecOptions", "encoderName"),
  scid: void 0,
  videoCodec: "h264",
  videoBitRate: 8e6,
  videoCodecOptions: void 0,
  videoEncoder: void 0,
  audio: true,
  audioCodec: "opus",
  audioBitRate: 128e3,
  audioCodecOptions: void 0,
  audioEncoder: void 0,
  listEncoders: false,
  listDisplays: false,
  sendCodecMeta: true
}))();
const InjectTouchControlMessage = /* @__PURE__ */ (() => /* @__PURE__ */ struct({
  type: u8(ScrcpyControlMessageType.InjectTouch),
  action: u8(),
  pointerId: u64,
  pointerX: u32,
  pointerY: u32,
  videoWidth: u16,
  videoHeight: u16,
  pressure: UnsignedFloat,
  actionButton: u32,
  buttons: u32
}, { littleEndian: false }))();
function serializeInjectTouchControlMessage(message) {
  return InjectTouchControlMessage.serialize(message);
}
async function parseAudioStreamMetadata(stream2, options2) {
  const buffered = new BufferedReadableStream(stream2);
  const buffer2 = await buffered.readExactly(4);
  const codecMetadataValue = /* @__PURE__ */ getUint32BigEndian(buffer2, 0);
  switch (codecMetadataValue) {
    case 0:
      return {
        type: "disabled"
      };
    case 1:
      return {
        type: "errored"
      };
  }
  if (options2.sendCodecMeta) {
    let codec2;
    switch (codecMetadataValue) {
      case ScrcpyAudioCodec.Raw.metadataValue:
        codec2 = ScrcpyAudioCodec.Raw;
        break;
      case ScrcpyAudioCodec.Opus.metadataValue:
        codec2 = ScrcpyAudioCodec.Opus;
        break;
      case ScrcpyAudioCodec.Aac.metadataValue:
        codec2 = ScrcpyAudioCodec.Aac;
        break;
      case ScrcpyAudioCodec.Flac.metadataValue:
        codec2 = ScrcpyAudioCodec.Flac;
        break;
      default:
        throw new Error(`Unknown audio codec metadata value: ${codecMetadataValue}`);
    }
    return {
      type: "success",
      codec: codec2,
      stream: buffered.release()
    };
  }
  let codec;
  switch (options2.audioCodec) {
    case "raw":
      codec = ScrcpyAudioCodec.Raw;
      break;
    case "opus":
      codec = ScrcpyAudioCodec.Opus;
      break;
    case "aac":
      codec = ScrcpyAudioCodec.Aac;
      break;
    case "flac":
      codec = ScrcpyAudioCodec.Flac;
      break;
    default:
      throw new Error(`Unknown audio codec metadata value: ${codecMetadataValue}`);
  }
  return {
    type: "success",
    codec,
    stream: new PushReadableStream(async (controller) => {
      await controller.enqueue(buffer2);
      const stream3 = buffered.release();
      const reader2 = stream3.getReader();
      while (true) {
        const { done, value } = await reader2.read();
        if (done) {
          break;
        }
        await controller.enqueue(value);
      }
    })
  };
}
function toCodecId(codec) {
  switch (codec) {
    case "h264":
      return ScrcpyVideoCodecId.H264;
    case "h265":
      return ScrcpyVideoCodecId.H265;
    case "av1":
      return ScrcpyVideoCodecId.AV1;
    default:
      throw new Error(`Unknown video codec: ${codec}`);
  }
}
async function parseAsync(options2, stream2) {
  const buffered = new BufferedReadableStream(stream2);
  let deviceName;
  if (options2.sendDeviceMeta) {
    deviceName = await readString(buffered, 64);
  }
  let codec;
  let width;
  let height;
  if (options2.sendCodecMeta) {
    codec = await readU32(buffered);
    width = await readU32(buffered);
    height = await readU32(buffered);
  } else {
    codec = toCodecId(options2.videoCodec);
  }
  return {
    stream: buffered.release(),
    metadata: { deviceName, codec, width, height }
  };
}
function parseVideoStreamMetadata(options2, stream2) {
  if (!options2.sendDeviceMeta && !options2.sendCodecMeta) {
    return {
      stream: stream2,
      metadata: { codec: toCodecId(options2.videoCodec) }
    };
  }
  return parseAsync(options2, stream2);
}
function setListDisplays(options2) {
  options2.listDisplays = true;
}
function setListEncoders(options2) {
  options2.listEncoders = true;
}
const Defaults$4 = /* @__PURE__ */ (() => ({
  ...Defaults$5,
  video: true,
  audioSource: "output"
}))();
const Defaults$3 = /* @__PURE__ */ (() => ({
  ...Defaults$4,
  videoSource: "display",
  displayId: 0,
  cameraId: void 0,
  cameraSize: void 0,
  cameraFacing: void 0,
  cameraAr: void 0,
  cameraFps: void 0,
  cameraHighSpeed: false,
  listCameras: false,
  listCameraSizes: false
}))();
function parseDisplay(line) {
  const match2 = line.match(/^\s+--display-id=(\d+)\s+\(([^)]+)\)$/);
  if (match2) {
    const display = {
      id: Number.parseInt(match2[1], 10)
    };
    if (match2[2] !== "size unknown") {
      display.resolution = match2[2];
    }
    return display;
  }
  return void 0;
}
const ControlMessageTypes$2 = /* @__PURE__ */ (() => [
  ...ControlMessageTypes$3,
  ScrcpyControlMessageType.UHidCreate,
  ScrcpyControlMessageType.UHidInput,
  ScrcpyControlMessageType.OpenHardKeyboardSettings
])();
const UHidOutputDeviceMessage = /* @__PURE__ */ struct({
  id: u16,
  data: /* @__PURE__ */ buffer(u16)
}, { littleEndian: false });
class UHidOutputStream extends PushReadableStream {
  constructor() {
    let controller;
    super((controller_) => {
      controller = controller_;
    });
    __privateAdd(this, _controller2);
    __publicField(this, "id", 2);
    __privateSet(this, _controller2, controller);
  }
  async parse(_id, stream2) {
    const message = await UHidOutputDeviceMessage.deserialize(stream2);
    await __privateGet(this, _controller2).enqueue(message);
  }
  close() {
    __privateGet(this, _controller2).close();
  }
  error(e) {
    __privateGet(this, _controller2).error(e);
  }
}
_controller2 = new WeakMap();
const Defaults$2 = /* @__PURE__ */ (() => ({
  ...Defaults$3,
  audioDup: false
}))();
const ControlMessageTypes$1 = /* @__PURE__ */ (() => {
  const result = ControlMessageTypes$2.slice();
  result.splice(14, 0, ScrcpyControlMessageType.UHidDestroy);
  return result;
})();
const ControlMessageTypes = /* @__PURE__ */ (() => [
  ...ControlMessageTypes$1,
  ScrcpyControlMessageType.StartApp,
  ScrcpyControlMessageType.ResetVideo
])();
const Defaults$1 = /* @__PURE__ */ (() => ({
  .../* @__PURE__ */ omit(Defaults$2, "lockVideoOrientation"),
  captureOrientation: void 0,
  angle: 0,
  screenOffTimeout: void 0,
  listApps: false,
  newDisplay: void 0,
  vdSystemDecorations: true
}))();
const EncoderRegex = /^\s+--(video|audio)-codec=(\S+)\s+--\1-encoder=(\S+)(?:\s*\((sw|hw|hybrid)\))?(?:\s*\[vendor\])?(?:\s*\(alias for (\S+)\))?$/;
function toHardwareType(value) {
  switch (value) {
    case "sw":
      return "software";
    case "hw":
      return "hardware";
    case "hybrid":
      return "hybrid";
    default:
      throw new Error(`Unknown hardware type: ${value}`);
  }
}
function parseEncoder(line) {
  const match2 = line.match(EncoderRegex);
  return match2 ? {
    type: match2[1],
    name: match2[3],
    codec: match2[2],
    hardwareType: match2[4] ? toHardwareType(match2[4]) : void 0,
    vendor: !!match2[5],
    aliasFor: match2[6]
  } : void 0;
}
const Defaults = /* @__PURE__ */ (() => ({
  ...Defaults$1,
  vdDestroyContent: false
}))();
const UHidCreateControlMessage = /* @__PURE__ */ struct({
  type: u8,
  id: u16,
  vendorId: u16,
  productId: u16,
  name: /* @__PURE__ */ string(u8),
  data: /* @__PURE__ */ buffer(u16)
}, { littleEndian: false });
function serializeUHidCreateControlMessage(message) {
  return UHidCreateControlMessage.serialize(message);
}
class ScrcpyOptions3_1 {
  constructor(init2) {
    __publicField(this, "value");
    __privateAdd(this, _clipboard);
    __privateAdd(this, _ackClipboardHandler);
    __privateAdd(this, _uHidOutput);
    __privateAdd(this, _deviceMessageParsers, new ScrcpyDeviceMessageParsers());
    this.value = { ...Defaults, ...init2 };
    if (this.value.videoSource === "camera") {
      this.value.control = false;
    }
    if (this.value.audioDup) {
      this.value.audioSource = "playback";
    }
    if (this.value.control) {
      if (this.value.clipboardAutosync) {
        __privateSet(this, _clipboard, __privateGet(this, _deviceMessageParsers).add(new ClipboardStream()));
        __privateSet(this, _ackClipboardHandler, __privateGet(this, _deviceMessageParsers).add(new AckClipboardHandler()));
      }
      __privateSet(this, _uHidOutput, __privateGet(this, _deviceMessageParsers).add(new UHidOutputStream()));
    }
  }
  get controlMessageTypes() {
    return ControlMessageTypes;
  }
  get clipboard() {
    return __privateGet(this, _clipboard);
  }
  get uHidOutput() {
    return __privateGet(this, _uHidOutput);
  }
  get deviceMessageParsers() {
    return __privateGet(this, _deviceMessageParsers);
  }
  serialize() {
    return serialize(this.value, Defaults);
  }
  setListDisplays() {
    setListDisplays(this.value);
  }
  parseDisplay(line) {
    return parseDisplay(line);
  }
  setListEncoders() {
    setListEncoders(this.value);
  }
  parseEncoder(line) {
    return parseEncoder(line);
  }
  parseVideoStreamMetadata(stream2) {
    return parseVideoStreamMetadata(this.value, stream2);
  }
  parseAudioStreamMetadata(stream2) {
    return parseAudioStreamMetadata(stream2, this.value);
  }
  createMediaStreamTransformer() {
    return createMediaStreamTransformer(this.value);
  }
  serializeInjectTouchControlMessage(message) {
    return serializeInjectTouchControlMessage(message);
  }
  serializeBackOrScreenOnControlMessage(message) {
    return serializeBackOrScreenOnControlMessage(message);
  }
  serializeSetClipboardControlMessage(message) {
    return __privateGet(this, _ackClipboardHandler).serializeSetClipboardControlMessage(message);
  }
  createScrollController() {
    return createScrollController();
  }
  serializeUHidCreateControlMessage(message) {
    return serializeUHidCreateControlMessage(message);
  }
}
_clipboard = new WeakMap();
_ackClipboardHandler = new WeakMap();
_uHidOutput = new WeakMap();
_deviceMessageParsers = new WeakMap();
__publicField(ScrcpyOptions3_1, "Defaults", Defaults);
const SCRCPY_REMOTE_PATH = "/data/local/tmp/omni/scrcpy.jar";
class ScrcpyClient {
  constructor(deviceId, adb2, scrcpyOptions) {
    __publicField(this, "server");
    __publicField(this, "control");
    __publicField(this, "controlReady");
    __publicField(this, "controlReadyResolve");
    __publicField(this, "scid", "");
    __publicField(this, "options");
    __publicField(this, "videoConnected", false);
    this.deviceId = deviceId;
    this.adb = adb2;
    this.scrcpyOptions = scrcpyOptions;
    this.scid = buildScid(deviceId);
    this.options = new ScrcpyOptions3_1({
      audio: (scrcpyOptions == null ? void 0 : scrcpyOptions.audio) ?? false,
      videoBitRate: (scrcpyOptions == null ? void 0 : scrcpyOptions.videoBitRate) ?? 8e6,
      maxSize: (scrcpyOptions == null ? void 0 : scrcpyOptions.maxSize) ?? 0,
      clipboardAutosync: false,
      stayAwake: false
    });
    this.options.value.scid = this.scid;
  }
  async start() {
    const jarPath = resolveScrcpyJarPath();
    await this.adb.push(this.deviceId, jarPath, SCRCPY_REMOTE_PATH);
    const args = this.options.serialize();
    const cmd = `CLASSPATH=${SCRCPY_REMOTE_PATH} app_process /system/bin com.genymobile.scrcpy.Server 3.1 ${args.join(
      " "
    )}`;
    const socket2 = await this.adb.shellSocket(this.deviceId, cmd);
    socket2.on("readable", () => {
      socket2.read();
    });
    socket2.on("error", () => {
    });
  }
  async startStream(onFrame) {
    const remote = `localabstract:scrcpy_${this.scid}`;
    const port = await this.adb.reverseTcp(this.deviceId, remote);
    this.controlReady = new Promise((resolve3) => {
      this.controlReadyResolve = resolve3;
    });
    const server2 = net.createServer((socket2) => {
      if (!this.control) {
        if (!this.server) return;
        if (!this.videoConnected) {
          this.videoConnected = true;
          socket2.on("data", (chunk) => {
            const buf = typeof chunk === "string" ? Buffer.from(chunk) : Buffer.from(chunk);
            onFrame({ data: new Uint8Array(buf), format: "h264" });
          });
          socket2.on("close", () => {
          });
          return;
        }
        let isAudio = false;
        this.detectAudioStream(socketToReadableStream(socket2)).then((value) => {
          if (value.audio) {
            isAudio = true;
          }
        });
        setTimeout(() => {
          if (!isAudio) {
            this.createControl(socket2);
          }
        }, 1e3);
      }
    });
    await new Promise((resolve3, reject) => {
      server2.once("error", reject);
      server2.listen(port, () => resolve3());
    });
    this.server = server2;
    await this.start();
  }
  async stop() {
    if (this.server) {
      this.server.close();
      this.server = void 0;
    }
    this.control = void 0;
    this.controlReady = void 0;
    this.controlReadyResolve = void 0;
    this.videoConnected = false;
  }
  async tap(x, y2, size) {
    const writer = await this.getControlWriter();
    writer.injectTouch({
      action: AndroidMotionEventAction.Down,
      pointerId: 1n,
      screenWidth: size.width,
      screenHeight: size.height,
      pointerX: x,
      pointerY: y2,
      pressure: 1,
      actionButton: AndroidMotionEventButton.Primary,
      buttons: 1
    });
    writer.injectTouch({
      action: AndroidMotionEventAction.Up,
      pointerId: 1n,
      screenWidth: size.width,
      screenHeight: size.height,
      pointerX: x,
      pointerY: y2,
      pressure: 0,
      actionButton: AndroidMotionEventButton.Primary,
      buttons: 0
    });
  }
  async scroll(dx, dy, size) {
    const writer = await this.getControlWriter();
    const centerX = Math.round(size.width / 2);
    const centerY = Math.round(size.height / 2);
    writer.injectScroll({
      screenWidth: size.width,
      screenHeight: size.height,
      pointerX: centerX,
      pointerY: centerY,
      scrollX: -dx / 100,
      scrollY: -dy / 100,
      buttons: 0
    });
  }
  async type(text) {
    const writer = await this.getControlWriter();
    writer.injectText(text);
  }
  async longPress(x, y2, size, durationMs = 500) {
    const writer = await this.getControlWriter();
    writer.injectTouch({
      action: AndroidMotionEventAction.Down,
      pointerId: 1n,
      screenWidth: size.width,
      screenHeight: size.height,
      pointerX: x,
      pointerY: y2,
      pressure: 1,
      actionButton: AndroidMotionEventButton.Primary,
      buttons: 1
    });
    await delay(durationMs);
    writer.injectTouch({
      action: AndroidMotionEventAction.Up,
      pointerId: 1n,
      screenWidth: size.width,
      screenHeight: size.height,
      pointerX: x,
      pointerY: y2,
      pressure: 0,
      actionButton: AndroidMotionEventButton.Primary,
      buttons: 0
    });
  }
  async swipe(start, end, size, durationMs = 300) {
    const writer = await this.getControlWriter();
    writer.injectTouch({
      action: AndroidMotionEventAction.Down,
      pointerId: 1n,
      screenWidth: size.width,
      screenHeight: size.height,
      pointerX: start[0],
      pointerY: start[1],
      pressure: 1,
      actionButton: AndroidMotionEventButton.Primary,
      buttons: 1
    });
    await delay(durationMs);
    writer.injectTouch({
      action: AndroidMotionEventAction.Move,
      pointerId: 1n,
      screenWidth: size.width,
      screenHeight: size.height,
      pointerX: end[0],
      pointerY: end[1],
      pressure: 1,
      actionButton: AndroidMotionEventButton.Primary,
      buttons: 1
    });
    writer.injectTouch({
      action: AndroidMotionEventAction.Up,
      pointerId: 1n,
      screenWidth: size.width,
      screenHeight: size.height,
      pointerX: end[0],
      pointerY: end[1],
      pressure: 0,
      actionButton: AndroidMotionEventButton.Primary,
      buttons: 0
    });
  }
  async back() {
    const writer = await this.getControlWriter();
    writer.injectKeyCode({
      action: AndroidKeyEventAction.Down,
      keyCode: AndroidKeyCode.AndroidBack,
      repeat: 0,
      metaState: 0
    });
    writer.injectKeyCode({
      action: AndroidKeyEventAction.Up,
      keyCode: AndroidKeyCode.AndroidBack,
      repeat: 0,
      metaState: 0
    });
  }
  async backspace() {
    const writer = await this.getControlWriter();
    writer.injectKeyCode({
      action: AndroidKeyEventAction.Down,
      keyCode: AndroidKeyCode.Backspace,
      repeat: 0,
      metaState: 0
    });
    writer.injectKeyCode({
      action: AndroidKeyEventAction.Up,
      keyCode: AndroidKeyCode.Backspace,
      repeat: 0,
      metaState: 0
    });
  }
  async getControlWriter() {
    var _a3, _b;
    if ((_a3 = this.control) == null ? void 0 : _a3.writer) return this.control.writer;
    if (!this.controlReady) {
      throw new Error("scrcpy control channel not initialized");
    }
    await waitFor(this.controlReady, 3e3, "scrcpy control channel not ready");
    if (!((_b = this.control) == null ? void 0 : _b.writer)) {
      throw new Error("scrcpy control channel not ready");
    }
    return this.control.writer;
  }
  async detectAudioStream(stream2) {
    const buffered = new BufferedReadableStream(stream2);
    const buffer2 = await buffered.readExactly(4);
    const codecMetadataValue = /* @__PURE__ */ getUint32BigEndian(buffer2, 0);
    const readableStream = new PushReadableStream(async (controller) => {
      await controller.enqueue(buffer2);
      const rest = buffered.release();
      const reader2 = rest.getReader();
      while (true) {
        const { done, value } = await reader2.read();
        if (done) break;
        const buf = typeof value === "string" ? Buffer.from(value) : Buffer.from(value);
        await controller.enqueue(new Uint8Array(buf));
      }
    });
    const isAudio = codecMetadataValue === 0 || codecMetadataValue === ScrcpyAudioCodec.Opus.metadataValue;
    return {
      audio: isAudio,
      stream: readableStream
    };
  }
  createControl(socket2) {
    var _a3;
    const controlStream = socketToReadableWritablePair(socket2);
    const writer = new ScrcpyControlMessageWriter(controlStream.writable.getWriter(), this.options);
    this.control = { writer };
    (_a3 = this.controlReadyResolve) == null ? void 0 : _a3.call(this);
  }
}
function resolveScrcpyJarPath() {
  const root3 = process.cwd();
  const jarPath = path__default.resolve(root3, "resources", "bin", "android", "scrcpy.jar");
  if (!fs__default.existsSync(jarPath)) {
    throw new Error(`scrcpy.jar not found at ${jarPath}`);
  }
  return jarPath;
}
function buildScid(deviceId) {
  let hash2 = 0;
  for (let i = 0; i < deviceId.length; i += 1) {
    hash2 = hash2 * 31 + deviceId.charCodeAt(i) | 0;
  }
  const scid = Math.abs(hash2) % 999999;
  return String(scid).padStart(8, "0");
}
function socketToReadableStream(socket2) {
  return new ReadableStream({
    start(controller) {
      socket2.on("data", (data) => {
        const buf = typeof data === "string" ? Buffer.from(data) : Buffer.from(data);
        controller.enqueue(new Uint8Array(buf));
      });
      socket2.on("end", () => controller.close());
      socket2.on("error", (e) => controller.error(e));
    },
    cancel() {
      socket2.destroy();
    }
  });
}
function socketToWritableStream(socket2) {
  return new WritableStream({
    write(chunk) {
      return new Promise((resolve3, reject) => {
        socket2.write(chunk.value, (err) => {
          if (err) reject(err);
          else resolve3();
        });
      });
    },
    close() {
      socket2.end();
    },
    abort() {
      socket2.destroy();
    }
  });
}
function socketToReadableWritablePair(socket2) {
  return {
    readable: socketToReadableStream(socket2),
    writable: socketToWritableStream(socket2)
  };
}
async function waitFor(promise2, timeoutMs, message) {
  let timeout2 = null;
  try {
    await Promise.race([
      promise2,
      new Promise((_, reject) => {
        timeout2 = setTimeout(() => reject(new Error(message)), timeoutMs);
      })
    ]);
  } finally {
    if (timeout2) clearTimeout(timeout2);
  }
}
function delay(ms2) {
  return new Promise((resolve3) => setTimeout(resolve3, ms2));
}
async function safeStop(scrcpy) {
  try {
    await (scrcpy == null ? void 0 : scrcpy.stop());
  } catch {
  }
}
class AndroidAdapter {
  constructor() {
    __publicField(this, "interfaceType", "android");
    __publicField(this, "adb", new AdbClient());
    __publicField(this, "scrcpy");
    __publicField(this, "deviceId", "");
    __publicField(this, "deviceSize");
  }
  async connect(deviceId) {
    const result = await this.connectWithResult(deviceId);
    return result.ok;
  }
  async connectWithResult(deviceId) {
    try {
      const devices2 = await this.adb.listDevices();
      if (deviceId) {
        const exists = devices2.find((d2) => d2.id === deviceId);
        if (!exists) return { ok: false, error: "device_not_found" };
        this.deviceId = deviceId;
        this.scrcpy = new ScrcpyClient(this.deviceId, this.adb);
        this.deviceSize = await this.size();
        return { ok: true };
      }
      if (!devices2.length) return { ok: false, error: "no_devices" };
      this.deviceId = devices2[0].id;
      this.scrcpy = new ScrcpyClient(this.deviceId, this.adb);
      this.deviceSize = await this.size();
      return { ok: true };
    } catch (e) {
      return { ok: false, error: (e == null ? void 0 : e.message) || "connect_error" };
    }
  }
  async listDevices() {
    const devices2 = await this.adb.listDevices();
    return devices2.map((d2) => ({
      id: d2.id,
      name: d2.id,
      type: "android"
    }));
  }
  async disconnect() {
    await safeStop(this.scrcpy);
    this.scrcpy = void 0;
    this.deviceId = "";
    this.deviceSize = void 0;
  }
  async screenshotBase64() {
    const output = await this.adb.shellRaw(this.deviceId, "screencap -p");
    return Buffer.from(output).toString("base64");
  }
  async size() {
    const sizeStr = await this.adb.shell(this.deviceId, "wm size");
    const match2 = /Physical size: (\d+)x(\d+)/.exec(sizeStr);
    if (match2) {
      return { width: Number(match2[1]), height: Number(match2[2]) };
    }
    return { width: 0, height: 0 };
  }
  actionSpace() {
    return [
      defineActionTap(async (param3) => {
        const { center } = param3.locate;
        await this.tap(center[0], center[1]);
      }),
      defineActionInput(async (param3) => {
        await this.type(param3.value);
      }),
      defineActionKeyboardPress(async (param3) => {
        var _a3;
        if (param3.keyName.toLowerCase() === "backspace") {
          await ((_a3 = this.scrcpy) == null ? void 0 : _a3.backspace());
        }
      }),
      defineActionScroll(async (param3) => {
        const dir = param3.direction || "down";
        const distance = param3.distance || 300;
        if (dir === "down") {
          await this.scroll(0, distance);
        } else if (dir === "up") {
          await this.scroll(0, -distance);
        } else if (dir === "left") {
          await this.scroll(-distance, 0);
        } else if (dir === "right") {
          await this.scroll(distance, 0);
        }
      }),
      defineActionLongPress(async (param3) => {
        var _a3;
        const { center } = param3.locate;
        const size = await this.ensureSize();
        await ((_a3 = this.scrcpy) == null ? void 0 : _a3.longPress(center[0], center[1], size, 500));
      }),
      defineActionSwipe(async (param3) => {
        var _a3, _b, _c;
        const start = (_a3 = param3.start) == null ? void 0 : _a3.center;
        const end = (_b = param3.end) == null ? void 0 : _b.center;
        if (start && end) {
          const size = await this.ensureSize();
          await ((_c = this.scrcpy) == null ? void 0 : _c.swipe(start, end, size));
          return;
        }
        const dir = param3.direction || "down";
        const distance = param3.distance || 300;
        if (dir === "down") {
          await this.scroll(0, distance);
        } else if (dir === "up") {
          await this.scroll(0, -distance);
        } else if (dir === "left") {
          await this.scroll(-distance, 0);
        } else if (dir === "right") {
          await this.scroll(distance, 0);
        }
      })
    ];
  }
  async startStream(onFrame) {
    var _a3;
    await ((_a3 = this.scrcpy) == null ? void 0 : _a3.startStream(onFrame));
  }
  async tap(x, y2) {
    var _a3;
    const size = await this.ensureSize();
    await ((_a3 = this.scrcpy) == null ? void 0 : _a3.tap(x, y2, size));
  }
  async type(text) {
    var _a3;
    await ((_a3 = this.scrcpy) == null ? void 0 : _a3.type(text));
  }
  async scroll(dx, dy) {
    var _a3;
    const size = await this.ensureSize();
    await ((_a3 = this.scrcpy) == null ? void 0 : _a3.scroll(dx, dy, size));
  }
  async back() {
    var _a3;
    await ((_a3 = this.scrcpy) == null ? void 0 : _a3.back());
  }
  async getDeviceInfo() {
    const id = this.deviceId || "android-unknown";
    let name = "Android";
    let osVersion = "";
    try {
      name = (await this.adb.shell(id, "getprop ro.product.model")).trim() || name;
      osVersion = (await this.adb.shell(id, "getprop ro.build.version.release")).trim();
    } catch {
    }
    let size;
    try {
      size = await this.size();
    } catch {
    }
    return { id, name, type: "android", osVersion, size };
  }
  async ensureSize() {
    if (!this.deviceSize || this.deviceSize.width === 0 || this.deviceSize.height === 0) {
      this.deviceSize = await this.size();
    }
    return this.deviceSize;
  }
}
class DeviceManager extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    __publicField(this, "adapter", new AndroidAdapter());
    __publicField(this, "devices", []);
    __publicField(this, "activeDeviceId", "");
    __publicField(this, "pollingTimer");
    __publicField(this, "streaming", false);
  }
  startPolling(intervalMs = 3e3) {
    if (this.pollingTimer) return;
    this.refreshDevices().catch(() => {
    });
    this.pollingTimer = setInterval(() => {
      this.refreshDevices().catch(() => {
      });
    }, intervalMs);
  }
  stopPolling() {
    if (this.pollingTimer) clearInterval(this.pollingTimer);
    this.pollingTimer = void 0;
  }
  getDevices() {
    return this.devices;
  }
  getActiveDeviceId() {
    return this.activeDeviceId;
  }
  getAdapter() {
    return this.adapter;
  }
  async refreshDevices() {
    try {
      const devices2 = await this.adapter.listDevices();
      this.devices = devices2;
      this.emit("deviceList", devices2);
      const exists = devices2.some((device) => device.id === this.activeDeviceId);
      if (!exists && this.activeDeviceId) {
        await this.disconnect();
      }
      if (!this.activeDeviceId && devices2.length > 0) {
        await this.selectDevice(devices2[0].id);
      }
    } catch (error2) {
      this.emit("log", {
        type: "error",
        content: (error2 == null ? void 0 : error2.message) || "Failed to refresh devices"
      });
    }
  }
  async selectDevice(deviceId) {
    if (!deviceId || deviceId === this.activeDeviceId) return;
    await this.connect(deviceId);
  }
  async connect(deviceId) {
    if (this.activeDeviceId && deviceId && this.activeDeviceId !== deviceId) {
      await this.disconnect();
    }
    const result = await this.adapter.connectWithResult(deviceId);
    if (!result.ok) {
      this.emit("log", {
        type: "error",
        content: `Device connect failed: ${result.error || "unknown"}`
      });
      return;
    }
    const info = await this.adapter.getDeviceInfo();
    this.activeDeviceId = info.id;
    this.devices = this.devices.map(
      (device) => device.id === info.id ? { ...device, ...info } : device
    );
    this.emit("deviceList", this.devices);
    await this.startStream();
    this.emit("log", { type: "info", content: `Device connected: ${info.id}` });
  }
  async disconnect() {
    await this.adapter.disconnect();
    this.activeDeviceId = "";
    this.streaming = false;
  }
  async startStream() {
    if (this.streaming) return;
    this.streaming = true;
    try {
      await this.adapter.startStream((frame) => {
        if (!this.activeDeviceId) return;
        this.emit("frame", { deviceId: this.activeDeviceId, frame });
      });
    } catch (error2) {
      this.streaming = false;
      this.emit("log", {
        type: "error",
        content: (error2 == null ? void 0 : error2.message) || "Failed to start scrcpy stream"
      });
    }
  }
}
function summarizeTask(task) {
  var _a3, _b, _c, _d, _e, _f, _g2;
  const title = task.subType || task.type || "Task";
  let detail = "";
  if ((_a3 = task == null ? void 0 : task.param) == null ? void 0 : _a3.userInstruction) detail = task.param.userInstruction;
  if (!detail && ((_d = (_c = (_b = task == null ? void 0 : task.param) == null ? void 0 : _b.locate) == null ? void 0 : _c.prompt) == null ? void 0 : _d.prompt)) {
    detail = task.param.locate.prompt.prompt;
  }
  if (!detail && ((_f = (_e = task == null ? void 0 : task.param) == null ? void 0 : _e.locate) == null ? void 0 : _f.prompt)) detail = task.param.locate.prompt;
  if (!detail && typeof ((_g2 = task == null ? void 0 : task.param) == null ? void 0 : _g2.value) === "string") detail = task.param.value;
  if (!detail && typeof (task == null ? void 0 : task.thought) === "string") detail = task.thought;
  if (!detail && typeof (task == null ? void 0 : task.param) === "string") detail = task.param;
  return detail ? `${title}  ${detail}` : title;
}
class TaskScheduler extends EventEmitter$1 {
  constructor(getAgent) {
    super();
    __publicField(this, "running", false);
    __publicField(this, "aborted", false);
    __publicField(this, "lastTaskId", "");
    this.getAgent = getAgent;
  }
  isRunning() {
    return this.running;
  }
  stop() {
    if (!this.running) return;
    this.aborted = true;
    this.emit("log", {
      type: "info",
      content: "Stop requested. Current task will finish if already running."
    });
    this.emit("state", {
      status: "idle",
      finishedAt: Date.now()
    });
  }
  async run(instruction) {
    if (this.running) {
      this.emit("log", {
        type: "info",
        content: "Task already running. Please stop it first."
      });
      return;
    }
    if (!instruction.trim()) {
      this.emit("log", {
        type: "error",
        content: "Instruction is empty."
      });
      return;
    }
    this.running = true;
    this.aborted = false;
    this.lastTaskId = "";
    this.emit("state", {
      status: "running",
      startedAt: Date.now()
    });
    const title = instruction.split("\n")[0].slice(0, 80);
    this.emit("log", {
      type: "info",
      content: `Task started: ${instruction}`
    });
    let removeDumpListener;
    let agent;
    try {
      agent = await this.getAgent();
      if (agent == null ? void 0 : agent.addDumpUpdateListener) {
        removeDumpListener = agent.addDumpUpdateListener(
          (_dump, executionDump) => {
            const tasks = (executionDump == null ? void 0 : executionDump.tasks) || [];
            const last = tasks[tasks.length - 1];
            if (!last || last.taskId === this.lastTaskId) return;
            this.lastTaskId = last.taskId;
            const type3 = last.type === "Planning" ? "plan" : last.type === "Insight" ? "thought" : last.type === "Action Space" ? "action" : "info";
            this.emit("log", {
              type: type3,
              content: summarizeTask(last),
              taskId: last.taskId
            });
          }
        );
      }
      const result = await agent.aiAct(instruction);
      if (!this.aborted) {
        this.emit("log", {
          type: "info",
          content: result ? `Task finished: ${result}` : "Task finished."
        });
        this.emit("state", {
          status: "success",
          finishedAt: Date.now()
        });
      }
    } catch (error2) {
      if (!this.aborted) {
        this.emit("log", {
          type: "error",
          content: (error2 == null ? void 0 : error2.message) || "Task failed."
        });
        this.emit("state", {
          status: "error",
          finishedAt: Date.now()
        });
      }
    } finally {
      if (removeDumpListener) removeDumpListener();
      if ((agent == null ? void 0 : agent.reportHTMLString) && !this.aborted) {
        const html = agent.reportHTMLString({ inlineScreenshots: true });
        this.emit("report", { html, title });
      }
      this.running = false;
    }
  }
}
const __dirname$1 = path__default.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path__default.join(__dirname$1, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path__default.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path__default.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path__default.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
let deviceManager = null;
let playgroundServer = null;
let taskScheduler = null;
const reportDir = path__default.join(process.env.APP_ROOT || process.cwd(), "reports");
const reportIndexFile = path__default.join(reportDir, "index.json");
const reportIndex = [];
function loadReportIndex() {
  try {
    if (!existsSync(reportIndexFile)) return;
    const content = readFileSync(reportIndexFile, "utf-8");
    const parsed = JSON.parse(content);
    if (Array.isArray(parsed)) {
      reportIndex.splice(0, reportIndex.length, ...parsed);
    }
  } catch {
  }
}
function saveReportIndex() {
  try {
    if (!existsSync(reportDir)) mkdirSync(reportDir, { recursive: true });
    writeFileSync(reportIndexFile, JSON.stringify(reportIndex, null, 2), "utf-8");
  } catch {
  }
}
function sendToRenderer(channel, payload) {
  if (!win) return;
  win.webContents.send(channel, payload);
}
function createWindow() {
  const isMac2 = process.platform === "darwin";
  win = new BrowserWindow({
    icon: path__default.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    frame: false,
    titleBarStyle: isMac2 ? "hiddenInset" : void 0,
    webPreferences: {
      preload: path__default.join(__dirname$1, "preload.mjs")
    }
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path__default.join(RENDERER_DIST, "index.html"));
  }
  win.webContents.on("did-finish-load", () => {
    const payload = { reports: reportIndex };
    sendToRenderer(IPC_REPORT_LIST, payload);
    sendToRenderer(IPC_WINDOW_STATE, { maximized: (win == null ? void 0 : win.isMaximized()) || false });
  });
  win.on("maximize", () => sendToRenderer(IPC_WINDOW_STATE, { maximized: true }));
  win.on("unmaximize", () => sendToRenderer(IPC_WINDOW_STATE, { maximized: false }));
}
function registerDeviceManager() {
  deviceManager = new DeviceManager();
  deviceManager.on("deviceList", (devices2) => {
    const payload = { devices: devices2 };
    sendToRenderer(IPC_DEVICE_LIST, payload);
  });
  deviceManager.on("frame", ({ deviceId, frame }) => {
    const payload = {
      deviceId,
      format: frame.format,
      data: frame.data
    };
    sendToRenderer(IPC_DEVICE_FRAME, payload);
  });
  deviceManager.on("log", (log2) => {
    const payload = {
      type: log2.type,
      content: log2.content
    };
    sendToRenderer(IPC_TASK_LOG, payload);
  });
  deviceManager.startPolling();
}
function registerTaskScheduler() {
  taskScheduler = new TaskScheduler(async () => {
    if (!deviceManager) {
      throw new Error("Device manager not initialized");
    }
    if (!deviceManager.getActiveDeviceId()) {
      await deviceManager.refreshDevices();
    }
    if (!deviceManager.getActiveDeviceId()) {
      throw new Error("No active device available");
    }
    return createAgentFromEnv(deviceManager.getAdapter());
  });
  taskScheduler.on("log", (payload) => {
    sendToRenderer(IPC_TASK_LOG, payload);
  });
  taskScheduler.on("state", (payload) => {
    sendToRenderer(IPC_TASK_STATE, payload);
  });
  taskScheduler.on("report", (payload) => {
    if (payload.html) {
      if (!existsSync(reportDir)) mkdirSync(reportDir, { recursive: true });
      const id = `${Date.now()}-${Math.random().toString(16).slice(2, 8)}`;
      const filePath = path__default.join(reportDir, `report-${id}.html`);
      writeFileSync(filePath, payload.html, "utf-8");
      reportIndex.unshift({
        id,
        title: payload.title || "Untitled",
        path: filePath,
        createdAt: Date.now()
      });
      saveReportIndex();
      const listPayload = { reports: reportIndex };
      sendToRenderer(IPC_REPORT_LIST, listPayload);
      const reportPayload = {
        html: payload.html,
        id,
        title: payload.title,
        path: filePath
      };
      sendToRenderer(IPC_REPORT_UPDATE, reportPayload);
    }
  });
}
async function ensurePlaygroundServer() {
  if (!deviceManager) return;
  playgroundServer = new PlaygroundServer(async () => {
    if (!deviceManager) {
      throw new Error("Device manager not initialized");
    }
    if (!deviceManager.getActiveDeviceId()) {
      await deviceManager.refreshDevices();
    }
    if (!deviceManager.getActiveDeviceId()) {
      throw new Error("No active device available");
    }
    return createAgentFromEnv(deviceManager.getAdapter());
  });
  playgroundServer.app.use((req2, res2, next) => {
    res2.setHeader("Access-Control-Allow-Origin", "*");
    res2.setHeader("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
    res2.setHeader("Access-Control-Allow-Headers", "*");
    if (req2.method === "OPTIONS") {
      res2.status(200).end();
      return;
    }
    next();
  });
  await playgroundServer.launch(PLAYGROUND_SERVER_PORT);
  const payload = {
    type: "info",
    content: `Playground server running on :${playgroundServer.port}`
  };
  sendToRenderer(IPC_TASK_LOG, payload);
}
function registerIpc() {
  ipcMain.on(IPC_DEVICE_SELECT, async (_event, payload) => {
    if (!deviceManager) return;
    await deviceManager.selectDevice((payload == null ? void 0 : payload.deviceId) || "");
  });
  ipcMain.on(IPC_START_TASK, async (_event, payload) => {
    if (!taskScheduler) return;
    if (deviceManager && (payload == null ? void 0 : payload.deviceId)) {
      await deviceManager.selectDevice(payload.deviceId);
    }
    await taskScheduler.run((payload == null ? void 0 : payload.instruction) || "");
  });
  ipcMain.on(IPC_STOP_TASK, () => {
    taskScheduler == null ? void 0 : taskScheduler.stop();
  });
  ipcMain.on(IPC_DEVICE_REFRESH, async () => {
    await (deviceManager == null ? void 0 : deviceManager.refreshDevices());
  });
  ipcMain.on(IPC_DEVICE_DISCONNECT, async () => {
    await (deviceManager == null ? void 0 : deviceManager.disconnect());
  });
  ipcMain.on(IPC_REPORT_SELECT, (_event, payload) => {
    const target = reportIndex.find((item) => item.id === (payload == null ? void 0 : payload.id));
    if (!target) return;
    const html = readFileSync(target.path, "utf-8");
    const reportPayload = {
      html,
      id: target.id,
      title: target.title,
      path: target.path
    };
    sendToRenderer(IPC_REPORT_UPDATE, reportPayload);
  });
  ipcMain.on(IPC_REPORT_DELETE, (_event, payload) => {
    const targetIndex = reportIndex.findIndex((item) => item.id === (payload == null ? void 0 : payload.id));
    if (targetIndex < 0) return;
    const target = reportIndex[targetIndex];
    try {
      if (existsSync(target.path)) unlinkSync(target.path);
    } catch {
    }
    reportIndex.splice(targetIndex, 1);
    saveReportIndex();
    sendToRenderer(IPC_REPORT_LIST, { reports: reportIndex });
    if (target.id === (payload == null ? void 0 : payload.id)) {
      sendToRenderer(IPC_REPORT_UPDATE, { html: null, id: "", title: "", path: "" });
    }
  });
  ipcMain.on(IPC_WINDOW_MINIMIZE, () => {
    win == null ? void 0 : win.minimize();
  });
  ipcMain.on(IPC_WINDOW_TOGGLE_MAXIMIZE, () => {
    if (!win) return;
    if (win.isMaximized()) win.unmaximize();
    else win.maximize();
  });
  ipcMain.on(IPC_WINDOW_CLOSE, () => {
    win == null ? void 0 : win.close();
  });
}
app.whenReady().then(async () => {
  loadReportIndex();
  registerDeviceManager();
  registerTaskScheduler();
  registerIpc();
  createWindow();
  const payload = { status: "idle" };
  sendToRenderer(IPC_TASK_STATE, payload);
  try {
    await ensurePlaygroundServer();
  } catch (error2) {
    sendToRenderer(IPC_TASK_LOG, {
      type: "error",
      content: (error2 == null ? void 0 : error2.message) || "Failed to start playground server"
    });
  }
  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") app.quit();
});
export {
  MAIN_DIST as M,
  RENDERER_DIST as R,
  VITE_DEV_SERVER_URL as V,
  getDebug as a,
  commonjsRequire as b,
  commonjsGlobal as c,
  getDefaultExportFromCjs as g
};
